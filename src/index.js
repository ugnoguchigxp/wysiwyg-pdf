var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// ../../node_modules/.pnpm/react@19.2.3/node_modules/react/cjs/react.development.js
var require_react_development = __commonJS((exports, module) => {
  (function() {
    function defineDeprecationWarning(methodName, info) {
      Object.defineProperty(Component.prototype, methodName, {
        get: function() {
          console.warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
        }
      });
    }
    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable !== "object")
        return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return typeof maybeIterable === "function" ? maybeIterable : null;
    }
    function warnNoop(publicInstance, callerName) {
      publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
      var warningKey = publicInstance + "." + callerName;
      didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, publicInstance), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
    }
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function ComponentDummy() {}
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function noop() {}
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = false;
      } catch (e) {
        JSCompiler_inline_result = true;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
        return testStringCoercion(value);
      }
    }
    function getComponentNameFromType(type) {
      if (type == null)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE)
        return "<>";
      if (typeof type === "object" && type !== null && type.$$typeof === REACT_LAZY_TYPE)
        return "<...>";
      try {
        var name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return dispatcher === null ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning)
          return false;
      }
      return config.key !== undefined;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
      }
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
      componentName = this.props.ref;
      return componentName !== undefined ? componentName : null;
    }
    function ReactElement(type, key, props, owner, debugStack, debugTask) {
      var refProp = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        props,
        _owner: owner
      };
      (refProp !== undefined ? refProp : null) !== null ? Object.defineProperty(type, "ref", {
        enumerable: false,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      newKey = ReactElement(oldElement.type, newKey, oldElement.props, oldElement._owner, oldElement._debugStack, oldElement._debugTask);
      oldElement._store && (newKey._store.validated = oldElement._store.validated);
      return newKey;
    }
    function validateChildKeys(node) {
      isValidElement(node) ? node._store && (node._store.validated = 1) : typeof node === "object" && node !== null && node.$$typeof === REACT_LAZY_TYPE && (node._payload.status === "fulfilled" ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
    }
    function isValidElement(object) {
      return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape2(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key.replace(/[=:]/g, function(match) {
        return escaperLookup[match];
      });
    }
    function getElementKey(element, index) {
      return typeof element === "object" && element !== null && element.key != null ? (checkKeyStringCoercion(element.key), escape2("" + element.key)) : index.toString(36);
    }
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch (typeof thenable.status === "string" ? thenable.then(noop, noop) : (thenable.status = "pending", thenable.then(function(fulfilledValue) {
            thenable.status === "pending" && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
          }, function(error) {
            thenable.status === "pending" && (thenable.status = "rejected", thenable.reason = error);
          })), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if (type === "undefined" || type === "boolean")
        children = null;
      var invokeCallback = false;
      if (children === null)
        invokeCallback = true;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE:
                return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
            }
        }
      if (invokeCallback) {
        invokeCallback = children;
        callback = callback(invokeCallback);
        var childKey = nameSoFar === "" ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
        isArrayImpl(callback) ? (escapedPrefix = "", childKey != null && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
          return c;
        })) : callback != null && (isValidElement(callback) && (callback.key != null && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(callback, escapedPrefix + (callback.key == null || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + childKey), nameSoFar !== "" && invokeCallback != null && isValidElement(invokeCallback) && invokeCallback.key == null && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
        return 1;
      }
      invokeCallback = 0;
      childKey = nameSoFar === "" ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i = 0;i < children.length; i++)
          nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
      else if (i = getIteratorFn(children), typeof i === "function")
        for (i === children.entries && (didWarnAboutMaps || console.warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = true), children = i.call(children), i = 0;!(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
      else if (type === "object") {
        if (typeof children.then === "function")
          return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
        array = String(children);
        throw Error("Objects are not valid as a React child (found: " + (array === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (children == null)
        return children;
      var result = [], count = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (payload._status === -1) {
        var ioInfo = payload._ioInfo;
        ioInfo != null && (ioInfo.start = ioInfo.end = performance.now());
        ioInfo = payload._result;
        var thenable = ioInfo();
        thenable.then(function(moduleObject) {
          if (payload._status === 0 || payload._status === -1) {
            payload._status = 1;
            payload._result = moduleObject;
            var _ioInfo = payload._ioInfo;
            _ioInfo != null && (_ioInfo.end = performance.now());
            thenable.status === undefined && (thenable.status = "fulfilled", thenable.value = moduleObject);
          }
        }, function(error) {
          if (payload._status === 0 || payload._status === -1) {
            payload._status = 2;
            payload._result = error;
            var _ioInfo2 = payload._ioInfo;
            _ioInfo2 != null && (_ioInfo2.end = performance.now());
            thenable.status === undefined && (thenable.status = "rejected", thenable.reason = error);
          }
        });
        ioInfo = payload._ioInfo;
        if (ioInfo != null) {
          ioInfo.value = thenable;
          var displayName = thenable.displayName;
          typeof displayName === "string" && (ioInfo.name = displayName);
        }
        payload._status === -1 && (payload._status = 0, payload._result = thenable);
      }
      if (payload._status === 1)
        return ioInfo = payload._result, ioInfo === undefined && console.error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, ioInfo), "default" in ioInfo || console.error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, ioInfo), ioInfo.default;
      throw payload._result;
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      dispatcher === null && console.error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return dispatcher;
    }
    function releaseAsyncTransition() {
      ReactSharedInternals.asyncTransitions--;
    }
    function enqueueTask(task) {
      if (enqueueTaskImpl === null)
        try {
          var requireString = ("require" + Math.random()).slice(0, 7);
          enqueueTaskImpl = (module && module[requireString]).call(module, "timers").setImmediate;
        } catch (_err) {
          enqueueTaskImpl = function(callback) {
            didWarnAboutMessageChannel === false && (didWarnAboutMessageChannel = true, typeof MessageChannel === "undefined" && console.error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
            var channel = new MessageChannel;
            channel.port1.onmessage = callback;
            channel.port2.postMessage(undefined);
          };
        }
      return enqueueTaskImpl(task);
    }
    function aggregateErrors(errors) {
      return 1 < errors.length && typeof AggregateError === "function" ? new AggregateError(errors) : errors[0];
    }
    function popActScope(prevActQueue, prevActScopeDepth) {
      prevActScopeDepth !== actScopeDepth - 1 && console.error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
      actScopeDepth = prevActScopeDepth;
    }
    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
      var queue = ReactSharedInternals.actQueue;
      if (queue !== null)
        if (queue.length !== 0)
          try {
            flushActQueue(queue);
            enqueueTask(function() {
              return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
            });
            return;
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
        else
          ReactSharedInternals.actQueue = null;
      0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
    }
    function flushActQueue(queue) {
      if (!isFlushing) {
        isFlushing = true;
        var i = 0;
        try {
          for (;i < queue.length; i++) {
            var callback = queue[i];
            do {
              ReactSharedInternals.didUsePromise = false;
              var continuation = callback(false);
              if (continuation !== null) {
                if (ReactSharedInternals.didUsePromise) {
                  queue[i] = callback;
                  queue.splice(0, i);
                  return;
                }
                callback = continuation;
              } else
                break;
            } while (1);
          }
          queue.length = 0;
        } catch (error) {
          queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
        } finally {
          isFlushing = false;
        }
      }
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function(publicInstance) {
        warnNoop(publicInstance, "forceUpdate");
      },
      enqueueReplaceState: function(publicInstance) {
        warnNoop(publicInstance, "replaceState");
      },
      enqueueSetState: function(publicInstance) {
        warnNoop(publicInstance, "setState");
      }
    }, assign = Object.assign, emptyObject = {};
    Object.freeze(emptyObject);
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
      if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null)
        throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    var deprecatedAPIs = {
      isMounted: [
        "isMounted",
        "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
      ],
      replaceState: [
        "replaceState",
        "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
      ]
    };
    for (fnName in deprecatedAPIs)
      deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    ComponentDummy.prototype = Component.prototype;
    deprecatedAPIs = PureComponent.prototype = new ComponentDummy;
    deprecatedAPIs.constructor = PureComponent;
    assign(deprecatedAPIs, Component.prototype);
    deprecatedAPIs.isPureReactComponent = true;
    var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
      H: null,
      A: null,
      T: null,
      S: null,
      actQueue: null,
      asyncTransitions: 0,
      isBatchingLegacy: false,
      didScheduleLegacyUpdate: false,
      didUsePromise: false,
      thrownErrors: [],
      getCurrentStack: null,
      recentlyCreatedOwnerStacks: 0
    }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
      return null;
    };
    deprecatedAPIs = {
      react_stack_bottom_frame: function(callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(deprecatedAPIs, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = typeof reportError === "function" ? reportError : function(error) {
      if (typeof window === "object" && typeof window.ErrorEvent === "function") {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event))
          return;
      } else if (typeof process === "object" && typeof process.emit === "function") {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = typeof queueMicrotask === "function" ? function(callback) {
      queueMicrotask(function() {
        return queueMicrotask(callback);
      });
    } : enqueueTask;
    deprecatedAPIs = Object.freeze({
      __proto__: null,
      c: function(size) {
        return resolveDispatcher().useMemoCache(size);
      }
    });
    var fnName = {
      map: mapChildren,
      forEach: function(children, forEachFunc, forEachContext) {
        mapChildren(children, function() {
          forEachFunc.apply(this, arguments);
        }, forEachContext);
      },
      count: function(children) {
        var n = 0;
        mapChildren(children, function() {
          n++;
        });
        return n;
      },
      toArray: function(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      },
      only: function(children) {
        if (!isValidElement(children))
          throw Error("React.Children.only expected to receive a single React element child.");
        return children;
      }
    };
    exports.Activity = REACT_ACTIVITY_TYPE;
    exports.Children = fnName;
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports.__COMPILER_RUNTIME = deprecatedAPIs;
    exports.act = function(callback) {
      var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
      actScopeDepth++;
      var queue = ReactSharedInternals.actQueue = prevActQueue !== null ? prevActQueue : [], didAwaitActCall = false;
      try {
        var result = callback();
      } catch (error) {
        ReactSharedInternals.thrownErrors.push(error);
      }
      if (0 < ReactSharedInternals.thrownErrors.length)
        throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
      if (result !== null && typeof result === "object" && typeof result.then === "function") {
        var thenable = result;
        queueSeveralMicrotasks(function() {
          didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
        });
        return {
          then: function(resolve, reject) {
            didAwaitActCall = true;
            thenable.then(function(returnValue) {
              popActScope(prevActQueue, prevActScopeDepth);
              if (prevActScopeDepth === 0) {
                try {
                  flushActQueue(queue), enqueueTask(function() {
                    return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  });
                } catch (error$0) {
                  ReactSharedInternals.thrownErrors.push(error$0);
                }
                if (0 < ReactSharedInternals.thrownErrors.length) {
                  var _thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);
                  ReactSharedInternals.thrownErrors.length = 0;
                  reject(_thrownError);
                }
              } else
                resolve(returnValue);
            }, function(error) {
              popActScope(prevActQueue, prevActScopeDepth);
              0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
            });
          }
        };
      }
      var returnValue$jscomp$0 = result;
      popActScope(prevActQueue, prevActScopeDepth);
      prevActScopeDepth === 0 && (flushActQueue(queue), queue.length !== 0 && queueSeveralMicrotasks(function() {
        didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error("A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"));
      }), ReactSharedInternals.actQueue = null);
      if (0 < ReactSharedInternals.thrownErrors.length)
        throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
      return {
        then: function(resolve, reject) {
          didAwaitActCall = true;
          prevActScopeDepth === 0 ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
            return recursivelyFlushAsyncActWork(returnValue$jscomp$0, resolve, reject);
          })) : resolve(returnValue$jscomp$0);
        }
      };
    };
    exports.cache = function(fn) {
      return function() {
        return fn.apply(null, arguments);
      };
    };
    exports.cacheSignal = function() {
      return null;
    };
    exports.captureOwnerStack = function() {
      var getCurrentStack = ReactSharedInternals.getCurrentStack;
      return getCurrentStack === null ? null : getCurrentStack();
    };
    exports.cloneElement = function(element, config, children) {
      if (element === null || element === undefined)
        throw Error("The argument must be a React element, but you passed " + element + ".");
      var props = assign({}, element.props), key = element.key, owner = element._owner;
      if (config != null) {
        var JSCompiler_inline_result;
        a: {
          if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(config, "ref").get) && JSCompiler_inline_result.isReactWarning) {
            JSCompiler_inline_result = false;
            break a;
          }
          JSCompiler_inline_result = config.ref !== undefined;
        }
        JSCompiler_inline_result && (owner = getOwner());
        hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
        for (propName in config)
          !hasOwnProperty.call(config, propName) || propName === "key" || propName === "__self" || propName === "__source" || propName === "ref" && config.ref === undefined || (props[propName] = config[propName]);
      }
      var propName = arguments.length - 2;
      if (propName === 1)
        props.children = children;
      else if (1 < propName) {
        JSCompiler_inline_result = Array(propName);
        for (var i = 0;i < propName; i++)
          JSCompiler_inline_result[i] = arguments[i + 2];
        props.children = JSCompiler_inline_result;
      }
      props = ReactElement(element.type, key, props, owner, element._debugStack, element._debugTask);
      for (key = 2;key < arguments.length; key++)
        validateChildKeys(arguments[key]);
      return props;
    };
    exports.createContext = function(defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      defaultValue._currentRenderer = null;
      defaultValue._currentRenderer2 = null;
      return defaultValue;
    };
    exports.createElement = function(type, config, children) {
      for (var i = 2;i < arguments.length; i++)
        validateChildKeys(arguments[i]);
      i = {};
      var key = null;
      if (config != null)
        for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn("Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform")), hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key), config)
          hasOwnProperty.call(config, propName) && propName !== "key" && propName !== "__self" && propName !== "__source" && (i[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1)
        i.children = children;
      else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), _i = 0;_i < childrenLength; _i++)
          childArray[_i] = arguments[_i + 2];
        Object.freeze && Object.freeze(childArray);
        i.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in childrenLength = type.defaultProps, childrenLength)
          i[propName] === undefined && (i[propName] = childrenLength[propName]);
      key && defineKeyPropWarningGetter(i, typeof type === "function" ? type.displayName || type.name || "Unknown" : type);
      var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return ReactElement(type, key, i, getOwner(), propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack, propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
    exports.createRef = function() {
      var refObject = { current: null };
      Object.seal(refObject);
      return refObject;
    };
    exports.forwardRef = function(render) {
      render != null && render.$$typeof === REACT_MEMO_TYPE ? console.error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof render !== "function" ? console.error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render) : render.length !== 0 && render.length !== 2 && console.error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
      render != null && render.defaultProps != null && console.error("forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?");
      var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
      Object.defineProperty(elementType, "displayName", {
        enumerable: false,
        configurable: true,
        get: function() {
          return ownName;
        },
        set: function(name) {
          ownName = name;
          render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
        }
      });
      return elementType;
    };
    exports.isValidElement = isValidElement;
    exports.lazy = function(ctor) {
      ctor = { _status: -1, _result: ctor };
      var lazyType = {
        $$typeof: REACT_LAZY_TYPE,
        _payload: ctor,
        _init: lazyInitializer
      }, ioInfo = {
        name: "lazy",
        start: -1,
        end: -1,
        value: null,
        owner: null,
        debugStack: Error("react-stack-top-frame"),
        debugTask: console.createTask ? console.createTask("lazy()") : null
      };
      ctor._ioInfo = ioInfo;
      lazyType._debugInfo = [{ awaited: ioInfo }];
      return lazyType;
    };
    exports.memo = function(type, compare) {
      type == null && console.error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
      compare = {
        $$typeof: REACT_MEMO_TYPE,
        type,
        compare: compare === undefined ? null : compare
      };
      var ownName;
      Object.defineProperty(compare, "displayName", {
        enumerable: false,
        configurable: true,
        get: function() {
          return ownName;
        },
        set: function(name) {
          ownName = name;
          type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
        }
      });
      return compare;
    };
    exports.startTransition = function(scope) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      currentTransition._updatedFibers = new Set;
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
        onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue);
        typeof returnValue === "object" && returnValue !== null && typeof returnValue.then === "function" && (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(noop, reportGlobalError));
      } catch (error) {
        reportGlobalError(error);
      } finally {
        prevTransition === null && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.")), prevTransition !== null && currentTransition.types !== null && (prevTransition.types !== null && prevTransition.types !== currentTransition.types && console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
      }
    };
    exports.unstable_useCacheRefresh = function() {
      return resolveDispatcher().useCacheRefresh();
    };
    exports.use = function(usable) {
      return resolveDispatcher().use(usable);
    };
    exports.useActionState = function(action, initialState, permalink) {
      return resolveDispatcher().useActionState(action, initialState, permalink);
    };
    exports.useCallback = function(callback, deps) {
      return resolveDispatcher().useCallback(callback, deps);
    };
    exports.useContext = function(Context) {
      var dispatcher = resolveDispatcher();
      Context.$$typeof === REACT_CONSUMER_TYPE && console.error("Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?");
      return dispatcher.useContext(Context);
    };
    exports.useDebugValue = function(value, formatterFn) {
      return resolveDispatcher().useDebugValue(value, formatterFn);
    };
    exports.useDeferredValue = function(value, initialValue) {
      return resolveDispatcher().useDeferredValue(value, initialValue);
    };
    exports.useEffect = function(create, deps) {
      create == null && console.warn("React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      return resolveDispatcher().useEffect(create, deps);
    };
    exports.useEffectEvent = function(callback) {
      return resolveDispatcher().useEffectEvent(callback);
    };
    exports.useId = function() {
      return resolveDispatcher().useId();
    };
    exports.useImperativeHandle = function(ref, create, deps) {
      return resolveDispatcher().useImperativeHandle(ref, create, deps);
    };
    exports.useInsertionEffect = function(create, deps) {
      create == null && console.warn("React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      return resolveDispatcher().useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function(create, deps) {
      create == null && console.warn("React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      return resolveDispatcher().useLayoutEffect(create, deps);
    };
    exports.useMemo = function(create, deps) {
      return resolveDispatcher().useMemo(create, deps);
    };
    exports.useOptimistic = function(passthrough, reducer) {
      return resolveDispatcher().useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function(reducer, initialArg, init) {
      return resolveDispatcher().useReducer(reducer, initialArg, init);
    };
    exports.useRef = function(initialValue) {
      return resolveDispatcher().useRef(initialValue);
    };
    exports.useState = function(initialState) {
      return resolveDispatcher().useState(initialState);
    };
    exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
      return resolveDispatcher().useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    };
    exports.useTransition = function() {
      return resolveDispatcher().useTransition();
    };
    exports.version = "19.2.3";
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
});

// ../../node_modules/.pnpm/react@19.2.3/node_modules/react/index.js
var require_react = __commonJS((exports, module) => {
  var react_development = __toESM(require_react_development());
  if (false) {} else {
    module.exports = react_development;
  }
});

// ../../node_modules/.pnpm/scheduler@0.27.0/node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS((exports) => {
  (function() {
    function performWorkUntilDeadline() {
      needsPaint = false;
      if (isMessageLoopRunning) {
        var currentTime = exports.unstable_now();
        startTime = currentTime;
        var hasMoreWork = true;
        try {
          a: {
            isHostCallbackScheduled = false;
            isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              b: {
                advanceTimers(currentTime);
                for (currentTask = peek(taskQueue);currentTask !== null && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                  var callback = currentTask.callback;
                  if (typeof callback === "function") {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var continuationCallback = callback(currentTask.expirationTime <= currentTime);
                    currentTime = exports.unstable_now();
                    if (typeof continuationCallback === "function") {
                      currentTask.callback = continuationCallback;
                      advanceTimers(currentTime);
                      hasMoreWork = true;
                      break b;
                    }
                    currentTask === peek(taskQueue) && pop(taskQueue);
                    advanceTimers(currentTime);
                  } else
                    pop(taskQueue);
                  currentTask = peek(taskQueue);
                }
                if (currentTask !== null)
                  hasMoreWork = true;
                else {
                  var firstTimer = peek(timerQueue);
                  firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                  hasMoreWork = false;
                }
              }
              break a;
            } finally {
              currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
            }
            hasMoreWork = undefined;
          }
        } finally {
          hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
        }
      }
    }
    function push(heap, node) {
      var index = heap.length;
      heap.push(node);
      a:
        for (;0 < index; ) {
          var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
          if (0 < compare(parent, node))
            heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
          else
            break a;
        }
    }
    function peek(heap) {
      return heap.length === 0 ? null : heap[0];
    }
    function pop(heap) {
      if (heap.length === 0)
        return null;
      var first = heap[0], last = heap.pop();
      if (last !== first) {
        heap[0] = last;
        a:
          for (var index = 0, length = heap.length, halfLength = length >>> 1;index < halfLength; ) {
            var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
            if (0 > compare(left, last))
              rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
            else if (rightIndex < length && 0 > compare(right, last))
              heap[index] = right, heap[rightIndex] = last, index = rightIndex;
            else
              break a;
          }
      }
      return first;
    }
    function compare(a, b) {
      var diff = a.sortIndex - b.sortIndex;
      return diff !== 0 ? diff : a.id - b.id;
    }
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue);timer !== null; ) {
        if (timer.callback === null)
          pop(timerQueue);
        else if (timer.startTime <= currentTime)
          pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
        else
          break;
        timer = peek(timerQueue);
      }
    }
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = false;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled)
        if (peek(taskQueue) !== null)
          isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
        else {
          var firstTimer = peek(timerQueue);
          firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
    }
    function shouldYieldToHost() {
      return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
    }
    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function() {
        callback(exports.unstable_now());
      }, ms);
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    exports.unstable_now = undefined;
    if (typeof performance === "object" && typeof performance.now === "function") {
      var localPerformance = performance;
      exports.unstable_now = function() {
        return localPerformance.now();
      };
    } else {
      var localDate = Date, initialTime = localDate.now();
      exports.unstable_now = function() {
        return localDate.now() - initialTime;
      };
    }
    var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = typeof setTimeout === "function" ? setTimeout : null, localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null, localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
    if (typeof localSetImmediate === "function")
      var schedulePerformWorkUntilDeadline = function() {
        localSetImmediate(performWorkUntilDeadline);
      };
    else if (typeof MessageChannel !== "undefined") {
      var channel = new MessageChannel, port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = function() {
        port.postMessage(null);
      };
    } else
      schedulePerformWorkUntilDeadline = function() {
        localSetTimeout(performWorkUntilDeadline, 0);
      };
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(task) {
      task.callback = null;
    };
    exports.unstable_forceFrameRate = function(fps) {
      0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = 0 < fps ? Math.floor(1000 / fps) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return currentPriorityLevel;
    };
    exports.unstable_next = function(eventHandler) {
      switch (currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_requestPaint = function() {
      needsPaint = true;
    };
    exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
      var currentTime = exports.unstable_now();
      typeof options === "object" && options !== null ? (options = options.delay, options = typeof options === "number" && 0 < options ? currentTime + options : currentTime) : options = currentTime;
      switch (priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 1e4;
          break;
        default:
          timeout = 5000;
      }
      timeout = options + timeout;
      priorityLevel = {
        id: taskIdCounter++,
        callback,
        priorityLevel,
        startTime: options,
        expirationTime: timeout,
        sortIndex: -1
      };
      options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), peek(taskQueue) === null && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
      return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function(callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function() {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
});

// ../../node_modules/.pnpm/scheduler@0.27.0/node_modules/scheduler/index.js
var require_scheduler = __commonJS((exports, module) => {
  var scheduler_development = __toESM(require_scheduler_development());
  if (false) {} else {
    module.exports = scheduler_development;
  }
});

// ../../node_modules/.pnpm/react-reconciler@0.33.0_react@19.2.3/node_modules/react-reconciler/cjs/react-reconciler.development.js
var require_react_reconciler_development = __commonJS((exports, module) => {
  var React = __toESM(require_react());
  var Scheduler = __toESM(require_scheduler());
  module.exports = function($$$config) {
    function findHook(fiber, id) {
      for (fiber = fiber.memoizedState;fiber !== null && 0 < id; )
        fiber = fiber.next, id--;
      return fiber;
    }
    function copyWithSetImpl(obj, path, index, value) {
      if (index >= path.length)
        return value;
      var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
      return updated;
    }
    function copyWithRename(obj, oldPath, newPath) {
      if (oldPath.length !== newPath.length)
        console.warn("copyWithRename() expects paths of the same length");
      else {
        for (var i = 0;i < newPath.length - 1; i++)
          if (oldPath[i] !== newPath[i]) {
            console.warn("copyWithRename() expects paths to be the same except for the deepest key");
            return;
          }
        return copyWithRenameImpl(obj, oldPath, newPath, 0);
      }
    }
    function copyWithRenameImpl(obj, oldPath, newPath, index) {
      var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);
      return updated;
    }
    function copyWithDeleteImpl(obj, path, index) {
      var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      if (index + 1 === path.length)
        return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
      updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
      return updated;
    }
    function shouldSuspendImpl() {
      return false;
    }
    function shouldErrorImpl() {
      return null;
    }
    function createFiber(tag, pendingProps, key, mode) {
      return new FiberNode(tag, pendingProps, key, mode);
    }
    function scheduleRoot(root, element) {
      root.context === emptyContextObject && (updateContainerSync(element, root, null, null), flushSyncWork());
    }
    function scheduleRefresh(root, update) {
      if (resolveFamily !== null) {
        var staleFamilies = update.staleFamilies;
        update = update.updatedFamilies;
        flushPendingEffects();
        scheduleFibersWithFamiliesRecursively(root.current, update, staleFamilies);
        flushSyncWork();
      }
    }
    function setRefreshHandler(handler) {
      resolveFamily = handler;
    }
    function warnInvalidHookAccess() {
      console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks");
    }
    function warnInvalidContextAccess() {
      console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
    }
    function noop() {}
    function warnForMissingKey() {}
    function setToSortedString(set) {
      var array = [];
      set.forEach(function(value) {
        array.push(value);
      });
      return array.sort().join(", ");
    }
    function getNearestMountedFiber(fiber) {
      var node = fiber, nearestMounted = fiber;
      if (fiber.alternate)
        for (;node.return; )
          node = node.return;
      else {
        fiber = node;
        do
          node = fiber, (node.flags & 4098) !== 0 && (nearestMounted = node.return), fiber = node.return;
        while (fiber);
      }
      return node.tag === 3 ? nearestMounted : null;
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber)
        throw Error("Unable to find node on an unmounted component.");
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        alternate = getNearestMountedFiber(fiber);
        if (alternate === null)
          throw Error("Unable to find node on an unmounted component.");
        return alternate !== fiber ? null : fiber;
      }
      for (var a = fiber, b = alternate;; ) {
        var parentA = a.return;
        if (parentA === null)
          break;
        var parentB = parentA.alternate;
        if (parentB === null) {
          b = parentA.return;
          if (b !== null) {
            a = b;
            continue;
          }
          break;
        }
        if (parentA.child === parentB.child) {
          for (parentB = parentA.child;parentB; ) {
            if (parentB === a)
              return assertIsMounted(parentA), fiber;
            if (parentB === b)
              return assertIsMounted(parentA), alternate;
            parentB = parentB.sibling;
          }
          throw Error("Unable to find node on an unmounted component.");
        }
        if (a.return !== b.return)
          a = parentA, b = parentB;
        else {
          for (var didFindChild = false, _child = parentA.child;_child; ) {
            if (_child === a) {
              didFindChild = true;
              a = parentA;
              b = parentB;
              break;
            }
            if (_child === b) {
              didFindChild = true;
              b = parentA;
              a = parentB;
              break;
            }
            _child = _child.sibling;
          }
          if (!didFindChild) {
            for (_child = parentB.child;_child; ) {
              if (_child === a) {
                didFindChild = true;
                a = parentB;
                b = parentA;
                break;
              }
              if (_child === b) {
                didFindChild = true;
                b = parentB;
                a = parentA;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild)
              throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (a.alternate !== b)
          throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (a.tag !== 3)
        throw Error("Unable to find node on an unmounted component.");
      return a.stateNode.current === a ? fiber : alternate;
    }
    function findCurrentHostFiber(parent) {
      parent = findCurrentFiberUsingSlowPath(parent);
      return parent !== null ? findCurrentHostFiberImpl(parent) : null;
    }
    function findCurrentHostFiberImpl(node) {
      var tag = node.tag;
      if (tag === 5 || tag === 26 || tag === 27 || tag === 6)
        return node;
      for (node = node.child;node !== null; ) {
        tag = findCurrentHostFiberImpl(node);
        if (tag !== null)
          return tag;
        node = node.sibling;
      }
      return null;
    }
    function findCurrentHostFiberWithNoPortalsImpl(node) {
      var tag = node.tag;
      if (tag === 5 || tag === 26 || tag === 27 || tag === 6)
        return node;
      for (node = node.child;node !== null; ) {
        if (node.tag !== 4 && (tag = findCurrentHostFiberWithNoPortalsImpl(node), tag !== null))
          return tag;
        node = node.sibling;
      }
      return null;
    }
    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable !== "object")
        return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return typeof maybeIterable === "function" ? maybeIterable : null;
    }
    function getComponentNameFromType(type) {
      if (type == null)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    function getComponentNameFromFiber(fiber) {
      var type = fiber.type;
      switch (fiber.tag) {
        case 31:
          return "Activity";
        case 24:
          return "Cache";
        case 9:
          return (type._context.displayName || "Context") + ".Consumer";
        case 10:
          return type.displayName || "Context";
        case 18:
          return "DehydratedFragment";
        case 11:
          return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || (fiber !== "" ? "ForwardRef(" + fiber + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 26:
        case 27:
        case 5:
          return type;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return getComponentNameFromType(type);
        case 8:
          return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 14:
        case 15:
          if (typeof type === "function")
            return type.displayName || type.name || null;
          if (typeof type === "string")
            return type;
          break;
        case 29:
          type = fiber._debugInfo;
          if (type != null) {
            for (var i = type.length - 1;0 <= i; i--)
              if (typeof type[i].name === "string")
                return type[i].name;
          }
          if (fiber.return !== null)
            return getComponentNameFromFiber(fiber.return);
      }
      return null;
    }
    function createCursor(defaultValue) {
      return { current: defaultValue };
    }
    function pop(cursor, fiber) {
      0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
    }
    function push(cursor, value, fiber) {
      index$jscomp$0++;
      valueStack[index$jscomp$0] = cursor.current;
      fiberStack[index$jscomp$0] = fiber;
      cursor.current = value;
    }
    function clz32Fallback(x) {
      x >>>= 0;
      return x === 0 ? 32 : 31 - (log$1(x) / LN2 | 0) | 0;
    }
    function getHighestPriorityLanes(lanes) {
      var pendingSyncLanes = lanes & 42;
      if (pendingSyncLanes !== 0)
        return pendingSyncLanes;
      switch (lanes & -lanes) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
          return lanes & 261888;
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return lanes & 3932160;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return lanes & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return console.error("Should have found matching lanes. This is a bug in React."), lanes;
      }
    }
    function getNextLanes(root, wipLanes, rootHasPendingCommit) {
      var pendingLanes = root.pendingLanes;
      if (pendingLanes === 0)
        return 0;
      var nextLanes = 0, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;
      root = root.warmLanes;
      var nonIdlePendingLanes = pendingLanes & 134217727;
      nonIdlePendingLanes !== 0 ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, pendingLanes !== 0 ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, pingedLanes !== 0 ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root, rootHasPendingCommit !== 0 && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, nonIdlePendingLanes !== 0 ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : pingedLanes !== 0 ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root, rootHasPendingCommit !== 0 && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
      return nextLanes === 0 ? 0 : wipLanes !== 0 && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === 0 && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || suspendedLanes === 32 && (rootHasPendingCommit & 4194048) !== 0) ? wipLanes : nextLanes;
    }
    function checkIfRootIsPrerendering(root, renderLanes2) {
      return (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes2) === 0;
    }
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return currentTime + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return currentTime + 5000;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return console.error("Should have found matching lanes. This is a bug in React."), -1;
      }
    }
    function claimNextRetryLane() {
      var lane = nextRetryLane;
      nextRetryLane <<= 1;
      (nextRetryLane & 62914560) === 0 && (nextRetryLane = 4194304);
      return lane;
    }
    function createLaneMap(initial) {
      for (var laneMap = [], i = 0;31 > i; i++)
        laneMap.push(initial);
      return laneMap;
    }
    function markRootUpdated$1(root, updateLane) {
      root.pendingLanes |= updateLane;
      updateLane !== 268435456 && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);
    }
    function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
      var previouslyPendingLanes = root.pendingLanes;
      root.pendingLanes = remainingLanes;
      root.suspendedLanes = 0;
      root.pingedLanes = 0;
      root.warmLanes = 0;
      root.expiredLanes &= remainingLanes;
      root.entangledLanes &= remainingLanes;
      root.errorRecoveryDisabledLanes &= remainingLanes;
      root.shellSuspendCounter = 0;
      var { entanglements, expirationTimes, hiddenUpdates } = root;
      for (remainingLanes = previouslyPendingLanes & ~remainingLanes;0 < remainingLanes; ) {
        var index = 31 - clz32(remainingLanes), lane = 1 << index;
        entanglements[index] = 0;
        expirationTimes[index] = -1;
        var hiddenUpdatesForLane = hiddenUpdates[index];
        if (hiddenUpdatesForLane !== null)
          for (hiddenUpdates[index] = null, index = 0;index < hiddenUpdatesForLane.length; index++) {
            var update = hiddenUpdatesForLane[index];
            update !== null && (update.lane &= -536870913);
          }
        remainingLanes &= ~lane;
      }
      spawnedLane !== 0 && markSpawnedDeferredLane(root, spawnedLane, 0);
      suspendedRetryLanes !== 0 && updatedLanes === 0 && root.tag !== 0 && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
    }
    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
      root.pendingLanes |= spawnedLane;
      root.suspendedLanes &= ~spawnedLane;
      var spawnedLaneIndex = 31 - clz32(spawnedLane);
      root.entangledLanes |= spawnedLane;
      root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
    }
    function markRootEntangled(root, entangledLanes) {
      var rootEntangledLanes = root.entangledLanes |= entangledLanes;
      for (root = root.entanglements;rootEntangledLanes; ) {
        var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;
        lane & entangledLanes | root[index] & entangledLanes && (root[index] |= entangledLanes);
        rootEntangledLanes &= ~lane;
      }
    }
    function getBumpedLaneForHydration(root, renderLanes2) {
      var renderLane = renderLanes2 & -renderLanes2;
      renderLane = (renderLane & 42) !== 0 ? 1 : getBumpedLaneForHydrationByLane(renderLane);
      return (renderLane & (root.suspendedLanes | renderLanes2)) !== 0 ? 0 : renderLane;
    }
    function getBumpedLaneForHydrationByLane(lane) {
      switch (lane) {
        case 2:
          lane = 1;
          break;
        case 8:
          lane = 4;
          break;
        case 32:
          lane = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          lane = 128;
          break;
        case 268435456:
          lane = 134217728;
          break;
        default:
          lane = 0;
      }
      return lane;
    }
    function addFiberToLanesMap(root, fiber, lanes) {
      if (isDevToolsPresent)
        for (root = root.pendingUpdatersLaneMap;0 < lanes; ) {
          var index = 31 - clz32(lanes), lane = 1 << index;
          root[index].add(fiber);
          lanes &= ~lane;
        }
    }
    function movePendingFibersToMemoized(root, lanes) {
      if (isDevToolsPresent)
        for (var { pendingUpdatersLaneMap, memoizedUpdaters } = root;0 < lanes; ) {
          var index = 31 - clz32(lanes);
          root = 1 << index;
          index = pendingUpdatersLaneMap[index];
          0 < index.size && (index.forEach(function(fiber) {
            var alternate = fiber.alternate;
            alternate !== null && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
          }), index.clear());
          lanes &= ~root;
        }
    }
    function lanesToEventPriority(lanes) {
      lanes &= -lanes;
      return 2 < lanes ? 8 < lanes ? (lanes & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
    }
    function injectInternals(internals) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined")
        return false;
      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (hook.isDisabled)
        return true;
      if (!hook.supportsFiber)
        return console.error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"), true;
      try {
        rendererID = hook.inject(internals), injectedHook = hook;
      } catch (err) {
        console.error("React instrumentation encountered an error: %o.", err);
      }
      return hook.checkDCE ? true : false;
    }
    function setIsStrictModeForDevtools(newIsStrictMode) {
      typeof log2 === "function" && unstable_setDisableYieldValue2(newIsStrictMode);
      if (injectedHook && typeof injectedHook.setStrictMode === "function")
        try {
          injectedHook.setStrictMode(rendererID, newIsStrictMode);
        } catch (err) {
          hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %o", err));
        }
    }
    function is(x, y) {
      return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
    }
    function getArrayKind(array) {
      for (var kind = 0, i = 0;i < array.length; i++) {
        var value = array[i];
        if (typeof value === "object" && value !== null)
          if (isArrayImpl(value) && value.length === 2 && typeof value[0] === "string") {
            if (kind !== 0 && kind !== 3)
              return 1;
            kind = 3;
          } else
            return 1;
        else {
          if (typeof value === "function" || typeof value === "string" && 50 < value.length || kind !== 0 && kind !== 2)
            return 1;
          kind = 2;
        }
      }
      return kind;
    }
    function addObjectToProperties(object, properties, indent, prefix2) {
      for (var key in object)
        hasOwnProperty.call(object, key) && key[0] !== "_" && addValueToProperties(key, object[key], properties, indent, prefix2);
    }
    function addValueToProperties(propertyName, value, properties, indent, prefix2) {
      switch (typeof value) {
        case "object":
          if (value === null) {
            value = "null";
            break;
          } else {
            if (value.$$typeof === REACT_ELEMENT_TYPE) {
              var typeName = getComponentNameFromType(value.type) || "", key = value.key;
              value = value.props;
              var propsKeys = Object.keys(value), propsLength = propsKeys.length;
              if (key == null && propsLength === 0) {
                value = "<" + typeName + " />";
                break;
              }
              if (3 > indent || propsLength === 1 && propsKeys[0] === "children" && key == null) {
                value = "<" + typeName + "  />";
                break;
              }
              properties.push([
                prefix2 + "".repeat(indent) + propertyName,
                "<" + typeName
              ]);
              key !== null && addValueToProperties("key", key, properties, indent + 1, prefix2);
              propertyName = false;
              for (var propKey in value)
                propKey === "children" ? value.children != null && (!isArrayImpl(value.children) || 0 < value.children.length) && (propertyName = true) : hasOwnProperty.call(value, propKey) && propKey[0] !== "_" && addValueToProperties(propKey, value[propKey], properties, indent + 1, prefix2);
              properties.push([
                "",
                propertyName ? "></" + typeName + ">" : "/>"
              ]);
              return;
            }
            typeName = Object.prototype.toString.call(value);
            typeName = typeName.slice(8, typeName.length - 1);
            if (typeName === "Array") {
              if (propKey = getArrayKind(value), propKey === 2 || propKey === 0) {
                value = JSON.stringify(value);
                break;
              } else if (propKey === 3) {
                properties.push([
                  prefix2 + "".repeat(indent) + propertyName,
                  ""
                ]);
                for (propertyName = 0;propertyName < value.length; propertyName++)
                  typeName = value[propertyName], addValueToProperties(typeName[0], typeName[1], properties, indent + 1, prefix2);
                return;
              }
            }
            if (typeName === "Promise") {
              if (value.status === "fulfilled") {
                if (typeName = properties.length, addValueToProperties(propertyName, value.value, properties, indent, prefix2), properties.length > typeName) {
                  properties = properties[typeName];
                  properties[1] = "Promise<" + (properties[1] || "Object") + ">";
                  return;
                }
              } else if (value.status === "rejected" && (typeName = properties.length, addValueToProperties(propertyName, value.reason, properties, indent, prefix2), properties.length > typeName)) {
                properties = properties[typeName];
                properties[1] = "Rejected Promise<" + properties[1] + ">";
                return;
              }
              properties.push([
                "".repeat(indent) + propertyName,
                "Promise"
              ]);
              return;
            }
            typeName === "Object" && (propKey = Object.getPrototypeOf(value)) && typeof propKey.constructor === "function" && (typeName = propKey.constructor.name);
            properties.push([
              prefix2 + "".repeat(indent) + propertyName,
              typeName === "Object" ? 3 > indent ? "" : "" : typeName
            ]);
            3 > indent && addObjectToProperties(value, properties, indent + 1, prefix2);
            return;
          }
        case "function":
          value = value.name === "" ? "() => {}" : value.name + "() {}";
          break;
        case "string":
          value = value === "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects." ? "" : JSON.stringify(value);
          break;
        case "undefined":
          value = "undefined";
          break;
        case "boolean":
          value = value ? "true" : "false";
          break;
        default:
          value = String(value);
      }
      properties.push([
        prefix2 + "".repeat(indent) + propertyName,
        value
      ]);
    }
    function addObjectDiffToProperties(prev, next, properties, indent) {
      var isDeeplyEqual = true;
      for (key in prev)
        key in next || (properties.push([
          "" + "".repeat(indent) + key,
          ""
        ]), isDeeplyEqual = false);
      for (var _key in next)
        if (_key in prev) {
          var key = prev[_key];
          var nextValue = next[_key];
          if (key !== nextValue) {
            if (indent === 0 && _key === "children")
              isDeeplyEqual = "".repeat(indent) + _key, properties.push(["" + isDeeplyEqual, ""], ["+" + isDeeplyEqual, ""]);
            else {
              if (!(3 <= indent)) {
                if (typeof key === "object" && typeof nextValue === "object" && key !== null && nextValue !== null && key.$$typeof === nextValue.$$typeof)
                  if (nextValue.$$typeof === REACT_ELEMENT_TYPE) {
                    if (key.type === nextValue.type && key.key === nextValue.key) {
                      key = getComponentNameFromType(nextValue.type) || "";
                      isDeeplyEqual = "".repeat(indent) + _key;
                      key = "<" + key + "  />";
                      properties.push(["" + isDeeplyEqual, key], ["+" + isDeeplyEqual, key]);
                      isDeeplyEqual = false;
                      continue;
                    }
                  } else {
                    var prevKind = Object.prototype.toString.call(key), nextKind = Object.prototype.toString.call(nextValue);
                    if (prevKind === nextKind && (nextKind === "[object Object]" || nextKind === "[object Array]")) {
                      prevKind = [
                        "" + "".repeat(indent) + _key,
                        nextKind === "[object Array]" ? "Array" : ""
                      ];
                      properties.push(prevKind);
                      nextKind = properties.length;
                      addObjectDiffToProperties(key, nextValue, properties, indent + 1) ? nextKind === properties.length && (prevKind[1] = "Referentially unequal but deeply equal objects. Consider memoization.") : isDeeplyEqual = false;
                      continue;
                    }
                  }
                else if (typeof key === "function" && typeof nextValue === "function" && key.name === nextValue.name && key.length === nextValue.length && (prevKind = Function.prototype.toString.call(key), nextKind = Function.prototype.toString.call(nextValue), prevKind === nextKind)) {
                  key = nextValue.name === "" ? "() => {}" : nextValue.name + "() {}";
                  properties.push([
                    "" + "".repeat(indent) + _key,
                    key + " Referentially unequal function closure. Consider memoization."
                  ]);
                  continue;
                }
              }
              addValueToProperties(_key, key, properties, indent, "");
              addValueToProperties(_key, nextValue, properties, indent, "+");
            }
            isDeeplyEqual = false;
          }
        } else
          properties.push([
            "+" + "".repeat(indent) + _key,
            ""
          ]), isDeeplyEqual = false;
      return isDeeplyEqual;
    }
    function setCurrentTrackFromLanes(lanes) {
      currentTrack = lanes & 63 ? "Blocking" : lanes & 64 ? "Gesture" : lanes & 4194176 ? "Transition" : lanes & 62914560 ? "Suspense" : lanes & 2080374784 ? "Idle" : "Other";
    }
    function logComponentTrigger(fiber, startTime, endTime, trigger) {
      supportsUserTiming && (reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, reusableComponentDevToolDetails.color = "warning", reusableComponentDevToolDetails.tooltipText = trigger, reusableComponentDevToolDetails.properties = null, (fiber = fiber._debugTask) ? fiber.run(performance.measure.bind(performance, trigger, reusableComponentOptions)) : performance.measure(trigger, reusableComponentOptions));
    }
    function logComponentReappeared(fiber, startTime, endTime) {
      logComponentTrigger(fiber, startTime, endTime, "Reconnect");
    }
    function logComponentRender(fiber, startTime, endTime, wasHydrated, committedLanes) {
      var name = getComponentNameFromFiber(fiber);
      if (name !== null && supportsUserTiming) {
        var { alternate, actualDuration: selfTime } = fiber;
        if (alternate === null || alternate.child !== fiber.child)
          for (var child = fiber.child;child !== null; child = child.sibling)
            selfTime -= child.actualDuration;
        wasHydrated = 0.5 > selfTime ? wasHydrated ? "tertiary-light" : "primary-light" : 10 > selfTime ? wasHydrated ? "tertiary" : "primary" : 100 > selfTime ? wasHydrated ? "tertiary-dark" : "primary-dark" : "error";
        var props = fiber.memoizedProps;
        selfTime = fiber._debugTask;
        props !== null && alternate !== null && alternate.memoizedProps !== props ? (child = [resuableChangedPropsEntry], props = addObjectDiffToProperties(alternate.memoizedProps, props, child, 0), 1 < child.length && (props && !alreadyWarnedForDeepEquality && (alternate.lanes & committedLanes) === 0 && 100 < fiber.actualDuration ? (alreadyWarnedForDeepEquality = true, child[0] = reusableDeeplyEqualPropsEntry, reusableComponentDevToolDetails.color = "warning", reusableComponentDevToolDetails.tooltipText = "This component received deeply equal props. It might benefit from useMemo or the React Compiler in its owner.") : (reusableComponentDevToolDetails.color = wasHydrated, reusableComponentDevToolDetails.tooltipText = name), reusableComponentDevToolDetails.properties = child, reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, selfTime != null ? selfTime.run(performance.measure.bind(performance, "" + name, reusableComponentOptions)) : performance.measure("" + name, reusableComponentOptions))) : selfTime != null ? selfTime.run(console.timeStamp.bind(console, name, startTime, endTime, "Components ", undefined, wasHydrated)) : console.timeStamp(name, startTime, endTime, "Components ", undefined, wasHydrated);
      }
    }
    function logComponentErrored(fiber, startTime, endTime, errors) {
      if (supportsUserTiming) {
        var name = getComponentNameFromFiber(fiber);
        if (name !== null) {
          for (var debugTask = null, properties = [], i = 0;i < errors.length; i++) {
            var capturedValue = errors[i];
            debugTask == null && capturedValue.source !== null && (debugTask = capturedValue.source._debugTask);
            capturedValue = capturedValue.value;
            properties.push([
              "Error",
              typeof capturedValue === "object" && capturedValue !== null && typeof capturedValue.message === "string" ? String(capturedValue.message) : String(capturedValue)
            ]);
          }
          fiber.key !== null && addValueToProperties("key", fiber.key, properties, 0, "");
          fiber.memoizedProps !== null && addObjectToProperties(fiber.memoizedProps, properties, 0, "");
          debugTask == null && (debugTask = fiber._debugTask);
          fiber = {
            start: startTime,
            end: endTime,
            detail: {
              devtools: {
                color: "error",
                track: "Components ",
                tooltipText: fiber.tag === 13 ? "Hydration failed" : "Error boundary caught an error",
                properties
              }
            }
          };
          debugTask ? debugTask.run(performance.measure.bind(performance, "" + name, fiber)) : performance.measure("" + name, fiber);
        }
      }
    }
    function logComponentEffect(fiber, startTime, endTime, selfTime, errors) {
      if (errors !== null) {
        if (supportsUserTiming) {
          var name = getComponentNameFromFiber(fiber);
          if (name !== null) {
            selfTime = [];
            for (var i = 0;i < errors.length; i++) {
              var error = errors[i].value;
              selfTime.push([
                "Error",
                typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error)
              ]);
            }
            fiber.key !== null && addValueToProperties("key", fiber.key, selfTime, 0, "");
            fiber.memoizedProps !== null && addObjectToProperties(fiber.memoizedProps, selfTime, 0, "");
            startTime = {
              start: startTime,
              end: endTime,
              detail: {
                devtools: {
                  color: "error",
                  track: "Components ",
                  tooltipText: "A lifecycle or effect errored",
                  properties: selfTime
                }
              }
            };
            (fiber = fiber._debugTask) ? fiber.run(performance.measure.bind(performance, "" + name, startTime)) : performance.measure("" + name, startTime);
          }
        }
      } else
        name = getComponentNameFromFiber(fiber), name !== null && supportsUserTiming && (errors = 1 > selfTime ? "secondary-light" : 100 > selfTime ? "secondary" : 500 > selfTime ? "secondary-dark" : "error", (fiber = fiber._debugTask) ? fiber.run(console.timeStamp.bind(console, name, startTime, endTime, "Components ", undefined, errors)) : console.timeStamp(name, startTime, endTime, "Components ", undefined, errors));
    }
    function logRenderPhase(startTime, endTime, lanes, debugTask) {
      if (supportsUserTiming && !(endTime <= startTime)) {
        var color = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark";
        lanes = (lanes & 536870912) === lanes ? "Prepared" : (lanes & 201326741) === lanes ? "Hydrated" : "Render";
        debugTask ? debugTask.run(console.timeStamp.bind(console, lanes, startTime, endTime, currentTrack, "Scheduler ", color)) : console.timeStamp(lanes, startTime, endTime, currentTrack, "Scheduler ", color);
      }
    }
    function logSuspendedRenderPhase(startTime, endTime, lanes, debugTask) {
      !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", debugTask ? debugTask.run(console.timeStamp.bind(console, "Prewarm", startTime, endTime, currentTrack, "Scheduler ", lanes)) : console.timeStamp("Prewarm", startTime, endTime, currentTrack, "Scheduler ", lanes));
    }
    function logSuspendedWithDelayPhase(startTime, endTime, lanes, debugTask) {
      !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", debugTask ? debugTask.run(console.timeStamp.bind(console, "Suspended", startTime, endTime, currentTrack, "Scheduler ", lanes)) : console.timeStamp("Suspended", startTime, endTime, currentTrack, "Scheduler ", lanes));
    }
    function logRecoveredRenderPhase(startTime, endTime, lanes, recoverableErrors, hydrationFailed, debugTask) {
      if (supportsUserTiming && !(endTime <= startTime)) {
        lanes = [];
        for (var i = 0;i < recoverableErrors.length; i++) {
          var error = recoverableErrors[i].value;
          lanes.push([
            "Recoverable Error",
            typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error)
          ]);
        }
        startTime = {
          start: startTime,
          end: endTime,
          detail: {
            devtools: {
              color: "primary-dark",
              track: currentTrack,
              trackGroup: "Scheduler ",
              tooltipText: hydrationFailed ? "Hydration Failed" : "Recovered after Error",
              properties: lanes
            }
          }
        };
        debugTask ? debugTask.run(performance.measure.bind(performance, "Recovered", startTime)) : performance.measure("Recovered", startTime);
      }
    }
    function logErroredRenderPhase(startTime, endTime, lanes, debugTask) {
      !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(console.timeStamp.bind(console, "Errored", startTime, endTime, currentTrack, "Scheduler ", "error")) : console.timeStamp("Errored", startTime, endTime, currentTrack, "Scheduler ", "error"));
    }
    function logSuspendedCommitPhase(startTime, endTime, reason, debugTask) {
      !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(console.timeStamp.bind(console, reason, startTime, endTime, currentTrack, "Scheduler ", "secondary-light")) : console.timeStamp(reason, startTime, endTime, currentTrack, "Scheduler ", "secondary-light"));
    }
    function logCommitErrored(startTime, endTime, errors, passive, debugTask) {
      if (supportsUserTiming && !(endTime <= startTime)) {
        for (var properties = [], i = 0;i < errors.length; i++) {
          var error = errors[i].value;
          properties.push([
            "Error",
            typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error)
          ]);
        }
        startTime = {
          start: startTime,
          end: endTime,
          detail: {
            devtools: {
              color: "error",
              track: currentTrack,
              trackGroup: "Scheduler ",
              tooltipText: passive ? "Remaining Effects Errored" : "Commit Errored",
              properties
            }
          }
        };
        debugTask ? debugTask.run(performance.measure.bind(performance, "Errored", startTime)) : performance.measure("Errored", startTime);
      }
    }
    function disabledLog() {}
    function disableLogs() {
      if (disabledDepth === 0) {
        prevLog = console.log;
        prevInfo = console.info;
        prevWarn = console.warn;
        prevError = console.error;
        prevGroup = console.group;
        prevGroupCollapsed = console.groupCollapsed;
        prevGroupEnd = console.groupEnd;
        var props = {
          configurable: true,
          enumerable: true,
          value: disabledLog,
          writable: true
        };
        Object.defineProperties(console, {
          info: props,
          log: props,
          warn: props,
          error: props,
          group: props,
          groupCollapsed: props,
          groupEnd: props
        });
      }
      disabledDepth++;
    }
    function reenableLogs() {
      disabledDepth--;
      if (disabledDepth === 0) {
        var props = { configurable: true, enumerable: true, writable: true };
        Object.defineProperties(console, {
          log: assign({}, props, { value: prevLog }),
          info: assign({}, props, { value: prevInfo }),
          warn: assign({}, props, { value: prevWarn }),
          error: assign({}, props, { value: prevError }),
          group: assign({}, props, { value: prevGroup }),
          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
          groupEnd: assign({}, props, { value: prevGroupEnd })
        });
      }
      0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function formatOwnerStack(error) {
      var prevPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = undefined;
      error = error.stack;
      Error.prepareStackTrace = prevPrepareStackTrace;
      error.startsWith(`Error: react-stack-top-frame
`) && (error = error.slice(29));
      prevPrepareStackTrace = error.indexOf(`
`);
      prevPrepareStackTrace !== -1 && (error = error.slice(prevPrepareStackTrace + 1));
      prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
      prevPrepareStackTrace !== -1 && (prevPrepareStackTrace = error.lastIndexOf(`
`, prevPrepareStackTrace));
      if (prevPrepareStackTrace !== -1)
        error = error.slice(0, prevPrepareStackTrace);
      else
        return "";
      return error;
    }
    function describeBuiltInComponentFrame(name) {
      if (prefix === undefined)
        try {
          throw Error();
        } catch (x) {
          var match = x.stack.trim().match(/\n( *(at )?)/);
          prefix = match && match[1] || "";
          suffix = -1 < x.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry)
        return "";
      var frame = componentFrameCache.get(fn);
      if (frame !== undefined)
        return frame;
      reentry = true;
      frame = Error.prepareStackTrace;
      Error.prepareStackTrace = undefined;
      var previousDispatcher = null;
      previousDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = null;
      disableLogs();
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function() {
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$0) {
                    control = x$0;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$1) {
                  control = x$1;
                }
                (Fake = fn()) && typeof Fake.catch === "function" && Fake.catch(function() {});
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string")
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
        namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split(`
`), controlLines = controlStack.split(`
`);
          for (_RunInRootFrame$Deter = namePropDescriptor = 0;namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot"); )
            namePropDescriptor++;
          for (;_RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot"); )
            _RunInRootFrame$Deter++;
          if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
            for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1;1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
              _RunInRootFrame$Deter--;
          for (;1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
            if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
              if (namePropDescriptor !== 1 || _RunInRootFrame$Deter !== 1) {
                do
                  if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                    var _frame = `
` + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                    fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                    typeof fn === "function" && componentFrameCache.set(fn, _frame);
                    return _frame;
                  }
                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
              }
              break;
            }
        }
      } finally {
        reentry = false, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
      }
      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
      typeof fn === "function" && componentFrameCache.set(fn, sampleLines);
      return sampleLines;
    }
    function describeFiber(fiber, childFiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return describeBuiltInComponentFrame(fiber.type);
        case 16:
          return describeBuiltInComponentFrame("Lazy");
        case 13:
          return fiber.child !== childFiber && childFiber !== null ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
        case 19:
          return describeBuiltInComponentFrame("SuspenseList");
        case 0:
        case 15:
          return describeNativeComponentFrame(fiber.type, false);
        case 11:
          return describeNativeComponentFrame(fiber.type.render, false);
        case 1:
          return describeNativeComponentFrame(fiber.type, true);
        case 31:
          return describeBuiltInComponentFrame("Activity");
        default:
          return "";
      }
    }
    function getStackByFiberInDevAndProd(workInProgress2) {
      try {
        var info = "", previous = null;
        do {
          info += describeFiber(workInProgress2, previous);
          var debugInfo = workInProgress2._debugInfo;
          if (debugInfo)
            for (var i = debugInfo.length - 1;0 <= i; i--) {
              var entry = debugInfo[i];
              if (typeof entry.name === "string") {
                var JSCompiler_temp_const = info;
                a: {
                  var { name, env, debugLocation: location } = entry;
                  if (location != null) {
                    var childStack = formatOwnerStack(location), idx = childStack.lastIndexOf(`
`), lastLine = idx === -1 ? childStack : childStack.slice(idx + 1);
                    if (lastLine.indexOf(name) !== -1) {
                      var JSCompiler_inline_result = `
` + lastLine;
                      break a;
                    }
                  }
                  JSCompiler_inline_result = describeBuiltInComponentFrame(name + (env ? " [" + env + "]" : ""));
                }
                info = JSCompiler_temp_const + JSCompiler_inline_result;
              }
            }
          previous = workInProgress2;
          workInProgress2 = workInProgress2.return;
        } while (workInProgress2);
        return info;
      } catch (x) {
        return `
Error generating stack: ` + x.message + `
` + x.stack;
      }
    }
    function describeFunctionComponentFrameWithoutLineNumber(fn) {
      return (fn = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(fn) : "";
    }
    function createCapturedValueAtFiber(value, source) {
      if (typeof value === "object" && value !== null) {
        var existing = CapturedStacks.get(value);
        if (existing !== undefined)
          return existing;
        source = {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
        CapturedStacks.set(value, source);
        return source;
      }
      return {
        value,
        source,
        stack: getStackByFiberInDevAndProd(source)
      };
    }
    function pushTreeFork(workInProgress2, totalChildren) {
      warnIfNotHydrating();
      forkStack[forkStackIndex++] = treeForkCount;
      forkStack[forkStackIndex++] = treeForkProvider;
      treeForkProvider = workInProgress2;
      treeForkCount = totalChildren;
    }
    function pushTreeId(workInProgress2, totalChildren, index) {
      warnIfNotHydrating();
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextProvider = workInProgress2;
      var baseIdWithLeadingBit = treeContextId;
      workInProgress2 = treeContextOverflow;
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index += 1;
      var length = 32 - clz32(totalChildren) + baseLength;
      if (30 < length) {
        var numberOfOverflowBits = baseLength - baseLength % 5;
        length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
        treeContextOverflow = length + workInProgress2;
      } else
        treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
    }
    function pushMaterializedTreeId(workInProgress2) {
      warnIfNotHydrating();
      workInProgress2.return !== null && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
    }
    function popTreeContext(workInProgress2) {
      for (;workInProgress2 === treeForkProvider; )
        treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
      for (;workInProgress2 === treeContextProvider; )
        treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
    }
    function getSuspendedTreeContext() {
      warnIfNotHydrating();
      return treeContextProvider !== null ? { id: treeContextId, overflow: treeContextOverflow } : null;
    }
    function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
      warnIfNotHydrating();
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextId = suspendedContext.id;
      treeContextOverflow = suspendedContext.overflow;
      treeContextProvider = workInProgress2;
    }
    function warnIfNotHydrating() {
      isHydrating || console.error("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    function requiredContext(c) {
      c === null && console.error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return c;
    }
    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance, fiber);
      push(contextFiberStackCursor, fiber, fiber);
      push(contextStackCursor, null, fiber);
      nextRootInstance = getRootHostContext(nextRootInstance);
      pop(contextStackCursor, fiber);
      push(contextStackCursor, nextRootInstance, fiber);
    }
    function popHostContainer(fiber) {
      pop(contextStackCursor, fiber);
      pop(contextFiberStackCursor, fiber);
      pop(rootInstanceStackCursor, fiber);
    }
    function getHostContext() {
      return requiredContext(contextStackCursor.current);
    }
    function pushHostContext(fiber) {
      fiber.memoizedState !== null && push(hostTransitionProviderCursor, fiber, fiber);
      var context = requiredContext(contextStackCursor.current), nextContext = getChildHostContext(context, fiber.type);
      context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
    }
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
      hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), isPrimaryRenderer ? HostTransitionContext._currentValue = NotPendingTransition : HostTransitionContext._currentValue2 = NotPendingTransition);
    }
    function findNotableNode(node, indent) {
      return node.serverProps === undefined && node.serverTail.length === 0 && node.children.length === 1 && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
    }
    function indentation(indent) {
      return "  " + "  ".repeat(indent);
    }
    function added(indent) {
      return "+ " + "  ".repeat(indent);
    }
    function removed(indent) {
      return "- " + "  ".repeat(indent);
    }
    function describeFiberType(fiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return fiber.type;
        case 16:
          return "Lazy";
        case 31:
          return "Activity";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 0:
        case 15:
          return fiber = fiber.type, fiber.displayName || fiber.name || null;
        case 11:
          return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
        case 1:
          return fiber = fiber.type, fiber.displayName || fiber.name || null;
        default:
          return null;
      }
    }
    function describeTextNode(content, maxLength) {
      return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
    }
    function describeTextDiff(clientText, serverProps, indent) {
      var maxLength = 120 - 2 * indent;
      if (serverProps === null)
        return added(indent) + describeTextNode(clientText, maxLength) + `
`;
      if (typeof serverProps === "string") {
        for (var firstDiff = 0;firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++)
          ;
        firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
        return added(indent) + describeTextNode(clientText, maxLength) + `
` + removed(indent) + describeTextNode(serverProps, maxLength) + `
`;
      }
      return indentation(indent) + describeTextNode(clientText, maxLength) + `
`;
    }
    function objectName(object) {
      return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m, p0) {
        return p0;
      });
    }
    function describeValue(value, maxLength) {
      switch (typeof value) {
        case "string":
          return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
        case "object":
          if (value === null)
            return "null";
          if (isArrayImpl(value))
            return "[...]";
          if (value.$$typeof === REACT_ELEMENT_TYPE)
            return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
          var name = objectName(value);
          if (name === "Object") {
            name = "";
            maxLength -= 2;
            for (var propName in value)
              if (value.hasOwnProperty(propName)) {
                var jsonPropName = JSON.stringify(propName);
                jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
                maxLength -= propName.length - 2;
                jsonPropName = describeValue(value[propName], 15 > maxLength ? maxLength : 15);
                maxLength -= jsonPropName.length;
                if (0 > maxLength) {
                  name += name === "" ? "..." : ", ...";
                  break;
                }
                name += (name === "" ? "" : ",") + propName + ":" + jsonPropName;
              }
            return "{" + name + "}";
          }
          return name;
        case "function":
          return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
        default:
          return String(value);
      }
    }
    function describePropValue(value, maxLength) {
      return typeof value !== "string" || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
    }
    function describeExpandedElement(type, props, rowPrefix) {
      var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;
      for (propName in props)
        if (props.hasOwnProperty(propName) && propName !== "children") {
          var propValue = describePropValue(props[propName], 120 - rowPrefix.length - propName.length - 1);
          remainingRowLength -= propName.length + propValue.length + 2;
          properties.push(propName + "=" + propValue);
        }
      return properties.length === 0 ? rowPrefix + "<" + type + `>
` : 0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + `>
` : rowPrefix + "<" + type + `
` + rowPrefix + "  " + properties.join(`
` + rowPrefix + "  ") + `
` + rowPrefix + `>
`;
    }
    function describePropertiesDiff(clientObject, serverObject, indent) {
      var properties = "", remainingServerProperties = assign({}, serverObject), propName;
      for (propName in clientObject)
        if (clientObject.hasOwnProperty(propName)) {
          delete remainingServerProperties[propName];
          var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);
          serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + `
`, properties += removed(indent) + propName + ": " + maxLength + `
`) : properties += added(indent) + propName + ": " + clientPropValue + `
`;
        }
      for (var _propName in remainingServerProperties)
        remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(remainingServerProperties[_propName], 120 - 2 * indent - _propName.length - 2), properties += removed(indent) + _propName + ": " + clientObject + `
`);
      return properties;
    }
    function describeElementDiff(type, clientProps, serverProps, indent) {
      var content = "", serverPropNames = new Map;
      for (propName$jscomp$0 in serverProps)
        serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(propName$jscomp$0.toLowerCase(), propName$jscomp$0);
      if (serverPropNames.size === 1 && serverPropNames.has("children"))
        content += describeExpandedElement(type, clientProps, indentation(indent));
      else {
        for (var _propName2 in clientProps)
          if (clientProps.hasOwnProperty(_propName2) && _propName2 !== "children") {
            var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());
            if (serverPropName !== undefined) {
              serverPropNames.delete(_propName2.toLowerCase());
              var propName$jscomp$0 = clientProps[_propName2];
              serverPropName = serverProps[serverPropName];
              var clientPropValue = describePropValue(propName$jscomp$0, maxLength$jscomp$0);
              maxLength$jscomp$0 = describePropValue(serverPropName, maxLength$jscomp$0);
              typeof propName$jscomp$0 === "object" && propName$jscomp$0 !== null && typeof serverPropName === "object" && serverPropName !== null && objectName(propName$jscomp$0) === "Object" && objectName(serverPropName) === "Object" && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + `={{
` + describePropertiesDiff(propName$jscomp$0, serverPropName, indent + 2) + indentation(indent + 1) + `}}
` : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + `
`, content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + `
`);
            } else
              content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + `
`;
          }
        serverPropNames.forEach(function(propName) {
          if (propName !== "children") {
            var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
            content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + `
`;
          }
        });
        content = content === "" ? indentation(indent) + "<" + type + `>
` : indentation(indent) + "<" + type + `
` + content + indentation(indent) + `>
`;
      }
      type = serverProps.children;
      clientProps = clientProps.children;
      if (typeof type === "string" || typeof type === "number" || typeof type === "bigint") {
        serverPropNames = "";
        if (typeof clientProps === "string" || typeof clientProps === "number" || typeof clientProps === "bigint")
          serverPropNames = "" + clientProps;
        content += describeTextDiff(serverPropNames, "" + type, indent + 1);
      } else if (typeof clientProps === "string" || typeof clientProps === "number" || typeof clientProps === "bigint")
        content = type == null ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, undefined, indent + 1);
      return content;
    }
    function describeSiblingFiber(fiber, indent) {
      var type = describeFiberType(fiber);
      if (type === null) {
        type = "";
        for (fiber = fiber.child;fiber; )
          type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
        return type;
      }
      return indentation(indent) + "<" + type + `>
`;
    }
    function describeNode(node, indent) {
      var skipToNode = findNotableNode(node, indent);
      if (skipToNode !== node && (node.children.length !== 1 || node.children[0] !== skipToNode))
        return indentation(indent) + `...
` + describeNode(skipToNode, indent + 1);
      skipToNode = "";
      var debugInfo = node.fiber._debugInfo;
      if (debugInfo)
        for (var i = 0;i < debugInfo.length; i++) {
          var serverComponentName = debugInfo[i].name;
          typeof serverComponentName === "string" && (skipToNode += indentation(indent) + "<" + serverComponentName + `>
`, indent++);
        }
      debugInfo = "";
      i = node.fiber.pendingProps;
      if (node.fiber.tag === 6)
        debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;
      else if (serverComponentName = describeFiberType(node.fiber), serverComponentName !== null)
        if (node.serverProps === undefined) {
          debugInfo = indent;
          var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = "";
          for (propName in i)
            if (i.hasOwnProperty(propName) && propName !== "children") {
              var propValue = describePropValue(i[propName], 15);
              maxLength -= propName.length + propValue.length + 2;
              if (0 > maxLength) {
                content += " ...";
                break;
              }
              content += " " + propName + "=" + propValue;
            }
          debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + `>
`;
          indent++;
        } else
          node.serverProps === null ? (debugInfo = describeExpandedElement(serverComponentName, i, added(indent)), indent++) : typeof node.serverProps === "string" ? console.error("Should not have matched a non HostText fiber to a Text node. This is a bug in React.") : (debugInfo = describeElementDiff(serverComponentName, i, node.serverProps, indent), indent++);
      var propName = "";
      i = node.fiber.child;
      for (serverComponentName = 0;i && serverComponentName < node.children.length; )
        maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;
      i && 0 < node.children.length && (propName += indentation(indent) + `...
`);
      i = node.serverTail;
      node.serverProps === null && indent--;
      for (node = 0;node < i.length; node++)
        serverComponentName = i[node], propName = typeof serverComponentName === "string" ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + `
`) : propName + describeExpandedElement(serverComponentName.type, serverComponentName.props, removed(indent));
      return skipToNode + debugInfo + propName;
    }
    function describeDiff(rootNode) {
      try {
        return `

` + describeNode(rootNode, 0);
      } catch (x) {
        return "";
      }
    }
    function getCurrentFiberStackInDev() {
      if (current === null)
        return "";
      var workInProgress2 = current;
      try {
        var info = "";
        workInProgress2.tag === 6 && (workInProgress2 = workInProgress2.return);
        switch (workInProgress2.tag) {
          case 26:
          case 27:
          case 5:
            info += describeBuiltInComponentFrame(workInProgress2.type);
            break;
          case 13:
            info += describeBuiltInComponentFrame("Suspense");
            break;
          case 19:
            info += describeBuiltInComponentFrame("SuspenseList");
            break;
          case 31:
            info += describeBuiltInComponentFrame("Activity");
            break;
          case 30:
          case 0:
          case 15:
          case 1:
            workInProgress2._debugOwner || info !== "" || (info += describeFunctionComponentFrameWithoutLineNumber(workInProgress2.type));
            break;
          case 11:
            workInProgress2._debugOwner || info !== "" || (info += describeFunctionComponentFrameWithoutLineNumber(workInProgress2.type.render));
        }
        for (;workInProgress2; )
          if (typeof workInProgress2.tag === "number") {
            var fiber = workInProgress2;
            workInProgress2 = fiber._debugOwner;
            var debugStack = fiber._debugStack;
            if (workInProgress2 && debugStack) {
              var formattedStack = formatOwnerStack(debugStack);
              formattedStack !== "" && (info += `
` + formattedStack);
            }
          } else if (workInProgress2.debugStack != null) {
            var ownerStack = workInProgress2.debugStack;
            (workInProgress2 = workInProgress2.owner) && ownerStack && (info += `
` + formatOwnerStack(ownerStack));
          } else
            break;
        var JSCompiler_inline_result = info;
      } catch (x) {
        JSCompiler_inline_result = `
Error generating stack: ` + x.message + `
` + x.stack;
      }
      return JSCompiler_inline_result;
    }
    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
      var previousFiber = current;
      setCurrentFiber(fiber);
      try {
        return fiber !== null && fiber._debugTask ? fiber._debugTask.run(callback.bind(null, arg0, arg1, arg2, arg3, arg4)) : callback(arg0, arg1, arg2, arg3, arg4);
      } finally {
        setCurrentFiber(previousFiber);
      }
      throw Error("runWithFiberInDEV should never be called in production. This is a bug in React.");
    }
    function setCurrentFiber(fiber) {
      ReactSharedInternals.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
      isRendering = false;
      current = fiber;
    }
    function buildHydrationDiffNode(fiber, distanceFromLeaf) {
      if (fiber.return === null) {
        if (hydrationDiffRootDEV === null)
          hydrationDiffRootDEV = {
            fiber,
            children: [],
            serverProps: undefined,
            serverTail: [],
            distanceFromLeaf
          };
        else {
          if (hydrationDiffRootDEV.fiber !== fiber)
            throw Error("Saw multiple hydration diff roots in a pass. This is a bug in React.");
          hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
        }
        return hydrationDiffRootDEV;
      }
      var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children;
      if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
        return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
      distanceFromLeaf = {
        fiber,
        children: [],
        serverProps: undefined,
        serverTail: [],
        distanceFromLeaf
      };
      siblings.push(distanceFromLeaf);
      return distanceFromLeaf;
    }
    function warnIfHydrating() {
      isHydrating && console.error("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function warnNonHydratedInstance(fiber, rejectedCandidate) {
      didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, rejectedCandidate !== null && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
    }
    function throwOnHydrationMismatch(fiber) {
      var fromText = 1 < arguments.length && arguments[1] !== undefined ? arguments[1] : false, diff = "", diffRoot = hydrationDiffRootDEV;
      diffRoot !== null && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
      queueHydrationError(createCapturedValueAtFiber(Error("Hydration failed because the server rendered " + (fromText ? "text" : "HTML") + ` didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

https://react.dev/link/hydration-mismatch` + diff), fiber));
      throw HydrationMismatchException;
    }
    function prepareToHydrateHostInstance(fiber, hostContext) {
      if (!supportsHydration)
        throw Error("Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      hydrateInstance(fiber.stateNode, fiber.type, fiber.memoizedProps, hostContext, fiber) || throwOnHydrationMismatch(fiber, true);
    }
    function popToNextHostParent(fiber) {
      for (hydrationParentFiber = fiber.return;hydrationParentFiber; )
        switch (hydrationParentFiber.tag) {
          case 5:
          case 31:
          case 13:
            rootOrSingletonContext = false;
            return;
          case 27:
          case 3:
            rootOrSingletonContext = true;
            return;
          default:
            hydrationParentFiber = hydrationParentFiber.return;
        }
    }
    function popHydrationState(fiber) {
      if (!supportsHydration || fiber !== hydrationParentFiber)
        return false;
      if (!isHydrating)
        return popToNextHostParent(fiber), isHydrating = true, false;
      var tag = fiber.tag;
      supportsSingletons ? tag !== 3 && tag !== 27 && (tag !== 5 || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && nextHydratableInstance && (warnIfUnhydratedTailNodes(fiber), throwOnHydrationMismatch(fiber)) : tag !== 3 && (tag !== 5 || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && nextHydratableInstance && (warnIfUnhydratedTailNodes(fiber), throwOnHydrationMismatch(fiber));
      popToNextHostParent(fiber);
      if (tag === 13) {
        if (!supportsHydration)
          throw Error("Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
        fiber = fiber.memoizedState;
        fiber = fiber !== null ? fiber.dehydrated : null;
        if (!fiber)
          throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);
      } else if (tag === 31) {
        fiber = fiber.memoizedState;
        fiber = fiber !== null ? fiber.dehydrated : null;
        if (!fiber)
          throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        nextHydratableInstance = getNextHydratableInstanceAfterActivityInstance(fiber);
      } else
        nextHydratableInstance = supportsSingletons && tag === 27 ? getNextHydratableSiblingAfterSingleton(fiber.type, nextHydratableInstance) : hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
      return true;
    }
    function warnIfUnhydratedTailNodes(fiber) {
      for (var nextInstance = nextHydratableInstance;nextInstance; ) {
        var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(nextInstance);
        diffNode.serverTail.push(description);
        nextInstance = description.type === "Suspense" ? getNextHydratableInstanceAfterSuspenseInstance(nextInstance) : getNextHydratableSibling(nextInstance);
      }
    }
    function resetHydrationState() {
      supportsHydration && (nextHydratableInstance = hydrationParentFiber = null, didSuspendOrErrorDEV = isHydrating = false);
    }
    function upgradeHydrationErrorsToRecoverable() {
      var queuedErrors = hydrationErrors;
      queuedErrors !== null && (workInProgressRootRecoverableErrors === null ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, queuedErrors), hydrationErrors = null);
      return queuedErrors;
    }
    function queueHydrationError(error) {
      hydrationErrors === null ? hydrationErrors = [error] : hydrationErrors.push(error);
    }
    function emitPendingHydrationWarnings() {
      var diffRoot = hydrationDiffRootDEV;
      if (diffRoot !== null) {
        hydrationDiffRootDEV = null;
        for (var diff = describeDiff(diffRoot);0 < diffRoot.children.length; )
          diffRoot = diffRoot.children[0];
        runWithFiberInDEV(diffRoot.fiber, function() {
          console.error(`A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

%s%s`, "https://react.dev/link/hydration-mismatch", diff);
        });
      }
    }
    function resetContextDependencies() {
      lastContextDependency = currentlyRenderingFiber$1 = null;
      isDisallowedContextReadInDEV = false;
    }
    function pushProvider(providerFiber, context, nextValue) {
      isPrimaryRenderer ? (push(valueCursor, context._currentValue, providerFiber), context._currentValue = nextValue, push(rendererCursorDEV, context._currentRenderer, providerFiber), context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), context._currentRenderer = rendererSigil) : (push(valueCursor, context._currentValue2, providerFiber), context._currentValue2 = nextValue, push(renderer2CursorDEV, context._currentRenderer2, providerFiber), context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), context._currentRenderer2 = rendererSigil);
    }
    function popProvider(context, providerFiber) {
      var currentValue = valueCursor.current;
      isPrimaryRenderer ? (context._currentValue = currentValue, currentValue = rendererCursorDEV.current, pop(rendererCursorDEV, providerFiber), context._currentRenderer = currentValue) : (context._currentValue2 = currentValue, currentValue = renderer2CursorDEV.current, pop(renderer2CursorDEV, providerFiber), context._currentRenderer2 = currentValue);
      pop(valueCursor, providerFiber);
    }
    function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
      for (;parent !== null; ) {
        var alternate = parent.alternate;
        (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, alternate !== null && (alternate.childLanes |= renderLanes2)) : alternate !== null && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
        if (parent === propagationRoot)
          break;
        parent = parent.return;
      }
      parent !== propagationRoot && console.error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
      var fiber = workInProgress2.child;
      fiber !== null && (fiber.return = workInProgress2);
      for (;fiber !== null; ) {
        var list = fiber.dependencies;
        if (list !== null) {
          var nextFiber = fiber.child;
          list = list.firstContext;
          a:
            for (;list !== null; ) {
              var dependency = list;
              list = fiber;
              for (var i = 0;i < contexts.length; i++)
                if (dependency.context === contexts[i]) {
                  list.lanes |= renderLanes2;
                  dependency = list.alternate;
                  dependency !== null && (dependency.lanes |= renderLanes2);
                  scheduleContextWorkOnParentPath(list.return, renderLanes2, workInProgress2);
                  forcePropagateEntireTree || (nextFiber = null);
                  break a;
                }
              list = dependency.next;
            }
        } else if (fiber.tag === 18) {
          nextFiber = fiber.return;
          if (nextFiber === null)
            throw Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          nextFiber.lanes |= renderLanes2;
          list = nextFiber.alternate;
          list !== null && (list.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
          nextFiber = null;
        } else
          nextFiber = fiber.child;
        if (nextFiber !== null)
          nextFiber.return = fiber;
        else
          for (nextFiber = fiber;nextFiber !== null; ) {
            if (nextFiber === workInProgress2) {
              nextFiber = null;
              break;
            }
            fiber = nextFiber.sibling;
            if (fiber !== null) {
              fiber.return = nextFiber.return;
              nextFiber = fiber;
              break;
            }
            nextFiber = nextFiber.return;
          }
        fiber = nextFiber;
      }
    }
    function propagateParentContextChanges(current2, workInProgress2, renderLanes2, forcePropagateEntireTree) {
      current2 = null;
      for (var parent = workInProgress2, isInsidePropagationBailout = false;parent !== null; ) {
        if (!isInsidePropagationBailout) {
          if ((parent.flags & 524288) !== 0)
            isInsidePropagationBailout = true;
          else if ((parent.flags & 262144) !== 0)
            break;
        }
        if (parent.tag === 10) {
          var currentParent = parent.alternate;
          if (currentParent === null)
            throw Error("Should have a current fiber. This is a bug in React.");
          currentParent = currentParent.memoizedProps;
          if (currentParent !== null) {
            var context = parent.type;
            objectIs(parent.pendingProps.value, currentParent.value) || (current2 !== null ? current2.push(context) : current2 = [context]);
          }
        } else if (parent === hostTransitionProviderCursor.current) {
          currentParent = parent.alternate;
          if (currentParent === null)
            throw Error("Should have a current fiber. This is a bug in React.");
          currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (current2 !== null ? current2.push(HostTransitionContext) : current2 = [HostTransitionContext]);
        }
        parent = parent.return;
      }
      current2 !== null && propagateContextChanges(workInProgress2, current2, renderLanes2, forcePropagateEntireTree);
      workInProgress2.flags |= 262144;
    }
    function checkIfContextChanged(currentDependencies) {
      for (currentDependencies = currentDependencies.firstContext;currentDependencies !== null; ) {
        var context = currentDependencies.context;
        if (!objectIs(isPrimaryRenderer ? context._currentValue : context._currentValue2, currentDependencies.memoizedValue))
          return true;
        currentDependencies = currentDependencies.next;
      }
      return false;
    }
    function prepareToReadContext(workInProgress2) {
      currentlyRenderingFiber$1 = workInProgress2;
      lastContextDependency = null;
      workInProgress2 = workInProgress2.dependencies;
      workInProgress2 !== null && (workInProgress2.firstContext = null);
    }
    function readContext(context) {
      isDisallowedContextReadInDEV && console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      return readContextForConsumer(currentlyRenderingFiber$1, context);
    }
    function readContextDuringReconciliation(consumer, context) {
      currentlyRenderingFiber$1 === null && prepareToReadContext(consumer);
      return readContextForConsumer(consumer, context);
    }
    function readContextForConsumer(consumer, context) {
      var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;
      context = { context, memoizedValue: value, next: null };
      if (lastContextDependency === null) {
        if (consumer === null)
          throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        lastContextDependency = context;
        consumer.dependencies = {
          lanes: 0,
          firstContext: context,
          _debugThenableState: null
        };
        consumer.flags |= 524288;
      } else
        lastContextDependency = lastContextDependency.next = context;
      return value;
    }
    function createCache() {
      return {
        controller: new AbortControllerLocal,
        data: new Map,
        refCount: 0
      };
    }
    function retainCache(cache) {
      cache.controller.signal.aborted && console.warn("A cache instance was retained after it was already freed. This likely indicates a bug in React.");
      cache.refCount++;
    }
    function releaseCache(cache) {
      cache.refCount--;
      0 > cache.refCount && console.warn("A cache instance was released after it was already freed. This likely indicates a bug in React.");
      cache.refCount === 0 && scheduleCallback$2(NormalPriority, function() {
        cache.controller.abort();
      });
    }
    function startUpdateTimerByLane(lane, method, fiber) {
      if ((lane & 127) !== 0)
        0 > blockingUpdateTime && (blockingUpdateTime = now2(), blockingUpdateTask = createTask(method), blockingUpdateMethodName = method, fiber != null && (blockingUpdateComponentName = getComponentNameFromFiber(fiber)), isAlreadyRendering() && (componentEffectSpawnedUpdate = true, blockingUpdateType = 1), lane = resolveEventTimeStamp(), method = resolveEventType(), lane !== blockingEventRepeatTime || method !== blockingEventType ? blockingEventRepeatTime = -1.1 : method !== null && (blockingUpdateType = 1), blockingEventTime = lane, blockingEventType = method);
      else if ((lane & 4194048) !== 0 && 0 > transitionUpdateTime && (transitionUpdateTime = now2(), transitionUpdateTask = createTask(method), transitionUpdateMethodName = method, fiber != null && (transitionUpdateComponentName = getComponentNameFromFiber(fiber)), 0 > transitionStartTime)) {
        lane = resolveEventTimeStamp();
        method = resolveEventType();
        if (lane !== transitionEventRepeatTime || method !== transitionEventType)
          transitionEventRepeatTime = -1.1;
        transitionEventTime = lane;
        transitionEventType = method;
      }
    }
    function startHostActionTimer(fiber) {
      if (0 > blockingUpdateTime) {
        blockingUpdateTime = now2();
        blockingUpdateTask = fiber._debugTask != null ? fiber._debugTask : null;
        isAlreadyRendering() && (blockingUpdateType = 1);
        var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();
        newEventTime !== blockingEventRepeatTime || newEventType !== blockingEventType ? blockingEventRepeatTime = -1.1 : newEventType !== null && (blockingUpdateType = 1);
        blockingEventTime = newEventTime;
        blockingEventType = newEventType;
      }
      if (0 > transitionUpdateTime && (transitionUpdateTime = now2(), transitionUpdateTask = fiber._debugTask != null ? fiber._debugTask : null, 0 > transitionStartTime)) {
        fiber = resolveEventTimeStamp();
        newEventTime = resolveEventType();
        if (fiber !== transitionEventRepeatTime || newEventTime !== transitionEventType)
          transitionEventRepeatTime = -1.1;
        transitionEventTime = fiber;
        transitionEventType = newEventTime;
      }
    }
    function pushNestedEffectDurations() {
      var prevEffectDuration = profilerEffectDuration;
      profilerEffectDuration = 0;
      return prevEffectDuration;
    }
    function popNestedEffectDurations(prevEffectDuration) {
      var elapsedTime = profilerEffectDuration;
      profilerEffectDuration = prevEffectDuration;
      return elapsedTime;
    }
    function bubbleNestedEffectDurations(prevEffectDuration) {
      var elapsedTime = profilerEffectDuration;
      profilerEffectDuration += prevEffectDuration;
      return elapsedTime;
    }
    function resetComponentEffectTimers() {
      componentEffectEndTime = componentEffectStartTime = -1.1;
    }
    function pushComponentEffectStart() {
      var prevEffectStart = componentEffectStartTime;
      componentEffectStartTime = -1.1;
      return prevEffectStart;
    }
    function popComponentEffectStart(prevEffectStart) {
      0 <= prevEffectStart && (componentEffectStartTime = prevEffectStart);
    }
    function pushComponentEffectDuration() {
      var prevEffectDuration = componentEffectDuration;
      componentEffectDuration = -0;
      return prevEffectDuration;
    }
    function popComponentEffectDuration(prevEffectDuration) {
      0 <= prevEffectDuration && (componentEffectDuration = prevEffectDuration);
    }
    function pushComponentEffectErrors() {
      var prevErrors = componentEffectErrors;
      componentEffectErrors = null;
      return prevErrors;
    }
    function pushComponentEffectDidSpawnUpdate() {
      var prev = componentEffectSpawnedUpdate;
      componentEffectSpawnedUpdate = false;
      return prev;
    }
    function startProfilerTimer(fiber) {
      profilerStartTime = now2();
      0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
    }
    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
      if (0 <= profilerStartTime) {
        var elapsedTime = now2() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        fiber.selfBaseDuration = elapsedTime;
        profilerStartTime = -1;
      }
    }
    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
      if (0 <= profilerStartTime) {
        var elapsedTime = now2() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        profilerStartTime = -1;
      }
    }
    function recordEffectDuration() {
      if (0 <= profilerStartTime) {
        var endTime = now2(), elapsedTime = endTime - profilerStartTime;
        profilerStartTime = -1;
        profilerEffectDuration += elapsedTime;
        componentEffectDuration += elapsedTime;
        componentEffectEndTime = endTime;
      }
    }
    function recordEffectError(errorInfo) {
      componentEffectErrors === null && (componentEffectErrors = []);
      componentEffectErrors.push(errorInfo);
      commitErrors === null && (commitErrors = []);
      commitErrors.push(errorInfo);
    }
    function startEffectTimer() {
      profilerStartTime = now2();
      0 > componentEffectStartTime && (componentEffectStartTime = profilerStartTime);
    }
    function transferActualDuration(fiber) {
      for (var child = fiber.child;child; )
        fiber.actualDuration += child.actualDuration, child = child.sibling;
    }
    function noop$1() {}
    function ensureRootIsScheduled(root) {
      root !== lastScheduledRoot && root.next === null && (lastScheduledRoot === null ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);
      mightHavePendingSyncWork = true;
      ReactSharedInternals.actQueue !== null ? didScheduleMicrotask_act || (didScheduleMicrotask_act = true, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
    }
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
      if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = true;
        do {
          var didPerformSomeWork = false;
          for (var root = firstScheduledRoot;root !== null; ) {
            if (!onlyLegacy)
              if (syncTransitionLanes !== 0) {
                var pendingLanes = root.pendingLanes;
                if (pendingLanes === 0)
                  var nextLanes = 0;
                else {
                  var { suspendedLanes, pingedLanes } = root;
                  nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                  nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                  nextLanes = nextLanes & 201326741 ? nextLanes & 201326741 | 1 : nextLanes ? nextLanes | 2 : 0;
                }
                nextLanes !== 0 && (didPerformSomeWork = true, performSyncWorkOnRoot(root, nextLanes));
              } else
                nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(root, root === workInProgressRoot ? nextLanes : 0, root.cancelPendingCommit !== null || root.timeoutHandle !== noTimeout), (nextLanes & 3) === 0 || checkIfRootIsPrerendering(root, nextLanes) || (didPerformSomeWork = true, performSyncWorkOnRoot(root, nextLanes));
            root = root.next;
          }
        } while (didPerformSomeWork);
        isFlushingWork = false;
      }
    }
    function processRootScheduleInImmediateTask() {
      trackSchedulerEvent();
      processRootScheduleInMicrotask();
    }
    function processRootScheduleInMicrotask() {
      mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = false;
      var syncTransitionLanes = 0;
      currentEventTransitionLane !== 0 && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
      for (var currentTime = now$1(), prev = null, root = firstScheduledRoot;root !== null; ) {
        var next = root.next, nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
        if (nextLanes === 0)
          root.next = null, prev === null ? firstScheduledRoot = next : prev.next = next, next === null && (lastScheduledRoot = prev);
        else if (prev = root, syncTransitionLanes !== 0 || (nextLanes & 3) !== 0)
          mightHavePendingSyncWork = true;
        root = next;
      }
      pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE || flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
      currentEventTransitionLane !== 0 && (currentEventTransitionLane = 0);
    }
    function scheduleTaskForRootDuringMicrotask(root, currentTime) {
      for (var { suspendedLanes, pingedLanes, expirationTimes } = root, lanes = root.pendingLanes & -62914561;0 < lanes; ) {
        var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];
        if (expirationTime === -1) {
          if ((lane & suspendedLanes) === 0 || (lane & pingedLanes) !== 0)
            expirationTimes[index] = computeExpirationTime(lane, currentTime);
        } else
          expirationTime <= currentTime && (root.expiredLanes |= lane);
        lanes &= ~lane;
      }
      currentTime = workInProgressRoot;
      suspendedLanes = workInProgressRootRenderLanes;
      suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0, root.cancelPendingCommit !== null || root.timeoutHandle !== noTimeout);
      pingedLanes = root.callbackNode;
      if (suspendedLanes === 0 || root === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || root.cancelPendingCommit !== null)
        return pingedLanes !== null && cancelCallback(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;
      if ((suspendedLanes & 3) === 0 || checkIfRootIsPrerendering(root, suspendedLanes)) {
        currentTime = suspendedLanes & -suspendedLanes;
        if (currentTime !== root.callbackPriority || ReactSharedInternals.actQueue !== null && pingedLanes !== fakeActCallbackNode$1)
          cancelCallback(pingedLanes);
        else
          return currentTime;
        switch (lanesToEventPriority(suspendedLanes)) {
          case 2:
          case 8:
            suspendedLanes = UserBlockingPriority;
            break;
          case 32:
            suspendedLanes = NormalPriority$1;
            break;
          case 268435456:
            suspendedLanes = IdlePriority;
            break;
          default:
            suspendedLanes = NormalPriority$1;
        }
        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
        ReactSharedInternals.actQueue !== null ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode$1) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
        root.callbackPriority = currentTime;
        root.callbackNode = suspendedLanes;
        return currentTime;
      }
      pingedLanes !== null && cancelCallback(pingedLanes);
      root.callbackPriority = 2;
      root.callbackNode = null;
      return 2;
    }
    function performWorkOnRootViaSchedulerTask(root, didTimeout) {
      nestedUpdateScheduled = currentUpdateIsNested = false;
      trackSchedulerEvent();
      if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
        return root.callbackNode = null, root.callbackPriority = 0, null;
      var originalCallbackNode = root.callbackNode;
      pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
      if (flushPendingEffects() && root.callbackNode !== originalCallbackNode)
        return null;
      var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0, root.cancelPendingCommit !== null || root.timeoutHandle !== noTimeout);
      if (workInProgressRootRenderLanes$jscomp$0 === 0)
        return null;
      performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
      scheduleTaskForRootDuringMicrotask(root, now$1());
      return root.callbackNode != null && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;
    }
    function performSyncWorkOnRoot(root, lanes) {
      if (flushPendingEffects())
        return null;
      currentUpdateIsNested = nestedUpdateScheduled;
      nestedUpdateScheduled = false;
      performWorkOnRoot(root, lanes, true);
    }
    function cancelCallback(callbackNode) {
      callbackNode !== fakeActCallbackNode$1 && callbackNode !== null && cancelCallback$1(callbackNode);
    }
    function scheduleImmediateRootScheduleTask() {
      ReactSharedInternals.actQueue !== null && ReactSharedInternals.actQueue.push(function() {
        processRootScheduleInMicrotask();
        return null;
      });
      supportsMicrotasks ? scheduleMicrotask(function() {
        (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask) : processRootScheduleInMicrotask();
      }) : scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask);
    }
    function requestTransitionLane() {
      if (currentEventTransitionLane === 0) {
        var actionScopeLane = currentEntangledLane;
        actionScopeLane === 0 && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, (nextTransitionUpdateLane & 261888) === 0 && (nextTransitionUpdateLane = 256));
        currentEventTransitionLane = actionScopeLane;
      }
      return currentEventTransitionLane;
    }
    function entangleAsyncAction(transition, thenable) {
      if (currentEntangledListeners === null) {
        var entangledListeners = currentEntangledListeners = [];
        currentEntangledPendingCount = 0;
        currentEntangledLane = requestTransitionLane();
        currentEntangledActionThenable = {
          status: "pending",
          value: undefined,
          then: function(resolve) {
            entangledListeners.push(resolve);
          }
        };
      }
      currentEntangledPendingCount++;
      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
      return thenable;
    }
    function pingEngtangledActionScope() {
      if (--currentEntangledPendingCount === 0 && (-1 < transitionUpdateTime || (transitionStartTime = -1.1), currentEntangledListeners !== null)) {
        currentEntangledActionThenable !== null && (currentEntangledActionThenable.status = "fulfilled");
        var listeners = currentEntangledListeners;
        currentEntangledListeners = null;
        currentEntangledLane = 0;
        currentEntangledActionThenable = null;
        for (var i = 0;i < listeners.length; i++)
          (0, listeners[i])();
      }
    }
    function chainThenableValue(thenable, result) {
      var listeners = [], thenableWithOverride = {
        status: "pending",
        value: null,
        reason: null,
        then: function(resolve) {
          listeners.push(resolve);
        }
      };
      thenable.then(function() {
        thenableWithOverride.status = "fulfilled";
        thenableWithOverride.value = result;
        for (var i = 0;i < listeners.length; i++)
          (0, listeners[i])(result);
      }, function(error) {
        thenableWithOverride.status = "rejected";
        thenableWithOverride.reason = error;
        for (error = 0;error < listeners.length; error++)
          (0, listeners[error])(undefined);
      });
      return thenableWithOverride;
    }
    function peekCacheFromPool() {
      var cacheResumedFromPreviousRender = resumedCache.current;
      return cacheResumedFromPreviousRender !== null ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
    }
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
      prevCachePool === null ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
    }
    function getSuspendedCache() {
      var cacheFromPool = peekCacheFromPool();
      return cacheFromPool === null ? null : {
        parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,
        pool: cacheFromPool
      };
    }
    function shallowEqual(objA, objB) {
      if (objectIs(objA, objB))
        return true;
      if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null)
        return false;
      var keysA = Object.keys(objA), keysB = Object.keys(objB);
      if (keysA.length !== keysB.length)
        return false;
      for (keysB = 0;keysB < keysA.length; keysB++) {
        var currentKey = keysA[keysB];
        if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
          return false;
      }
      return true;
    }
    function createThenableState() {
      return { didWarnAboutUncachedPromise: false, thenables: [] };
    }
    function isThenableResolved(thenable) {
      thenable = thenable.status;
      return thenable === "fulfilled" || thenable === "rejected";
    }
    function trackUsedThenable(thenableState2, thenable, index) {
      ReactSharedInternals.actQueue !== null && (ReactSharedInternals.didUsePromise = true);
      var trackedThenables = thenableState2.thenables;
      index = trackedThenables[index];
      index === undefined ? trackedThenables.push(thenable) : index !== thenable && (thenableState2.didWarnAboutUncachedPromise || (thenableState2.didWarnAboutUncachedPromise = true, console.error("A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.")), thenable.then(noop$1, noop$1), thenable = index);
      if (thenable._debugInfo === undefined) {
        thenableState2 = performance.now();
        trackedThenables = thenable.displayName;
        var ioInfo = {
          name: typeof trackedThenables === "string" ? trackedThenables : "Promise",
          start: thenableState2,
          end: thenableState2,
          value: thenable
        };
        thenable._debugInfo = [{ awaited: ioInfo }];
        thenable.status !== "fulfilled" && thenable.status !== "rejected" && (thenableState2 = function() {
          ioInfo.end = performance.now();
        }, thenable.then(thenableState2, thenableState2));
      }
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
        default:
          if (typeof thenable.status === "string")
            thenable.then(noop$1, noop$1);
          else {
            thenableState2 = workInProgressRoot;
            if (thenableState2 !== null && 100 < thenableState2.shellSuspendCounter)
              throw Error("An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
            thenableState2 = thenable;
            thenableState2.status = "pending";
            thenableState2.then(function(fulfilledValue) {
              if (thenable.status === "pending") {
                var fulfilledThenable = thenable;
                fulfilledThenable.status = "fulfilled";
                fulfilledThenable.value = fulfilledValue;
              }
            }, function(error) {
              if (thenable.status === "pending") {
                var rejectedThenable = thenable;
                rejectedThenable.status = "rejected";
                rejectedThenable.reason = error;
              }
            });
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          }
          suspendedThenable = thenable;
          needsToResetSuspendedThenableDEV = true;
          throw SuspenseException;
      }
    }
    function resolveLazy(lazyType) {
      try {
        return callLazyInitInDEV(lazyType);
      } catch (x) {
        if (x !== null && typeof x === "object" && typeof x.then === "function")
          throw suspendedThenable = x, needsToResetSuspendedThenableDEV = true, SuspenseException;
        throw x;
      }
    }
    function getSuspendedThenable() {
      if (suspendedThenable === null)
        throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
      var thenable = suspendedThenable;
      suspendedThenable = null;
      needsToResetSuspendedThenableDEV = false;
      return thenable;
    }
    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
      if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
        throw Error("Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
    }
    function pushDebugInfo(debugInfo) {
      var previousDebugInfo = currentDebugInfo;
      debugInfo != null && (currentDebugInfo = previousDebugInfo === null ? debugInfo : previousDebugInfo.concat(debugInfo));
      return previousDebugInfo;
    }
    function getCurrentDebugTask() {
      var debugInfo = currentDebugInfo;
      if (debugInfo != null) {
        for (var i = debugInfo.length - 1;0 <= i; i--)
          if (debugInfo[i].name != null) {
            var debugTask = debugInfo[i].debugTask;
            if (debugTask != null)
              return debugTask;
          }
      }
      return null;
    }
    function validateFragmentProps(element, fiber, returnFiber) {
      for (var keys = Object.keys(element.props), i = 0;i < keys.length; i++) {
        var key = keys[i];
        if (key !== "children" && key !== "key") {
          fiber === null && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
          runWithFiberInDEV(fiber, function(erroredKey) {
            console.error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", erroredKey);
          }, key);
          break;
        }
      }
    }
    function unwrapThenable(thenable) {
      var index = thenableIndexCounter$1;
      thenableIndexCounter$1 += 1;
      thenableState$1 === null && (thenableState$1 = createThenableState());
      return trackUsedThenable(thenableState$1, thenable, index);
    }
    function coerceRef(workInProgress2, element) {
      element = element.props.ref;
      workInProgress2.ref = element !== undefined ? element : null;
    }
    function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
        throw Error(`A React Element from an older version of React was rendered. This is not supported. It can happen if:
- Multiple copies of the "react" package is used.
- A library pre-bundled an old copy of "react" or "react/jsx-runtime".
- A compiler tries to "inline" JSX instead of using the runtime.`);
      returnFiber = Object.prototype.toString.call(newChild);
      throw Error("Objects are not valid as a React child (found: " + (returnFiber === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead.");
    }
    function throwOnInvalidObjectType(returnFiber, newChild) {
      var debugTask = getCurrentDebugTask();
      debugTask !== null ? debugTask.run(throwOnInvalidObjectTypeImpl.bind(null, returnFiber, newChild)) : throwOnInvalidObjectTypeImpl(returnFiber, newChild);
    }
    function warnOnFunctionTypeImpl(returnFiber, invalidChild) {
      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
      ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = true, invalidChild = invalidChild.displayName || invalidChild.name || "Component", returnFiber.tag === 3 ? console.error(`Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  root.render(%s)`, invalidChild, invalidChild, invalidChild) : console.error(`Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  <%s>{%s}</%s>`, invalidChild, invalidChild, parentName, invalidChild, parentName));
    }
    function warnOnFunctionType(returnFiber, invalidChild) {
      var debugTask = getCurrentDebugTask();
      debugTask !== null ? debugTask.run(warnOnFunctionTypeImpl.bind(null, returnFiber, invalidChild)) : warnOnFunctionTypeImpl(returnFiber, invalidChild);
    }
    function warnOnSymbolTypeImpl(returnFiber, invalidChild) {
      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
      ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = true, invalidChild = String(invalidChild), returnFiber.tag === 3 ? console.error(`Symbols are not valid as a React child.
  root.render(%s)`, invalidChild) : console.error(`Symbols are not valid as a React child.
  <%s>%s</%s>`, parentName, invalidChild, parentName));
    }
    function warnOnSymbolType(returnFiber, invalidChild) {
      var debugTask = getCurrentDebugTask();
      debugTask !== null ? debugTask.run(warnOnSymbolTypeImpl.bind(null, returnFiber, invalidChild)) : warnOnSymbolTypeImpl(returnFiber, invalidChild);
    }
    function createChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          var deletions = returnFiber.deletions;
          deletions === null ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
        }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects)
          return null;
        for (;currentFirstChild !== null; )
          deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return null;
      }
      function mapRemainingChildren(currentFirstChild) {
        for (var existingChildren = new Map;currentFirstChild !== null; )
          currentFirstChild.key !== null ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return existingChildren;
      }
      function useFiber(fiber, pendingProps) {
        fiber = createWorkInProgress(fiber, pendingProps);
        fiber.index = 0;
        fiber.sibling = null;
        return fiber;
      }
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects)
          return newFiber.flags |= 1048576, lastPlacedIndex;
        newIndex = newFiber.alternate;
        if (newIndex !== null)
          return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
        newFiber.flags |= 67108866;
        return lastPlacedIndex;
      }
      function placeSingleChild(newFiber) {
        shouldTrackSideEffects && newFiber.alternate === null && (newFiber.flags |= 67108866);
        return newFiber;
      }
      function updateTextNode(returnFiber, current2, textContent, lanes) {
        if (current2 === null || current2.tag !== 6)
          return current2 = createFiberFromText(textContent, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
        current2 = useFiber(current2, textContent);
        current2.return = returnFiber;
        current2._debugInfo = currentDebugInfo;
        return current2;
      }
      function updateElement(returnFiber, current2, element, lanes) {
        var elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE)
          return current2 = updateFragment(returnFiber, current2, element.props.children, lanes, element.key), validateFragmentProps(element, current2, returnFiber), current2;
        if (current2 !== null && (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type))
          return current2 = useFiber(current2, element.props), coerceRef(current2, element), current2.return = returnFiber, current2._debugOwner = element._owner, current2._debugInfo = currentDebugInfo, current2;
        current2 = createFiberFromElement(element, returnFiber.mode, lanes);
        coerceRef(current2, element);
        current2.return = returnFiber;
        current2._debugInfo = currentDebugInfo;
        return current2;
      }
      function updatePortal(returnFiber, current2, portal, lanes) {
        if (current2 === null || current2.tag !== 4 || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation)
          return current2 = createFiberFromPortal(portal, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugInfo = currentDebugInfo, current2;
        current2 = useFiber(current2, portal.children || []);
        current2.return = returnFiber;
        current2._debugInfo = currentDebugInfo;
        return current2;
      }
      function updateFragment(returnFiber, current2, fragment, lanes, key) {
        if (current2 === null || current2.tag !== 7)
          return current2 = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
        current2 = useFiber(current2, fragment);
        current2.return = returnFiber;
        current2._debugInfo = currentDebugInfo;
        return current2;
      }
      function createChild(returnFiber, newChild, lanes) {
        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
          return newChild = createFiberFromText("" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;
        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
            case REACT_PORTAL_TYPE:
              return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
            case REACT_LAZY_TYPE:
              var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              newChild = resolveLazy(newChild);
              returnFiber = createChild(returnFiber, newChild, lanes);
              currentDebugInfo = _prevDebugInfo;
              return returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return lanes = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
          if (typeof newChild.then === "function")
            return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(returnFiber, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        typeof newChild === "function" && warnOnFunctionType(returnFiber, newChild);
        typeof newChild === "symbol" && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        var key = oldFiber !== null ? oldFiber.key : null;
        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
          return key !== null ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber) : null;
            case REACT_PORTAL_TYPE:
              return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_LAZY_TYPE:
              return key = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = updateSlot(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
            if (key !== null)
              return null;
            key = pushDebugInfo(newChild._debugInfo);
            returnFiber = updateFragment(returnFiber, oldFiber, newChild, lanes, null);
            currentDebugInfo = key;
            return returnFiber;
          }
          if (typeof newChild.then === "function")
            return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes), currentDebugInfo = key, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        typeof newChild === "function" && warnOnFunctionType(returnFiber, newChild);
        typeof newChild === "symbol" && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
          return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newIdx = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, newIdx, newChild, lanes), currentDebugInfo = existingChildren, returnFiber;
            case REACT_PORTAL_TYPE:
              return existingChildren = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
            case REACT_LAZY_TYPE:
              var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
              newChild = resolveLazy(newChild);
              returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);
              currentDebugInfo = _prevDebugInfo7;
              return returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(returnFiber, newIdx, newChild, lanes, null), currentDebugInfo = existingChildren, returnFiber;
          if (typeof newChild.then === "function")
            return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo7, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        typeof newChild === "function" && warnOnFunctionType(returnFiber, newChild);
        typeof newChild === "symbol" && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys) {
        if (typeof child !== "object" || child === null)
          return knownKeys;
        switch (child.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            warnForMissingKey(returnFiber, workInProgress2, child);
            var key = child.key;
            if (typeof key !== "string")
              break;
            if (knownKeys === null) {
              knownKeys = new Set;
              knownKeys.add(key);
              break;
            }
            if (!knownKeys.has(key)) {
              knownKeys.add(key);
              break;
            }
            runWithFiberInDEV(workInProgress2, function() {
              console.error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", key);
            });
            break;
          case REACT_LAZY_TYPE:
            child = resolveLazy(child), warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys);
        }
        return knownKeys;
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
        for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null;oldFiber !== null && newIdx < newChildren.length; newIdx++) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
          if (newFiber === null) {
            oldFiber === null && (oldFiber = nextOldFiber);
            break;
          }
          knownKeys = warnOnInvalidKey(returnFiber, newFiber, newChildren[newIdx], knownKeys);
          shouldTrackSideEffects && oldFiber && newFiber.alternate === null && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          previousNewFiber === null ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (newIdx === newChildren.length)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (oldFiber === null) {
          for (;newIdx < newChildren.length; newIdx++)
            oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), oldFiber !== null && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, newChildren[newIdx], knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber);newIdx < newChildren.length; newIdx++)
          nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), nextOldFiber !== null && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, newChildren[newIdx], knownKeys), shouldTrackSideEffects && nextOldFiber.alternate !== null && oldFiber.delete(nextOldFiber.key === null ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
        if (newChildren == null)
          throw Error("An iterable object provided no iterator.");
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next();oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
          if (newFiber === null) {
            oldFiber === null && (oldFiber = nextOldFiber);
            break;
          }
          knownKeys = warnOnInvalidKey(returnFiber, newFiber, step.value, knownKeys);
          shouldTrackSideEffects && oldFiber && newFiber.alternate === null && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          previousNewFiber === null ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (step.done)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (oldFiber === null) {
          for (;!step.done; newIdx++, step = newChildren.next())
            oldFiber = createChild(returnFiber, step.value, lanes), oldFiber !== null && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, step.value, knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber);!step.done; newIdx++, step = newChildren.next())
          nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), nextOldFiber !== null && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, step.value, knownKeys), shouldTrackSideEffects && nextOldFiber.alternate !== null && oldFiber.delete(nextOldFiber.key === null ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
        typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              a: {
                for (var key = newChild.key;currentFirstChild !== null; ) {
                  if (currentFirstChild.key === key) {
                    key = newChild.type;
                    if (key === REACT_FRAGMENT_TYPE) {
                      if (currentFirstChild.tag === 7) {
                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                        lanes = useFiber(currentFirstChild, newChild.props.children);
                        lanes.return = returnFiber;
                        lanes._debugOwner = newChild._owner;
                        lanes._debugInfo = currentDebugInfo;
                        validateFragmentProps(newChild, lanes, returnFiber);
                        returnFiber = lanes;
                        break a;
                      }
                    } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(currentFirstChild, newChild) || typeof key === "object" && key !== null && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                      lanes = useFiber(currentFirstChild, newChild.props);
                      coerceRef(lanes, newChild);
                      lanes.return = returnFiber;
                      lanes._debugOwner = newChild._owner;
                      lanes._debugInfo = currentDebugInfo;
                      returnFiber = lanes;
                      break a;
                    }
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  } else
                    deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
              }
              returnFiber = placeSingleChild(returnFiber);
              currentDebugInfo = prevDebugInfo;
              return returnFiber;
            case REACT_PORTAL_TYPE:
              a: {
                prevDebugInfo = newChild;
                for (newChild = prevDebugInfo.key;currentFirstChild !== null; ) {
                  if (currentFirstChild.key === newChild)
                    if (currentFirstChild.tag === 4 && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                      lanes = useFiber(currentFirstChild, prevDebugInfo.children || []);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    } else {
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    }
                  else
                    deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                lanes = createFiberFromPortal(prevDebugInfo, returnFiber.mode, lanes);
                lanes.return = returnFiber;
                returnFiber = lanes;
              }
              return placeSingleChild(returnFiber);
            case REACT_LAZY_TYPE:
              return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;
          }
          if (isArrayImpl(newChild))
            return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;
          if (getIteratorFn(newChild)) {
            prevDebugInfo = pushDebugInfo(newChild._debugInfo);
            key = getIteratorFn(newChild);
            if (typeof key !== "function")
              throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            var newChildren = key.call(newChild);
            if (newChildren === newChild) {
              if (returnFiber.tag !== 0 || Object.prototype.toString.call(returnFiber.type) !== "[object GeneratorFunction]" || Object.prototype.toString.call(newChildren) !== "[object Generator]")
                didWarnAboutGenerators || console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."), didWarnAboutGenerators = true;
            } else
              newChild.entries !== key || didWarnAboutMaps || (console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = true);
            returnFiber = reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes);
            currentDebugInfo = prevDebugInfo;
            return returnFiber;
          }
          if (typeof newChild.then === "function")
            return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes), currentDebugInfo = prevDebugInfo, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
          return prevDebugInfo = "" + newChild, currentFirstChild !== null && currentFirstChild.tag === 6 ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(prevDebugInfo, returnFiber.mode, lanes), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
        typeof newChild === "function" && warnOnFunctionType(returnFiber, newChild);
        typeof newChild === "symbol" && warnOnSymbolType(returnFiber, newChild);
        return deleteRemainingChildren(returnFiber, currentFirstChild);
      }
      return function(returnFiber, currentFirstChild, newChild, lanes) {
        var prevDebugInfo = currentDebugInfo;
        currentDebugInfo = null;
        try {
          thenableIndexCounter$1 = 0;
          var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
          thenableState$1 = null;
          return firstChildFiber;
        } catch (x) {
          if (x === SuspenseException || x === SuspenseActionException)
            throw x;
          var fiber = createFiber(29, x, null, returnFiber.mode);
          fiber.lanes = lanes;
          fiber.return = returnFiber;
          var debugInfo = fiber._debugInfo = currentDebugInfo;
          fiber._debugOwner = returnFiber._debugOwner;
          fiber._debugTask = returnFiber._debugTask;
          if (debugInfo != null) {
            for (var i = debugInfo.length - 1;0 <= i; i--)
              if (typeof debugInfo[i].stack === "string") {
                fiber._debugOwner = debugInfo[i];
                fiber._debugTask = debugInfo[i].debugTask;
                break;
              }
          }
          return fiber;
        } finally {
          currentDebugInfo = prevDebugInfo;
        }
      };
    }
    function validateSuspenseListNestedChild(childSlot, index) {
      var isAnArray = isArrayImpl(childSlot);
      childSlot = !isAnArray && typeof getIteratorFn(childSlot) === "function";
      return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", isAnArray, index, isAnArray), false) : true;
    }
    function finishQueueingConcurrentUpdates() {
      for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0;i < endIndex; ) {
        var fiber = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var queue = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var update = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var lane = concurrentQueues[i];
        concurrentQueues[i++] = null;
        if (queue !== null && update !== null) {
          var pending = queue.pending;
          pending === null ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        lane !== 0 && markUpdateLaneFromFiberToRoot(fiber, update, lane);
      }
    }
    function enqueueUpdate$1(fiber, queue, update, lane) {
      concurrentQueues[concurrentQueuesIndex++] = fiber;
      concurrentQueues[concurrentQueuesIndex++] = queue;
      concurrentQueues[concurrentQueuesIndex++] = update;
      concurrentQueues[concurrentQueuesIndex++] = lane;
      concurrentlyUpdatedLanes |= lane;
      fiber.lanes |= lane;
      fiber = fiber.alternate;
      fiber !== null && (fiber.lanes |= lane);
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
      enqueueUpdate$1(fiber, queue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
      enqueueUpdate$1(fiber, null, null, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
      sourceFiber.lanes |= lane;
      var alternate = sourceFiber.alternate;
      alternate !== null && (alternate.lanes |= lane);
      for (var isHidden = false, parent = sourceFiber.return;parent !== null; )
        parent.childLanes |= lane, alternate = parent.alternate, alternate !== null && (alternate.childLanes |= lane), parent.tag === 22 && (sourceFiber = parent.stateNode, sourceFiber === null || sourceFiber._visibility & OffscreenVisible || (isHidden = true)), sourceFiber = parent, parent = parent.return;
      return sourceFiber.tag === 3 ? (parent = sourceFiber.stateNode, isHidden && update !== null && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], alternate === null ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
    }
    function getRootForUpdatedFiber(sourceFiber) {
      if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
        throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
      sourceFiber.alternate === null && (sourceFiber.flags & 4098) !== 0 && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
      for (var node = sourceFiber, parent = node.return;parent !== null; )
        node.alternate === null && (node.flags & 4098) !== 0 && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
      return node.tag === 3 ? node.stateNode : null;
    }
    function initializeUpdateQueue(fiber) {
      fiber.updateQueue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function cloneUpdateQueue(current2, workInProgress2) {
      current2 = current2.updateQueue;
      workInProgress2.updateQueue === current2 && (workInProgress2.updateQueue = {
        baseState: current2.baseState,
        firstBaseUpdate: current2.firstBaseUpdate,
        lastBaseUpdate: current2.lastBaseUpdate,
        shared: current2.shared,
        callbacks: null
      });
    }
    function createUpdate(lane) {
      return {
        lane,
        tag: UpdateState,
        payload: null,
        callback: null,
        next: null
      };
    }
    function enqueueUpdate(fiber, update, lane) {
      var updateQueue = fiber.updateQueue;
      if (updateQueue === null)
        return null;
      updateQueue = updateQueue.shared;
      if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
        var componentName2 = getComponentNameFromFiber(fiber);
        console.error(`An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.

Please update the following component: %s`, componentName2);
        didWarnUpdateInsideUpdate = true;
      }
      if ((executionContext & RenderContext) !== NoContext)
        return componentName2 = updateQueue.pending, componentName2 === null ? update.next = update : (update.next = componentName2.next, componentName2.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
      enqueueUpdate$1(fiber, updateQueue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function entangleTransitions(root, fiber, lane) {
      fiber = fiber.updateQueue;
      if (fiber !== null && (fiber = fiber.shared, (lane & 4194048) !== 0)) {
        var queueLanes = fiber.lanes;
        queueLanes &= root.pendingLanes;
        lane |= queueLanes;
        fiber.lanes = lane;
        markRootEntangled(root, lane);
      }
    }
    function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
      var { updateQueue: queue, alternate: current2 } = workInProgress2;
      if (current2 !== null && (current2 = current2.updateQueue, queue === current2)) {
        var newFirst = null, newLast = null;
        queue = queue.firstBaseUpdate;
        if (queue !== null) {
          do {
            var clone = {
              lane: queue.lane,
              tag: queue.tag,
              payload: queue.payload,
              callback: null,
              next: null
            };
            newLast === null ? newFirst = newLast = clone : newLast = newLast.next = clone;
            queue = queue.next;
          } while (queue !== null);
          newLast === null ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
        } else
          newFirst = newLast = capturedUpdate;
        queue = {
          baseState: current2.baseState,
          firstBaseUpdate: newFirst,
          lastBaseUpdate: newLast,
          shared: current2.shared,
          callbacks: current2.callbacks
        };
        workInProgress2.updateQueue = queue;
        return;
      }
      workInProgress2 = queue.lastBaseUpdate;
      workInProgress2 === null ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
      queue.lastBaseUpdate = capturedUpdate;
    }
    function suspendIfUpdateReadFromEntangledAsyncAction() {
      if (didReadFromEntangledAsyncAction) {
        var entangledActionThenable = currentEntangledActionThenable;
        if (entangledActionThenable !== null)
          throw entangledActionThenable;
      }
    }
    function processUpdateQueue(workInProgress2, props, instance$jscomp$0, renderLanes2) {
      didReadFromEntangledAsyncAction = false;
      var queue = workInProgress2.updateQueue;
      hasForceUpdate = false;
      currentlyProcessingQueue = queue.shared;
      var { firstBaseUpdate, lastBaseUpdate } = queue, pendingQueue = queue.shared.pending;
      if (pendingQueue !== null) {
        queue.shared.pending = null;
        var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
        lastPendingUpdate.next = null;
        lastBaseUpdate === null ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
        lastBaseUpdate = lastPendingUpdate;
        var current2 = workInProgress2.alternate;
        current2 !== null && (current2 = current2.updateQueue, pendingQueue = current2.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (pendingQueue === null ? current2.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current2.lastBaseUpdate = lastPendingUpdate));
      }
      if (firstBaseUpdate !== null) {
        var newState = queue.baseState;
        lastBaseUpdate = 0;
        current2 = firstPendingUpdate = lastPendingUpdate = null;
        pendingQueue = firstBaseUpdate;
        do {
          var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
          if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
            updateLane !== 0 && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
            current2 !== null && (current2 = current2.next = {
              lane: 0,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: null,
              next: null
            });
            a: {
              updateLane = workInProgress2;
              var partialState = pendingQueue;
              var nextProps = props, instance = instance$jscomp$0;
              switch (partialState.tag) {
                case ReplaceState:
                  partialState = partialState.payload;
                  if (typeof partialState === "function") {
                    isDisallowedContextReadInDEV = true;
                    var nextState = partialState.call(instance, newState, nextProps);
                    if (updateLane.mode & 8) {
                      setIsStrictModeForDevtools(true);
                      try {
                        partialState.call(instance, newState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    isDisallowedContextReadInDEV = false;
                    newState = nextState;
                    break a;
                  }
                  newState = partialState;
                  break a;
                case CaptureUpdate:
                  updateLane.flags = updateLane.flags & -65537 | 128;
                case UpdateState:
                  nextState = partialState.payload;
                  if (typeof nextState === "function") {
                    isDisallowedContextReadInDEV = true;
                    partialState = nextState.call(instance, newState, nextProps);
                    if (updateLane.mode & 8) {
                      setIsStrictModeForDevtools(true);
                      try {
                        nextState.call(instance, newState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    isDisallowedContextReadInDEV = false;
                  } else
                    partialState = nextState;
                  if (partialState === null || partialState === undefined)
                    break a;
                  newState = assign({}, newState, partialState);
                  break a;
                case ForceUpdate:
                  hasForceUpdate = true;
              }
            }
            updateLane = pendingQueue.callback;
            updateLane !== null && (workInProgress2.flags |= 64, isHiddenUpdate && (workInProgress2.flags |= 8192), isHiddenUpdate = queue.callbacks, isHiddenUpdate === null ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
          } else
            isHiddenUpdate = {
              lane: updateLane,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: pendingQueue.callback,
              next: null
            }, current2 === null ? (firstPendingUpdate = current2 = isHiddenUpdate, lastPendingUpdate = newState) : current2 = current2.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
          pendingQueue = pendingQueue.next;
          if (pendingQueue === null)
            if (pendingQueue = queue.shared.pending, pendingQueue === null)
              break;
            else
              isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
        } while (1);
        current2 === null && (lastPendingUpdate = newState);
        queue.baseState = lastPendingUpdate;
        queue.firstBaseUpdate = firstPendingUpdate;
        queue.lastBaseUpdate = current2;
        firstBaseUpdate === null && (queue.shared.lanes = 0);
        workInProgressRootSkippedLanes |= lastBaseUpdate;
        workInProgress2.lanes = lastBaseUpdate;
        workInProgress2.memoizedState = newState;
      }
      currentlyProcessingQueue = null;
    }
    function callCallback(callback, context) {
      if (typeof callback !== "function")
        throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + callback);
      callback.call(context);
    }
    function commitHiddenCallbacks(updateQueue, context) {
      var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
      if (hiddenCallbacks !== null)
        for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0;updateQueue < hiddenCallbacks.length; updateQueue++)
          callCallback(hiddenCallbacks[updateQueue], context);
    }
    function commitCallbacks(updateQueue, context) {
      var callbacks = updateQueue.callbacks;
      if (callbacks !== null)
        for (updateQueue.callbacks = null, updateQueue = 0;updateQueue < callbacks.length; updateQueue++)
          callCallback(callbacks[updateQueue], context);
    }
    function pushHiddenContext(fiber, context) {
      var prevEntangledRenderLanes = entangledRenderLanes;
      push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
      push(currentTreeHiddenStackCursor, context, fiber);
      entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
    }
    function reuseHiddenContextOnStack(fiber) {
      push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
      push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);
    }
    function popHiddenContext(fiber) {
      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
      pop(currentTreeHiddenStackCursor, fiber);
      pop(prevEntangledRenderLanesCursor, fiber);
    }
    function pushPrimaryTreeSuspenseHandler(handler) {
      var current2 = handler.alternate;
      push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask, handler);
      push(suspenseHandlerStackCursor, handler, handler);
      shellBoundary === null && (current2 === null || currentTreeHiddenStackCursor.current !== null ? shellBoundary = handler : current2.memoizedState !== null && (shellBoundary = handler));
    }
    function pushDehydratedActivitySuspenseHandler(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current, fiber);
      push(suspenseHandlerStackCursor, fiber, fiber);
      shellBoundary === null && (shellBoundary = fiber);
    }
    function pushOffscreenSuspenseHandler(fiber) {
      fiber.tag === 22 ? (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), shellBoundary === null && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack(fiber);
    }
    function reuseSuspenseHandlerOnStack(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current, fiber);
      push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current, fiber);
    }
    function popSuspenseHandler(fiber) {
      pop(suspenseHandlerStackCursor, fiber);
      shellBoundary === fiber && (shellBoundary = null);
      pop(suspenseStackCursor, fiber);
    }
    function findFirstSuspended(row) {
      for (var node = row;node !== null; ) {
        if (node.tag === 13) {
          var state = node.memoizedState;
          if (state !== null && (state = state.dehydrated, state === null || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
            return node;
        } else if (node.tag === 19 && (node.memoizedProps.revealOrder === "forwards" || node.memoizedProps.revealOrder === "backwards" || node.memoizedProps.revealOrder === "unstable_legacy-backwards" || node.memoizedProps.revealOrder === "together")) {
          if ((node.flags & 128) !== 0)
            return node;
        } else if (node.child !== null) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === row)
          break;
        for (;node.sibling === null; ) {
          if (node.return === null || node.return === row)
            return null;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
      return null;
    }
    function mountHookTypesDev() {
      var hookName = currentHookNameInDev;
      hookTypesDev === null ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
    }
    function updateHookTypesDev() {
      var hookName = currentHookNameInDev;
      if (hookTypesDev !== null && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
        var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
        if (!didWarnAboutMismatchedHooksForComponent.has(componentName2) && (didWarnAboutMismatchedHooksForComponent.add(componentName2), hookTypesDev !== null)) {
          for (var table = "", i = 0;i <= hookTypesUpdateIndexDev; i++) {
            var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;
            for (oldHookName = i + 1 + ". " + oldHookName;30 > oldHookName.length; )
              oldHookName += " ";
            oldHookName += newHookName + `
`;
            table += oldHookName;
          }
          console.error(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, componentName2, table);
        }
      }
    }
    function checkDepsAreArrayDev(deps) {
      deps === undefined || deps === null || isArrayImpl(deps) || console.error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
    }
    function warnOnUseFormStateInDev() {
      var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
      didWarnAboutUseFormState.has(componentName2) || (didWarnAboutUseFormState.add(componentName2), console.error("ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.", componentName2));
    }
    function throwInvalidHookError() {
      throw Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (ignorePreviousDependencies)
        return false;
      if (prevDeps === null)
        return console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), false;
      nextDeps.length !== prevDeps.length && console.error(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
      for (var i = 0;i < prevDeps.length && i < nextDeps.length; i++)
        if (!objectIs(nextDeps[i], prevDeps[i]))
          return false;
      return true;
    }
    function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
      renderLanes = nextRenderLanes;
      currentlyRenderingFiber = workInProgress2;
      hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
      hookTypesUpdateIndexDev = -1;
      ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
      if (Object.prototype.toString.call(Component) === "[object AsyncFunction]" || Object.prototype.toString.call(Component) === "[object AsyncGeneratorFunction]")
        nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error("%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.", nextRenderLanes === null ? "An unknown Component" : "<" + nextRenderLanes + ">"));
      workInProgress2.memoizedState = null;
      workInProgress2.updateQueue = null;
      workInProgress2.lanes = 0;
      ReactSharedInternals.H = current2 !== null && current2.memoizedState !== null ? HooksDispatcherOnUpdateInDEV : hookTypesDev !== null ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
      shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress2.mode & 8) !== NoMode;
      var children = callComponentInDEV(Component, props, secondArg);
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(workInProgress2, Component, props, secondArg));
      if (nextRenderLanes) {
        setIsStrictModeForDevtools(true);
        try {
          children = renderWithHooksAgain(workInProgress2, Component, props, secondArg);
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      finishRenderingHooks(current2, workInProgress2);
      return children;
    }
    function finishRenderingHooks(current2, workInProgress2) {
      workInProgress2._debugHookTypes = hookTypesDev;
      workInProgress2.dependencies === null ? thenableState !== null && (workInProgress2.dependencies = {
        lanes: 0,
        firstContext: null,
        _debugThenableState: thenableState
      }) : workInProgress2.dependencies._debugThenableState = thenableState;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
      renderLanes = 0;
      hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
      hookTypesUpdateIndexDev = -1;
      current2 !== null && (current2.flags & 65011712) !== (workInProgress2.flags & 65011712) && console.error("Internal React error: Expected static flag was missing. Please notify the React team.");
      didScheduleRenderPhaseUpdate = false;
      thenableIndexCounter = 0;
      thenableState = null;
      if (didRenderTooFewHooks)
        throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      current2 === null || didReceiveUpdate || (current2 = current2.dependencies, current2 !== null && checkIfContextChanged(current2) && (didReceiveUpdate = true));
      needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = false, current2 = true) : current2 = false;
      current2 && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress2) || didWarnAboutAsyncClientComponent.has(workInProgress2) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress2), console.error("`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.")));
    }
    function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
      currentlyRenderingFiber = workInProgress2;
      var numberOfReRenders = 0;
      do {
        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
        thenableIndexCounter = 0;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        if (numberOfReRenders >= RE_RENDER_LIMIT)
          throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        numberOfReRenders += 1;
        ignorePreviousDependencies = false;
        workInProgressHook = currentHook = null;
        if (workInProgress2.updateQueue != null) {
          var children = workInProgress2.updateQueue;
          children.lastEffect = null;
          children.events = null;
          children.stores = null;
          children.memoCache != null && (children.memoCache.index = 0);
        }
        hookTypesUpdateIndexDev = -1;
        ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
        children = callComponentInDEV(Component, props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
      return children;
    }
    function TransitionAwareHostComponent() {
      var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
      maybeThenable = typeof maybeThenable.then === "function" ? useThenable(maybeThenable) : maybeThenable;
      dispatcher = dispatcher.useState()[0];
      (currentHook !== null ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
      return maybeThenable;
    }
    function checkDidRenderIdHook() {
      var didRenderIdHook = localIdCounter !== 0;
      localIdCounter = 0;
      return didRenderIdHook;
    }
    function bailoutHooks(current2, workInProgress2, lanes) {
      workInProgress2.updateQueue = current2.updateQueue;
      workInProgress2.flags = (workInProgress2.mode & 16) !== NoMode ? workInProgress2.flags & -402655237 : workInProgress2.flags & -2053;
      current2.lanes &= ~lanes;
    }
    function resetHooksOnUnwind(workInProgress2) {
      if (didScheduleRenderPhaseUpdate) {
        for (workInProgress2 = workInProgress2.memoizedState;workInProgress2 !== null; ) {
          var queue = workInProgress2.queue;
          queue !== null && (queue.pending = null);
          workInProgress2 = workInProgress2.next;
        }
        didScheduleRenderPhaseUpdate = false;
      }
      renderLanes = 0;
      hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
      hookTypesUpdateIndexDev = -1;
      currentHookNameInDev = null;
      didScheduleRenderPhaseUpdateDuringThisPass = false;
      thenableIndexCounter = localIdCounter = 0;
      thenableState = null;
    }
    function mountWorkInProgressHook() {
      var hook = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      workInProgressHook === null ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
      return workInProgressHook;
    }
    function updateWorkInProgressHook() {
      if (currentHook === null) {
        var nextCurrentHook = currentlyRenderingFiber.alternate;
        nextCurrentHook = nextCurrentHook !== null ? nextCurrentHook.memoizedState : null;
      } else
        nextCurrentHook = currentHook.next;
      var nextWorkInProgressHook = workInProgressHook === null ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
      if (nextWorkInProgressHook !== null)
        workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
      else {
        if (nextCurrentHook === null) {
          if (currentlyRenderingFiber.alternate === null)
            throw Error("Update hook called on initial render. This is likely a bug in React. Please file an issue.");
          throw Error("Rendered more hooks than during the previous render.");
        }
        currentHook = nextCurrentHook;
        nextCurrentHook = {
          memoizedState: currentHook.memoizedState,
          baseState: currentHook.baseState,
          baseQueue: currentHook.baseQueue,
          queue: currentHook.queue,
          next: null
        };
        workInProgressHook === null ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
      }
      return workInProgressHook;
    }
    function createFunctionComponentUpdateQueue() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function useThenable(thenable) {
      var index = thenableIndexCounter;
      thenableIndexCounter += 1;
      thenableState === null && (thenableState = createThenableState());
      thenable = trackUsedThenable(thenableState, thenable, index);
      index = currentlyRenderingFiber;
      (workInProgressHook === null ? index.memoizedState : workInProgressHook.next) === null && (index = index.alternate, ReactSharedInternals.H = index !== null && index.memoizedState !== null ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
      return thenable;
    }
    function use(usable) {
      if (usable !== null && typeof usable === "object") {
        if (typeof usable.then === "function")
          return useThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE)
          return readContext(usable);
      }
      throw Error("An unsupported type was passed to use(): " + String(usable));
    }
    function useMemoCache(size) {
      var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
      updateQueue !== null && (memoCache = updateQueue.memoCache);
      if (memoCache == null) {
        var current2 = currentlyRenderingFiber.alternate;
        current2 !== null && (current2 = current2.updateQueue, current2 !== null && (current2 = current2.memoCache, current2 != null && (memoCache = {
          data: current2.data.map(function(array) {
            return array.slice();
          }),
          index: 0
        })));
      }
      memoCache == null && (memoCache = { data: [], index: 0 });
      updateQueue === null && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
      updateQueue.memoCache = memoCache;
      updateQueue = memoCache.data[memoCache.index];
      if (updateQueue === undefined || ignorePreviousDependencies)
        for (updateQueue = memoCache.data[memoCache.index] = Array(size), current2 = 0;current2 < size; current2++)
          updateQueue[current2] = REACT_MEMO_CACHE_SENTINEL;
      else
        updateQueue.length !== size && console.error("Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.", updateQueue.length, size);
      memoCache.index++;
      return updateQueue;
    }
    function basicStateReducer(state, action) {
      return typeof action === "function" ? action(state) : action;
    }
    function mountReducer(reducer, initialArg, init) {
      var hook = mountWorkInProgressHook();
      if (init !== undefined) {
        var initialState = init(initialArg);
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            init(initialArg);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      } else
        initialState = initialArg;
      hook.memoizedState = hook.baseState = initialState;
      reducer = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialState
      };
      hook.queue = reducer;
      reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, reducer);
      return [hook.memoizedState, reducer];
    }
    function updateReducer(reducer) {
      var hook = updateWorkInProgressHook();
      return updateReducerImpl(hook, currentHook, reducer);
    }
    function updateReducerImpl(hook, current2, reducer) {
      var queue = hook.queue;
      if (queue === null)
        throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
      queue.lastRenderedReducer = reducer;
      var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
      if (pendingQueue !== null) {
        if (baseQueue !== null) {
          var baseFirst = baseQueue.next;
          baseQueue.next = pendingQueue.next;
          pendingQueue.next = baseFirst;
        }
        current2.baseQueue !== baseQueue && console.error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
        current2.baseQueue = baseQueue = pendingQueue;
        queue.pending = null;
      }
      pendingQueue = hook.baseState;
      if (baseQueue === null)
        hook.memoizedState = pendingQueue;
      else {
        current2 = baseQueue.next;
        var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current2, didReadFromEntangledAsyncAction2 = false;
        do {
          var updateLane = update.lane & -536870913;
          if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
            var revertLane = update.revertLane;
            if (revertLane === 0)
              newBaseQueueLast !== null && (newBaseQueueLast = newBaseQueueLast.next = {
                lane: 0,
                revertLane: 0,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
            else if ((renderLanes & revertLane) === revertLane) {
              update = update.next;
              revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
              continue;
            } else
              updateLane = {
                lane: 0,
                revertLane: update.revertLane,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, newBaseQueueLast === null ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
            updateLane = update.action;
            shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
            pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
          } else
            revertLane = {
              lane: updateLane,
              revertLane: update.revertLane,
              gesture: update.gesture,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }, newBaseQueueLast === null ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
          update = update.next;
        } while (update !== null && update !== current2);
        newBaseQueueLast === null ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
        if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction2 && (reducer = currentEntangledActionThenable, reducer !== null)))
          throw reducer;
        hook.memoizedState = pendingQueue;
        hook.baseState = baseFirst;
        hook.baseQueue = newBaseQueueLast;
        queue.lastRenderedState = pendingQueue;
      }
      baseQueue === null && (queue.lanes = 0);
      return [hook.memoizedState, queue.dispatch];
    }
    function rerenderReducer(reducer) {
      var hook = updateWorkInProgressHook(), queue = hook.queue;
      if (queue === null)
        throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
      queue.lastRenderedReducer = reducer;
      var { dispatch, pending: lastRenderPhaseUpdate } = queue, newState = hook.memoizedState;
      if (lastRenderPhaseUpdate !== null) {
        queue.pending = null;
        var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
        do
          newState = reducer(newState, update.action), update = update.next;
        while (update !== lastRenderPhaseUpdate);
        objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
        hook.memoizedState = newState;
        hook.baseQueue === null && (hook.baseState = newState);
        queue.lastRenderedState = newState;
      }
      return [newState, dispatch];
    }
    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
      if (isHydrating) {
        if (getServerSnapshot === undefined)
          throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        var nextSnapshot = getServerSnapshot();
        didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error("The result of getServerSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = true);
      } else {
        nextSnapshot = getSnapshot();
        didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = true));
        if (workInProgressRoot === null)
          throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        (workInProgressRootRenderLanes & 127) !== 0 || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
      }
      hook.memoizedState = nextSnapshot;
      getServerSnapshot = { value: nextSnapshot, getSnapshot };
      hook.queue = getServerSnapshot;
      mountEffect(subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe), [subscribe]);
      fiber.flags |= 2048;
      pushSimpleEffect(HasEffect | Passive, { destroy: undefined }, updateStoreInstance.bind(null, fiber, getServerSnapshot, nextSnapshot, getSnapshot), null);
      return nextSnapshot;
    }
    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
      if (isHydrating$jscomp$0) {
        if (getServerSnapshot === undefined)
          throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        getServerSnapshot = getServerSnapshot();
      } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
        var cachedSnapshot = getSnapshot();
        objectIs(getServerSnapshot, cachedSnapshot) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = true);
      }
      if (cachedSnapshot = !objectIs((currentHook || hook).memoizedState, getServerSnapshot))
        hook.memoizedState = getServerSnapshot, didReceiveUpdate = true;
      hook = hook.queue;
      var create = subscribeToStore.bind(null, fiber, hook, subscribe);
      updateEffectImpl(2048, Passive, create, [subscribe]);
      if (hook.getSnapshot !== getSnapshot || cachedSnapshot || workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
        fiber.flags |= 2048;
        pushSimpleEffect(HasEffect | Passive, { destroy: undefined }, updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), null);
        if (workInProgressRoot === null)
          throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        isHydrating$jscomp$0 || (renderLanes & 127) !== 0 || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      return getServerSnapshot;
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= 16384;
      fiber = { getSnapshot, value: renderedSnapshot };
      getSnapshot = currentlyRenderingFiber.updateQueue;
      getSnapshot === null ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, renderedSnapshot === null ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    function subscribeToStore(fiber, inst, subscribe) {
      return subscribe(function() {
        checkIfSnapshotChanged(inst) && (startUpdateTimerByLane(2, "updateSyncExternalStore()", fiber), forceStoreRerender(fiber));
      });
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    function forceStoreRerender(fiber) {
      var root = enqueueConcurrentRenderForLane(fiber, 2);
      root !== null && scheduleUpdateOnFiber(root, fiber, 2);
    }
    function mountStateImpl(initialState) {
      var hook = mountWorkInProgressHook();
      if (typeof initialState === "function") {
        var initialStateInitializer = initialState;
        initialState = initialStateInitializer();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            initialStateInitializer();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      }
      hook.memoizedState = hook.baseState = initialState;
      hook.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialState
      };
      return hook;
    }
    function mountState(initialState) {
      initialState = mountStateImpl(initialState);
      var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [initialState.memoizedState, dispatch];
    }
    function mountOptimistic(passthrough) {
      var hook = mountWorkInProgressHook();
      hook.memoizedState = hook.baseState = passthrough;
      var queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      hook.queue = queue;
      hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, true, queue);
      queue.dispatch = hook;
      return [passthrough, hook];
    }
    function updateOptimistic(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    }
    function updateOptimisticImpl(hook, current2, passthrough, reducer) {
      hook.baseState = passthrough;
      return updateReducerImpl(hook, currentHook, typeof reducer === "function" ? reducer : basicStateReducer);
    }
    function rerenderOptimistic(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      if (currentHook !== null)
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      hook.baseState = passthrough;
      return [passthrough, hook.queue.dispatch];
    }
    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
      if (isRenderPhaseUpdate(fiber))
        throw Error("Cannot update form state while rendering.");
      fiber = actionQueue.action;
      if (fiber !== null) {
        var actionNode = {
          payload,
          action: fiber,
          next: null,
          isTransition: true,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(listener) {
            actionNode.listeners.push(listener);
          }
        };
        ReactSharedInternals.T !== null ? setPendingState(true) : actionNode.isTransition = false;
        setState(actionNode);
        setPendingState = actionQueue.pending;
        setPendingState === null ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
      }
    }
    function runActionStateAction(actionQueue, node) {
      var { action, payload } = node, prevState = actionQueue.state;
      if (node.isTransition) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        currentTransition._updatedFibers = new Set;
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
          onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue);
          handleActionReturnValue(actionQueue, node, returnValue);
        } catch (error) {
          onActionError(actionQueue, node, error);
        } finally {
          prevTransition !== null && currentTransition.types !== null && (prevTransition.types !== null && prevTransition.types !== currentTransition.types && console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, prevTransition === null && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
        }
      } else
        try {
          currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
        } catch (error$2) {
          onActionError(actionQueue, node, error$2);
        }
    }
    function handleActionReturnValue(actionQueue, node, returnValue) {
      returnValue !== null && typeof returnValue === "object" && typeof returnValue.then === "function" ? (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(function(nextState) {
        onActionSuccess(actionQueue, node, nextState);
      }, function(error) {
        return onActionError(actionQueue, node, error);
      }), node.isTransition || console.error("An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop.")) : onActionSuccess(actionQueue, node, returnValue);
    }
    function onActionSuccess(actionQueue, actionNode, nextState) {
      actionNode.status = "fulfilled";
      actionNode.value = nextState;
      notifyActionListeners(actionNode);
      actionQueue.state = nextState;
      actionNode = actionQueue.pending;
      actionNode !== null && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
    }
    function onActionError(actionQueue, actionNode, error) {
      var last = actionQueue.pending;
      actionQueue.pending = null;
      if (last !== null) {
        last = last.next;
        do
          actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
        while (actionNode !== last);
      }
      actionQueue.action = null;
    }
    function notifyActionListeners(actionNode) {
      actionNode = actionNode.listeners;
      for (var i = 0;i < actionNode.length; i++)
        (0, actionNode[i])();
    }
    function actionStateReducer(oldState, newState) {
      return newState;
    }
    function mountActionState(action, initialStateProp) {
      if (isHydrating) {
        var ssrFormState = workInProgressRoot.formState;
        if (ssrFormState !== null) {
          a: {
            var isMatching = currentlyRenderingFiber;
            if (isHydrating) {
              if (nextHydratableInstance) {
                var markerInstance = canHydrateFormStateMarker(nextHydratableInstance, rootOrSingletonContext);
                if (markerInstance) {
                  nextHydratableInstance = getNextHydratableSibling(markerInstance);
                  isMatching = isFormStateMarkerMatching(markerInstance);
                  break a;
                }
              }
              throwOnHydrationMismatch(isMatching);
            }
            isMatching = false;
          }
          isMatching && (initialStateProp = ssrFormState[0]);
        }
      }
      ssrFormState = mountWorkInProgressHook();
      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
      isMatching = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: actionStateReducer,
        lastRenderedState: initialStateProp
      };
      ssrFormState.queue = isMatching;
      ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber, isMatching);
      isMatching.dispatch = ssrFormState;
      isMatching = mountStateImpl(false);
      var setPendingState = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, false, isMatching.queue);
      isMatching = mountWorkInProgressHook();
      markerInstance = {
        state: initialStateProp,
        dispatch: null,
        action,
        pending: null
      };
      isMatching.queue = markerInstance;
      ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber, markerInstance, setPendingState, ssrFormState);
      markerInstance.dispatch = ssrFormState;
      isMatching.memoizedState = action;
      return [initialStateProp, ssrFormState, false];
    }
    function updateActionState(action) {
      var stateHook = updateWorkInProgressHook();
      return updateActionStateImpl(stateHook, currentHook, action);
    }
    function updateActionStateImpl(stateHook, currentStateHook, action) {
      currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];
      stateHook = updateReducer(basicStateReducer)[0];
      if (typeof currentStateHook === "object" && currentStateHook !== null && typeof currentStateHook.then === "function")
        try {
          var state = useThenable(currentStateHook);
        } catch (x) {
          if (x === SuspenseException)
            throw SuspenseActionException;
          throw x;
        }
      else
        state = currentStateHook;
      currentStateHook = updateWorkInProgressHook();
      var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
      action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(HasEffect | Passive, { destroy: undefined }, actionStateActionEffect.bind(null, actionQueue, action), null));
      return [state, dispatch, stateHook];
    }
    function actionStateActionEffect(actionQueue, action) {
      actionQueue.action = action;
    }
    function rerenderActionState(action) {
      var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
      if (currentStateHook !== null)
        return updateActionStateImpl(stateHook, currentStateHook, action);
      updateWorkInProgressHook();
      stateHook = stateHook.memoizedState;
      currentStateHook = updateWorkInProgressHook();
      var dispatch = currentStateHook.queue.dispatch;
      currentStateHook.memoizedState = action;
      return [stateHook, dispatch, false];
    }
    function pushSimpleEffect(tag, inst, create, deps) {
      tag = { tag, create, deps, inst, next: null };
      inst = currentlyRenderingFiber.updateQueue;
      inst === null && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
      create = inst.lastEffect;
      create === null ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);
      return tag;
    }
    function mountRef(initialValue) {
      var hook = mountWorkInProgressHook();
      initialValue = { current: initialValue };
      return hook.memoizedState = initialValue;
    }
    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = mountWorkInProgressHook();
      currentlyRenderingFiber.flags |= fiberFlags;
      hook.memoizedState = pushSimpleEffect(HasEffect | hookFlags, { destroy: undefined }, create, deps === undefined ? null : deps);
    }
    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = updateWorkInProgressHook();
      deps = deps === undefined ? null : deps;
      var inst = hook.memoizedState.inst;
      currentHook !== null && deps !== null && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(HasEffect | hookFlags, inst, create, deps));
    }
    function mountEffect(create, deps) {
      (currentlyRenderingFiber.mode & 16) !== NoMode ? mountEffectImpl(276826112, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);
    }
    function useEffectEventImpl(payload) {
      currentlyRenderingFiber.flags |= 4;
      var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
      if (componentUpdateQueue === null)
        componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
      else {
        var events = componentUpdateQueue.events;
        events === null ? componentUpdateQueue.events = [payload] : events.push(payload);
      }
    }
    function mountEvent(callback) {
      var hook = mountWorkInProgressHook(), ref = { impl: callback };
      hook.memoizedState = ref;
      return function() {
        if ((executionContext & RenderContext) !== NoContext)
          throw Error("A function wrapped in useEffectEvent can't be called during rendering.");
        return ref.impl.apply(undefined, arguments);
      };
    }
    function updateEvent(callback) {
      var ref = updateWorkInProgressHook().memoizedState;
      useEffectEventImpl({ ref, nextImpl: callback });
      return function() {
        if ((executionContext & RenderContext) !== NoContext)
          throw Error("A function wrapped in useEffectEvent can't be called during rendering.");
        return ref.impl.apply(undefined, arguments);
      };
    }
    function mountLayoutEffect(create, deps) {
      var fiberFlags = 4194308;
      (currentlyRenderingFiber.mode & 16) !== NoMode && (fiberFlags |= 134217728);
      return mountEffectImpl(fiberFlags, Layout, create, deps);
    }
    function imperativeHandleEffect(create, ref) {
      if (typeof ref === "function") {
        create = create();
        var refCleanup = ref(create);
        return function() {
          typeof refCleanup === "function" ? refCleanup() : ref(null);
        };
      }
      if (ref !== null && ref !== undefined)
        return ref.hasOwnProperty("current") || console.error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(ref).join(", ") + "}"), create = create(), ref.current = create, function() {
          ref.current = null;
        };
    }
    function mountImperativeHandle(ref, create, deps) {
      typeof create !== "function" && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
      deps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
      var fiberFlags = 4194308;
      (currentlyRenderingFiber.mode & 16) !== NoMode && (fiberFlags |= 134217728);
      mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), deps);
    }
    function updateImperativeHandle(ref, create, deps) {
      typeof create !== "function" && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
      deps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
      updateEffectImpl(4, Layout, imperativeHandleEffect.bind(null, create, ref), deps);
    }
    function mountCallback(callback, deps) {
      mountWorkInProgressHook().memoizedState = [
        callback,
        deps === undefined ? null : deps
      ];
      return callback;
    }
    function updateCallback(callback, deps) {
      var hook = updateWorkInProgressHook();
      deps = deps === undefined ? null : deps;
      var prevState = hook.memoizedState;
      if (deps !== null && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      hook.memoizedState = [callback, deps];
      return callback;
    }
    function mountMemo(nextCreate, deps) {
      var hook = mountWorkInProgressHook();
      deps = deps === undefined ? null : deps;
      var nextValue = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [nextValue, deps];
      return nextValue;
    }
    function updateMemo(nextCreate, deps) {
      var hook = updateWorkInProgressHook();
      deps = deps === undefined ? null : deps;
      var prevState = hook.memoizedState;
      if (deps !== null && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      prevState = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [prevState, deps];
      return prevState;
    }
    function mountDeferredValue(value, initialValue) {
      var hook = mountWorkInProgressHook();
      return mountDeferredValueImpl(hook, value, initialValue);
    }
    function updateDeferredValue(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
    }
    function rerenderDeferredValue(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return currentHook === null ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
    }
    function mountDeferredValueImpl(hook, value, initialValue) {
      if (initialValue === undefined || (renderLanes & 1073741824) !== 0 && (workInProgressRootRenderLanes & 261930) === 0)
        return hook.memoizedState = value;
      hook.memoizedState = initialValue;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return initialValue;
    }
    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
      if (objectIs(value, prevValue))
        return value;
      if (currentTreeHiddenStackCursor.current !== null)
        return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
      if ((renderLanes & 42) === 0 || (renderLanes & 1073741824) !== 0 && (workInProgressRootRenderLanes & 261930) === 0)
        return didReceiveUpdate = true, hook.memoizedState = value;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return prevValue;
    }
    function releaseAsyncTransition() {
      ReactSharedInternals.asyncTransitions--;
    }
    function startTransition(fiber, queue, pendingState, finishedState, callback) {
      var previousPriority = getCurrentUpdatePriority();
      setCurrentUpdatePriority(previousPriority !== 0 && 8 > previousPriority ? previousPriority : 8);
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      currentTransition._updatedFibers = new Set;
      ReactSharedInternals.T = currentTransition;
      dispatchOptimisticSetState(fiber, false, queue, pendingState);
      try {
        var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
        onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue);
        if (returnValue !== null && typeof returnValue === "object" && typeof returnValue.then === "function") {
          ReactSharedInternals.asyncTransitions++;
          returnValue.then(releaseAsyncTransition, releaseAsyncTransition);
          var thenableForFinishedState = chainThenableValue(returnValue, finishedState);
          dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));
        } else
          dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));
      } catch (error) {
        dispatchSetStateInternal(fiber, queue, { then: function() {}, status: "rejected", reason: error }, requestUpdateLane(fiber));
      } finally {
        setCurrentUpdatePriority(previousPriority), prevTransition !== null && currentTransition.types !== null && (prevTransition.types !== null && prevTransition.types !== currentTransition.types && console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, prevTransition === null && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
      }
    }
    function ensureFormComponentIsStateful(formFiber) {
      var existingStateHook = formFiber.memoizedState;
      if (existingStateHook !== null)
        return existingStateHook;
      existingStateHook = {
        memoizedState: NotPendingTransition,
        baseState: NotPendingTransition,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: NotPendingTransition
        },
        next: null
      };
      var initialResetState = {};
      existingStateHook.next = {
        memoizedState: initialResetState,
        baseState: initialResetState,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialResetState
        },
        next: null
      };
      formFiber.memoizedState = existingStateHook;
      formFiber = formFiber.alternate;
      formFiber !== null && (formFiber.memoizedState = existingStateHook);
      return existingStateHook;
    }
    function mountTransition() {
      var stateHook = mountStateImpl(false);
      stateHook = startTransition.bind(null, currentlyRenderingFiber, stateHook.queue, true, false);
      mountWorkInProgressHook().memoizedState = stateHook;
      return [false, stateHook];
    }
    function updateTransition() {
      var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
      return [
        typeof booleanOrThenable === "boolean" ? booleanOrThenable : useThenable(booleanOrThenable),
        start
      ];
    }
    function rerenderTransition() {
      var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
      return [
        typeof booleanOrThenable === "boolean" ? booleanOrThenable : useThenable(booleanOrThenable),
        start
      ];
    }
    function useHostTransitionStatus() {
      return readContext(HostTransitionContext);
    }
    function mountId() {
      var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
      if (isHydrating) {
        var treeId = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
        identifierPrefix = "_" + identifierPrefix + "R_" + treeId;
        treeId = localIdCounter++;
        0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
        identifierPrefix += "_";
      } else
        treeId = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + treeId.toString(32) + "_";
      return hook.memoizedState = identifierPrefix;
    }
    function mountRefresh() {
      return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber);
    }
    function refreshCache(fiber, seedKey) {
      for (var provider = fiber.return;provider !== null; ) {
        switch (provider.tag) {
          case 24:
          case 3:
            var lane = requestUpdateLane(provider), refreshUpdate = createUpdate(lane), root = enqueueUpdate(provider, refreshUpdate, lane);
            root !== null && (startUpdateTimerByLane(lane, "refresh()", fiber), scheduleUpdateOnFiber(root, provider, lane), entangleTransitions(root, provider, lane));
            fiber = createCache();
            seedKey !== null && seedKey !== undefined && root !== null && console.error("The seed argument is not enabled outside experimental channels.");
            refreshUpdate.payload = { cache: fiber };
            return;
        }
        provider = provider.return;
      }
    }
    function dispatchReducerAction(fiber, queue, action) {
      var args = arguments;
      typeof args[3] === "function" && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      args = requestUpdateLane(fiber);
      var update = {
        lane: args,
        revertLane: 0,
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), update !== null && (startUpdateTimerByLane(args, "dispatch()", fiber), scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));
    }
    function dispatchSetState(fiber, queue, action) {
      var args = arguments;
      typeof args[3] === "function" && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      args = requestUpdateLane(fiber);
      dispatchSetStateInternal(fiber, queue, action, args) && startUpdateTimerByLane(args, "setState()", fiber);
    }
    function dispatchSetStateInternal(fiber, queue, action, lane) {
      var update = {
        lane,
        revertLane: 0,
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber))
        enqueueRenderPhaseUpdate(queue, update);
      else {
        var alternate = fiber.alternate;
        if (fiber.lanes === 0 && (alternate === null || alternate.lanes === 0) && (alternate = queue.lastRenderedReducer, alternate !== null)) {
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
            update.hasEagerState = true;
            update.eagerState = eagerState;
            if (objectIs(eagerState, currentState))
              return enqueueUpdate$1(fiber, queue, update, 0), workInProgressRoot === null && finishQueueingConcurrentUpdates(), false;
          } catch (error) {} finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        }
        action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (action !== null)
          return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
      }
      return false;
    }
    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
      ReactSharedInternals.T === null && currentEntangledLane === 0 && console.error("An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition.");
      action = {
        lane: 2,
        revertLane: requestTransitionLane(),
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) {
        if (throwIfDuringRender)
          throw Error("Cannot update optimistic state while rendering.");
        console.error("Cannot call startTransition while rendering.");
      } else
        throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), throwIfDuringRender !== null && (startUpdateTimerByLane(2, "setOptimistic()", fiber), scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2));
    }
    function isRenderPhaseUpdate(fiber) {
      var alternate = fiber.alternate;
      return fiber === currentlyRenderingFiber || alternate !== null && alternate === currentlyRenderingFiber;
    }
    function enqueueRenderPhaseUpdate(queue, update) {
      didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
      var pending = queue.pending;
      pending === null ? update.next = update : (update.next = pending.next, pending.next = update);
      queue.pending = update;
    }
    function entangleTransitionUpdate(root, queue, lane) {
      if ((lane & 4194048) !== 0) {
        var queueLanes = queue.lanes;
        queueLanes &= root.pendingLanes;
        lane |= queueLanes;
        queue.lanes = lane;
        markRootEntangled(root, lane);
      }
    }
    function warnOnInvalidCallback(callback) {
      if (callback !== null && typeof callback !== "function") {
        var key = String(callback);
        didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback));
      }
    }
    function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
      var prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
      if (workInProgress2.mode & 8) {
        setIsStrictModeForDevtools(true);
        try {
          partialState = getDerivedStateFromProps(nextProps, prevState);
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      partialState === undefined && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", ctor)));
      prevState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);
      workInProgress2.memoizedState = prevState;
      workInProgress2.lanes === 0 && (workInProgress2.updateQueue.baseState = prevState);
    }
    function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
      var instance = workInProgress2.stateNode;
      if (typeof instance.shouldComponentUpdate === "function") {
        oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);
        if (workInProgress2.mode & 8) {
          setIsStrictModeForDevtools(true);
          try {
            oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        oldProps === undefined && console.error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
        return oldProps;
      }
      return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
    }
    function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
      var oldState = instance.state;
      typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps(newProps, nextContext);
      typeof instance.UNSAFE_componentWillReceiveProps === "function" && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      instance.state !== oldState && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress2) || (didWarnAboutStateAssignmentForComponent.add(workInProgress2), console.error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", workInProgress2)), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));
    }
    function resolveClassComponentProps(Component, baseProps) {
      var newProps = baseProps;
      if ("ref" in baseProps) {
        newProps = {};
        for (var propName in baseProps)
          propName !== "ref" && (newProps[propName] = baseProps[propName]);
      }
      if (Component = Component.defaultProps) {
        newProps === baseProps && (newProps = assign({}, newProps));
        for (var _propName in Component)
          newProps[_propName] === undefined && (newProps[_propName] = Component[_propName]);
      }
      return newProps;
    }
    function logUncaughtError(root, errorInfo) {
      try {
        componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
        errorBoundaryName = null;
        var error = errorInfo.value;
        if (ReactSharedInternals.actQueue !== null)
          ReactSharedInternals.thrownErrors.push(error);
        else {
          var onUncaughtError = root.onUncaughtError;
          onUncaughtError(error, { componentStack: errorInfo.stack });
        }
      } catch (e) {
        setTimeout(function() {
          throw e;
        });
      }
    }
    function logCaughtError(root, boundary, errorInfo) {
      try {
        componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
        errorBoundaryName = getComponentNameFromFiber(boundary);
        var onCaughtError = root.onCaughtError;
        onCaughtError(errorInfo.value, {
          componentStack: errorInfo.stack,
          errorBoundary: boundary.tag === 1 ? boundary.stateNode : null
        });
      } catch (e) {
        setTimeout(function() {
          throw e;
        });
      }
    }
    function createRootErrorUpdate(root, errorInfo, lane) {
      lane = createUpdate(lane);
      lane.tag = CaptureUpdate;
      lane.payload = { element: null };
      lane.callback = function() {
        runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);
      };
      return lane;
    }
    function createClassErrorUpdate(lane) {
      lane = createUpdate(lane);
      lane.tag = CaptureUpdate;
      return lane;
    }
    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if (typeof getDerivedStateFromError === "function") {
        var error = errorInfo.value;
        update.payload = function() {
          return getDerivedStateFromError(error);
        };
        update.callback = function() {
          markFailedErrorBoundaryForHotReloading(fiber);
          runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);
        };
      }
      var inst = fiber.stateNode;
      inst !== null && typeof inst.componentDidCatch === "function" && (update.callback = function() {
        markFailedErrorBoundaryForHotReloading(fiber);
        runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);
        typeof getDerivedStateFromError !== "function" && (legacyErrorBoundariesThatAlreadyFailed === null ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
        callComponentDidCatchInDEV(this, errorInfo);
        typeof getDerivedStateFromError === "function" || (fiber.lanes & 2) === 0 && console.error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
      });
    }
    function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
      sourceFiber.flags |= 32768;
      isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);
      if (value !== null && typeof value === "object" && typeof value.then === "function") {
        returnFiber = sourceFiber.alternate;
        returnFiber !== null && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, true);
        isHydrating && (didSuspendOrErrorDEV = true);
        sourceFiber = suspenseHandlerStackCursor.current;
        if (sourceFiber !== null) {
          switch (sourceFiber.tag) {
            case 31:
            case 13:
              return shellBoundary === null ? renderDidSuspendDelayIfPossible() : sourceFiber.alternate === null && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, returnFiber === null ? sourceFiber.updateQueue = new Set([value]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), false;
            case 22:
              return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, returnFiber === null ? (returnFiber = {
                transitions: null,
                markerInstances: null,
                retryQueue: new Set([value])
              }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, sourceFiber === null ? returnFiber.retryQueue = new Set([value]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), false;
          }
          throw Error("Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React.");
        }
        attachPingListener(root, value, rootRenderLanes);
        renderDidSuspendDelayIfPossible();
        return false;
      }
      if (isHydrating)
        return didSuspendOrErrorDEV = true, returnFiber = suspenseHandlerStackCursor.current, returnFiber !== null ? ((returnFiber.flags & 65536) === 0 && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error("There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.", { cause: value }), sourceFiber))) : (value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error("There was an error while hydrating but React was able to recover by instead client rendering the entire root.", { cause: value }), sourceFiber)), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), false;
      var error = createCapturedValueAtFiber(Error("There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.", { cause: value }), sourceFiber);
      workInProgressRootConcurrentErrors === null ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
      workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
      if (returnFiber === null)
        return true;
      value = createCapturedValueAtFiber(value, sourceFiber);
      sourceFiber = returnFiber;
      do {
        switch (sourceFiber.tag) {
          case 3:
            return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), false;
          case 1:
            if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, (sourceFiber.flags & 128) === 0 && (typeof returnFiber.getDerivedStateFromError === "function" || error !== null && typeof error.componentDidCatch === "function" && (legacyErrorBoundariesThatAlreadyFailed === null || !legacyErrorBoundariesThatAlreadyFailed.has(error))))
              return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
        }
        sourceFiber = sourceFiber.return;
      } while (sourceFiber !== null);
      return false;
    }
    function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
      workInProgress2.child = current2 === null ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
    }
    function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
      Component = Component.render;
      var ref = workInProgress2.ref;
      if ("ref" in nextProps) {
        var propsWithoutRef = {};
        for (var key in nextProps)
          key !== "ref" && (propsWithoutRef[key] = nextProps[key]);
      } else
        propsWithoutRef = nextProps;
      prepareToReadContext(workInProgress2);
      nextProps = renderWithHooks(current2, workInProgress2, Component, propsWithoutRef, ref, renderLanes2);
      key = checkDidRenderIdHook();
      if (current2 !== null && !didReceiveUpdate)
        return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      isHydrating && key && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      if (current2 === null) {
        var type = Component.type;
        if (typeof type === "function" && !shouldConstruct(type) && type.defaultProps === undefined && Component.compare === null)
          return Component = resolveFunctionForHotReloading(type), workInProgress2.tag = 15, workInProgress2.type = Component, validateFunctionComponentInDev(workInProgress2, type), updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
        current2 = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
        current2.ref = workInProgress2.ref;
        current2.return = workInProgress2;
        return workInProgress2.child = current2;
      }
      type = current2.child;
      if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
        var prevProps = type.memoizedProps;
        Component = Component.compare;
        Component = Component !== null ? Component : shallowEqual;
        if (Component(prevProps, nextProps) && current2.ref === workInProgress2.ref)
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      }
      workInProgress2.flags |= 1;
      current2 = createWorkInProgress(type, nextProps);
      current2.ref = workInProgress2.ref;
      current2.return = workInProgress2;
      return workInProgress2.child = current2;
    }
    function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      if (current2 !== null) {
        var prevProps = current2.memoizedProps;
        if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type)
          if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current2, renderLanes2))
            (current2.flags & 131072) !== 0 && (didReceiveUpdate = true);
          else
            return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      }
      return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
    }
    function updateOffscreenComponent(current2, workInProgress2, renderLanes2, nextProps) {
      var nextChildren = nextProps.children, prevState = current2 !== null ? current2.memoizedState : null;
      current2 === null && workInProgress2.stateNode === null && (workInProgress2.stateNode = {
        _visibility: OffscreenVisible,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      });
      if (nextProps.mode === "hidden") {
        if ((workInProgress2.flags & 128) !== 0) {
          prevState = prevState !== null ? prevState.baseLanes | renderLanes2 : renderLanes2;
          if (current2 !== null) {
            nextProps = workInProgress2.child = current2.child;
            for (nextChildren = 0;nextProps !== null; )
              nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
            nextProps = nextChildren & ~prevState;
          } else
            nextProps = 0, workInProgress2.child = null;
          return deferHiddenOffscreenComponent(current2, workInProgress2, prevState, renderLanes2, nextProps);
        }
        if ((renderLanes2 & 536870912) !== 0)
          workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, current2 !== null && pushTransition(workInProgress2, prevState !== null ? prevState.cachePool : null), prevState !== null ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(workInProgress2), pushOffscreenSuspenseHandler(workInProgress2);
        else
          return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(current2, workInProgress2, prevState !== null ? prevState.baseLanes | renderLanes2 : renderLanes2, renderLanes2, nextProps);
      } else
        prevState !== null ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (current2 !== null && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(workInProgress2), reuseSuspenseHandlerOnStack(workInProgress2));
      reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    function bailoutOffscreenComponent(current2, workInProgress2) {
      current2 !== null && current2.tag === 22 || workInProgress2.stateNode !== null || (workInProgress2.stateNode = {
        _visibility: OffscreenVisible,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      });
      return workInProgress2.sibling;
    }
    function deferHiddenOffscreenComponent(current2, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
      var JSCompiler_inline_result = peekCacheFromPool();
      JSCompiler_inline_result = JSCompiler_inline_result === null ? null : {
        parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,
        pool: JSCompiler_inline_result
      };
      workInProgress2.memoizedState = {
        baseLanes: nextBaseLanes,
        cachePool: JSCompiler_inline_result
      };
      current2 !== null && pushTransition(workInProgress2, null);
      reuseHiddenContextOnStack(workInProgress2);
      pushOffscreenSuspenseHandler(workInProgress2);
      current2 !== null && propagateParentContextChanges(current2, workInProgress2, renderLanes2, true);
      workInProgress2.childLanes = remainingChildLanes;
      return null;
    }
    function mountActivityChildren(workInProgress2, nextProps) {
      var hiddenProp = nextProps.hidden;
      hiddenProp !== undefined && console.error(`<Activity> doesn't accept a hidden prop. Use mode="hidden" instead.
- <Activity %s>
+ <Activity %s>`, hiddenProp === true ? "hidden" : hiddenProp === false ? "hidden={false}" : "hidden={...}", hiddenProp ? 'mode="hidden"' : 'mode="visible"');
      nextProps = mountWorkInProgressOffscreenFiber({ mode: nextProps.mode, children: nextProps.children }, workInProgress2.mode);
      nextProps.ref = workInProgress2.ref;
      workInProgress2.child = nextProps;
      nextProps.return = workInProgress2;
      return nextProps;
    }
    function retryActivityComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
      current2 = mountActivityChildren(workInProgress2, workInProgress2.pendingProps);
      current2.flags |= 2;
      popSuspenseHandler(workInProgress2);
      workInProgress2.memoizedState = null;
      return current2;
    }
    function updateActivityComponent(current2, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, didSuspend = (workInProgress2.flags & 128) !== 0;
      workInProgress2.flags &= -129;
      if (current2 === null) {
        if (isHydrating) {
          if (nextProps.mode === "hidden")
            return current2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current2);
          pushDehydratedActivitySuspenseHandler(workInProgress2);
          (current2 = nextHydratableInstance) ? (renderLanes2 = canHydrateActivityInstance(current2, rootOrSingletonContext), renderLanes2 !== null && (nextProps = {
            dehydrated: renderLanes2,
            treeContext: getSuspendedTreeContext(),
            retryLane: 536870912,
            hydrationErrors: null
          }, workInProgress2.memoizedState = nextProps, nextProps = createFiberFromDehydratedFragment(renderLanes2), nextProps.return = workInProgress2, workInProgress2.child = nextProps, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : renderLanes2 = null;
          if (renderLanes2 === null)
            throw warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2);
          workInProgress2.lanes = 536870912;
          return null;
        }
        return mountActivityChildren(workInProgress2, nextProps);
      }
      var prevState = current2.memoizedState;
      if (prevState !== null) {
        var activityInstance = prevState.dehydrated;
        pushDehydratedActivitySuspenseHandler(workInProgress2);
        if (didSuspend)
          if (workInProgress2.flags & 256)
            workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(current2, workInProgress2, renderLanes2);
          else if (workInProgress2.memoizedState !== null)
            workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null;
          else
            throw Error("Client rendering an Activity suspended it again. This is a bug in React.");
        else if (warnIfHydrating(), (renderLanes2 & 536870912) !== 0 && markRenderDerivedCause(workInProgress2), didReceiveUpdate || propagateParentContextChanges(current2, workInProgress2, renderLanes2, false), didSuspend = (renderLanes2 & current2.childLanes) !== 0, didReceiveUpdate || didSuspend) {
          nextProps = workInProgressRoot;
          if (nextProps !== null && (activityInstance = getBumpedLaneForHydration(nextProps, renderLanes2), activityInstance !== 0 && activityInstance !== prevState.retryLane))
            throw prevState.retryLane = activityInstance, enqueueConcurrentRenderForLane(current2, activityInstance), scheduleUpdateOnFiber(nextProps, current2, activityInstance), SelectiveHydrationException;
          renderDidSuspendDelayIfPossible();
          workInProgress2 = retryActivityComponentWithoutHydrating(current2, workInProgress2, renderLanes2);
        } else
          current2 = prevState.treeContext, supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinActivityInstance(activityInstance), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, current2 !== null && restoreSuspendedTreeContext(workInProgress2, current2)), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
        return workInProgress2;
      }
      prevState = current2.child;
      nextProps = { mode: nextProps.mode, children: nextProps.children };
      (renderLanes2 & 536870912) !== 0 && (renderLanes2 & current2.lanes) !== 0 && markRenderDerivedCause(workInProgress2);
      current2 = createWorkInProgress(prevState, nextProps);
      current2.ref = workInProgress2.ref;
      workInProgress2.child = current2;
      current2.return = workInProgress2;
      return current2;
    }
    function markRef(current2, workInProgress2) {
      var ref = workInProgress2.ref;
      if (ref === null)
        current2 !== null && current2.ref !== null && (workInProgress2.flags |= 4194816);
      else {
        if (typeof ref !== "function" && typeof ref !== "object")
          throw Error("Expected ref to be a function, an object returned by React.createRef(), or undefined/null.");
        if (current2 === null || current2.ref !== ref)
          workInProgress2.flags |= 4194816;
      }
    }
    function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      if (Component.prototype && typeof Component.prototype.render === "function") {
        var componentName2 = getComponentNameFromType(Component) || "Unknown";
        didWarnAboutBadClass[componentName2] || (console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName2, componentName2), didWarnAboutBadClass[componentName2] = true);
      }
      workInProgress2.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
      current2 === null && (validateFunctionComponentInDev(workInProgress2, workInProgress2.type), Component.contextTypes && (componentName2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypes[componentName2] || (didWarnAboutContextTypes[componentName2] = true, console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)", componentName2))));
      prepareToReadContext(workInProgress2);
      Component = renderWithHooks(current2, workInProgress2, Component, nextProps, undefined, renderLanes2);
      nextProps = checkDidRenderIdHook();
      if (current2 !== null && !didReceiveUpdate)
        return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current2, workInProgress2, Component, renderLanes2);
      return workInProgress2.child;
    }
    function replayFunctionComponent(current2, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
      prepareToReadContext(workInProgress2);
      hookTypesUpdateIndexDev = -1;
      ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
      workInProgress2.updateQueue = null;
      nextProps = renderWithHooksAgain(workInProgress2, Component, nextProps, secondArg);
      finishRenderingHooks(current2, workInProgress2);
      Component = checkDidRenderIdHook();
      if (current2 !== null && !didReceiveUpdate)
        return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      isHydrating && Component && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      switch (shouldErrorImpl(workInProgress2)) {
        case false:
          var _instance = workInProgress2.stateNode, state = new workInProgress2.type(workInProgress2.memoizedProps, _instance.context).state;
          _instance.updater.enqueueSetState(_instance, state, null);
          break;
        case true:
          workInProgress2.flags |= 128;
          workInProgress2.flags |= 65536;
          _instance = Error("Simulated error coming from DevTools");
          var lane = renderLanes2 & -renderLanes2;
          workInProgress2.lanes |= lane;
          state = workInProgressRoot;
          if (state === null)
            throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
          lane = createClassErrorUpdate(lane);
          initializeClassErrorUpdate(lane, state, workInProgress2, createCapturedValueAtFiber(_instance, workInProgress2));
          enqueueCapturedUpdate(workInProgress2, lane);
      }
      prepareToReadContext(workInProgress2);
      if (workInProgress2.stateNode === null) {
        state = emptyContextObject;
        _instance = Component.contextType;
        "contextType" in Component && _instance !== null && (_instance === undefined || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = _instance === undefined ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof _instance !== "object" ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(Component) || "Component", lane));
        typeof _instance === "object" && _instance !== null && (state = readContext(_instance));
        _instance = new Component(nextProps, state);
        if (workInProgress2.mode & 8) {
          setIsStrictModeForDevtools(true);
          try {
            _instance = new Component(nextProps, state);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        state = workInProgress2.memoizedState = _instance.state !== null && _instance.state !== undefined ? _instance.state : null;
        _instance.updater = classComponentUpdater;
        workInProgress2.stateNode = _instance;
        _instance._reactInternals = workInProgress2;
        _instance._reactInternalInstance = fakeInternalInstance;
        typeof Component.getDerivedStateFromProps === "function" && state === null && (state = getComponentNameFromType(Component) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", state, _instance.state === null ? "null" : "undefined", state)));
        if (typeof Component.getDerivedStateFromProps === "function" || typeof _instance.getSnapshotBeforeUpdate === "function") {
          var foundWillUpdateName = lane = state = null;
          typeof _instance.componentWillMount === "function" && _instance.componentWillMount.__suppressDeprecationWarning !== true ? state = "componentWillMount" : typeof _instance.UNSAFE_componentWillMount === "function" && (state = "UNSAFE_componentWillMount");
          typeof _instance.componentWillReceiveProps === "function" && _instance.componentWillReceiveProps.__suppressDeprecationWarning !== true ? lane = "componentWillReceiveProps" : typeof _instance.UNSAFE_componentWillReceiveProps === "function" && (lane = "UNSAFE_componentWillReceiveProps");
          typeof _instance.componentWillUpdate === "function" && _instance.componentWillUpdate.__suppressDeprecationWarning !== true ? foundWillUpdateName = "componentWillUpdate" : typeof _instance.UNSAFE_componentWillUpdate === "function" && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
          if (state !== null || lane !== null || foundWillUpdateName !== null) {
            _instance = getComponentNameFromType(Component) || "Component";
            var newApiName = typeof Component.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://react.dev/link/unsafe-component-lifecycles`, _instance, newApiName, state !== null ? `
  ` + state : "", lane !== null ? `
  ` + lane : "", foundWillUpdateName !== null ? `
  ` + foundWillUpdateName : ""));
          }
        }
        _instance = workInProgress2.stateNode;
        state = getComponentNameFromType(Component) || "Component";
        _instance.render || (Component.prototype && typeof Component.prototype.render === "function" ? console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?", state) : console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.", state));
        !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", state);
        _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", state);
        _instance.contextType && console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", state);
        Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)", state));
        Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)", state));
        typeof _instance.componentShouldUpdate === "function" && console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", state);
        Component.prototype && Component.prototype.isPureReactComponent && typeof _instance.shouldComponentUpdate !== "undefined" && console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(Component) || "A pure component");
        typeof _instance.componentDidUnmount === "function" && console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", state);
        typeof _instance.componentDidReceiveProps === "function" && console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", state);
        typeof _instance.componentWillRecieveProps === "function" && console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", state);
        typeof _instance.UNSAFE_componentWillRecieveProps === "function" && console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", state);
        lane = _instance.props !== nextProps;
        _instance.props !== undefined && lane && console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", state);
        _instance.defaultProps && console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", state, state);
        typeof _instance.getSnapshotBeforeUpdate !== "function" || typeof _instance.componentDidUpdate === "function" || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(Component)));
        typeof _instance.getDerivedStateFromProps === "function" && console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", state);
        typeof _instance.getDerivedStateFromError === "function" && console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", state);
        typeof Component.getSnapshotBeforeUpdate === "function" && console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", state);
        (lane = _instance.state) && (typeof lane !== "object" || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
        typeof _instance.getChildContext === "function" && typeof Component.childContextTypes !== "object" && console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", state);
        _instance = workInProgress2.stateNode;
        _instance.props = nextProps;
        _instance.state = workInProgress2.memoizedState;
        _instance.refs = {};
        initializeUpdateQueue(workInProgress2);
        state = Component.contextType;
        _instance.context = typeof state === "object" && state !== null ? readContext(state) : emptyContextObject;
        _instance.state === nextProps && (state = getComponentNameFromType(Component) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", state)));
        workInProgress2.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, _instance);
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, _instance);
        _instance.state = workInProgress2.memoizedState;
        state = Component.getDerivedStateFromProps;
        typeof state === "function" && (applyDerivedStateFromProps(workInProgress2, Component, state, nextProps), _instance.state = workInProgress2.memoizedState);
        typeof Component.getDerivedStateFromProps === "function" || typeof _instance.getSnapshotBeforeUpdate === "function" || typeof _instance.UNSAFE_componentWillMount !== "function" && typeof _instance.componentWillMount !== "function" || (state = _instance.state, typeof _instance.componentWillMount === "function" && _instance.componentWillMount(), typeof _instance.UNSAFE_componentWillMount === "function" && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component"), classComponentUpdater.enqueueReplaceState(_instance, _instance.state, null)), processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress2.memoizedState);
        typeof _instance.componentDidMount === "function" && (workInProgress2.flags |= 4194308);
        (workInProgress2.mode & 16) !== NoMode && (workInProgress2.flags |= 134217728);
        _instance = true;
      } else if (current2 === null) {
        _instance = workInProgress2.stateNode;
        var unresolvedOldProps = workInProgress2.memoizedProps;
        lane = resolveClassComponentProps(Component, unresolvedOldProps);
        _instance.props = lane;
        var oldContext = _instance.context;
        foundWillUpdateName = Component.contextType;
        state = emptyContextObject;
        typeof foundWillUpdateName === "object" && foundWillUpdateName !== null && (state = readContext(foundWillUpdateName));
        newApiName = Component.getDerivedStateFromProps;
        foundWillUpdateName = typeof newApiName === "function" || typeof _instance.getSnapshotBeforeUpdate === "function";
        unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
        foundWillUpdateName || typeof _instance.UNSAFE_componentWillReceiveProps !== "function" && typeof _instance.componentWillReceiveProps !== "function" || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(workInProgress2, _instance, nextProps, state);
        hasForceUpdate = false;
        var oldState = workInProgress2.memoizedState;
        _instance.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        oldContext = workInProgress2.memoizedState;
        unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? (typeof newApiName === "function" && (applyDerivedStateFromProps(workInProgress2, Component, newApiName, nextProps), oldContext = workInProgress2.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(workInProgress2, Component, lane, nextProps, oldState, oldContext, state)) ? (foundWillUpdateName || typeof _instance.UNSAFE_componentWillMount !== "function" && typeof _instance.componentWillMount !== "function" || (typeof _instance.componentWillMount === "function" && _instance.componentWillMount(), typeof _instance.UNSAFE_componentWillMount === "function" && _instance.UNSAFE_componentWillMount()), typeof _instance.componentDidMount === "function" && (workInProgress2.flags |= 4194308), (workInProgress2.mode & 16) !== NoMode && (workInProgress2.flags |= 134217728)) : (typeof _instance.componentDidMount === "function" && (workInProgress2.flags |= 4194308), (workInProgress2.mode & 16) !== NoMode && (workInProgress2.flags |= 134217728), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : (typeof _instance.componentDidMount === "function" && (workInProgress2.flags |= 4194308), (workInProgress2.mode & 16) !== NoMode && (workInProgress2.flags |= 134217728), _instance = false);
      } else {
        _instance = workInProgress2.stateNode;
        cloneUpdateQueue(current2, workInProgress2);
        state = workInProgress2.memoizedProps;
        foundWillUpdateName = resolveClassComponentProps(Component, state);
        _instance.props = foundWillUpdateName;
        newApiName = workInProgress2.pendingProps;
        oldState = _instance.context;
        oldContext = Component.contextType;
        lane = emptyContextObject;
        typeof oldContext === "object" && oldContext !== null && (lane = readContext(oldContext));
        unresolvedOldProps = Component.getDerivedStateFromProps;
        (oldContext = typeof unresolvedOldProps === "function" || typeof _instance.getSnapshotBeforeUpdate === "function") || typeof _instance.UNSAFE_componentWillReceiveProps !== "function" && typeof _instance.componentWillReceiveProps !== "function" || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(workInProgress2, _instance, nextProps, lane);
        hasForceUpdate = false;
        oldState = workInProgress2.memoizedState;
        _instance.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        var newState = workInProgress2.memoizedState;
        state !== newApiName || oldState !== newState || hasForceUpdate || current2 !== null && current2.dependencies !== null && checkIfContextChanged(current2.dependencies) ? (typeof unresolvedOldProps === "function" && (applyDerivedStateFromProps(workInProgress2, Component, unresolvedOldProps, nextProps), newState = workInProgress2.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(workInProgress2, Component, foundWillUpdateName, nextProps, oldState, newState, lane) || current2 !== null && current2.dependencies !== null && checkIfContextChanged(current2.dependencies)) ? (oldContext || typeof _instance.UNSAFE_componentWillUpdate !== "function" && typeof _instance.componentWillUpdate !== "function" || (typeof _instance.componentWillUpdate === "function" && _instance.componentWillUpdate(nextProps, newState, lane), typeof _instance.UNSAFE_componentWillUpdate === "function" && _instance.UNSAFE_componentWillUpdate(nextProps, newState, lane)), typeof _instance.componentDidUpdate === "function" && (workInProgress2.flags |= 4), typeof _instance.getSnapshotBeforeUpdate === "function" && (workInProgress2.flags |= 1024)) : (typeof _instance.componentDidUpdate !== "function" || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), typeof _instance.getSnapshotBeforeUpdate !== "function" || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : (typeof _instance.componentDidUpdate !== "function" || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), typeof _instance.getSnapshotBeforeUpdate !== "function" || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), _instance = false);
      }
      lane = _instance;
      markRef(current2, workInProgress2);
      state = (workInProgress2.flags & 128) !== 0;
      if (lane || state) {
        lane = workInProgress2.stateNode;
        setCurrentFiber(workInProgress2);
        if (state && typeof Component.getDerivedStateFromError !== "function")
          Component = null, profilerStartTime = -1;
        else if (Component = callRenderInDEV(lane), workInProgress2.mode & 8) {
          setIsStrictModeForDevtools(true);
          try {
            callRenderInDEV(lane);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        workInProgress2.flags |= 1;
        current2 !== null && state ? (workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2), workInProgress2.child = reconcileChildFibers(workInProgress2, null, Component, renderLanes2)) : reconcileChildren(current2, workInProgress2, Component, renderLanes2);
        workInProgress2.memoizedState = lane.state;
        current2 = workInProgress2.child;
      } else
        current2 = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      renderLanes2 = workInProgress2.stateNode;
      _instance && renderLanes2.props !== nextProps && (didWarnAboutReassigningProps || console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component"), didWarnAboutReassigningProps = true);
      return current2;
    }
    function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2) {
      resetHydrationState();
      workInProgress2.flags |= 256;
      reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    function validateFunctionComponentInDev(workInProgress2, Component) {
      Component && Component.childContextTypes && console.error(`childContextTypes cannot be defined on a function component.
  %s.childContextTypes = ...`, Component.displayName || Component.name || "Component");
      typeof Component.getDerivedStateFromProps === "function" && (workInProgress2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] || (console.error("%s: Function components do not support getDerivedStateFromProps.", workInProgress2), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] = true));
      typeof Component.contextType === "object" && Component.contextType !== null && (Component = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error("%s: Function components do not support contextType.", Component), didWarnAboutContextTypeOnFunctionComponent[Component] = true));
    }
    function mountSuspenseOffscreenState(renderLanes2) {
      return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
    }
    function getRemainingWorkInPrimaryTree(current2, primaryTreeDidDefer, renderLanes2) {
      current2 = current2 !== null ? current2.childLanes & ~renderLanes2 : 0;
      primaryTreeDidDefer && (current2 |= workInProgressDeferredLane);
      return current2;
    }
    function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps;
      shouldSuspendImpl(workInProgress2) && (workInProgress2.flags |= 128);
      var showFallback = false, didSuspend = (workInProgress2.flags & 128) !== 0, JSCompiler_temp;
      (JSCompiler_temp = didSuspend) || (JSCompiler_temp = current2 !== null && current2.memoizedState === null ? false : (suspenseStackCursor.current & ForceSuspenseFallback) !== 0);
      JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
      JSCompiler_temp = (workInProgress2.flags & 32) !== 0;
      workInProgress2.flags &= -33;
      if (current2 === null) {
        if (isHydrating) {
          showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
          (current2 = nextHydratableInstance) ? (renderLanes2 = canHydrateSuspenseInstance(current2, rootOrSingletonContext), renderLanes2 !== null && (JSCompiler_temp = {
            dehydrated: renderLanes2,
            treeContext: getSuspendedTreeContext(),
            retryLane: 536870912,
            hydrationErrors: null
          }, workInProgress2.memoizedState = JSCompiler_temp, JSCompiler_temp = createFiberFromDehydratedFragment(renderLanes2), JSCompiler_temp.return = workInProgress2, workInProgress2.child = JSCompiler_temp, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : renderLanes2 = null;
          if (renderLanes2 === null)
            throw warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2);
          isSuspenseInstanceFallback(renderLanes2) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
          return null;
        }
        var nextPrimaryChildren = nextProps.children;
        nextProps = nextProps.fallback;
        if (showFallback)
          return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = workInProgress2.mode, nextPrimaryChildren = mountWorkInProgressOffscreenFiber({ mode: "hidden", children: nextPrimaryChildren }, showFallback), nextProps = createFiberFromFragment(nextProps, showFallback, renderLanes2, null), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextPrimaryChildren.sibling = nextProps, workInProgress2.child = nextPrimaryChildren, nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(current2, JSCompiler_temp, renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(null, nextProps);
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
      }
      var prevState = current2.memoizedState;
      if (prevState !== null && (nextPrimaryChildren = prevState.dehydrated, nextPrimaryChildren !== null)) {
        if (didSuspend)
          workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2)) : workInProgress2.memoizedState !== null ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber({ mode: "visible", children: nextProps.children }, showFallback), nextPrimaryChildren = createFiberFromFragment(nextPrimaryChildren, showFallback, renderLanes2, null), nextPrimaryChildren.flags |= 2, nextProps.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(current2, JSCompiler_temp, renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(null, nextProps));
        else if (pushPrimaryTreeSuspenseHandler(workInProgress2), warnIfHydrating(), (renderLanes2 & 536870912) !== 0 && markRenderDerivedCause(workInProgress2), isSuspenseInstanceFallback(nextPrimaryChildren))
          showFallback = getSuspenseInstanceFallbackErrorDetails(nextPrimaryChildren), JSCompiler_temp = showFallback.digest, nextPrimaryChildren = showFallback.message, nextProps = showFallback.stack, showFallback = showFallback.componentStack, nextPrimaryChildren = nextPrimaryChildren ? Error(nextPrimaryChildren) : Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."), nextPrimaryChildren.stack = nextProps || "", nextPrimaryChildren.digest = JSCompiler_temp, JSCompiler_temp = showFallback === undefined ? null : showFallback, nextProps = {
            value: nextPrimaryChildren,
            source: null,
            stack: JSCompiler_temp
          }, typeof JSCompiler_temp === "string" && CapturedStacks.set(nextPrimaryChildren, nextProps), queueHydrationError(nextProps), workInProgress2 = retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2);
        else if (didReceiveUpdate || propagateParentContextChanges(current2, workInProgress2, renderLanes2, false), JSCompiler_temp = (renderLanes2 & current2.childLanes) !== 0, didReceiveUpdate || JSCompiler_temp) {
          JSCompiler_temp = workInProgressRoot;
          if (JSCompiler_temp !== null && (nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes2), nextProps !== 0 && nextProps !== prevState.retryLane))
            throw prevState.retryLane = nextProps, enqueueConcurrentRenderForLane(current2, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current2, nextProps), SelectiveHydrationException;
          isSuspenseInstancePending(nextPrimaryChildren) || renderDidSuspendDelayIfPossible();
          workInProgress2 = retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2);
        } else
          isSuspenseInstancePending(nextPrimaryChildren) ? (workInProgress2.flags |= 192, workInProgress2.child = current2.child, workInProgress2 = null) : (current2 = prevState.treeContext, supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(nextPrimaryChildren), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, current2 !== null && restoreSuspendedTreeContext(workInProgress2, current2)), workInProgress2 = mountSuspensePrimaryChildren(workInProgress2, nextProps.children), workInProgress2.flags |= 4096);
        return workInProgress2;
      }
      if (showFallback)
        return reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, prevState = current2.child, didSuspend = prevState.sibling, nextProps = createWorkInProgress(prevState, {
          mode: "hidden",
          children: nextProps.children
        }), nextProps.subtreeFlags = prevState.subtreeFlags & 65011712, didSuspend !== null ? nextPrimaryChildren = createWorkInProgress(didSuspend, nextPrimaryChildren) : (nextPrimaryChildren = createFiberFromFragment(nextPrimaryChildren, showFallback, renderLanes2, null), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, bailoutOffscreenComponent(null, nextProps), nextProps = workInProgress2.child, nextPrimaryChildren = current2.child.memoizedState, nextPrimaryChildren === null ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (showFallback = nextPrimaryChildren.cachePool, showFallback !== null ? (prevState = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2, showFallback = showFallback.parent !== prevState ? { parent: prevState, pool: prevState } : showFallback) : showFallback = getSuspendedCache(), nextPrimaryChildren = {
          baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
          cachePool: showFallback
        }), nextProps.memoizedState = nextPrimaryChildren, nextProps.childLanes = getRemainingWorkInPrimaryTree(current2, JSCompiler_temp, renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(current2.child, nextProps);
      prevState !== null && (renderLanes2 & 62914560) === renderLanes2 && (renderLanes2 & current2.lanes) !== 0 && markRenderDerivedCause(workInProgress2);
      pushPrimaryTreeSuspenseHandler(workInProgress2);
      renderLanes2 = current2.child;
      current2 = renderLanes2.sibling;
      renderLanes2 = createWorkInProgress(renderLanes2, {
        mode: "visible",
        children: nextProps.children
      });
      renderLanes2.return = workInProgress2;
      renderLanes2.sibling = null;
      current2 !== null && (JSCompiler_temp = workInProgress2.deletions, JSCompiler_temp === null ? (workInProgress2.deletions = [current2], workInProgress2.flags |= 16) : JSCompiler_temp.push(current2));
      workInProgress2.child = renderLanes2;
      workInProgress2.memoizedState = null;
      return renderLanes2;
    }
    function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
      primaryChildren = mountWorkInProgressOffscreenFiber({ mode: "visible", children: primaryChildren }, workInProgress2.mode);
      primaryChildren.return = workInProgress2;
      return workInProgress2.child = primaryChildren;
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
      offscreenProps = createFiber(22, offscreenProps, null, mode);
      offscreenProps.lanes = 0;
      return offscreenProps;
    }
    function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
      current2 = mountSuspensePrimaryChildren(workInProgress2, workInProgress2.pendingProps.children);
      current2.flags |= 2;
      workInProgress2.memoizedState = null;
      return current2;
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
      fiber.lanes |= renderLanes2;
      var alternate = fiber.alternate;
      alternate !== null && (alternate.lanes |= renderLanes2);
      scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
    }
    function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
      var renderState = workInProgress2.memoizedState;
      renderState === null ? workInProgress2.memoizedState = {
        isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail,
        tailMode,
        treeForkCount: treeForkCount2
      } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
    }
    function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail, newChildren = nextProps.children, suspenseContext = suspenseStackCursor.current;
      (nextProps = (suspenseContext & ForceSuspenseFallback) !== 0) ? (suspenseContext = suspenseContext & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2.flags |= 128) : suspenseContext &= SubtreeSuspenseContextMask;
      push(suspenseStackCursor, suspenseContext, workInProgress2);
      suspenseContext = revealOrder == null ? "null" : revealOrder;
      if (revealOrder !== "forwards" && revealOrder !== "unstable_legacy-backwards" && revealOrder !== "together" && revealOrder !== "independent" && !didWarnAboutRevealOrder[suspenseContext])
        if (didWarnAboutRevealOrder[suspenseContext] = true, revealOrder == null)
          console.error('The default for the <SuspenseList revealOrder="..."> prop is changing. To be future compatible you must explictly specify either "independent" (the current default), "together", "forwards" or "legacy_unstable-backwards".');
        else if (revealOrder === "backwards")
          console.error('The rendering order of <SuspenseList revealOrder="backwards"> is changing. To be future compatible you must specify revealOrder="legacy_unstable-backwards" instead.');
        else if (typeof revealOrder === "string")
          switch (revealOrder.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards":
            case "independent":
              console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
              break;
            case "forward":
            case "backward":
              console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
              break;
            default:
              console.error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?', revealOrder);
          }
        else
          console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?', revealOrder);
      suspenseContext = tailMode == null ? "null" : tailMode;
      if (!didWarnAboutTailOptions[suspenseContext])
        if (tailMode == null) {
          if (revealOrder === "forwards" || revealOrder === "backwards" || revealOrder === "unstable_legacy-backwards")
            didWarnAboutTailOptions[suspenseContext] = true, console.error('The default for the <SuspenseList tail="..."> prop is changing. To be future compatible you must explictly specify either "visible" (the current default), "collapsed" or "hidden".');
        } else
          tailMode !== "visible" && tailMode !== "collapsed" && tailMode !== "hidden" ? (didWarnAboutTailOptions[suspenseContext] = true, console.error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "visible", "collapsed" or "hidden"?', tailMode)) : revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "unstable_legacy-backwards" && (didWarnAboutTailOptions[suspenseContext] = true, console.error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode));
      a:
        if ((revealOrder === "forwards" || revealOrder === "backwards" || revealOrder === "unstable_legacy-backwards") && newChildren !== undefined && newChildren !== null && newChildren !== false)
          if (isArrayImpl(newChildren))
            for (suspenseContext = 0;suspenseContext < newChildren.length; suspenseContext++) {
              if (!validateSuspenseListNestedChild(newChildren[suspenseContext], suspenseContext))
                break a;
            }
          else if (suspenseContext = getIteratorFn(newChildren), typeof suspenseContext === "function") {
            if (suspenseContext = suspenseContext.call(newChildren))
              for (var step = suspenseContext.next(), _i = 0;!step.done; step = suspenseContext.next()) {
                if (!validateSuspenseListNestedChild(step.value, _i))
                  break a;
                _i++;
              }
          } else
            console.error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
      reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
      isHydrating ? (warnIfNotHydrating(), newChildren = treeForkCount) : newChildren = 0;
      if (!nextProps && current2 !== null && (current2.flags & 128) !== 0)
        a:
          for (current2 = workInProgress2.child;current2 !== null; ) {
            if (current2.tag === 13)
              current2.memoizedState !== null && scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
            else if (current2.tag === 19)
              scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
            else if (current2.child !== null) {
              current2.child.return = current2;
              current2 = current2.child;
              continue;
            }
            if (current2 === workInProgress2)
              break a;
            for (;current2.sibling === null; ) {
              if (current2.return === null || current2.return === workInProgress2)
                break a;
              current2 = current2.return;
            }
            current2.sibling.return = current2.return;
            current2 = current2.sibling;
          }
      switch (revealOrder) {
        case "forwards":
          renderLanes2 = workInProgress2.child;
          for (revealOrder = null;renderLanes2 !== null; )
            current2 = renderLanes2.alternate, current2 !== null && findFirstSuspended(current2) === null && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
          renderLanes2 = revealOrder;
          renderLanes2 === null ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
          initSuspenseListRenderState(workInProgress2, false, revealOrder, renderLanes2, tailMode, newChildren);
          break;
        case "backwards":
        case "unstable_legacy-backwards":
          renderLanes2 = null;
          revealOrder = workInProgress2.child;
          for (workInProgress2.child = null;revealOrder !== null; ) {
            current2 = revealOrder.alternate;
            if (current2 !== null && findFirstSuspended(current2) === null) {
              workInProgress2.child = revealOrder;
              break;
            }
            current2 = revealOrder.sibling;
            revealOrder.sibling = renderLanes2;
            renderLanes2 = revealOrder;
            revealOrder = current2;
          }
          initSuspenseListRenderState(workInProgress2, true, renderLanes2, null, tailMode, newChildren);
          break;
        case "together":
          initSuspenseListRenderState(workInProgress2, false, null, null, undefined, newChildren);
          break;
        default:
          workInProgress2.memoizedState = null;
      }
      return workInProgress2.child;
    }
    function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
      current2 !== null && (workInProgress2.dependencies = current2.dependencies);
      profilerStartTime = -1;
      workInProgressRootSkippedLanes |= workInProgress2.lanes;
      if ((renderLanes2 & workInProgress2.childLanes) === 0)
        if (current2 !== null) {
          if (propagateParentContextChanges(current2, workInProgress2, renderLanes2, false), (renderLanes2 & workInProgress2.childLanes) === 0)
            return null;
        } else
          return null;
      if (current2 !== null && workInProgress2.child !== current2.child)
        throw Error("Resuming work not yet implemented.");
      if (workInProgress2.child !== null) {
        current2 = workInProgress2.child;
        renderLanes2 = createWorkInProgress(current2, current2.pendingProps);
        workInProgress2.child = renderLanes2;
        for (renderLanes2.return = workInProgress2;current2.sibling !== null; )
          current2 = current2.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current2, current2.pendingProps), renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
      }
      return workInProgress2.child;
    }
    function checkScheduledUpdateOrContext(current2, renderLanes2) {
      if ((current2.lanes & renderLanes2) !== 0)
        return true;
      current2 = current2.dependencies;
      return current2 !== null && checkIfContextChanged(current2) ? true : false;
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
      switch (workInProgress2.tag) {
        case 3:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          pushProvider(workInProgress2, CacheContext, current2.memoizedState.cache);
          resetHydrationState();
          break;
        case 27:
        case 5:
          pushHostContext(workInProgress2);
          break;
        case 4:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          break;
        case 10:
          pushProvider(workInProgress2, workInProgress2.type, workInProgress2.memoizedProps.value);
          break;
        case 12:
          (renderLanes2 & workInProgress2.childLanes) !== 0 && (workInProgress2.flags |= 4);
          workInProgress2.flags |= 2048;
          var stateNode = workInProgress2.stateNode;
          stateNode.effectDuration = -0;
          stateNode.passiveEffectDuration = -0;
          break;
        case 31:
          if (workInProgress2.memoizedState !== null)
            return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
          break;
        case 13:
          stateNode = workInProgress2.memoizedState;
          if (stateNode !== null) {
            if (stateNode.dehydrated !== null)
              return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
            if ((renderLanes2 & workInProgress2.child.childLanes) !== 0)
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            current2 = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            return current2 !== null ? current2.sibling : null;
          }
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          break;
        case 19:
          var didSuspendBefore = (current2.flags & 128) !== 0;
          stateNode = (renderLanes2 & workInProgress2.childLanes) !== 0;
          stateNode || (propagateParentContextChanges(current2, workInProgress2, renderLanes2, false), stateNode = (renderLanes2 & workInProgress2.childLanes) !== 0);
          if (didSuspendBefore) {
            if (stateNode)
              return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
            workInProgress2.flags |= 128;
          }
          didSuspendBefore = workInProgress2.memoizedState;
          didSuspendBefore !== null && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
          push(suspenseStackCursor, suspenseStackCursor.current, workInProgress2);
          if (stateNode)
            break;
          else
            return null;
        case 22:
          return workInProgress2.lanes = 0, updateOffscreenComponent(current2, workInProgress2, renderLanes2, workInProgress2.pendingProps);
        case 24:
          pushProvider(workInProgress2, CacheContext, current2.memoizedState.cache);
      }
      return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
    }
    function beginWork(current2, workInProgress2, renderLanes2) {
      if (workInProgress2._debugNeedsRemount && current2 !== null) {
        renderLanes2 = createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes);
        renderLanes2._debugStack = workInProgress2._debugStack;
        renderLanes2._debugTask = workInProgress2._debugTask;
        var returnFiber = workInProgress2.return;
        if (returnFiber === null)
          throw Error("Cannot swap the root fiber.");
        current2.alternate = null;
        workInProgress2.alternate = null;
        renderLanes2.index = workInProgress2.index;
        renderLanes2.sibling = workInProgress2.sibling;
        renderLanes2.return = workInProgress2.return;
        renderLanes2.ref = workInProgress2.ref;
        renderLanes2._debugInfo = workInProgress2._debugInfo;
        if (workInProgress2 === returnFiber.child)
          returnFiber.child = renderLanes2;
        else {
          var prevSibling = returnFiber.child;
          if (prevSibling === null)
            throw Error("Expected parent to have a child.");
          for (;prevSibling.sibling !== workInProgress2; )
            if (prevSibling = prevSibling.sibling, prevSibling === null)
              throw Error("Expected to find the previous sibling.");
          prevSibling.sibling = renderLanes2;
        }
        workInProgress2 = returnFiber.deletions;
        workInProgress2 === null ? (returnFiber.deletions = [current2], returnFiber.flags |= 16) : workInProgress2.push(current2);
        renderLanes2.flags |= 2;
        return renderLanes2;
      }
      if (current2 !== null)
        if (current2.memoizedProps !== workInProgress2.pendingProps || workInProgress2.type !== current2.type)
          didReceiveUpdate = true;
        else {
          if (!checkScheduledUpdateOrContext(current2, renderLanes2) && (workInProgress2.flags & 128) === 0)
            return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
          didReceiveUpdate = (current2.flags & 131072) !== 0 ? true : false;
        }
      else {
        didReceiveUpdate = false;
        if (returnFiber = isHydrating)
          warnIfNotHydrating(), returnFiber = (workInProgress2.flags & 1048576) !== 0;
        returnFiber && (returnFiber = workInProgress2.index, warnIfNotHydrating(), pushTreeId(workInProgress2, treeForkCount, returnFiber));
      }
      workInProgress2.lanes = 0;
      switch (workInProgress2.tag) {
        case 16:
          a:
            if (returnFiber = workInProgress2.pendingProps, current2 = resolveLazy(workInProgress2.elementType), workInProgress2.type = current2, typeof current2 === "function")
              shouldConstruct(current2) ? (returnFiber = resolveClassComponentProps(current2, returnFiber), workInProgress2.tag = 1, workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateClassComponent(null, workInProgress2, current2, returnFiber, renderLanes2)) : (workInProgress2.tag = 0, validateFunctionComponentInDev(workInProgress2, current2), workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateFunctionComponent(null, workInProgress2, current2, returnFiber, renderLanes2));
            else {
              if (current2 !== undefined && current2 !== null) {
                if (prevSibling = current2.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
                  workInProgress2.tag = 11;
                  workInProgress2.type = current2 = resolveForwardRefForHotReloading(current2);
                  workInProgress2 = updateForwardRef(null, workInProgress2, current2, returnFiber, renderLanes2);
                  break a;
                } else if (prevSibling === REACT_MEMO_TYPE) {
                  workInProgress2.tag = 14;
                  workInProgress2 = updateMemoComponent(null, workInProgress2, current2, returnFiber, renderLanes2);
                  break a;
                }
              }
              workInProgress2 = "";
              current2 !== null && typeof current2 === "object" && current2.$$typeof === REACT_LAZY_TYPE && (workInProgress2 = " Did you wrap a component in React.lazy() more than once?");
              current2 = getComponentNameFromType(current2) || current2;
              throw Error("Element type is invalid. Received a promise that resolves to: " + current2 + ". Lazy element type must resolve to a class or function." + workInProgress2);
            }
          return workInProgress2;
        case 0:
          return updateFunctionComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
        case 1:
          return returnFiber = workInProgress2.type, prevSibling = resolveClassComponentProps(returnFiber, workInProgress2.pendingProps), updateClassComponent(current2, workInProgress2, returnFiber, prevSibling, renderLanes2);
        case 3:
          a: {
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            if (current2 === null)
              throw Error("Should have a current fiber. This is a bug in React.");
            var nextProps = workInProgress2.pendingProps;
            prevSibling = workInProgress2.memoizedState;
            returnFiber = prevSibling.element;
            cloneUpdateQueue(current2, workInProgress2);
            processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            nextProps = nextState.cache;
            pushProvider(workInProgress2, CacheContext, nextProps);
            nextProps !== prevSibling.cache && propagateContextChanges(workInProgress2, [CacheContext], renderLanes2, true);
            suspendIfUpdateReadFromEntangledAsyncAction();
            nextProps = nextState.element;
            if (supportsHydration && prevSibling.isDehydrated)
              if (prevSibling = {
                element: nextProps,
                isDehydrated: false,
                cache: nextState.cache
              }, workInProgress2.updateQueue.baseState = prevSibling, workInProgress2.memoizedState = prevSibling, workInProgress2.flags & 256) {
                workInProgress2 = mountHostRootWithoutHydrating(current2, workInProgress2, nextProps, renderLanes2);
                break a;
              } else if (nextProps !== returnFiber) {
                returnFiber = createCapturedValueAtFiber(Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
                queueHydrationError(returnFiber);
                workInProgress2 = mountHostRootWithoutHydrating(current2, workInProgress2, nextProps, renderLanes2);
                break a;
              } else
                for (supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinContainer(workInProgress2.stateNode.containerInfo), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = true), current2 = mountChildFibers(workInProgress2, null, nextProps, renderLanes2), workInProgress2.child = current2;current2; )
                  current2.flags = current2.flags & -3 | 4096, current2 = current2.sibling;
            else {
              resetHydrationState();
              if (nextProps === returnFiber) {
                workInProgress2 = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                break a;
              }
              reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
            }
            workInProgress2 = workInProgress2.child;
          }
          return workInProgress2;
        case 26:
          if (supportsResources)
            return markRef(current2, workInProgress2), current2 === null ? (current2 = getResource(workInProgress2.type, null, workInProgress2.pendingProps, null)) ? workInProgress2.memoizedState = current2 : isHydrating || (workInProgress2.stateNode = createHoistableInstance(workInProgress2.type, workInProgress2.pendingProps, requiredContext(rootInstanceStackCursor.current), workInProgress2)) : workInProgress2.memoizedState = getResource(workInProgress2.type, current2.memoizedProps, workInProgress2.pendingProps, current2.memoizedState), null;
        case 27:
          if (supportsSingletons)
            return pushHostContext(workInProgress2), current2 === null && supportsSingletons && isHydrating && (prevSibling = requiredContext(rootInstanceStackCursor.current), returnFiber = getHostContext(), prevSibling = workInProgress2.stateNode = resolveSingletonInstance(workInProgress2.type, workInProgress2.pendingProps, prevSibling, returnFiber, false), didSuspendOrErrorDEV || (returnFiber = diffHydratedPropsForDevWarnings(prevSibling, workInProgress2.type, workInProgress2.pendingProps, returnFiber), returnFiber !== null && (buildHydrationDiffNode(workInProgress2, 0).serverProps = returnFiber)), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, nextHydratableInstance = getFirstHydratableChildWithinSingleton(workInProgress2.type, prevSibling, nextHydratableInstance)), reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps.children, renderLanes2), markRef(current2, workInProgress2), current2 === null && (workInProgress2.flags |= 4194304), workInProgress2.child;
        case 5:
          return current2 === null && isHydrating && (nextProps = getHostContext(), returnFiber = validateHydratableInstance(workInProgress2.type, workInProgress2.pendingProps, nextProps), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(prevSibling, workInProgress2.type, workInProgress2.pendingProps, rootOrSingletonContext), nextState !== null ? (workInProgress2.stateNode = nextState, didSuspendOrErrorDEV || (nextProps = diffHydratedPropsForDevWarnings(nextState, workInProgress2.type, workInProgress2.pendingProps, nextProps), nextProps !== null && (buildHydrationDiffNode(workInProgress2, 0).serverProps = nextProps)), hydrationParentFiber = workInProgress2, nextHydratableInstance = getFirstHydratableChild(nextState), rootOrSingletonContext = false, nextProps = true) : nextProps = false, nextState = !nextProps), nextState && (returnFiber && warnNonHydratedInstance(workInProgress2, prevSibling), throwOnHydrationMismatch(workInProgress2))), pushHostContext(workInProgress2), prevSibling = workInProgress2.type, nextProps = workInProgress2.pendingProps, nextState = current2 !== null ? current2.memoizedProps : null, returnFiber = nextProps.children, shouldSetTextContent(prevSibling, nextProps) ? returnFiber = null : nextState !== null && shouldSetTextContent(prevSibling, nextState) && (workInProgress2.flags |= 32), workInProgress2.memoizedState !== null && (prevSibling = renderWithHooks(current2, workInProgress2, TransitionAwareHostComponent, null, null, renderLanes2), isPrimaryRenderer ? HostTransitionContext._currentValue = prevSibling : HostTransitionContext._currentValue2 = prevSibling), markRef(current2, workInProgress2), reconcileChildren(current2, workInProgress2, returnFiber, renderLanes2), workInProgress2.child;
        case 6:
          return current2 === null && isHydrating && (current2 = workInProgress2.pendingProps, renderLanes2 = getHostContext(), current2 = validateHydratableTextInstance(current2, renderLanes2), renderLanes2 = nextHydratableInstance, (returnFiber = !renderLanes2) || (returnFiber = canHydrateTextInstance(renderLanes2, workInProgress2.pendingProps, rootOrSingletonContext), returnFiber !== null ? (workInProgress2.stateNode = returnFiber, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, returnFiber = true) : returnFiber = false, returnFiber = !returnFiber), returnFiber && (current2 && warnNonHydratedInstance(workInProgress2, renderLanes2), throwOnHydrationMismatch(workInProgress2))), null;
        case 13:
          return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
        case 4:
          return pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo), returnFiber = workInProgress2.pendingProps, current2 === null ? workInProgress2.child = reconcileChildFibers(workInProgress2, null, returnFiber, renderLanes2) : reconcileChildren(current2, workInProgress2, returnFiber, renderLanes2), workInProgress2.child;
        case 11:
          return updateForwardRef(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
        case 7:
          return reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps, renderLanes2), workInProgress2.child;
        case 8:
          return reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps.children, renderLanes2), workInProgress2.child;
        case 12:
          return workInProgress2.flags |= 4, workInProgress2.flags |= 2048, returnFiber = workInProgress2.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps.children, renderLanes2), workInProgress2.child;
        case 10:
          return returnFiber = workInProgress2.type, prevSibling = workInProgress2.pendingProps, nextProps = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = true, console.error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?")), pushProvider(workInProgress2, returnFiber, nextProps), reconcileChildren(current2, workInProgress2, prevSibling.children, renderLanes2), workInProgress2.child;
        case 9:
          return prevSibling = workInProgress2.type._context, returnFiber = workInProgress2.pendingProps.children, typeof returnFiber !== "function" && console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), prepareToReadContext(workInProgress2), prevSibling = readContext(prevSibling), returnFiber = callComponentInDEV(returnFiber, prevSibling, undefined), workInProgress2.flags |= 1, reconcileChildren(current2, workInProgress2, returnFiber, renderLanes2), workInProgress2.child;
        case 14:
          return updateMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
        case 15:
          return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
        case 19:
          return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
        case 31:
          return updateActivityComponent(current2, workInProgress2, renderLanes2);
        case 22:
          return updateOffscreenComponent(current2, workInProgress2, renderLanes2, workInProgress2.pendingProps);
        case 24:
          return prepareToReadContext(workInProgress2), returnFiber = readContext(CacheContext), current2 === null ? (prevSibling = peekCacheFromPool(), prevSibling === null && (prevSibling = workInProgressRoot, nextProps = createCache(), prevSibling.pooledCache = nextProps, retainCache(nextProps), nextProps !== null && (prevSibling.pooledCacheLanes |= renderLanes2), prevSibling = nextProps), workInProgress2.memoizedState = {
            parent: returnFiber,
            cache: prevSibling
          }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, prevSibling)) : ((current2.lanes & renderLanes2) !== 0 && (cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current2.memoizedState, nextProps = workInProgress2.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
            parent: returnFiber,
            cache: returnFiber
          }, workInProgress2.memoizedState = prevSibling, workInProgress2.lanes === 0 && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = prevSibling), pushProvider(workInProgress2, CacheContext, returnFiber)) : (returnFiber = nextProps.cache, pushProvider(workInProgress2, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(workInProgress2, [CacheContext], renderLanes2, true))), reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps.children, renderLanes2), workInProgress2.child;
        case 29:
          throw workInProgress2.pendingProps;
      }
      throw Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function markUpdate(workInProgress2) {
      workInProgress2.flags |= 4;
    }
    function markCloned(workInProgress2) {
      supportsPersistence && (workInProgress2.flags |= 8);
    }
    function doesRequireClone(current2, completedWork) {
      if (current2 !== null && current2.child === completedWork.child)
        return false;
      if ((completedWork.flags & 16) !== 0)
        return true;
      for (current2 = completedWork.child;current2 !== null; ) {
        if ((current2.flags & 8218) !== 0 || (current2.subtreeFlags & 8218) !== 0)
          return true;
        current2 = current2.sibling;
      }
      return false;
    }
    function appendAllChildren(parent, workInProgress2, needsVisibilityToggle, isHidden) {
      if (supportsMutation)
        for (needsVisibilityToggle = workInProgress2.child;needsVisibilityToggle !== null; ) {
          if (needsVisibilityToggle.tag === 5 || needsVisibilityToggle.tag === 6)
            appendInitialChild(parent, needsVisibilityToggle.stateNode);
          else if (!(needsVisibilityToggle.tag === 4 || supportsSingletons && needsVisibilityToggle.tag === 27) && needsVisibilityToggle.child !== null) {
            needsVisibilityToggle.child.return = needsVisibilityToggle;
            needsVisibilityToggle = needsVisibilityToggle.child;
            continue;
          }
          if (needsVisibilityToggle === workInProgress2)
            break;
          for (;needsVisibilityToggle.sibling === null; ) {
            if (needsVisibilityToggle.return === null || needsVisibilityToggle.return === workInProgress2)
              return;
            needsVisibilityToggle = needsVisibilityToggle.return;
          }
          needsVisibilityToggle.sibling.return = needsVisibilityToggle.return;
          needsVisibilityToggle = needsVisibilityToggle.sibling;
        }
      else if (supportsPersistence)
        for (var _node = workInProgress2.child;_node !== null; ) {
          if (_node.tag === 5) {
            var instance = _node.stateNode;
            needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance, _node.type, _node.memoizedProps));
            appendInitialChild(parent, instance);
          } else if (_node.tag === 6)
            instance = _node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(instance, _node.memoizedProps)), appendInitialChild(parent, instance);
          else if (_node.tag !== 4) {
            if (_node.tag === 22 && _node.memoizedState !== null)
              instance = _node.child, instance !== null && (instance.return = _node), appendAllChildren(parent, _node, true, true);
            else if (_node.child !== null) {
              _node.child.return = _node;
              _node = _node.child;
              continue;
            }
          }
          if (_node === workInProgress2)
            break;
          for (;_node.sibling === null; ) {
            if (_node.return === null || _node.return === workInProgress2)
              return;
            _node = _node.return;
          }
          _node.sibling.return = _node.return;
          _node = _node.sibling;
        }
    }
    function appendAllChildrenToContainer(containerChildSet, workInProgress2, needsVisibilityToggle, isHidden) {
      var hasOffscreenComponentChild = false;
      if (supportsPersistence)
        for (var node = workInProgress2.child;node !== null; ) {
          if (node.tag === 5) {
            var instance = node.stateNode;
            needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance, node.type, node.memoizedProps));
            appendChildToContainerChildSet(containerChildSet, instance);
          } else if (node.tag === 6)
            instance = node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(instance, node.memoizedProps)), appendChildToContainerChildSet(containerChildSet, instance);
          else if (node.tag !== 4) {
            if (node.tag === 22 && node.memoizedState !== null)
              hasOffscreenComponentChild = node.child, hasOffscreenComponentChild !== null && (hasOffscreenComponentChild.return = node), appendAllChildrenToContainer(containerChildSet, node, true, true), hasOffscreenComponentChild = true;
            else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
          }
          if (node === workInProgress2)
            break;
          for (;node.sibling === null; ) {
            if (node.return === null || node.return === workInProgress2)
              return hasOffscreenComponentChild;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      return hasOffscreenComponentChild;
    }
    function updateHostContainer(current2, workInProgress2) {
      if (supportsPersistence && doesRequireClone(current2, workInProgress2)) {
        current2 = workInProgress2.stateNode;
        var container = current2.containerInfo, newChildSet = createContainerChildSet();
        appendAllChildrenToContainer(newChildSet, workInProgress2, false, false);
        current2.pendingChildren = newChildSet;
        markUpdate(workInProgress2);
        finalizeContainerChildren(container, newChildSet);
      }
    }
    function updateHostComponent(current2, workInProgress2, type, newProps) {
      if (supportsMutation)
        current2.memoizedProps !== newProps && markUpdate(workInProgress2);
      else if (supportsPersistence) {
        var { stateNode: currentInstance, memoizedProps: _oldProps } = current2;
        if ((current2 = doesRequireClone(current2, workInProgress2)) || _oldProps !== newProps) {
          var currentHostContext = getHostContext();
          _oldProps = cloneInstance(currentInstance, type, _oldProps, newProps, !current2, null);
          _oldProps === currentInstance ? workInProgress2.stateNode = currentInstance : (markCloned(workInProgress2), finalizeInitialChildren(_oldProps, type, newProps, currentHostContext) && markUpdate(workInProgress2), workInProgress2.stateNode = _oldProps, current2 && appendAllChildren(_oldProps, workInProgress2, false, false));
        } else
          workInProgress2.stateNode = currentInstance;
      }
    }
    function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
      if ((workInProgress2.mode & 32) !== NoMode && (oldProps === null ? maySuspendCommit(type, newProps) : maySuspendCommitOnUpdate(type, oldProps, newProps))) {
        if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2 || maySuspendCommitInSyncRender(type, newProps))
          if (preloadInstance(workInProgress2.stateNode, type, newProps))
            workInProgress2.flags |= 8192;
          else if (shouldRemainOnPreviousScreen())
            workInProgress2.flags |= 8192;
          else
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      } else
        workInProgress2.flags &= -16777217;
    }
    function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
      if (mayResourceSuspendCommit(resource)) {
        if (workInProgress2.flags |= 16777216, !preloadResource(resource))
          if (shouldRemainOnPreviousScreen())
            workInProgress2.flags |= 8192;
          else
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      } else
        workInProgress2.flags &= -16777217;
    }
    function scheduleRetryEffect(workInProgress2, retryQueue) {
      retryQueue !== null && (workInProgress2.flags |= 4);
      workInProgress2.flags & 16384 && (retryQueue = workInProgress2.tag !== 22 ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
    }
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!isHydrating)
        switch (renderState.tailMode) {
          case "hidden":
            hasRenderedATailFallback = renderState.tail;
            for (var lastTailNode = null;hasRenderedATailFallback !== null; )
              hasRenderedATailFallback.alternate !== null && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
            lastTailNode === null ? renderState.tail = null : lastTailNode.sibling = null;
            break;
          case "collapsed":
            lastTailNode = renderState.tail;
            for (var _lastTailNode = null;lastTailNode !== null; )
              lastTailNode.alternate !== null && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
            _lastTailNode === null ? hasRenderedATailFallback || renderState.tail === null ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
        }
    }
    function bubbleProperties(completedWork) {
      var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
      if (didBailout)
        if ((completedWork.mode & 2) !== NoMode) {
          for (var { selfBaseDuration: _treeBaseDuration, child: _child2 } = completedWork;_child2 !== null; )
            newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65011712, subtreeFlags |= _child2.flags & 65011712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
          completedWork.treeBaseDuration = _treeBaseDuration;
        } else
          for (_treeBaseDuration = completedWork.child;_treeBaseDuration !== null; )
            newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712, subtreeFlags |= _treeBaseDuration.flags & 65011712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
      else if ((completedWork.mode & 2) !== NoMode) {
        _treeBaseDuration = completedWork.actualDuration;
        _child2 = completedWork.selfBaseDuration;
        for (var child = completedWork.child;child !== null; )
          newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
        completedWork.actualDuration = _treeBaseDuration;
        completedWork.treeBaseDuration = _child2;
      } else
        for (_treeBaseDuration = completedWork.child;_treeBaseDuration !== null; )
          newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
      completedWork.subtreeFlags |= subtreeFlags;
      completedWork.childLanes = newChildLanes;
      return didBailout;
    }
    function completeWork(current2, workInProgress2, renderLanes2) {
      var newProps = workInProgress2.pendingProps;
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return bubbleProperties(workInProgress2), null;
        case 1:
          return bubbleProperties(workInProgress2), null;
        case 3:
          renderLanes2 = workInProgress2.stateNode;
          newProps = null;
          current2 !== null && (newProps = current2.memoizedState.cache);
          workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
          popProvider(CacheContext, workInProgress2);
          popHostContainer(workInProgress2);
          renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
          if (current2 === null || current2.child === null)
            popHydrationState(workInProgress2) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress2)) : current2 === null || current2.memoizedState.isDehydrated && (workInProgress2.flags & 256) === 0 || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
          updateHostContainer(current2, workInProgress2);
          bubbleProperties(workInProgress2);
          return null;
        case 26:
          if (supportsResources) {
            var { type, memoizedState: nextResource } = workInProgress2;
            current2 === null ? (markUpdate(workInProgress2), nextResource !== null ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(workInProgress2, type, null, newProps, renderLanes2))) : nextResource ? nextResource !== current2.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (nextResource = current2.memoizedProps, supportsMutation ? nextResource !== newProps && markUpdate(workInProgress2) : updateHostComponent(current2, workInProgress2, type, newProps), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(workInProgress2, type, nextResource, newProps, renderLanes2));
            return null;
          }
        case 27:
          if (supportsSingletons) {
            popHostContext(workInProgress2);
            renderLanes2 = requiredContext(rootInstanceStackCursor.current);
            type = workInProgress2.type;
            if (current2 !== null && workInProgress2.stateNode != null)
              supportsMutation ? current2.memoizedProps !== newProps && markUpdate(workInProgress2) : updateHostComponent(current2, workInProgress2, type, newProps);
            else {
              if (!newProps) {
                if (workInProgress2.stateNode === null)
                  throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                bubbleProperties(workInProgress2);
                return null;
              }
              current2 = getHostContext();
              popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current2) : (current2 = resolveSingletonInstance(type, newProps, renderLanes2, current2, true), workInProgress2.stateNode = current2, markUpdate(workInProgress2));
            }
            bubbleProperties(workInProgress2);
            return null;
          }
        case 5:
          popHostContext(workInProgress2);
          type = workInProgress2.type;
          if (current2 !== null && workInProgress2.stateNode != null)
            updateHostComponent(current2, workInProgress2, type, newProps);
          else {
            if (!newProps) {
              if (workInProgress2.stateNode === null)
                throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              bubbleProperties(workInProgress2);
              return null;
            }
            nextResource = getHostContext();
            if (popHydrationState(workInProgress2))
              prepareToHydrateHostInstance(workInProgress2, nextResource), finalizeHydratedChildren(workInProgress2.stateNode, type, newProps, nextResource) && (workInProgress2.flags |= 64);
            else {
              var _rootContainerInstance = requiredContext(rootInstanceStackCursor.current);
              _rootContainerInstance = createInstance(type, newProps, _rootContainerInstance, nextResource, workInProgress2);
              markCloned(workInProgress2);
              appendAllChildren(_rootContainerInstance, workInProgress2, false, false);
              workInProgress2.stateNode = _rootContainerInstance;
              finalizeInitialChildren(_rootContainerInstance, type, newProps, nextResource) && markUpdate(workInProgress2);
            }
          }
          bubbleProperties(workInProgress2);
          preloadInstanceAndSuspendIfNeeded(workInProgress2, workInProgress2.type, current2 === null ? null : current2.memoizedProps, workInProgress2.pendingProps, renderLanes2);
          return null;
        case 6:
          if (current2 && workInProgress2.stateNode != null)
            renderLanes2 = current2.memoizedProps, supportsMutation ? renderLanes2 !== newProps && markUpdate(workInProgress2) : supportsPersistence && (renderLanes2 !== newProps ? (current2 = requiredContext(rootInstanceStackCursor.current), renderLanes2 = getHostContext(), markCloned(workInProgress2), workInProgress2.stateNode = createTextInstance(newProps, current2, renderLanes2, workInProgress2)) : workInProgress2.stateNode = current2.stateNode);
          else {
            if (typeof newProps !== "string" && workInProgress2.stateNode === null)
              throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            current2 = requiredContext(rootInstanceStackCursor.current);
            renderLanes2 = getHostContext();
            if (popHydrationState(workInProgress2)) {
              if (!supportsHydration)
                throw Error("Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
              current2 = workInProgress2.stateNode;
              renderLanes2 = workInProgress2.memoizedProps;
              type = !didSuspendOrErrorDEV;
              newProps = null;
              nextResource = hydrationParentFiber;
              if (nextResource !== null)
                switch (nextResource.tag) {
                  case 3:
                    type && (type = diffHydratedTextForDevWarnings(current2, renderLanes2, newProps), type !== null && (buildHydrationDiffNode(workInProgress2, 0).serverProps = type));
                    break;
                  case 27:
                  case 5:
                    newProps = nextResource.memoizedProps, type && (type = diffHydratedTextForDevWarnings(current2, renderLanes2, newProps), type !== null && (buildHydrationDiffNode(workInProgress2, 0).serverProps = type));
                }
              hydrateTextInstance(current2, renderLanes2, workInProgress2, newProps) || throwOnHydrationMismatch(workInProgress2, true);
            } else
              markCloned(workInProgress2), workInProgress2.stateNode = createTextInstance(newProps, current2, renderLanes2, workInProgress2);
          }
          bubbleProperties(workInProgress2);
          return null;
        case 31:
          renderLanes2 = workInProgress2.memoizedState;
          if (current2 === null || current2.memoizedState !== null) {
            newProps = popHydrationState(workInProgress2);
            if (renderLanes2 !== null) {
              if (current2 === null) {
                if (!newProps)
                  throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                if (!supportsHydration)
                  throw Error("Expected prepareToHydrateHostActivityInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
                current2 = workInProgress2.memoizedState;
                current2 = current2 !== null ? current2.dehydrated : null;
                if (!current2)
                  throw Error("Expected to have a hydrated activity instance. This error is likely caused by a bug in React. Please file an issue.");
                hydrateActivityInstance(current2, workInProgress2);
                bubbleProperties(workInProgress2);
                (workInProgress2.mode & 2) !== NoMode && renderLanes2 !== null && (current2 = workInProgress2.child, current2 !== null && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
              } else
                emitPendingHydrationWarnings(), resetHydrationState(), (workInProgress2.flags & 128) === 0 && (renderLanes2 = workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & 2) !== NoMode && renderLanes2 !== null && (current2 = workInProgress2.child, current2 !== null && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
              current2 = false;
            } else
              renderLanes2 = upgradeHydrationErrorsToRecoverable(), current2 !== null && current2.memoizedState !== null && (current2.memoizedState.hydrationErrors = renderLanes2), current2 = true;
            if (!current2) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
            if ((workInProgress2.flags & 128) !== 0)
              throw Error("Client rendering an Activity suspended it again. This is a bug in React.");
          }
          bubbleProperties(workInProgress2);
          return null;
        case 13:
          newProps = workInProgress2.memoizedState;
          if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
            type = newProps;
            nextResource = popHydrationState(workInProgress2);
            if (type !== null && type.dehydrated !== null) {
              if (current2 === null) {
                if (!nextResource)
                  throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                if (!supportsHydration)
                  throw Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
                nextResource = workInProgress2.memoizedState;
                nextResource = nextResource !== null ? nextResource.dehydrated : null;
                if (!nextResource)
                  throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
                hydrateSuspenseInstance(nextResource, workInProgress2);
                bubbleProperties(workInProgress2);
                (workInProgress2.mode & 2) !== NoMode && type !== null && (type = workInProgress2.child, type !== null && (workInProgress2.treeBaseDuration -= type.treeBaseDuration));
              } else
                emitPendingHydrationWarnings(), resetHydrationState(), (workInProgress2.flags & 128) === 0 && (type = workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & 2) !== NoMode && type !== null && (type = workInProgress2.child, type !== null && (workInProgress2.treeBaseDuration -= type.treeBaseDuration));
              type = false;
            } else
              type = upgradeHydrationErrorsToRecoverable(), current2 !== null && current2.memoizedState !== null && (current2.memoizedState.hydrationErrors = type), type = true;
            if (!type) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
          }
          popSuspenseHandler(workInProgress2);
          if ((workInProgress2.flags & 128) !== 0)
            return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & 2) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
          renderLanes2 = newProps !== null;
          current2 = current2 !== null && current2.memoizedState !== null;
          renderLanes2 && (newProps = workInProgress2.child, type = null, newProps.alternate !== null && newProps.alternate.memoizedState !== null && newProps.alternate.memoizedState.cachePool !== null && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, newProps.memoizedState !== null && newProps.memoizedState.cachePool !== null && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
          renderLanes2 !== current2 && renderLanes2 && (workInProgress2.child.flags |= 8192);
          scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
          bubbleProperties(workInProgress2);
          (workInProgress2.mode & 2) !== NoMode && renderLanes2 && (current2 = workInProgress2.child, current2 !== null && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
          return null;
        case 4:
          return popHostContainer(workInProgress2), updateHostContainer(current2, workInProgress2), current2 === null && preparePortalMount(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
        case 10:
          return popProvider(workInProgress2.type, workInProgress2), bubbleProperties(workInProgress2), null;
        case 19:
          pop(suspenseStackCursor, workInProgress2);
          newProps = workInProgress2.memoizedState;
          if (newProps === null)
            return bubbleProperties(workInProgress2), null;
          type = (workInProgress2.flags & 128) !== 0;
          nextResource = newProps.rendering;
          if (nextResource === null)
            if (type)
              cutOffTailIfNeeded(newProps, false);
            else {
              if (workInProgressRootExitStatus !== RootInProgress || current2 !== null && (current2.flags & 128) !== 0)
                for (current2 = workInProgress2.child;current2 !== null; ) {
                  nextResource = findFirstSuspended(current2);
                  if (nextResource !== null) {
                    workInProgress2.flags |= 128;
                    cutOffTailIfNeeded(newProps, false);
                    current2 = nextResource.updateQueue;
                    workInProgress2.updateQueue = current2;
                    scheduleRetryEffect(workInProgress2, current2);
                    workInProgress2.subtreeFlags = 0;
                    current2 = renderLanes2;
                    for (renderLanes2 = workInProgress2.child;renderLanes2 !== null; )
                      resetWorkInProgress(renderLanes2, current2), renderLanes2 = renderLanes2.sibling;
                    push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2);
                    isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                    return workInProgress2.child;
                  }
                  current2 = current2.sibling;
                }
              newProps.tail !== null && now$1() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
            }
          else {
            if (!type)
              if (current2 = findFirstSuspended(nextResource), current2 !== null) {
                if (workInProgress2.flags |= 128, type = true, current2 = current2.updateQueue, workInProgress2.updateQueue = current2, scheduleRetryEffect(workInProgress2, current2), cutOffTailIfNeeded(newProps, true), newProps.tail === null && newProps.tailMode === "hidden" && !nextResource.alternate && !isHydrating)
                  return bubbleProperties(workInProgress2), null;
              } else
                2 * now$1() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && renderLanes2 !== 536870912 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
            newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current2 = newProps.last, current2 !== null ? current2.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
          }
          if (newProps.tail !== null)
            return current2 = newProps.tail, newProps.rendering = current2, newProps.tail = current2.sibling, newProps.renderingStartTime = now$1(), current2.sibling = null, renderLanes2 = suspenseStackCursor.current, renderLanes2 = type ? renderLanes2 & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes2 & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes2, workInProgress2), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current2;
          bubbleProperties(workInProgress2);
          return null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), newProps = workInProgress2.memoizedState !== null, current2 !== null ? current2.memoizedState !== null !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? (renderLanes2 & 536870912) !== 0 && (workInProgress2.flags & 128) === 0 && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, renderLanes2 !== null && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, current2 !== null && current2.memoizedState !== null && current2.memoizedState.cachePool !== null && (renderLanes2 = current2.memoizedState.cachePool.pool), newProps = null, workInProgress2.memoizedState !== null && workInProgress2.memoizedState.cachePool !== null && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), current2 !== null && pop(resumedCache, workInProgress2), null;
        case 24:
          return renderLanes2 = null, current2 !== null && (renderLanes2 = current2.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext, workInProgress2), bubbleProperties(workInProgress2), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function unwindWork(current2, workInProgress2) {
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 1:
          return current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & 2) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
        case 3:
          return popProvider(CacheContext, workInProgress2), popHostContainer(workInProgress2), current2 = workInProgress2.flags, (current2 & 65536) !== 0 && (current2 & 128) === 0 ? (workInProgress2.flags = current2 & -65537 | 128, workInProgress2) : null;
        case 26:
        case 27:
        case 5:
          return popHostContext(workInProgress2), null;
        case 31:
          if (workInProgress2.memoizedState !== null) {
            popSuspenseHandler(workInProgress2);
            if (workInProgress2.alternate === null)
              throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            resetHydrationState();
          }
          current2 = workInProgress2.flags;
          return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & 2) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
        case 13:
          popSuspenseHandler(workInProgress2);
          current2 = workInProgress2.memoizedState;
          if (current2 !== null && current2.dehydrated !== null) {
            if (workInProgress2.alternate === null)
              throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            resetHydrationState();
          }
          current2 = workInProgress2.flags;
          return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & 2) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
        case 19:
          return pop(suspenseStackCursor, workInProgress2), null;
        case 4:
          return popHostContainer(workInProgress2), null;
        case 10:
          return popProvider(workInProgress2.type, workInProgress2), null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), current2 !== null && pop(resumedCache, workInProgress2), current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & 2) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
        case 24:
          return popProvider(CacheContext, workInProgress2), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function unwindInterruptedWork(current2, interruptedWork) {
      popTreeContext(interruptedWork);
      switch (interruptedWork.tag) {
        case 3:
          popProvider(CacheContext, interruptedWork);
          popHostContainer(interruptedWork);
          break;
        case 26:
        case 27:
        case 5:
          popHostContext(interruptedWork);
          break;
        case 4:
          popHostContainer(interruptedWork);
          break;
        case 31:
          interruptedWork.memoizedState !== null && popSuspenseHandler(interruptedWork);
          break;
        case 13:
          popSuspenseHandler(interruptedWork);
          break;
        case 19:
          pop(suspenseStackCursor, interruptedWork);
          break;
        case 10:
          popProvider(interruptedWork.type, interruptedWork);
          break;
        case 22:
        case 23:
          popSuspenseHandler(interruptedWork);
          popHiddenContext(interruptedWork);
          current2 !== null && pop(resumedCache, interruptedWork);
          break;
        case 24:
          popProvider(CacheContext, interruptedWork);
      }
    }
    function shouldProfile(current2) {
      return (current2.mode & 2) !== NoMode;
    }
    function commitHookLayoutEffects(finishedWork, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
    }
    function commitHookEffectListMount(flags, finishedWork) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags && (lastEffect = undefined, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = runWithFiberInDEV(finishedWork, callCreateInDEV, updateQueue), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), lastEffect !== undefined && typeof lastEffect !== "function")) {
              var hookName = undefined;
              hookName = (updateQueue.tag & Layout) !== 0 ? "useLayoutEffect" : (updateQueue.tag & Insertion) !== 0 ? "useInsertionEffect" : "useEffect";
              var addendum = undefined;
              addendum = lastEffect === null ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof lastEffect.then === "function" ? `

It looks like you wrote ` + hookName + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + hookName + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching` : " You returned: " + lastEffect;
              runWithFiberInDEV(finishedWork, function(n, a) {
                console.error("%s must not return anything besides a function, which is used for clean-up.%s", n, a);
              }, hookName, addendum);
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              var inst = updateQueue.inst, destroy = inst.destroy;
              destroy !== undefined && (inst.destroy = undefined, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = finishedWork, runWithFiberInDEV(lastEffect, callDestroyInDEV, lastEffect, nearestMountedAncestor, destroy), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false));
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookPassiveMountEffects(finishedWork, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
    }
    function commitClassCallbacks(finishedWork) {
      var updateQueue = finishedWork.updateQueue;
      if (updateQueue !== null) {
        var instance = finishedWork.stateNode;
        finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), instance.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
        try {
          runWithFiberInDEV(finishedWork, commitCallbacks, updateQueue, instance);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
      return instance.getSnapshotBeforeUpdate(prevProps, prevState);
    }
    function commitClassSnapshot(finishedWork, current2) {
      var { memoizedProps: prevProps, memoizedState: prevState } = current2;
      current2 = finishedWork.stateNode;
      finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current2.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), current2.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
      try {
        var resolvedPrevProps = resolveClassComponentProps(finishedWork.type, prevProps);
        var snapshot = runWithFiberInDEV(finishedWork, callGetSnapshotBeforeUpdates, current2, resolvedPrevProps, prevState);
        prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
        snapshot !== undefined || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {
          console.error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
        }));
        current2.__reactInternalSnapshotBeforeUpdate = snapshot;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
      instance.props = resolveClassComponentProps(current2.type, current2.memoizedProps);
      instance.state = current2.memoizedState;
      shouldProfile(current2) ? (startEffectTimer(), runWithFiberInDEV(current2, callComponentWillUnmountInDEV, current2, nearestMountedAncestor, instance), recordEffectDuration()) : runWithFiberInDEV(current2, callComponentWillUnmountInDEV, current2, nearestMountedAncestor, instance);
    }
    function commitAttachRef(finishedWork) {
      var ref = finishedWork.ref;
      if (ref !== null) {
        switch (finishedWork.tag) {
          case 26:
          case 27:
          case 5:
            var instanceToUse = getPublicInstance(finishedWork.stateNode);
            break;
          case 30:
            instanceToUse = finishedWork.stateNode;
            break;
          default:
            instanceToUse = finishedWork.stateNode;
        }
        if (typeof ref === "function")
          if (shouldProfile(finishedWork))
            try {
              startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);
            } finally {
              recordEffectDuration();
            }
          else
            finishedWork.refCleanup = ref(instanceToUse);
        else
          typeof ref === "string" ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork)), ref.current = instanceToUse;
      }
    }
    function safelyAttachRef(current2, nearestMountedAncestor) {
      try {
        runWithFiberInDEV(current2, commitAttachRef, current2);
      } catch (error) {
        captureCommitPhaseError(current2, nearestMountedAncestor, error);
      }
    }
    function safelyDetachRef(current2, nearestMountedAncestor) {
      var { ref, refCleanup } = current2;
      if (ref !== null)
        if (typeof refCleanup === "function")
          try {
            if (shouldProfile(current2))
              try {
                startEffectTimer(), runWithFiberInDEV(current2, refCleanup);
              } finally {
                recordEffectDuration(current2);
              }
            else
              runWithFiberInDEV(current2, refCleanup);
          } catch (error) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error);
          } finally {
            current2.refCleanup = null, current2 = current2.alternate, current2 != null && (current2.refCleanup = null);
          }
        else if (typeof ref === "function")
          try {
            if (shouldProfile(current2))
              try {
                startEffectTimer(), runWithFiberInDEV(current2, ref, null);
              } finally {
                recordEffectDuration(current2);
              }
            else
              runWithFiberInDEV(current2, ref, null);
          } catch (error$3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error$3);
          }
        else
          ref.current = null;
    }
    function commitProfiler(finishedWork, current2, commitStartTime2, effectDuration) {
      var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;
      _finishedWork$memoize = _finishedWork$memoize.onRender;
      current2 = current2 === null ? "mount" : "update";
      currentUpdateIsNested && (current2 = "nested-update");
      typeof _finishedWork$memoize === "function" && _finishedWork$memoize(id, current2, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitStartTime2);
      typeof onCommit === "function" && onCommit(id, current2, effectDuration, commitStartTime2);
    }
    function commitProfilerPostCommitImpl(finishedWork, current2, commitStartTime2, passiveEffectDuration) {
      var _finishedWork$memoize2 = finishedWork.memoizedProps;
      finishedWork = _finishedWork$memoize2.id;
      _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
      current2 = current2 === null ? "mount" : "update";
      currentUpdateIsNested && (current2 = "nested-update");
      typeof _finishedWork$memoize2 === "function" && _finishedWork$memoize2(finishedWork, current2, passiveEffectDuration, commitStartTime2);
    }
    function commitHostMount(finishedWork) {
      var { type, memoizedProps: props, stateNode: instance } = finishedWork;
      try {
        runWithFiberInDEV(finishedWork, commitMount, instance, type, props, finishedWork);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHostUpdate(finishedWork, newProps, oldProps) {
      try {
        runWithFiberInDEV(finishedWork, commitUpdate, finishedWork.stateNode, finishedWork.type, oldProps, newProps, finishedWork);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHostParent(fiber) {
      return fiber.tag === 5 || fiber.tag === 3 || (supportsResources ? fiber.tag === 26 : false) || (supportsSingletons ? fiber.tag === 27 && isSingletonScope(fiber.type) : false) || fiber.tag === 4;
    }
    function getHostSibling(fiber) {
      a:
        for (;; ) {
          for (;fiber.sibling === null; ) {
            if (fiber.return === null || isHostParent(fiber.return))
              return null;
            fiber = fiber.return;
          }
          fiber.sibling.return = fiber.return;
          for (fiber = fiber.sibling;fiber.tag !== 5 && fiber.tag !== 6 && fiber.tag !== 18; ) {
            if (supportsSingletons && fiber.tag === 27 && isSingletonScope(fiber.type))
              continue a;
            if (fiber.flags & 2)
              continue a;
            if (fiber.child === null || fiber.tag === 4)
              continue a;
            else
              fiber.child.return = fiber, fiber = fiber.child;
          }
          if (!(fiber.flags & 2))
            return fiber.stateNode;
        }
    }
    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
      var tag = node.tag;
      if (tag === 5 || tag === 6)
        node = node.stateNode, before ? insertInContainerBefore(parent, node, before) : appendChildToContainer(parent, node);
      else if (tag !== 4 && (supportsSingletons && tag === 27 && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, node !== null))
        for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;node !== null; )
          insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
    }
    function insertOrAppendPlacementNode(node, before, parent) {
      var tag = node.tag;
      if (tag === 5 || tag === 6)
        node = node.stateNode, before ? insertBefore(parent, node, before) : appendChild(parent, node);
      else if (tag !== 4 && (supportsSingletons && tag === 27 && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, node !== null))
        for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling;node !== null; )
          insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
    }
    function commitPlacement(finishedWork) {
      for (var hostParentFiber, parentFiber = finishedWork.return;parentFiber !== null; ) {
        if (isHostParent(parentFiber)) {
          hostParentFiber = parentFiber;
          break;
        }
        parentFiber = parentFiber.return;
      }
      if (supportsMutation) {
        if (hostParentFiber == null)
          throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        switch (hostParentFiber.tag) {
          case 27:
            if (supportsSingletons) {
              hostParentFiber = hostParentFiber.stateNode;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, parentFiber, hostParentFiber);
              break;
            }
          case 5:
            parentFiber = hostParentFiber.stateNode;
            hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);
            hostParentFiber = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, hostParentFiber, parentFiber);
            break;
          case 3:
          case 4:
            hostParentFiber = hostParentFiber.stateNode.containerInfo;
            parentFiber = getHostSibling(finishedWork);
            insertOrAppendPlacementNodeIntoContainer(finishedWork, parentFiber, hostParentFiber);
            break;
          default:
            throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
    }
    function commitHostPortalContainerChildren(portal, finishedWork, pendingChildren) {
      portal = portal.containerInfo;
      try {
        runWithFiberInDEV(finishedWork, replaceContainerChildren, portal, pendingChildren);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHostSingletonAcquisition(finishedWork) {
      var { stateNode: singleton, memoizedProps: props } = finishedWork;
      try {
        runWithFiberInDEV(finishedWork, acquireSingletonInstance, finishedWork.type, props, singleton, finishedWork);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHydratingParent(current2, finishedWork) {
      return finishedWork.tag === 31 ? (finishedWork = finishedWork.memoizedState, current2.memoizedState !== null && finishedWork === null) : finishedWork.tag === 13 ? (current2 = current2.memoizedState, finishedWork = finishedWork.memoizedState, current2 !== null && current2.dehydrated !== null && (finishedWork === null || finishedWork.dehydrated === null)) : finishedWork.tag === 3 ? current2.memoizedState.isDehydrated && (finishedWork.flags & 256) === 0 : false;
    }
    function commitBeforeMutationEffects(root, firstChild) {
      prepareForCommit(root.containerInfo);
      for (nextEffect = firstChild;nextEffect !== null; )
        if (root = nextEffect, firstChild = root.child, (root.subtreeFlags & 1028) !== 0 && firstChild !== null)
          firstChild.return = root, nextEffect = firstChild;
        else
          for (;nextEffect !== null; ) {
            firstChild = root = nextEffect;
            var { alternate: current2, flags } = firstChild;
            switch (firstChild.tag) {
              case 0:
                if ((flags & 4) !== 0 && (firstChild = firstChild.updateQueue, firstChild = firstChild !== null ? firstChild.events : null, firstChild !== null))
                  for (current2 = 0;current2 < firstChild.length; current2++)
                    flags = firstChild[current2], flags.ref.impl = flags.nextImpl;
                break;
              case 11:
              case 15:
                break;
              case 1:
                (flags & 1024) !== 0 && current2 !== null && commitClassSnapshot(firstChild, current2);
                break;
              case 3:
                (flags & 1024) !== 0 && supportsMutation && clearContainer(firstChild.stateNode.containerInfo);
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if ((flags & 1024) !== 0)
                  throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
            firstChild = root.sibling;
            if (firstChild !== null) {
              firstChild.return = root.return;
              nextEffect = firstChild;
              break;
            }
            nextEffect = root.return;
          }
    }
    function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
          break;
        case 1:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 4)
            if (finishedRoot = finishedWork.stateNode, current2 === null)
              finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), finishedRoot.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance")), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot);
            else {
              var prevProps = resolveClassComponentProps(finishedWork.type, current2.memoizedProps);
              current2 = current2.memoizedState;
              finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), finishedRoot.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
              shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current2, finishedRoot.__reactInternalSnapshotBeforeUpdate), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current2, finishedRoot.__reactInternalSnapshotBeforeUpdate);
            }
          flags & 64 && commitClassCallbacks(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 3:
          current2 = pushNestedEffectDurations();
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 64 && (flags = finishedWork.updateQueue, flags !== null)) {
            prevProps = null;
            if (finishedWork.child !== null)
              switch (finishedWork.child.tag) {
                case 27:
                case 5:
                  prevProps = getPublicInstance(finishedWork.child.stateNode);
                  break;
                case 1:
                  prevProps = finishedWork.child.stateNode;
              }
            try {
              runWithFiberInDEV(finishedWork, commitCallbacks, flags, prevProps);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          finishedRoot.effectDuration += popNestedEffectDurations(current2);
          break;
        case 27:
          supportsSingletons && current2 === null && flags & 4 && commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (current2 === null) {
            if (flags & 4)
              commitHostMount(finishedWork);
            else if (flags & 64) {
              finishedRoot = finishedWork.type;
              current2 = finishedWork.memoizedProps;
              prevProps = finishedWork.stateNode;
              try {
                runWithFiberInDEV(finishedWork, commitHydratedInstance, prevProps, finishedRoot, current2, finishedWork);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
          }
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          if (flags & 4) {
            flags = pushNestedEffectDurations();
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            finishedRoot = finishedWork.stateNode;
            finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current2, commitStartTime, finishedRoot.effectDuration);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          break;
        case 31:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          flags & 64 && (finishedRoot = finishedWork.memoizedState, finishedRoot !== null && (finishedRoot = finishedRoot.dehydrated, finishedRoot !== null && (flags = retryDehydratedSuspenseBoundary.bind(null, finishedWork), registerSuspenseInstanceRetry(finishedRoot, flags))));
          break;
        case 22:
          flags = finishedWork.memoizedState !== null || offscreenSubtreeIsHidden;
          if (!flags) {
            current2 = current2 !== null && current2.memoizedState !== null || offscreenSubtreeWasHidden;
            prevProps = offscreenSubtreeIsHidden;
            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = flags;
            (offscreenSubtreeWasHidden = current2) && !prevOffscreenSubtreeWasHidden ? (recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, (finishedWork.subtreeFlags & 8772) !== 0), (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(finishedWork, componentEffectStartTime, componentEffectEndTime)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            offscreenSubtreeIsHidden = prevProps;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          }
          break;
        case 30:
          break;
        default:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      }
      (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors), finishedWork.alternate === null && finishedWork.return !== null && finishedWork.return.alternate !== null && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(finishedWork.return.alternate, finishedWork.return) || logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, "Mount")));
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function detachFiberAfterEffects(fiber) {
      var alternate = fiber.alternate;
      alternate !== null && (fiber.alternate = null, detachFiberAfterEffects(alternate));
      fiber.child = null;
      fiber.deletions = null;
      fiber.sibling = null;
      fiber.tag === 5 && (alternate = fiber.stateNode, alternate !== null && detachDeletedInstance(alternate));
      fiber.stateNode = null;
      fiber._debugOwner = null;
      fiber.return = null;
      fiber.dependencies = null;
      fiber.memoizedProps = null;
      fiber.memoizedState = null;
      fiber.pendingProps = null;
      fiber.stateNode = null;
      fiber.updateQueue = null;
    }
    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
      for (parent = parent.child;parent !== null; )
        commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
    }
    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
      if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function")
        try {
          injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
        } catch (err) {
          hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %o", err));
        }
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
      switch (deletedFiber.tag) {
        case 26:
          if (supportsResources) {
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            deletedFiber.memoizedState ? releaseResource(deletedFiber.memoizedState) : deletedFiber.stateNode && unmountHoistable(deletedFiber.stateNode);
            break;
          }
        case 27:
          if (supportsSingletons) {
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
            isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            runWithFiberInDEV(deletedFiber, releaseSingletonInstance, deletedFiber.stateNode);
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          }
        case 5:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        case 6:
          if (supportsMutation) {
            if (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = null, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer, hostParent !== null)
              if (hostParentIsContainer)
                try {
                  runWithFiberInDEV(deletedFiber, removeChildFromContainer, hostParent, deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
                }
              else
                try {
                  runWithFiberInDEV(deletedFiber, removeChild, hostParent, deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
                }
          } else
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        case 18:
          supportsMutation && hostParent !== null && (hostParentIsContainer ? clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
          break;
        case 4:
          supportsMutation ? (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = deletedFiber.stateNode.containerInfo, hostParentIsContainer = true, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer) : (supportsPersistence && commitHostPortalContainerChildren(deletedFiber.stateNode, deletedFiber, createContainerChildSet()), recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber));
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookEffectListUnmount(Insertion, deletedFiber, nearestMountedAncestor);
          offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(deletedFiber, nearestMountedAncestor, Layout);
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        case 1:
          offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, typeof prevHostParent.componentWillUnmount === "function" && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        case 21:
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        case 22:
          offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || deletedFiber.memoizedState !== null;
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          offscreenSubtreeWasHidden = prevHostParent;
          break;
        default:
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      }
      (deletedFiber.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(deletedFiber, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
      if (supportsHydration && finishedWork.memoizedState === null && (finishedRoot = finishedWork.alternate, finishedRoot !== null && (finishedRoot = finishedRoot.memoizedState, finishedRoot !== null))) {
        finishedRoot = finishedRoot.dehydrated;
        try {
          runWithFiberInDEV(finishedWork, commitHydratedActivityInstance, finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      if (supportsHydration && finishedWork.memoizedState === null && (finishedRoot = finishedWork.alternate, finishedRoot !== null && (finishedRoot = finishedRoot.memoizedState, finishedRoot !== null && (finishedRoot = finishedRoot.dehydrated, finishedRoot !== null))))
        try {
          runWithFiberInDEV(finishedWork, commitHydratedSuspenseInstance, finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function getRetryCache(finishedWork) {
      switch (finishedWork.tag) {
        case 31:
        case 13:
        case 19:
          var retryCache = finishedWork.stateNode;
          retryCache === null && (retryCache = finishedWork.stateNode = new PossiblyWeakSet);
          return retryCache;
        case 22:
          return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, retryCache === null && (retryCache = finishedWork._retryCache = new PossiblyWeakSet), retryCache;
        default:
          throw Error("Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React.");
      }
    }
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
      var retryCache = getRetryCache(finishedWork);
      wakeables.forEach(function(wakeable) {
        if (!retryCache.has(wakeable)) {
          retryCache.add(wakeable);
          if (isDevToolsPresent)
            if (inProgressLanes !== null && inProgressRoot !== null)
              restorePendingUpdaters(inProgressRoot, inProgressLanes);
            else
              throw Error("Expected finished root and lanes to be set. This is a bug in React.");
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          wakeable.then(retry, retry);
        }
      });
    }
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
      var deletions = parentFiber.deletions;
      if (deletions !== null)
        for (var i = 0;i < deletions.length; i++) {
          var root = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i], prevEffectStart = pushComponentEffectStart();
          if (supportsMutation) {
            var parent = returnFiber;
            a:
              for (;parent !== null; ) {
                switch (parent.tag) {
                  case 27:
                    if (supportsSingletons) {
                      if (isSingletonScope(parent.type)) {
                        hostParent = parent.stateNode;
                        hostParentIsContainer = false;
                        break a;
                      }
                      break;
                    }
                  case 5:
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  case 3:
                  case 4:
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break a;
                }
                parent = parent.return;
              }
            if (hostParent === null)
              throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
            commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
            hostParent = null;
            hostParentIsContainer = false;
          } else
            commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
          (deletedFiber.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(deletedFiber, componentEffectStartTime, componentEffectEndTime, "Unmount");
          popComponentEffectStart(prevEffectStart);
          root = deletedFiber;
          returnFiber = root.alternate;
          returnFiber !== null && (returnFiber.return = null);
          root.return = null;
        }
      if (parentFiber.subtreeFlags & 13886)
        for (parentFiber = parentFiber.child;parentFiber !== null; )
          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
    }
    function commitMutationEffectsOnFiber(finishedWork, root) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), current2 = finishedWork.alternate, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout | HasEffect));
          break;
        case 1:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || current2 === null || safelyDetachRef(current2, current2.return));
          flags & 64 && offscreenSubtreeIsHidden && (flags = finishedWork.updateQueue, flags !== null && (current2 = flags.callbacks, current2 !== null && (root = flags.shared.hiddenCallbacks, flags.shared.hiddenCallbacks = root === null ? current2 : root.concat(current2))));
          break;
        case 26:
          if (supportsResources) {
            var hoistableRoot = currentHoistableRoot;
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || current2 === null || safelyDetachRef(current2, current2.return));
            flags & 4 && (flags = current2 !== null ? current2.memoizedState : null, root = finishedWork.memoizedState, current2 === null ? root === null ? finishedWork.stateNode === null ? finishedWork.stateNode = hydrateHoistable(hoistableRoot, finishedWork.type, finishedWork.memoizedProps, finishedWork) : mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : finishedWork.stateNode = acquireResource(hoistableRoot, root, finishedWork.memoizedProps) : flags !== root ? (flags === null ? current2.stateNode !== null && unmountHoistable(current2.stateNode) : releaseResource(flags), root === null ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, root, finishedWork.memoizedProps)) : root === null && finishedWork.stateNode !== null && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current2.memoizedProps));
            break;
          }
        case 27:
          if (supportsSingletons) {
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || current2 === null || safelyDetachRef(current2, current2.return));
            current2 !== null && flags & 4 && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current2.memoizedProps);
            break;
          }
        case 5:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || current2 === null || safelyDetachRef(current2, current2.return));
          if (supportsMutation) {
            if (finishedWork.flags & 32) {
              root = finishedWork.stateNode;
              try {
                runWithFiberInDEV(finishedWork, resetTextContent, root);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            flags & 4 && finishedWork.stateNode != null && (root = finishedWork.memoizedProps, commitHostUpdate(finishedWork, root, current2 !== null ? current2.memoizedProps : root));
            flags & 1024 && (needsFormReset = true, finishedWork.type !== "form" && console.error("Unexpected host component type. Expected a form. This is a bug in React."));
          } else
            supportsPersistence && finishedWork.alternate !== null && (finishedWork.alternate.stateNode = finishedWork.stateNode);
          break;
        case 6:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4 && supportsMutation) {
            if (finishedWork.stateNode === null)
              throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            flags = finishedWork.memoizedProps;
            current2 = current2 !== null ? current2.memoizedProps : flags;
            root = finishedWork.stateNode;
            try {
              runWithFiberInDEV(finishedWork, commitTextUpdate, root, current2, flags);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 3:
          hoistableRoot = pushNestedEffectDurations();
          if (supportsResources) {
            prepareToCommitHoistables();
            var previousHoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(root.containerInfo);
            recursivelyTraverseMutationEffects(root, finishedWork);
            currentHoistableRoot = previousHoistableRoot;
          } else
            recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4) {
            if (supportsMutation && supportsHydration && current2 !== null && current2.memoizedState.isDehydrated)
              try {
                runWithFiberInDEV(finishedWork, commitHydratedContainer, root.containerInfo);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            if (supportsPersistence) {
              flags = root.containerInfo;
              current2 = root.pendingChildren;
              try {
                runWithFiberInDEV(finishedWork, replaceContainerChildren, flags, current2);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
          }
          needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
          root.effectDuration += popNestedEffectDurations(hoistableRoot);
          break;
        case 4:
          supportsResources ? (current2 = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo), recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), currentHoistableRoot = current2) : (recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork));
          flags & 4 && supportsPersistence && commitHostPortalContainerChildren(finishedWork.stateNode, finishedWork, finishedWork.stateNode.pendingChildren);
          break;
        case 12:
          flags = pushNestedEffectDurations();
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
          break;
        case 31:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, flags !== null && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 13:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.child.flags & 8192 && finishedWork.memoizedState !== null !== (current2 !== null && current2.memoizedState !== null) && (globalMostRecentFallbackTime = now$1());
          flags & 4 && (flags = finishedWork.updateQueue, flags !== null && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 22:
          hoistableRoot = finishedWork.memoizedState !== null;
          var wasHidden = current2 !== null && current2.memoizedState !== null, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
          recursivelyTraverseMutationEffects(root, finishedWork);
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
          wasHidden && !hoistableRoot && !prevOffscreenSubtreeIsHidden && !prevOffscreenSubtreeWasHidden && (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(finishedWork, componentEffectStartTime, componentEffectEndTime);
          commitReconciliationEffects(finishedWork);
          if (flags & 8192 && (root = finishedWork.stateNode, root._visibility = hoistableRoot ? root._visibility & ~OffscreenVisible : root._visibility | OffscreenVisible, !hoistableRoot || current2 === null || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || (recursivelyTraverseDisappearLayoutEffects(finishedWork), (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, "Disconnect")), supportsMutation))
            a:
              if (current2 = null, supportsMutation)
                for (root = finishedWork;; ) {
                  if (root.tag === 5 || supportsResources && root.tag === 26) {
                    if (current2 === null) {
                      wasHidden = current2 = root;
                      try {
                        previousHoistableRoot = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideInstance, previousHoistableRoot) : runWithFiberInDEV(wasHidden, unhideInstance, wasHidden.stateNode, wasHidden.memoizedProps);
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (root.tag === 6) {
                    if (current2 === null) {
                      wasHidden = root;
                      try {
                        var instance = wasHidden.stateNode;
                        hoistableRoot ? runWithFiberInDEV(wasHidden, hideTextInstance, instance) : runWithFiberInDEV(wasHidden, unhideTextInstance, instance, wasHidden.memoizedProps);
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (root.tag === 18) {
                    if (current2 === null) {
                      wasHidden = root;
                      try {
                        var instance$jscomp$0 = wasHidden.stateNode;
                        hoistableRoot ? runWithFiberInDEV(wasHidden, hideDehydratedBoundary, instance$jscomp$0) : runWithFiberInDEV(wasHidden, unhideDehydratedBoundary, wasHidden.stateNode);
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if ((root.tag !== 22 && root.tag !== 23 || root.memoizedState === null || root === finishedWork) && root.child !== null) {
                    root.child.return = root;
                    root = root.child;
                    continue;
                  }
                  if (root === finishedWork)
                    break a;
                  for (;root.sibling === null; ) {
                    if (root.return === null || root.return === finishedWork)
                      break a;
                    current2 === root && (current2 = null);
                    root = root.return;
                  }
                  current2 === root && (current2 = null);
                  root.sibling.return = root.return;
                  root = root.sibling;
                }
          flags & 4 && (flags = finishedWork.updateQueue, flags !== null && (current2 = flags.retryQueue, current2 !== null && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current2))));
          break;
        case 19:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, flags !== null && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);
      }
      (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors), finishedWork.alternate === null && finishedWork.return !== null && finishedWork.return.alternate !== null && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(finishedWork.return.alternate, finishedWork.return) || logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, "Mount")));
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function commitReconciliationEffects(finishedWork) {
      var flags = finishedWork.flags;
      if (flags & 2) {
        try {
          runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        finishedWork.flags &= -3;
      }
      flags & 4096 && (finishedWork.flags &= -4097);
    }
    function recursivelyResetForms(parentFiber) {
      if (parentFiber.subtreeFlags & 1024)
        for (parentFiber = parentFiber.child;parentFiber !== null; ) {
          var fiber = parentFiber;
          recursivelyResetForms(fiber);
          fiber.tag === 5 && fiber.flags & 1024 && resetFormInstance(fiber.stateNode);
          parentFiber = parentFiber.sibling;
        }
    }
    function recursivelyTraverseLayoutEffects(root, parentFiber) {
      if (parentFiber.subtreeFlags & 8772)
        for (parentFiber = parentFiber.child;parentFiber !== null; )
          commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
    }
    function disappearLayoutEffects(finishedWork) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 1:
          safelyDetachRef(finishedWork, finishedWork.return);
          var instance = finishedWork.stateNode;
          typeof instance.componentWillUnmount === "function" && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 27:
          supportsSingletons && runWithFiberInDEV(finishedWork, releaseSingletonInstance, finishedWork.stateNode);
        case 26:
        case 5:
          safelyDetachRef(finishedWork, finishedWork.return);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 22:
          finishedWork.memoizedState === null && recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 30:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        default:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
      }
      (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
      for (parentFiber = parentFiber.child;parentFiber !== null; )
        disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
    }
    function reappearLayoutEffects(finishedRoot, current2, finishedWork, includeWorkInProgressEffects) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          commitHookLayoutEffects(finishedWork, Layout);
          break;
        case 1:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          current2 = finishedWork.stateNode;
          typeof current2.componentDidMount === "function" && runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, current2);
          current2 = finishedWork.updateQueue;
          if (current2 !== null) {
            finishedRoot = finishedWork.stateNode;
            try {
              runWithFiberInDEV(finishedWork, commitHiddenCallbacks, current2, finishedRoot);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 27:
          supportsSingletons && commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          includeWorkInProgressEffects && current2 === null && flags & 4 && commitHostMount(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          if (includeWorkInProgressEffects && flags & 4) {
            flags = pushNestedEffectDurations();
            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
            includeWorkInProgressEffects = finishedWork.stateNode;
            includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current2, commitStartTime, includeWorkInProgressEffects.effectDuration);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          break;
        case 31:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 22:
          finishedWork.memoizedState === null && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 30:
          break;
        default:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
      }
      (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & 8772) !== 0;
      for (parentFiber = parentFiber.child;parentFiber !== null; )
        reappearLayoutEffects(finishedRoot, parentFiber.alternate, parentFiber, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;
    }
    function commitOffscreenPassiveMountEffects(current2, finishedWork) {
      var previousCache = null;
      current2 !== null && current2.memoizedState !== null && current2.memoizedState.cachePool !== null && (previousCache = current2.memoizedState.cachePool.pool);
      current2 = null;
      finishedWork.memoizedState !== null && finishedWork.memoizedState.cachePool !== null && (current2 = finishedWork.memoizedState.cachePool.pool);
      current2 !== previousCache && (current2 != null && retainCache(current2), previousCache != null && releaseCache(previousCache));
    }
    function commitCachePassiveMountEffect(current2, finishedWork) {
      current2 = null;
      finishedWork.alternate !== null && (current2 = finishedWork.alternate.memoizedState.cache);
      finishedWork = finishedWork.memoizedState.cache;
      finishedWork !== current2 && (retainCache(finishedWork), current2 != null && releaseCache(current2));
    }
    function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions, endTime) {
      if (parentFiber.subtreeFlags & 10256 || parentFiber.actualDuration !== 0 && (parentFiber.alternate === null || parentFiber.alternate.child !== parentFiber.child))
        for (parentFiber = parentFiber.child;parentFiber !== null; ) {
          var nextSibling = parentFiber.sibling;
          commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions, nextSibling !== null ? nextSibling.actualStartTime : endTime);
          parentFiber = nextSibling;
        }
    }
    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          (finishedWork.mode & 2) !== NoMode && 0 < finishedWork.actualStartTime && (finishedWork.flags & 1) !== 0 && logComponentRender(finishedWork, finishedWork.actualStartTime, endTime, inHydratedSubtree, committedLanes);
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
          break;
        case 1:
          (finishedWork.mode & 2) !== NoMode && 0 < finishedWork.actualStartTime && ((finishedWork.flags & 128) !== 0 ? logComponentErrored(finishedWork, finishedWork.actualStartTime, endTime, []) : (finishedWork.flags & 1) !== 0 && logComponentRender(finishedWork, finishedWork.actualStartTime, endTime, inHydratedSubtree, committedLanes));
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          break;
        case 3:
          var prevProfilerEffectDuration = pushNestedEffectDurations(), wasInHydratedSubtree = inHydratedSubtree;
          inHydratedSubtree = finishedWork.alternate !== null && finishedWork.alternate.memoizedState.isDehydrated && (finishedWork.flags & 256) === 0;
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          inHydratedSubtree = wasInHydratedSubtree;
          flags & 2048 && (committedLanes = null, finishedWork.alternate !== null && (committedLanes = finishedWork.alternate.memoizedState.cache), committedTransitions = finishedWork.memoizedState.cache, committedTransitions !== committedLanes && (retainCache(committedTransitions), committedLanes != null && releaseCache(committedLanes)));
          finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevProfilerEffectDuration);
          break;
        case 12:
          if (flags & 2048) {
            flags = pushNestedEffectDurations();
            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
            finishedRoot = finishedWork.stateNode;
            finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(finishedWork, commitProfilerPostCommitImpl, finishedWork, finishedWork.alternate, commitStartTime, finishedRoot.passiveEffectDuration);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          break;
        case 31:
          flags = inHydratedSubtree;
          prevProfilerEffectDuration = finishedWork.alternate !== null ? finishedWork.alternate.memoizedState : null;
          wasInHydratedSubtree = finishedWork.memoizedState;
          prevProfilerEffectDuration !== null && wasInHydratedSubtree === null ? (wasInHydratedSubtree = finishedWork.deletions, wasInHydratedSubtree !== null && 0 < wasInHydratedSubtree.length && wasInHydratedSubtree[0].tag === 18 ? (inHydratedSubtree = false, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, prevProfilerEffectDuration !== null && logComponentErrored(finishedWork, finishedWork.actualStartTime, endTime, prevProfilerEffectDuration)) : inHydratedSubtree = true) : inHydratedSubtree = false;
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          inHydratedSubtree = flags;
          break;
        case 13:
          flags = inHydratedSubtree;
          prevProfilerEffectDuration = finishedWork.alternate !== null ? finishedWork.alternate.memoizedState : null;
          wasInHydratedSubtree = finishedWork.memoizedState;
          prevProfilerEffectDuration === null || prevProfilerEffectDuration.dehydrated === null || wasInHydratedSubtree !== null && wasInHydratedSubtree.dehydrated !== null ? inHydratedSubtree = false : (wasInHydratedSubtree = finishedWork.deletions, wasInHydratedSubtree !== null && 0 < wasInHydratedSubtree.length && wasInHydratedSubtree[0].tag === 18 ? (inHydratedSubtree = false, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, prevProfilerEffectDuration !== null && logComponentErrored(finishedWork, finishedWork.actualStartTime, endTime, prevProfilerEffectDuration)) : inHydratedSubtree = true);
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          inHydratedSubtree = flags;
          break;
        case 23:
          break;
        case 22:
          wasInHydratedSubtree = finishedWork.stateNode;
          prevProfilerEffectDuration = finishedWork.alternate;
          finishedWork.memoizedState !== null ? wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) : wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) : (wasInHydratedSubtree._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, (finishedWork.subtreeFlags & 10256) !== 0 || finishedWork.actualDuration !== 0 && (finishedWork.alternate === null || finishedWork.alternate.child !== finishedWork.child), endTime), (finishedWork.mode & 2) === NoMode || inHydratedSubtree || (finishedRoot = finishedWork.actualStartTime, 0 <= finishedRoot && 0.05 < endTime - finishedRoot && logComponentReappeared(finishedWork, finishedRoot, endTime), 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(finishedWork, componentEffectStartTime, componentEffectEndTime)));
          flags & 2048 && commitOffscreenPassiveMountEffects(prevProfilerEffectDuration, finishedWork);
          break;
        case 24:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
      }
      if ((finishedWork.mode & 2) !== NoMode) {
        if (finishedRoot = !inHydratedSubtree && finishedWork.alternate === null && finishedWork.return !== null && finishedWork.return.alternate !== null)
          committedLanes = finishedWork.actualStartTime, 0 <= committedLanes && 0.05 < endTime - committedLanes && logComponentTrigger(finishedWork, committedLanes, endTime, "Mount");
        0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors), finishedRoot && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, "Mount"));
      }
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      alreadyWarnedForDeepEquality = prevDeepEquality;
    }
    function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && ((parentFiber.subtreeFlags & 10256) !== 0 || parentFiber.actualDuration !== 0 && (parentFiber.alternate === null || parentFiber.alternate.child !== parentFiber.child));
      for (parentFiber = parentFiber.child;parentFiber !== null; ) {
        var nextSibling = parentFiber.sibling;
        reconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects, nextSibling !== null ? nextSibling.actualStartTime : endTime);
        parentFiber = nextSibling;
      }
    }
    function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality;
      includeWorkInProgressEffects && (finishedWork.mode & 2) !== NoMode && 0 < finishedWork.actualStartTime && (finishedWork.flags & 1) !== 0 && logComponentRender(finishedWork, finishedWork.actualStartTime, endTime, inHydratedSubtree, committedLanes);
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime);
          commitHookPassiveMountEffects(finishedWork, Passive);
          break;
        case 23:
          break;
        case 22:
          var _instance2 = finishedWork.stateNode;
          finishedWork.memoizedState !== null ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime));
          includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
          break;
        case 24:
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime);
          includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime);
      }
      (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      alreadyWarnedForDeepEquality = prevDeepEquality;
    }
    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, endTime$jscomp$0) {
      if (parentFiber.subtreeFlags & 10256 || parentFiber.actualDuration !== 0 && (parentFiber.alternate === null || parentFiber.alternate.child !== parentFiber.child))
        for (var child = parentFiber.child;child !== null; ) {
          parentFiber = child.sibling;
          var finishedRoot = finishedRoot$jscomp$0, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, endTime = parentFiber !== null ? parentFiber.actualStartTime : endTime$jscomp$0, prevDeepEquality = alreadyWarnedForDeepEquality;
          (child.mode & 2) !== NoMode && 0 < child.actualStartTime && (child.flags & 1) !== 0 && logComponentRender(child, child.actualStartTime, endTime, inHydratedSubtree, committedLanes);
          var flags = child.flags;
          switch (child.tag) {
            case 22:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, child, committedLanes, committedTransitions, endTime);
              flags & 2048 && commitOffscreenPassiveMountEffects(child.alternate, child);
              break;
            case 24:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, child, committedLanes, committedTransitions, endTime);
              flags & 2048 && commitCachePassiveMountEffect(child.alternate, child);
              break;
            default:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, child, committedLanes, committedTransitions, endTime);
          }
          alreadyWarnedForDeepEquality = prevDeepEquality;
          child = parentFiber;
        }
    }
    function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
      if (parentFiber.subtreeFlags & suspenseyCommitFlag)
        for (parentFiber = parentFiber.child;parentFiber !== null; )
          accumulateSuspenseyCommitOnFiber(parentFiber, committedLanes, suspendedState), parentFiber = parentFiber.sibling;
    }
    function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
      switch (fiber.tag) {
        case 26:
          recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);
          if (fiber.flags & suspenseyCommitFlag)
            if (fiber.memoizedState !== null)
              suspendResource(suspendedState, currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);
            else {
              var { stateNode: instance, type } = fiber;
              fiber = fiber.memoizedProps;
              ((committedLanes & 335544128) === committedLanes || maySuspendCommitInSyncRender(type, fiber)) && suspendInstance(suspendedState, instance, type, fiber);
            }
          break;
        case 5:
          recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);
          fiber.flags & suspenseyCommitFlag && (instance = fiber.stateNode, type = fiber.type, fiber = fiber.memoizedProps, ((committedLanes & 335544128) === committedLanes || maySuspendCommitInSyncRender(type, fiber)) && suspendInstance(suspendedState, instance, type, fiber));
          break;
        case 3:
        case 4:
          supportsResources ? (instance = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo), recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState), currentHoistableRoot = instance) : recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);
          break;
        case 22:
          fiber.memoizedState === null && (instance = fiber.alternate, instance !== null && instance.memoizedState !== null ? (instance = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState), suspenseyCommitFlag = instance) : recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState));
          break;
        default:
          recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);
      }
    }
    function detachAlternateSiblings(parentFiber) {
      var previousFiber = parentFiber.alternate;
      if (previousFiber !== null && (parentFiber = previousFiber.child, parentFiber !== null)) {
        previousFiber.child = null;
        do
          previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
        while (parentFiber !== null);
      }
    }
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if ((parentFiber.flags & 16) !== 0) {
        if (deletions !== null)
          for (var i = 0;i < deletions.length; i++) {
            var childToDelete = deletions[i], prevEffectStart = pushComponentEffectStart();
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
            (childToDelete.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(childToDelete, componentEffectStartTime, componentEffectEndTime, "Unmount");
            popComponentEffectStart(prevEffectStart);
          }
        detachAlternateSiblings(parentFiber);
      }
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child;parentFiber !== null; )
          commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);
          break;
        case 3:
          var prevProfilerEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevProfilerEffectDuration);
          break;
        case 12:
          prevProfilerEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevProfilerEffectDuration);
          break;
        case 22:
          prevProfilerEffectDuration = finishedWork.stateNode;
          finishedWork.memoizedState !== null && prevProfilerEffectDuration._visibility & OffscreenPassiveEffectsConnected && (finishedWork.return === null || finishedWork.return.tag !== 13) ? (prevProfilerEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork), (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, "Disconnect")) : recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        default:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
      }
      (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      componentEffectErrors = prevEffectErrors;
    }
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if ((parentFiber.flags & 16) !== 0) {
        if (deletions !== null)
          for (var i = 0;i < deletions.length; i++) {
            var childToDelete = deletions[i], prevEffectStart = pushComponentEffectStart();
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
            (childToDelete.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(childToDelete, componentEffectStartTime, componentEffectEndTime, "Unmount");
            popComponentEffectStart(prevEffectStart);
          }
        detachAlternateSiblings(parentFiber);
      }
      for (parentFiber = parentFiber.child;parentFiber !== null; )
        disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
    }
    function disconnectPassiveEffect(finishedWork) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive);
          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
          break;
        case 22:
          var instance = finishedWork.stateNode;
          instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
          break;
        default:
          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
      }
      (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      componentEffectErrors = prevEffectErrors;
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor$jscomp$0) {
      for (;nextEffect !== null; ) {
        var fiber = nextEffect, current2 = fiber, nearestMountedAncestor = nearestMountedAncestor$jscomp$0, prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
        switch (current2.tag) {
          case 0:
          case 11:
          case 15:
            commitHookPassiveUnmountEffects(current2, nearestMountedAncestor, Passive);
            break;
          case 23:
          case 22:
            current2.memoizedState !== null && current2.memoizedState.cachePool !== null && (nearestMountedAncestor = current2.memoizedState.cachePool.pool, nearestMountedAncestor != null && retainCache(nearestMountedAncestor));
            break;
          case 24:
            releaseCache(current2.memoizedState.cache);
        }
        (current2.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(current2, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
        popComponentEffectStart(prevEffectStart);
        popComponentEffectDuration(prevEffectDuration);
        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        componentEffectErrors = prevEffectErrors;
        current2 = fiber.child;
        if (current2 !== null)
          current2.return = fiber, nextEffect = current2;
        else
          a:
            for (fiber = deletedSubtreeRoot;nextEffect !== null; ) {
              current2 = nextEffect;
              prevEffectStart = current2.sibling;
              prevEffectDuration = current2.return;
              detachFiberAfterEffects(current2);
              if (current2 === fiber) {
                nextEffect = null;
                break a;
              }
              if (prevEffectStart !== null) {
                prevEffectStart.return = prevEffectDuration;
                nextEffect = prevEffectStart;
                break a;
              }
              nextEffect = prevEffectDuration;
            }
      }
    }
    function findFiberRootForHostRoot(hostRoot) {
      var maybeFiber = getInstanceFromNode(hostRoot);
      if (maybeFiber != null) {
        if (typeof maybeFiber.memoizedProps["data-testname"] !== "string")
          throw Error("Invalid host root specified. Should be either a React container or a node with a testname attribute.");
        return maybeFiber;
      }
      hostRoot = findFiberRoot(hostRoot);
      if (hostRoot === null)
        throw Error("Could not find React container within specified host subtree.");
      return hostRoot.stateNode.current;
    }
    function matchSelector(fiber$jscomp$0, selector) {
      var tag = fiber$jscomp$0.tag;
      switch (selector.$$typeof) {
        case COMPONENT_TYPE:
          if (fiber$jscomp$0.type === selector.value)
            return true;
          break;
        case HAS_PSEUDO_CLASS_TYPE:
          a: {
            selector = selector.value;
            fiber$jscomp$0 = [fiber$jscomp$0, 0];
            for (tag = 0;tag < fiber$jscomp$0.length; ) {
              var fiber = fiber$jscomp$0[tag++], tag$jscomp$0 = fiber.tag, selectorIndex = fiber$jscomp$0[tag++], selector$jscomp$0 = selector[selectorIndex];
              if (tag$jscomp$0 !== 5 && tag$jscomp$0 !== 26 && tag$jscomp$0 !== 27 || !isHiddenSubtree(fiber)) {
                for (;selector$jscomp$0 != null && matchSelector(fiber, selector$jscomp$0); )
                  selectorIndex++, selector$jscomp$0 = selector[selectorIndex];
                if (selectorIndex === selector.length) {
                  selector = true;
                  break a;
                } else
                  for (fiber = fiber.child;fiber !== null; )
                    fiber$jscomp$0.push(fiber, selectorIndex), fiber = fiber.sibling;
              }
            }
            selector = false;
          }
          return selector;
        case ROLE_TYPE:
          if ((tag === 5 || tag === 26 || tag === 27) && matchAccessibilityRole(fiber$jscomp$0.stateNode, selector.value))
            return true;
          break;
        case TEXT_TYPE:
          if (tag === 5 || tag === 6 || tag === 26 || tag === 27) {
            if (fiber$jscomp$0 = getTextContent(fiber$jscomp$0), fiber$jscomp$0 !== null && 0 <= fiber$jscomp$0.indexOf(selector.value))
              return true;
          }
          break;
        case TEST_NAME_TYPE:
          if (tag === 5 || tag === 26 || tag === 27) {
            if (fiber$jscomp$0 = fiber$jscomp$0.memoizedProps["data-testname"], typeof fiber$jscomp$0 === "string" && fiber$jscomp$0.toLowerCase() === selector.value.toLowerCase())
              return true;
          }
          break;
        default:
          throw Error("Invalid selector type specified.");
      }
      return false;
    }
    function selectorToString(selector) {
      switch (selector.$$typeof) {
        case COMPONENT_TYPE:
          return "<" + (getComponentNameFromType(selector.value) || "Unknown") + ">";
        case HAS_PSEUDO_CLASS_TYPE:
          return ":has(" + (selectorToString(selector) || "") + ")";
        case ROLE_TYPE:
          return '[role="' + selector.value + '"]';
        case TEXT_TYPE:
          return '"' + selector.value + '"';
        case TEST_NAME_TYPE:
          return '[data-testname="' + selector.value + '"]';
        default:
          throw Error("Invalid selector type specified.");
      }
    }
    function findPaths(root, selectors) {
      var matchingFibers = [];
      root = [root, 0];
      for (var index = 0;index < root.length; ) {
        var fiber = root[index++], tag = fiber.tag, selectorIndex = root[index++], selector = selectors[selectorIndex];
        if (tag !== 5 && tag !== 26 && tag !== 27 || !isHiddenSubtree(fiber)) {
          for (;selector != null && matchSelector(fiber, selector); )
            selectorIndex++, selector = selectors[selectorIndex];
          if (selectorIndex === selectors.length)
            matchingFibers.push(fiber);
          else
            for (fiber = fiber.child;fiber !== null; )
              root.push(fiber, selectorIndex), fiber = fiber.sibling;
        }
      }
      return matchingFibers;
    }
    function findAllNodes(hostRoot, selectors) {
      if (!supportsTestSelectors)
        throw Error("Test selector API is not supported by this renderer.");
      hostRoot = findFiberRootForHostRoot(hostRoot);
      hostRoot = findPaths(hostRoot, selectors);
      selectors = [];
      hostRoot = Array.from(hostRoot);
      for (var index = 0;index < hostRoot.length; ) {
        var node = hostRoot[index++], tag = node.tag;
        if (tag === 5 || tag === 26 || tag === 27)
          isHiddenSubtree(node) || selectors.push(node.stateNode);
        else
          for (node = node.child;node !== null; )
            hostRoot.push(node), node = node.sibling;
      }
      return selectors;
    }
    function onCommitRoot() {
      supportsTestSelectors && commitHooks.forEach(function(commitHook) {
        return commitHook();
      });
    }
    function isConcurrentActEnvironment() {
      var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : undefined;
      isReactActEnvironmentGlobal || ReactSharedInternals.actQueue === null || console.error("The current testing environment is not configured to support act(...)");
      return isReactActEnvironmentGlobal;
    }
    function requestUpdateLane(fiber) {
      if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== 0)
        return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
      var transition = ReactSharedInternals.T;
      return transition !== null ? (transition._updatedFibers || (transition._updatedFibers = new Set), transition._updatedFibers.add(fiber), requestTransitionLane()) : resolveUpdatePriority();
    }
    function requestDeferredLane() {
      if (workInProgressDeferredLane === 0)
        if ((workInProgressRootRenderLanes & 536870912) === 0 || isHydrating) {
          var lane = nextTransitionDeferredLane;
          nextTransitionDeferredLane <<= 1;
          (nextTransitionDeferredLane & 3932160) === 0 && (nextTransitionDeferredLane = 262144);
          workInProgressDeferredLane = lane;
        } else
          workInProgressDeferredLane = 536870912;
      lane = suspenseHandlerStackCursor.current;
      lane !== null && (lane.flags |= 32);
      return workInProgressDeferredLane;
    }
    function scheduleUpdateOnFiber(root, fiber, lane) {
      isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
      isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = true);
      if (root === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || root.cancelPendingCommit !== null)
        prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, false);
      markRootUpdated$1(root, lane);
      if ((executionContext & RenderContext) !== NoContext && root === workInProgressRoot) {
        if (isRendering)
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15:
              root = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
              didWarnAboutUpdateInRenderForAnotherComponent.has(root) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render", fiber, root, root));
              break;
            case 1:
              didWarnAboutUpdateInRender || (console.error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), didWarnAboutUpdateInRender = true);
          }
      } else
        isDevToolsPresent && addFiberToLanesMap(root, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, false)), ensureRootIsScheduled(root);
    }
    function performWorkOnRoot(root, lanes, forceSync) {
      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
        throw Error("Should not already be working.");
      if (workInProgressRootRenderLanes !== 0 && workInProgress !== null) {
        var yieldedFiber = workInProgress, yieldEndTime = now$1();
        switch (yieldReason) {
          case SuspendedOnImmediate:
          case SuspendedOnData:
            var startTime = yieldStartTime;
            supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(console.timeStamp.bind(console, "Suspended", startTime, yieldEndTime, "Components ", undefined, "primary-light")) : console.timeStamp("Suspended", startTime, yieldEndTime, "Components ", undefined, "primary-light"));
            break;
          case SuspendedOnAction:
            startTime = yieldStartTime;
            supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(console.timeStamp.bind(console, "Action", startTime, yieldEndTime, "Components ", undefined, "primary-light")) : console.timeStamp("Action", startTime, yieldEndTime, "Components ", undefined, "primary-light"));
            break;
          default:
            supportsUserTiming && (yieldedFiber = yieldEndTime - yieldStartTime, 3 > yieldedFiber || console.timeStamp("Blocked", yieldStartTime, yieldEndTime, "Components ", undefined, 5 > yieldedFiber ? "primary-light" : 10 > yieldedFiber ? "primary" : 100 > yieldedFiber ? "primary-dark" : "error"));
        }
      }
      startTime = (forceSync = !forceSync && (lanes & 127) === 0 && (lanes & root.expiredLanes) === 0 || checkIfRootIsPrerendering(root, lanes)) ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes, true);
      var renderWasConcurrent = forceSync;
      do {
        if (startTime === RootInProgress) {
          workInProgressRootIsPrerendering && !forceSync && markRootSuspended(root, lanes, 0, false);
          lanes = workInProgressSuspendedReason;
          yieldStartTime = now2();
          yieldReason = lanes;
          break;
        } else {
          yieldedFiber = now$1();
          yieldEndTime = root.current.alternate;
          if (renderWasConcurrent && !isRenderConsistentWithExternalStores(yieldEndTime)) {
            setCurrentTrackFromLanes(lanes);
            yieldEndTime = renderStartTime;
            startTime = yieldedFiber;
            !supportsUserTiming || startTime <= yieldEndTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(console.timeStamp.bind(console, "Teared Render", yieldEndTime, startTime, currentTrack, "Scheduler ", "error")) : console.timeStamp("Teared Render", yieldEndTime, startTime, currentTrack, "Scheduler ", "error"));
            finalizeRender(lanes, yieldedFiber);
            startTime = renderRootSync(root, lanes, false);
            renderWasConcurrent = false;
            continue;
          }
          if (startTime === RootErrored) {
            renderWasConcurrent = lanes;
            if (root.errorRecoveryDisabledLanes & renderWasConcurrent)
              var errorRetryLanes = 0;
            else
              errorRetryLanes = root.pendingLanes & -536870913, errorRetryLanes = errorRetryLanes !== 0 ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
            if (errorRetryLanes !== 0) {
              setCurrentTrackFromLanes(lanes);
              logErroredRenderPhase(renderStartTime, yieldedFiber, lanes, workInProgressUpdateTask);
              finalizeRender(lanes, yieldedFiber);
              lanes = errorRetryLanes;
              a: {
                yieldedFiber = root;
                startTime = renderWasConcurrent;
                renderWasConcurrent = workInProgressRootConcurrentErrors;
                var wasRootDehydrated = supportsHydration && yieldedFiber.current.memoizedState.isDehydrated;
                wasRootDehydrated && (prepareFreshStack(yieldedFiber, errorRetryLanes).flags |= 256);
                errorRetryLanes = renderRootSync(yieldedFiber, errorRetryLanes, false);
                if (errorRetryLanes !== RootErrored) {
                  if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                    yieldedFiber.errorRecoveryDisabledLanes |= startTime;
                    workInProgressRootInterleavedUpdatedLanes |= startTime;
                    startTime = RootSuspendedWithDelay;
                    break a;
                  }
                  yieldedFiber = workInProgressRootRecoverableErrors;
                  workInProgressRootRecoverableErrors = renderWasConcurrent;
                  yieldedFiber !== null && (workInProgressRootRecoverableErrors === null ? workInProgressRootRecoverableErrors = yieldedFiber : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, yieldedFiber));
                }
                startTime = errorRetryLanes;
              }
              renderWasConcurrent = false;
              if (startTime !== RootErrored)
                continue;
              else
                yieldedFiber = now$1();
            }
          }
          if (startTime === RootFatalErrored) {
            setCurrentTrackFromLanes(lanes);
            logErroredRenderPhase(renderStartTime, yieldedFiber, lanes, workInProgressUpdateTask);
            finalizeRender(lanes, yieldedFiber);
            prepareFreshStack(root, 0);
            markRootSuspended(root, lanes, 0, true);
            break;
          }
          a: {
            forceSync = root;
            switch (startTime) {
              case RootInProgress:
              case RootFatalErrored:
                throw Error("Root did not complete. This is a bug in React.");
              case RootSuspendedWithDelay:
                if ((lanes & 4194048) !== lanes)
                  break;
              case RootSuspendedAtTheShell:
                setCurrentTrackFromLanes(lanes);
                logSuspendedRenderPhase(renderStartTime, yieldedFiber, lanes, workInProgressUpdateTask);
                finalizeRender(lanes, yieldedFiber);
                yieldEndTime = lanes;
                (yieldEndTime & 127) !== 0 ? blockingSuspendedTime = yieldedFiber : (yieldEndTime & 4194048) !== 0 && (transitionSuspendedTime = yieldedFiber);
                markRootSuspended(forceSync, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
                break a;
              case RootErrored:
                workInProgressRootRecoverableErrors = null;
                break;
              case RootSuspended:
              case RootCompleted:
                break;
              default:
                throw Error("Unknown root exit status.");
            }
            if (ReactSharedInternals.actQueue !== null)
              commitRoot(forceSync, yieldEndTime, lanes, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, startTime, null, null, renderStartTime, yieldedFiber);
            else {
              if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {
                markRootSuspended(forceSync, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
                if (getNextLanes(forceSync, 0, true) !== 0)
                  break a;
                pendingEffectsLanes = lanes;
                forceSync.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, forceSync, yieldEndTime, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, startTime, "Throttled", renderStartTime, yieldedFiber), renderWasConcurrent);
                break a;
              }
              commitRootWhenReady(forceSync, yieldEndTime, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, startTime, null, renderStartTime, yieldedFiber);
            }
          }
        }
        break;
      } while (1);
      ensureRootIsScheduled(root);
    }
    function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
      root.timeoutHandle = noTimeout;
      var subtreeFlags = finishedWork.subtreeFlags, suspendedState = null;
      if (subtreeFlags & 8192 || (subtreeFlags & 16785408) === 16785408) {
        if (suspendedState = startSuspendingCommit(), accumulateSuspenseyCommitOnFiber(finishedWork, lanes, suspendedState), subtreeFlags = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now$1() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now$1() : 0, subtreeFlags = waitForCommitToBeReady(suspendedState, subtreeFlags), subtreeFlags !== null) {
          pendingEffectsLanes = lanes;
          root.cancelPendingCommit = subtreeFlags(commitRoot.bind(null, root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedState, getSuspendedCommitReason(suspendedState, root.containerInfo), completedRenderStartTime, completedRenderEndTime));
          markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
          return;
        }
      }
      commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedState, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (var node = finishedWork;; ) {
        var tag = node.tag;
        if ((tag === 0 || tag === 11 || tag === 15) && node.flags & 16384 && (tag = node.updateQueue, tag !== null && (tag = tag.stores, tag !== null)))
          for (var i = 0;i < tag.length; i++) {
            var check = tag[i], getSnapshot = check.getSnapshot;
            check = check.value;
            try {
              if (!objectIs(getSnapshot(), check))
                return false;
            } catch (error) {
              return false;
            }
          }
        tag = node.child;
        if (node.subtreeFlags & 16384 && tag !== null)
          tag.return = node, node = tag;
        else {
          if (node === finishedWork)
            break;
          for (;node.sibling === null; ) {
            if (node.return === null || node.return === finishedWork)
              return true;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      return true;
    }
    function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {
      suspendedLanes &= ~workInProgressRootPingedLanes;
      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
      root.suspendedLanes |= suspendedLanes;
      root.pingedLanes &= ~suspendedLanes;
      didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
      didAttemptEntireTree = root.expirationTimes;
      for (var lanes = suspendedLanes;0 < lanes; ) {
        var index = 31 - clz32(lanes), lane = 1 << index;
        didAttemptEntireTree[index] = -1;
        lanes &= ~lane;
      }
      spawnedLane !== 0 && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
    }
    function flushSyncWork() {
      return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
    }
    function isAlreadyRendering() {
      return (executionContext & (RenderContext | CommitContext)) !== NoContext;
    }
    function resetWorkInProgressStack() {
      if (workInProgress !== null) {
        if (workInProgressSuspendedReason === NotSuspended)
          var interruptedWork = workInProgress.return;
        else
          interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
        for (;interruptedWork !== null; )
          unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
        workInProgress = null;
      }
    }
    function finalizeRender(lanes, finalizationTime) {
      (lanes & 127) !== 0 && (blockingClampTime = finalizationTime);
      (lanes & 4194048) !== 0 && (transitionClampTime = finalizationTime);
    }
    function prepareFreshStack(root, lanes) {
      supportsUserTiming && (console.timeStamp("Blocking Track", 0.003, 0.003, "Blocking", "Scheduler ", "primary-light"), console.timeStamp("Transition Track", 0.003, 0.003, "Transition", "Scheduler ", "primary-light"), console.timeStamp("Suspense Track", 0.003, 0.003, "Suspense", "Scheduler ", "primary-light"), console.timeStamp("Idle Track", 0.003, 0.003, "Idle", "Scheduler ", "primary-light"));
      var previousRenderStartTime = renderStartTime;
      renderStartTime = now2();
      if (workInProgressRootRenderLanes !== 0 && 0 < previousRenderStartTime) {
        setCurrentTrackFromLanes(workInProgressRootRenderLanes);
        if (workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootSuspendedWithDelay)
          logSuspendedRenderPhase(previousRenderStartTime, renderStartTime, lanes, workInProgressUpdateTask);
        else {
          var endTime = renderStartTime, debugTask = workInProgressUpdateTask;
          if (supportsUserTiming && !(endTime <= previousRenderStartTime)) {
            var color = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", label = (lanes & 536870912) === lanes ? "Prewarm" : (lanes & 201326741) === lanes ? "Interrupted Hydration" : "Interrupted Render";
            debugTask ? debugTask.run(console.timeStamp.bind(console, label, previousRenderStartTime, endTime, currentTrack, "Scheduler ", color)) : console.timeStamp(label, previousRenderStartTime, endTime, currentTrack, "Scheduler ", color);
          }
        }
        finalizeRender(workInProgressRootRenderLanes, renderStartTime);
      }
      previousRenderStartTime = workInProgressUpdateTask;
      workInProgressUpdateTask = null;
      if ((lanes & 127) !== 0) {
        workInProgressUpdateTask = blockingUpdateTask;
        debugTask = 0 <= blockingUpdateTime && blockingUpdateTime < blockingClampTime ? blockingClampTime : blockingUpdateTime;
        endTime = 0 <= blockingEventTime && blockingEventTime < blockingClampTime ? blockingClampTime : blockingEventTime;
        color = 0 <= endTime ? endTime : 0 <= debugTask ? debugTask : renderStartTime;
        0 <= blockingSuspendedTime && (setCurrentTrackFromLanes(2), logSuspendedWithDelayPhase(blockingSuspendedTime, color, lanes, previousRenderStartTime));
        previousRenderStartTime = debugTask;
        var eventTime = endTime, eventType = blockingEventType, eventIsRepeat = 0 < blockingEventRepeatTime, isSpawnedUpdate = blockingUpdateType === 1, isPingedUpdate = blockingUpdateType === 2;
        debugTask = renderStartTime;
        endTime = blockingUpdateTask;
        color = blockingUpdateMethodName;
        label = blockingUpdateComponentName;
        if (supportsUserTiming) {
          currentTrack = "Blocking";
          0 < previousRenderStartTime ? previousRenderStartTime > debugTask && (previousRenderStartTime = debugTask) : previousRenderStartTime = debugTask;
          0 < eventTime ? eventTime > previousRenderStartTime && (eventTime = previousRenderStartTime) : eventTime = previousRenderStartTime;
          if (eventType !== null && previousRenderStartTime > eventTime) {
            var color$jscomp$0 = eventIsRepeat ? "secondary-light" : "warning";
            endTime ? endTime.run(console.timeStamp.bind(console, eventIsRepeat ? "Consecutive" : "Event: " + eventType, eventTime, previousRenderStartTime, currentTrack, "Scheduler ", color$jscomp$0)) : console.timeStamp(eventIsRepeat ? "Consecutive" : "Event: " + eventType, eventTime, previousRenderStartTime, currentTrack, "Scheduler ", color$jscomp$0);
          }
          debugTask > previousRenderStartTime && (eventTime = isSpawnedUpdate ? "error" : (lanes & 738197653) === lanes ? "tertiary-light" : "primary-light", isSpawnedUpdate = isPingedUpdate ? "Promise Resolved" : isSpawnedUpdate ? "Cascading Update" : 5 < debugTask - previousRenderStartTime ? "Update Blocked" : "Update", isPingedUpdate = [], label != null && isPingedUpdate.push(["Component name", label]), color != null && isPingedUpdate.push(["Method name", color]), previousRenderStartTime = {
            start: previousRenderStartTime,
            end: debugTask,
            detail: {
              devtools: {
                properties: isPingedUpdate,
                track: currentTrack,
                trackGroup: "Scheduler ",
                color: eventTime
              }
            }
          }, endTime ? endTime.run(performance.measure.bind(performance, isSpawnedUpdate, previousRenderStartTime)) : performance.measure(isSpawnedUpdate, previousRenderStartTime));
        }
        blockingUpdateTime = -1.1;
        blockingUpdateType = 0;
        blockingUpdateComponentName = blockingUpdateMethodName = null;
        blockingSuspendedTime = -1.1;
        blockingEventRepeatTime = blockingEventTime;
        blockingEventTime = -1.1;
        blockingClampTime = now2();
      }
      (lanes & 4194048) !== 0 && (workInProgressUpdateTask = transitionUpdateTask, debugTask = 0 <= transitionStartTime && transitionStartTime < transitionClampTime ? transitionClampTime : transitionStartTime, previousRenderStartTime = 0 <= transitionUpdateTime && transitionUpdateTime < transitionClampTime ? transitionClampTime : transitionUpdateTime, endTime = 0 <= transitionEventTime && transitionEventTime < transitionClampTime ? transitionClampTime : transitionEventTime, color = 0 <= endTime ? endTime : 0 <= previousRenderStartTime ? previousRenderStartTime : renderStartTime, 0 <= transitionSuspendedTime && (setCurrentTrackFromLanes(256), logSuspendedWithDelayPhase(transitionSuspendedTime, color, lanes, workInProgressUpdateTask)), isPingedUpdate = endTime, eventTime = transitionEventType, eventType = 0 < transitionEventRepeatTime, eventIsRepeat = transitionUpdateType === 2, color = renderStartTime, endTime = transitionUpdateTask, label = transitionUpdateMethodName, isSpawnedUpdate = transitionUpdateComponentName, supportsUserTiming && (currentTrack = "Transition", 0 < previousRenderStartTime ? previousRenderStartTime > color && (previousRenderStartTime = color) : previousRenderStartTime = color, 0 < debugTask ? debugTask > previousRenderStartTime && (debugTask = previousRenderStartTime) : debugTask = previousRenderStartTime, 0 < isPingedUpdate ? isPingedUpdate > debugTask && (isPingedUpdate = debugTask) : isPingedUpdate = debugTask, debugTask > isPingedUpdate && eventTime !== null && (color$jscomp$0 = eventType ? "secondary-light" : "warning", endTime ? endTime.run(console.timeStamp.bind(console, eventType ? "Consecutive" : "Event: " + eventTime, isPingedUpdate, debugTask, currentTrack, "Scheduler ", color$jscomp$0)) : console.timeStamp(eventType ? "Consecutive" : "Event: " + eventTime, isPingedUpdate, debugTask, currentTrack, "Scheduler ", color$jscomp$0)), previousRenderStartTime > debugTask && (endTime ? endTime.run(console.timeStamp.bind(console, "Action", debugTask, previousRenderStartTime, currentTrack, "Scheduler ", "primary-dark")) : console.timeStamp("Action", debugTask, previousRenderStartTime, currentTrack, "Scheduler ", "primary-dark")), color > previousRenderStartTime && (debugTask = eventIsRepeat ? "Promise Resolved" : 5 < color - previousRenderStartTime ? "Update Blocked" : "Update", isPingedUpdate = [], isSpawnedUpdate != null && isPingedUpdate.push(["Component name", isSpawnedUpdate]), label != null && isPingedUpdate.push(["Method name", label]), previousRenderStartTime = {
        start: previousRenderStartTime,
        end: color,
        detail: {
          devtools: {
            properties: isPingedUpdate,
            track: currentTrack,
            trackGroup: "Scheduler ",
            color: "primary-light"
          }
        }
      }, endTime ? endTime.run(performance.measure.bind(performance, debugTask, previousRenderStartTime)) : performance.measure(debugTask, previousRenderStartTime))), transitionUpdateTime = transitionStartTime = -1.1, transitionUpdateType = 0, transitionSuspendedTime = -1.1, transitionEventRepeatTime = transitionEventTime, transitionEventTime = -1.1, transitionClampTime = now2());
      previousRenderStartTime = root.timeoutHandle;
      previousRenderStartTime !== noTimeout && (root.timeoutHandle = noTimeout, cancelTimeout(previousRenderStartTime));
      previousRenderStartTime = root.cancelPendingCommit;
      previousRenderStartTime !== null && (root.cancelPendingCommit = null, previousRenderStartTime());
      pendingEffectsLanes = 0;
      resetWorkInProgressStack();
      workInProgressRoot = root;
      workInProgress = previousRenderStartTime = createWorkInProgress(root.current, null);
      workInProgressRootRenderLanes = lanes;
      workInProgressSuspendedReason = NotSuspended;
      workInProgressThrownValue = null;
      workInProgressRootDidSkipSuspendedSiblings = false;
      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
      workInProgressRootDidAttachPingListener = false;
      workInProgressRootExitStatus = RootInProgress;
      workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
      workInProgressRootDidIncludeRecursiveRenderUpdate = false;
      (lanes & 8) !== 0 && (lanes |= lanes & 32);
      endTime = root.entangledLanes;
      if (endTime !== 0)
        for (root = root.entanglements, endTime &= lanes;0 < endTime; )
          debugTask = 31 - clz32(endTime), color = 1 << debugTask, lanes |= root[debugTask], endTime &= ~color;
      entangledRenderLanes = lanes;
      finishQueueingConcurrentUpdates();
      root = getCurrentTime();
      1000 < root - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = root);
      ReactStrictModeWarnings.discardPendingWarnings();
      return previousRenderStartTime;
    }
    function handleThrow(root, thrownValue) {
      currentlyRenderingFiber = null;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      ReactSharedInternals.getCurrentStack = null;
      isRendering = false;
      current = null;
      thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function" ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
      workInProgressThrownValue = thrownValue;
      var erroredWork = workInProgress;
      erroredWork === null ? (workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current))) : erroredWork.mode & 2 && stopProfilerTimerIfRunningAndRecordDuration(erroredWork);
    }
    function shouldRemainOnPreviousScreen() {
      var handler = suspenseHandlerStackCursor.current;
      return handler === null ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? shellBoundary === null ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || (workInProgressRootRenderLanes & 536870912) !== 0 ? handler === shellBoundary : false;
    }
    function pushDispatcher() {
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      return prevDispatcher === null ? ContextOnlyDispatcher : prevDispatcher;
    }
    function pushAsyncDispatcher() {
      var prevAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      return prevAsyncDispatcher;
    }
    function markRenderDerivedCause(fiber) {
      workInProgressUpdateTask === null && (workInProgressUpdateTask = fiber._debugTask == null ? null : fiber._debugTask);
    }
    function renderDidSuspendDelayIfPossible() {
      workInProgressRootExitStatus = RootSuspendedWithDelay;
      workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && suspenseHandlerStackCursor.current !== null || (workInProgressRootIsPrerendering = true);
      (workInProgressRootSkippedLanes & 134217727) === 0 && (workInProgressRootInterleavedUpdatedLanes & 134217727) === 0 || workInProgressRoot === null || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, false);
    }
    function renderRootSync(root, lanes, shouldYieldForPrerendering) {
      var prevExecutionContext = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root.memoizedUpdaters;
          0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());
          movePendingFibersToMemoized(root, lanes);
        }
        workInProgressTransitions = null;
        prepareFreshStack(root, lanes);
      }
      lanes = false;
      memoizedUpdaters = workInProgressRootExitStatus;
      a:
        do
          try {
            if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null) {
              var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
              switch (workInProgressSuspendedReason) {
                case SuspendedOnHydration:
                  resetWorkInProgressStack();
                  memoizedUpdaters = RootSuspendedAtTheShell;
                  break a;
                case SuspendedOnImmediate:
                case SuspendedOnData:
                case SuspendedOnAction:
                case SuspendedOnDeprecatedThrowPromise:
                  suspenseHandlerStackCursor.current === null && (lanes = true);
                  var reason = workInProgressSuspendedReason;
                  workInProgressSuspendedReason = NotSuspended;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
                  if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                    memoizedUpdaters = RootInProgress;
                    break a;
                  }
                  break;
                default:
                  reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
              }
            }
            workLoopSync();
            memoizedUpdaters = workInProgressRootExitStatus;
            break;
          } catch (thrownValue$4) {
            handleThrow(root, thrownValue$4);
          }
        while (1);
      lanes && root.shellSuspendCounter++;
      resetContextDependencies();
      executionContext = prevExecutionContext;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      workInProgress === null && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
      return memoizedUpdaters;
    }
    function workLoopSync() {
      for (;workInProgress !== null; )
        performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root, lanes) {
      var prevExecutionContext = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root.memoizedUpdaters;
          0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());
          movePendingFibersToMemoized(root, lanes);
        }
        workInProgressTransitions = null;
        workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
        prepareFreshStack(root, lanes);
      } else
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
      a:
        do
          try {
            if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null)
              b:
                switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
                  case SuspendedOnError:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnError);
                    break;
                  case SuspendedOnData:
                  case SuspendedOnAction:
                    if (isThenableResolved(memoizedUpdaters)) {
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      replaySuspendedUnitOfWork(lanes);
                      break;
                    }
                    lanes = function() {
                      workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
                      ensureRootIsScheduled(root);
                    };
                    memoizedUpdaters.then(lanes, lanes);
                    break a;
                  case SuspendedOnImmediate:
                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                    break a;
                  case SuspendedOnInstance:
                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
                    break a;
                  case SuspendedAndReadyToContinue:
                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedAndReadyToContinue));
                    break;
                  case SuspendedOnInstanceAndReadyToContinue:
                    var resource = null;
                    switch (workInProgress.tag) {
                      case 26:
                        resource = workInProgress.memoizedState;
                      case 5:
                      case 27:
                        var hostFiber = workInProgress, type = hostFiber.type, props = hostFiber.pendingProps;
                        if (resource ? preloadResource(resource) : preloadInstance(hostFiber.stateNode, type, props)) {
                          workInProgressSuspendedReason = NotSuspended;
                          workInProgressThrownValue = null;
                          var sibling = hostFiber.sibling;
                          if (sibling !== null)
                            workInProgress = sibling;
                          else {
                            var returnFiber = hostFiber.return;
                            returnFiber !== null ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                          }
                          break b;
                        }
                        break;
                      default:
                        console.error("Unexpected type of fiber triggered a suspensey commit. This is a bug in React.");
                    }
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnInstanceAndReadyToContinue);
                    break;
                  case SuspendedOnDeprecatedThrowPromise:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnDeprecatedThrowPromise);
                    break;
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    workInProgressRootExitStatus = RootSuspendedAtTheShell;
                    break a;
                  default:
                    throw Error("Unexpected SuspendedReason. This is a bug in React.");
                }
            ReactSharedInternals.actQueue !== null ? workLoopSync() : workLoopConcurrentByScheduler();
            break;
          } catch (thrownValue$5) {
            handleThrow(root, thrownValue$5);
          }
        while (1);
      resetContextDependencies();
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      executionContext = prevExecutionContext;
      if (workInProgress !== null)
        return RootInProgress;
      workInProgressRoot = null;
      workInProgressRootRenderLanes = 0;
      finishQueueingConcurrentUpdates();
      return workInProgressRootExitStatus;
    }
    function workLoopConcurrentByScheduler() {
      for (;workInProgress !== null && !shouldYield(); )
        performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
      var current2 = unitOfWork.alternate;
      (unitOfWork.mode & 2) !== NoMode ? (startProfilerTimer(unitOfWork), current2 = runWithFiberInDEV(unitOfWork, beginWork, current2, unitOfWork, entangledRenderLanes), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current2 = runWithFiberInDEV(unitOfWork, beginWork, current2, unitOfWork, entangledRenderLanes);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      current2 === null ? completeUnitOfWork(unitOfWork) : workInProgress = current2;
    }
    function replaySuspendedUnitOfWork(unitOfWork) {
      var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      next === null ? completeUnitOfWork(unitOfWork) : workInProgress = next;
    }
    function replayBeginWork(unitOfWork) {
      var current2 = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & 2) !== NoMode;
      isProfilingMode && startProfilerTimer(unitOfWork);
      switch (unitOfWork.tag) {
        case 15:
        case 0:
          current2 = replayFunctionComponent(current2, unitOfWork, unitOfWork.pendingProps, unitOfWork.type, undefined, workInProgressRootRenderLanes);
          break;
        case 11:
          current2 = replayFunctionComponent(current2, unitOfWork, unitOfWork.pendingProps, unitOfWork.type.render, unitOfWork.ref, workInProgressRootRenderLanes);
          break;
        case 5:
          resetHooksOnUnwind(unitOfWork);
        default:
          unwindInterruptedWork(current2, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current2 = beginWork(current2, unitOfWork, entangledRenderLanes);
      }
      isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
      return current2;
    }
    function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {
      resetContextDependencies();
      resetHooksOnUnwind(unitOfWork);
      thenableState$1 = null;
      thenableIndexCounter$1 = 0;
      var returnFiber = unitOfWork.return;
      try {
        if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {
          workInProgressRootExitStatus = RootFatalErrored;
          logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
          workInProgress = null;
          return;
        }
      } catch (error) {
        if (returnFiber !== null)
          throw workInProgress = returnFiber, error;
        workInProgressRootExitStatus = RootFatalErrored;
        logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
        workInProgress = null;
        return;
      }
      if (unitOfWork.flags & 32768) {
        if (isHydrating || suspendedReason === SuspendedOnError)
          root = true;
        else if (workInProgressRootIsPrerendering || (workInProgressRootRenderLanes & 536870912) !== 0)
          root = false;
        else if (workInProgressRootDidSkipSuspendedSiblings = root = true, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise)
          suspendedReason = suspenseHandlerStackCursor.current, suspendedReason !== null && suspendedReason.tag === 13 && (suspendedReason.flags |= 16384);
        unwindUnitOfWork(unitOfWork, root);
      } else
        completeUnitOfWork(unitOfWork);
    }
    function completeUnitOfWork(unitOfWork) {
      var completedWork = unitOfWork;
      do {
        if ((completedWork.flags & 32768) !== 0) {
          unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);
          return;
        }
        var current2 = completedWork.alternate;
        unitOfWork = completedWork.return;
        startProfilerTimer(completedWork);
        current2 = runWithFiberInDEV(completedWork, completeWork, current2, completedWork, entangledRenderLanes);
        (completedWork.mode & 2) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
        if (current2 !== null) {
          workInProgress = current2;
          return;
        }
        completedWork = completedWork.sibling;
        if (completedWork !== null) {
          workInProgress = completedWork;
          return;
        }
        workInProgress = completedWork = unitOfWork;
      } while (completedWork !== null);
      workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
    }
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
      do {
        var next = unwindWork(unitOfWork.alternate, unitOfWork);
        if (next !== null) {
          next.flags &= 32767;
          workInProgress = next;
          return;
        }
        if ((unitOfWork.mode & 2) !== NoMode) {
          stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
          next = unitOfWork.actualDuration;
          for (var child = unitOfWork.child;child !== null; )
            next += child.actualDuration, child = child.sibling;
          unitOfWork.actualDuration = next;
        }
        next = unitOfWork.return;
        next !== null && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
        if (!skipSiblings && (unitOfWork = unitOfWork.sibling, unitOfWork !== null)) {
          workInProgress = unitOfWork;
          return;
        }
        workInProgress = unitOfWork = next;
      } while (unitOfWork !== null);
      workInProgressRootExitStatus = RootSuspendedAtTheShell;
      workInProgress = null;
    }
    function commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedState, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
      root.cancelPendingCommit = null;
      do
        flushPendingEffects();
      while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
      ReactStrictModeWarnings.flushLegacyContextWarning();
      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
        throw Error("Should not already be working.");
      setCurrentTrackFromLanes(lanes);
      exitStatus === RootErrored ? logErroredRenderPhase(completedRenderStartTime, completedRenderEndTime, lanes, workInProgressUpdateTask) : recoverableErrors !== null ? logRecoveredRenderPhase(completedRenderStartTime, completedRenderEndTime, lanes, recoverableErrors, finishedWork !== null && finishedWork.alternate !== null && finishedWork.alternate.memoizedState.isDehydrated && (finishedWork.flags & 256) !== 0, workInProgressUpdateTask) : logRenderPhase(completedRenderStartTime, completedRenderEndTime, lanes, workInProgressUpdateTask);
      if (finishedWork !== null) {
        lanes === 0 && console.error("finishedLanes should not be empty during a commit. This is a bug in React.");
        if (finishedWork === root.current)
          throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
        didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
        didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
        markRootFinished(root, lanes, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
        root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
        pendingFinishedWork = finishedWork;
        pendingEffectsRoot = root;
        pendingEffectsLanes = lanes;
        pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
        pendingPassiveTransitions = transitions;
        pendingRecoverableErrors = recoverableErrors;
        pendingEffectsRenderEndTime = completedRenderEndTime;
        pendingSuspendedCommitReason = suspendedCommitReason;
        pendingDelayedCommitReason = IMMEDIATE_COMMIT;
        pendingSuspendedViewTransitionReason = null;
        finishedWork.actualDuration !== 0 || (finishedWork.subtreeFlags & 10256) !== 0 || (finishedWork.flags & 10256) !== 0 ? (root.callbackNode = null, root.callbackPriority = 0, scheduleCallback(NormalPriority$1, function() {
          trackSchedulerEvent();
          pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
          flushPassiveEffects();
          return null;
        })) : (root.callbackNode = null, root.callbackPriority = 0);
        commitErrors = null;
        commitStartTime = now2();
        suspendedCommitReason !== null && logSuspendedCommitPhase(completedRenderEndTime, commitStartTime, suspendedCommitReason, workInProgressUpdateTask);
        recoverableErrors = (finishedWork.flags & 13878) !== 0;
        if ((finishedWork.subtreeFlags & 13878) !== 0 || recoverableErrors) {
          recoverableErrors = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          transitions = getCurrentUpdatePriority();
          setCurrentUpdatePriority(2);
          spawnedLane = executionContext;
          executionContext |= CommitContext;
          try {
            commitBeforeMutationEffects(root, finishedWork, lanes);
          } finally {
            executionContext = spawnedLane, setCurrentUpdatePriority(transitions), ReactSharedInternals.T = recoverableErrors;
          }
        }
        pendingEffectsStatus = PENDING_MUTATION_PHASE;
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
      }
    }
    function flushMutationEffects() {
      if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootMutationHasEffect = (finishedWork.flags & 13878) !== 0;
        if ((finishedWork.subtreeFlags & 13878) !== 0 || rootMutationHasEffect) {
          rootMutationHasEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = getCurrentUpdatePriority();
          setCurrentUpdatePriority(2);
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          try {
            inProgressLanes = lanes, inProgressRoot = root, resetComponentEffectTimers(), commitMutationEffectsOnFiber(finishedWork, root), inProgressRoot = inProgressLanes = null, resetAfterCommit(root.containerInfo);
          } finally {
            executionContext = prevExecutionContext, setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = rootMutationHasEffect;
          }
        }
        root.current = finishedWork;
        pendingEffectsStatus = PENDING_LAYOUT_PHASE;
      }
    }
    function flushLayoutEffects() {
      if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        var suspendedViewTransitionReason = pendingSuspendedViewTransitionReason;
        if (suspendedViewTransitionReason !== null) {
          commitStartTime = now2();
          var startTime = commitEndTime, endTime = commitStartTime;
          !supportsUserTiming || endTime <= startTime || (animatingTask ? animatingTask.run(console.timeStamp.bind(console, suspendedViewTransitionReason, startTime, endTime, currentTrack, "Scheduler ", "secondary-light")) : console.timeStamp(suspendedViewTransitionReason, startTime, endTime, currentTrack, "Scheduler ", "secondary-light"));
        }
        suspendedViewTransitionReason = pendingEffectsRoot;
        startTime = pendingFinishedWork;
        endTime = pendingEffectsLanes;
        var rootHasLayoutEffect = (startTime.flags & 8772) !== 0;
        if ((startTime.subtreeFlags & 8772) !== 0 || rootHasLayoutEffect) {
          rootHasLayoutEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var _previousPriority = getCurrentUpdatePriority();
          setCurrentUpdatePriority(2);
          var _prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          try {
            inProgressLanes = endTime, inProgressRoot = suspendedViewTransitionReason, resetComponentEffectTimers(), commitLayoutEffectOnFiber(suspendedViewTransitionReason, startTime.alternate, startTime), inProgressRoot = inProgressLanes = null;
          } finally {
            executionContext = _prevExecutionContext, setCurrentUpdatePriority(_previousPriority), ReactSharedInternals.T = rootHasLayoutEffect;
          }
        }
        suspendedViewTransitionReason = pendingEffectsRenderEndTime;
        startTime = pendingSuspendedCommitReason;
        commitEndTime = now2();
        suspendedViewTransitionReason = startTime === null ? suspendedViewTransitionReason : commitStartTime;
        startTime = commitEndTime;
        endTime = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
        rootHasLayoutEffect = workInProgressUpdateTask;
        commitErrors !== null ? logCommitErrored(suspendedViewTransitionReason, startTime, commitErrors, false, rootHasLayoutEffect) : !supportsUserTiming || startTime <= suspendedViewTransitionReason || (rootHasLayoutEffect ? rootHasLayoutEffect.run(console.timeStamp.bind(console, endTime ? "Commit Interrupted View Transition" : "Commit", suspendedViewTransitionReason, startTime, currentTrack, "Scheduler ", endTime ? "error" : "secondary-dark")) : console.timeStamp(endTime ? "Commit Interrupted View Transition" : "Commit", suspendedViewTransitionReason, startTime, currentTrack, "Scheduler ", endTime ? "error" : "secondary-dark"));
        pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
      }
    }
    function flushSpawnedWork() {
      if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {
        if (pendingEffectsStatus === PENDING_SPAWNED_WORK) {
          var startViewTransitionStartTime = commitEndTime;
          commitEndTime = now2();
          var endTime = commitEndTime, abortedViewTransition = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
          !supportsUserTiming || endTime <= startViewTransitionStartTime || (animatingTask ? animatingTask.run(console.timeStamp.bind(console, abortedViewTransition ? "Interrupted View Transition" : "Starting Animation", startViewTransitionStartTime, endTime, currentTrack, "Scheduler ", abortedViewTransition ? "error" : "secondary-light")) : console.timeStamp(abortedViewTransition ? "Interrupted View Transition" : "Starting Animation", startViewTransitionStartTime, endTime, currentTrack, "Scheduler ", abortedViewTransition ? " error" : "secondary-light"));
          pendingDelayedCommitReason !== ABORTED_VIEW_TRANSITION_COMMIT && (pendingDelayedCommitReason = ANIMATION_STARTED_COMMIT);
        }
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        requestPaint();
        startViewTransitionStartTime = pendingEffectsRoot;
        var finishedWork = pendingFinishedWork;
        endTime = pendingEffectsLanes;
        abortedViewTransition = pendingRecoverableErrors;
        var rootDidHavePassiveEffects = finishedWork.actualDuration !== 0 || (finishedWork.subtreeFlags & 10256) !== 0 || (finishedWork.flags & 10256) !== 0;
        rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(startViewTransitionStartTime, startViewTransitionStartTime.pendingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
        var remainingLanes = startViewTransitionStartTime.pendingLanes;
        remainingLanes === 0 && (legacyErrorBoundariesThatAlreadyFailed = null);
        rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(startViewTransitionStartTime);
        remainingLanes = lanesToEventPriority(endTime);
        finishedWork = finishedWork.stateNode;
        if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function")
          try {
            var didError = (finishedWork.current.flags & 128) === 128;
            switch (remainingLanes) {
              case 2:
                var schedulerPriority = ImmediatePriority;
                break;
              case 8:
                schedulerPriority = UserBlockingPriority;
                break;
              case 32:
                schedulerPriority = NormalPriority$1;
                break;
              case 268435456:
                schedulerPriority = IdlePriority;
                break;
              default:
                schedulerPriority = NormalPriority$1;
            }
            injectedHook.onCommitFiberRoot(rendererID, finishedWork, schedulerPriority, didError);
          } catch (err) {
            hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %o", err));
          }
        isDevToolsPresent && startViewTransitionStartTime.memoizedUpdaters.clear();
        onCommitRoot();
        if (abortedViewTransition !== null) {
          didError = ReactSharedInternals.T;
          schedulerPriority = getCurrentUpdatePriority();
          setCurrentUpdatePriority(2);
          ReactSharedInternals.T = null;
          try {
            var onRecoverableError = startViewTransitionStartTime.onRecoverableError;
            for (finishedWork = 0;finishedWork < abortedViewTransition.length; finishedWork++) {
              var recoverableError = abortedViewTransition[finishedWork], errorInfo = makeErrorInfo(recoverableError.stack);
              runWithFiberInDEV(recoverableError.source, onRecoverableError, recoverableError.value, errorInfo);
            }
          } finally {
            ReactSharedInternals.T = didError, setCurrentUpdatePriority(schedulerPriority);
          }
        }
        (pendingEffectsLanes & 3) !== 0 && flushPendingEffects();
        ensureRootIsScheduled(startViewTransitionStartTime);
        remainingLanes = startViewTransitionStartTime.pendingLanes;
        (endTime & 261930) !== 0 && (remainingLanes & 42) !== 0 ? (nestedUpdateScheduled = true, startViewTransitionStartTime === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = startViewTransitionStartTime)) : nestedUpdateCount = 0;
        rootDidHavePassiveEffects || finalizeRender(endTime, commitEndTime);
        supportsHydration && flushHydrationEvents();
        flushSyncWorkAcrossRoots_impl(0, false);
      }
    }
    function makeErrorInfo(componentStack) {
      componentStack = { componentStack };
      Object.defineProperty(componentStack, "digest", {
        get: function() {
          console.error('You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');
        }
      });
      return componentStack;
    }
    function releaseRootPooledCache(root, remainingLanes) {
      (root.pooledCacheLanes &= remainingLanes) === 0 && (remainingLanes = root.pooledCache, remainingLanes != null && (root.pooledCache = null, releaseCache(remainingLanes)));
    }
    function flushPendingEffects() {
      flushMutationEffects();
      flushLayoutEffects();
      flushSpawnedWork();
      return flushPassiveEffects();
    }
    function flushPassiveEffects() {
      if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
        return false;
      var root = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
      pendingEffectsRemainingLanes = 0;
      var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = 32 > renderPriority ? 32 : renderPriority;
      renderPriority = ReactSharedInternals.T;
      var previousPriority = getCurrentUpdatePriority();
      try {
        setCurrentUpdatePriority(priority);
        ReactSharedInternals.T = null;
        var transitions = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        priority = pendingEffectsRoot;
        var lanes = pendingEffectsLanes;
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        pendingFinishedWork = pendingEffectsRoot = null;
        pendingEffectsLanes = 0;
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
          throw Error("Cannot flush passive effects while already rendering.");
        setCurrentTrackFromLanes(lanes);
        isFlushingPassiveEffects = true;
        didScheduleUpdateDuringPassiveEffects = false;
        var passiveEffectStartTime = 0;
        commitErrors = null;
        passiveEffectStartTime = now$1();
        if (pendingDelayedCommitReason === ANIMATION_STARTED_COMMIT) {
          var startTime = commitEndTime, endTime = passiveEffectStartTime;
          !supportsUserTiming || endTime <= startTime || (animatingTask ? animatingTask.run(console.timeStamp.bind(console, "Animating", startTime, endTime, currentTrack, "Scheduler ", "secondary-dark")) : console.timeStamp("Animating", startTime, endTime, currentTrack, "Scheduler ", "secondary-dark"));
        } else {
          startTime = commitEndTime;
          endTime = passiveEffectStartTime;
          var delayedUntilPaint = pendingDelayedCommitReason === DELAYED_PASSIVE_COMMIT;
          !supportsUserTiming || endTime <= startTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(console.timeStamp.bind(console, delayedUntilPaint ? "Waiting for Paint" : "Waiting", startTime, endTime, currentTrack, "Scheduler ", "secondary-light")) : console.timeStamp(delayedUntilPaint ? "Waiting for Paint" : "Waiting", startTime, endTime, currentTrack, "Scheduler ", "secondary-light"));
        }
        startTime = executionContext;
        executionContext |= CommitContext;
        var finishedWork = priority.current;
        resetComponentEffectTimers();
        commitPassiveUnmountOnFiber(finishedWork);
        var finishedWork$jscomp$0 = priority.current;
        finishedWork = pendingEffectsRenderEndTime;
        resetComponentEffectTimers();
        commitPassiveMountOnFiber(priority, finishedWork$jscomp$0, lanes, transitions, finishedWork);
        commitDoubleInvokeEffectsInDEV(priority);
        executionContext = startTime;
        var passiveEffectsEndTime = now$1();
        finishedWork$jscomp$0 = passiveEffectStartTime;
        finishedWork = workInProgressUpdateTask;
        commitErrors !== null ? logCommitErrored(finishedWork$jscomp$0, passiveEffectsEndTime, commitErrors, true, finishedWork) : !supportsUserTiming || passiveEffectsEndTime <= finishedWork$jscomp$0 || (finishedWork ? finishedWork.run(console.timeStamp.bind(console, "Remaining Effects", finishedWork$jscomp$0, passiveEffectsEndTime, currentTrack, "Scheduler ", "secondary-dark")) : console.timeStamp("Remaining Effects", finishedWork$jscomp$0, passiveEffectsEndTime, currentTrack, "Scheduler ", "secondary-dark"));
        finalizeRender(lanes, passiveEffectsEndTime);
        flushSyncWorkAcrossRoots_impl(0, false);
        didScheduleUpdateDuringPassiveEffects ? priority === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = priority) : nestedPassiveUpdateCount = 0;
        didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = false;
        if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function")
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, priority);
          } catch (err) {
            hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %o", err));
          }
        var stateNode = priority.current.stateNode;
        stateNode.effectDuration = 0;
        stateNode.passiveEffectDuration = 0;
        return true;
      } finally {
        setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root, remainingLanes);
      }
    }
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
      recordEffectError(sourceFiber);
      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
      rootFiber !== null && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
    }
    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
      isRunningInsertionEffect = false;
      if (sourceFiber.tag === 3)
        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
      else {
        for (;nearestMountedAncestor !== null; ) {
          if (nearestMountedAncestor.tag === 3) {
            captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);
            return;
          }
          if (nearestMountedAncestor.tag === 1) {
            var instance = nearestMountedAncestor.stateNode;
            if (typeof nearestMountedAncestor.type.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && (legacyErrorBoundariesThatAlreadyFailed === null || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
              recordEffectError(sourceFiber);
              error = createClassErrorUpdate(2);
              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
              instance !== null && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
              return;
            }
          }
          nearestMountedAncestor = nearestMountedAncestor.return;
        }
        console.error(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, error);
      }
    }
    function attachPingListener(root, wakeable, lanes) {
      var pingCache = root.pingCache;
      if (pingCache === null) {
        pingCache = root.pingCache = new PossiblyWeakMap;
        var threadIDs = new Set;
        pingCache.set(wakeable, threadIDs);
      } else
        threadIDs = pingCache.get(wakeable), threadIDs === undefined && (threadIDs = new Set, pingCache.set(wakeable, threadIDs));
      threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root, lanes), wakeable.then(pingCache, pingCache));
    }
    function pingSuspendedRoot(root, wakeable, pingedLanes) {
      var pingCache = root.pingCache;
      pingCache !== null && pingCache.delete(wakeable);
      root.pingedLanes |= root.suspendedLanes & pingedLanes;
      root.warmLanes &= ~pingedLanes;
      (pingedLanes & 127) !== 0 ? 0 > blockingUpdateTime && (blockingClampTime = blockingUpdateTime = now2(), blockingUpdateTask = createTask("Promise Resolved"), blockingUpdateType = 2) : (pingedLanes & 4194048) !== 0 && 0 > transitionUpdateTime && (transitionClampTime = transitionUpdateTime = now2(), transitionUpdateTask = createTask("Promise Resolved"), transitionUpdateType = 2);
      isConcurrentActEnvironment() && ReactSharedInternals.actQueue === null && console.error(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`);
      workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
      ensureRootIsScheduled(root);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      retryLane === 0 && (retryLane = claimNextRetryLane());
      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
      boundaryFiber !== null && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
      suspenseState !== null && (retryLane = suspenseState.retryLane);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      var retryLane = 0;
      switch (boundaryFiber.tag) {
        case 31:
        case 13:
          var retryCache = boundaryFiber.stateNode;
          var suspenseState = boundaryFiber.memoizedState;
          suspenseState !== null && (retryLane = suspenseState.retryLane);
          break;
        case 19:
          retryCache = boundaryFiber.stateNode;
          break;
        case 22:
          retryCache = boundaryFiber.stateNode._retryCache;
          break;
        default:
          throw Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      retryCache !== null && retryCache.delete(wakeable);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
      if ((parentFiber.subtreeFlags & 67117056) !== 0)
        for (parentFiber = parentFiber.child;parentFiber !== null; ) {
          var root = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
          isStrictModeFiber = isInStrictMode || isStrictModeFiber;
          fiber.tag !== 22 ? fiber.flags & 67108864 ? isStrictModeFiber && runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isStrictModeFiber) : fiber.memoizedState === null && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber) : fiber.subtreeFlags & 67108864 && runWithFiberInDEV(fiber, recursivelyTraverseAndDoubleInvokeEffectsInDEV, root, fiber, isStrictModeFiber));
          parentFiber = parentFiber.sibling;
        }
    }
    function doubleInvokeEffectsOnFiber(root, fiber) {
      setIsStrictModeForDevtools(true);
      try {
        disappearLayoutEffects(fiber), disconnectPassiveEffect(fiber), reappearLayoutEffects(root, fiber.alternate, fiber, false), reconnectPassiveEffects(root, fiber, 0, null, false, 0);
      } finally {
        setIsStrictModeForDevtools(false);
      }
    }
    function commitDoubleInvokeEffectsInDEV(root) {
      var doubleInvokeEffects = true;
      root.current.mode & 24 || (doubleInvokeEffects = false);
      recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);
    }
    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
      if ((executionContext & RenderContext) === NoContext) {
        var tag = fiber.tag;
        if (tag === 3 || tag === 1 || tag === 0 || tag === 11 || tag === 14 || tag === 15) {
          tag = getComponentNameFromFiber(fiber) || "ReactComponent";
          if (didWarnStateUpdateForNotYetMountedComponent !== null) {
            if (didWarnStateUpdateForNotYetMountedComponent.has(tag))
              return;
            didWarnStateUpdateForNotYetMountedComponent.add(tag);
          } else
            didWarnStateUpdateForNotYetMountedComponent = new Set([tag]);
          runWithFiberInDEV(fiber, function() {
            console.error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously tries to update the component. Move this work to useEffect instead.");
          });
        }
      }
    }
    function restorePendingUpdaters(root, lanes) {
      isDevToolsPresent && root.memoizedUpdaters.forEach(function(schedulingFiber) {
        addFiberToLanesMap(root, schedulingFiber, lanes);
      });
    }
    function scheduleCallback(priorityLevel, callback) {
      var actQueue = ReactSharedInternals.actQueue;
      return actQueue !== null ? (actQueue.push(callback), fakeActCallbackNode) : scheduleCallback$3(priorityLevel, callback);
    }
    function warnIfUpdatesNotWrappedWithActDEV(fiber) {
      isConcurrentActEnvironment() && ReactSharedInternals.actQueue === null && runWithFiberInDEV(fiber, function() {
        console.error(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`, getComponentNameFromFiber(fiber));
      });
    }
    function resolveFunctionForHotReloading(type) {
      if (resolveFamily === null)
        return type;
      var family = resolveFamily(type);
      return family === undefined ? type : family.current;
    }
    function resolveForwardRefForHotReloading(type) {
      if (resolveFamily === null)
        return type;
      var family = resolveFamily(type);
      return family === undefined ? type !== null && type !== undefined && typeof type.render === "function" && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }, type.displayName !== undefined && (family.displayName = type.displayName), family) : type : family.current;
    }
    function isCompatibleFamilyForHotReloading(fiber, element) {
      if (resolveFamily === null)
        return false;
      var prevType = fiber.elementType;
      element = element.type;
      var needsCompareFamilies = false, $$typeofNextType = typeof element === "object" && element !== null ? element.$$typeof : null;
      switch (fiber.tag) {
        case 1:
          typeof element === "function" && (needsCompareFamilies = true);
          break;
        case 0:
          typeof element === "function" ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
          break;
        case 11:
          $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
          break;
        case 14:
        case 15:
          $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
          break;
        default:
          return false;
      }
      return needsCompareFamilies && (fiber = resolveFamily(prevType), fiber !== undefined && fiber === resolveFamily(element)) ? true : false;
    }
    function markFailedErrorBoundaryForHotReloading(fiber) {
      resolveFamily !== null && typeof WeakSet === "function" && (failedBoundaries === null && (failedBoundaries = new WeakSet), failedBoundaries.add(fiber));
    }
    function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
      do {
        var _fiber = fiber, alternate = _fiber.alternate, child = _fiber.child, sibling = _fiber.sibling, tag = _fiber.tag;
        _fiber = _fiber.type;
        var candidateType = null;
        switch (tag) {
          case 0:
          case 15:
          case 1:
            candidateType = _fiber;
            break;
          case 11:
            candidateType = _fiber.render;
        }
        if (resolveFamily === null)
          throw Error("Expected resolveFamily to be set during hot reload.");
        var needsRender = false;
        _fiber = false;
        candidateType !== null && (candidateType = resolveFamily(candidateType), candidateType !== undefined && (staleFamilies.has(candidateType) ? _fiber = true : updatedFamilies.has(candidateType) && (tag === 1 ? _fiber = true : needsRender = true)));
        failedBoundaries !== null && (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) && (_fiber = true);
        _fiber && (fiber._debugNeedsRemount = true);
        if (_fiber || needsRender)
          alternate = enqueueConcurrentRenderForLane(fiber, 2), alternate !== null && scheduleUpdateOnFiber(alternate, fiber, 2);
        child === null || _fiber || scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
        if (sibling === null)
          break;
        fiber = sibling;
      } while (1);
    }
    function FiberNode(tag, pendingProps, key, mode) {
      this.tag = tag;
      this.key = key;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.refCleanup = this.ref = null;
      this.pendingProps = pendingProps;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = mode;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
      this.actualDuration = -0;
      this.actualStartTime = -1.1;
      this.treeBaseDuration = this.selfBaseDuration = -0;
      this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;
      this._debugNeedsRemount = false;
      this._debugHookTypes = null;
      hasBadMapPolyfill || typeof Object.preventExtensions !== "function" || Object.preventExtensions(this);
    }
    function shouldConstruct(Component) {
      Component = Component.prototype;
      return !(!Component || !Component.isReactComponent);
    }
    function createWorkInProgress(current2, pendingProps) {
      var workInProgress2 = current2.alternate;
      workInProgress2 === null ? (workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugStack = current2._debugStack, workInProgress2._debugTask = current2._debugTask, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current2.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.actualDuration = -0, workInProgress2.actualStartTime = -1.1);
      workInProgress2.flags = current2.flags & 65011712;
      workInProgress2.childLanes = current2.childLanes;
      workInProgress2.lanes = current2.lanes;
      workInProgress2.child = current2.child;
      workInProgress2.memoizedProps = current2.memoizedProps;
      workInProgress2.memoizedState = current2.memoizedState;
      workInProgress2.updateQueue = current2.updateQueue;
      pendingProps = current2.dependencies;
      workInProgress2.dependencies = pendingProps === null ? null : {
        lanes: pendingProps.lanes,
        firstContext: pendingProps.firstContext,
        _debugThenableState: pendingProps._debugThenableState
      };
      workInProgress2.sibling = current2.sibling;
      workInProgress2.index = current2.index;
      workInProgress2.ref = current2.ref;
      workInProgress2.refCleanup = current2.refCleanup;
      workInProgress2.selfBaseDuration = current2.selfBaseDuration;
      workInProgress2.treeBaseDuration = current2.treeBaseDuration;
      workInProgress2._debugInfo = current2._debugInfo;
      workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
      switch (workInProgress2.tag) {
        case 0:
        case 15:
          workInProgress2.type = resolveFunctionForHotReloading(current2.type);
          break;
        case 1:
          workInProgress2.type = resolveFunctionForHotReloading(current2.type);
          break;
        case 11:
          workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
      }
      return workInProgress2;
    }
    function resetWorkInProgress(workInProgress2, renderLanes2) {
      workInProgress2.flags &= 65011714;
      var current2 = workInProgress2.alternate;
      current2 === null ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0) : (workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type, renderLanes2 = current2.dependencies, workInProgress2.dependencies = renderLanes2 === null ? null : {
        lanes: renderLanes2.lanes,
        firstContext: renderLanes2.firstContext,
        _debugThenableState: renderLanes2._debugThenableState
      }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration);
      return workInProgress2;
    }
    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
      var fiberTag = 0, resolvedType = type;
      if (typeof type === "function")
        shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);
      else if (typeof type === "string")
        supportsResources && supportsSingletons ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : isHostSingletonType(type) ? 27 : 5) : supportsResources ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : 5) : fiberTag = supportsSingletons ? isHostSingletonType(type) ? 27 : 5 : 5;
      else
        a:
          switch (type) {
            case REACT_ACTIVITY_TYPE:
              return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            case REACT_STRICT_MODE_TYPE:
              fiberTag = 8;
              mode |= 24;
              break;
            case REACT_PROFILER_TYPE:
              return type = pendingProps, owner = mode, typeof type.id !== "string" && console.error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof type.id), key = createFiber(12, type, key, owner | 2), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, key;
            case REACT_SUSPENSE_TYPE:
              return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
            case REACT_SUSPENSE_LIST_TYPE:
              return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
            default:
              if (typeof type === "object" && type !== null)
                switch (type.$$typeof) {
                  case REACT_CONTEXT_TYPE:
                    fiberTag = 10;
                    break a;
                  case REACT_CONSUMER_TYPE:
                    fiberTag = 9;
                    break a;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = 11;
                    resolvedType = resolveForwardRefForHotReloading(resolvedType);
                    break a;
                  case REACT_MEMO_TYPE:
                    fiberTag = 14;
                    break a;
                  case REACT_LAZY_TYPE:
                    fiberTag = 16;
                    resolvedType = null;
                    break a;
                }
              resolvedType = "";
              if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0)
                resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              type === null ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
              fiberTag = owner ? typeof owner.tag === "number" ? getComponentNameFromFiber(owner) : typeof owner.name === "string" ? owner.name : null : null;
              fiberTag && (resolvedType += `

Check the render method of \`` + fiberTag + "`.");
              fiberTag = 29;
              pendingProps = Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType));
              resolvedType = null;
          }
      key = createFiber(fiberTag, pendingProps, key, mode);
      key.elementType = type;
      key.type = resolvedType;
      key.lanes = lanes;
      key._debugOwner = owner;
      return key;
    }
    function createFiberFromElement(element, mode, lanes) {
      mode = createFiberFromTypeAndProps(element.type, element.key, element.props, element._owner, mode, lanes);
      mode._debugOwner = element._owner;
      mode._debugStack = element._debugStack;
      mode._debugTask = element._debugTask;
      return mode;
    }
    function createFiberFromFragment(elements, mode, lanes, key) {
      elements = createFiber(7, elements, key, mode);
      elements.lanes = lanes;
      return elements;
    }
    function createFiberFromText(content, mode, lanes) {
      content = createFiber(6, content, null, mode);
      content.lanes = lanes;
      return content;
    }
    function createFiberFromDehydratedFragment(dehydratedNode) {
      var fiber = createFiber(18, null, null, NoMode);
      fiber.stateNode = dehydratedNode;
      return fiber;
    }
    function createFiberFromPortal(portal, mode, lanes) {
      mode = createFiber(4, portal.children !== null ? portal.children : [], portal.key, mode);
      mode.lanes = lanes;
      mode.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation
      };
      return mode;
    }
    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
      this.tag = 1;
      this.containerInfo = containerInfo;
      this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = noTimeout;
      this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
      this.callbackPriority = 0;
      this.expirationTimes = createLaneMap(-1);
      this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = createLaneMap(0);
      this.hiddenUpdates = createLaneMap(null);
      this.identifierPrefix = identifierPrefix;
      this.onUncaughtError = onUncaughtError;
      this.onCaughtError = onCaughtError;
      this.onRecoverableError = onRecoverableError;
      this.pooledCache = null;
      this.pooledCacheLanes = 0;
      this.formState = formState;
      this.incompleteTransitions = new Map;
      this.passiveEffectDuration = this.effectDuration = -0;
      this.memoizedUpdaters = new Set;
      containerInfo = this.pendingUpdatersLaneMap = [];
      for (tag = 0;31 > tag; tag++)
        containerInfo.push(new Set);
      this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
    }
    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
      containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState);
      tag = 1;
      isStrictMode === true && (tag |= 24);
      isStrictMode = createFiber(3, null, null, tag | 2);
      containerInfo.current = isStrictMode;
      isStrictMode.stateNode = containerInfo;
      tag = createCache();
      retainCache(tag);
      containerInfo.pooledCache = tag;
      retainCache(tag);
      isStrictMode.memoizedState = {
        element: initialChildren,
        isDehydrated: hydrate,
        cache: tag
      };
      initializeUpdateQueue(isStrictMode);
      return containerInfo;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function getContextForSubtree(parentComponent) {
      if (!parentComponent)
        return emptyContextObject;
      parentComponent = emptyContextObject;
      return parentComponent;
    }
    function updateContainerSync(element, container, parentComponent, callback) {
      updateContainerImpl(container.current, 2, element, container, parentComponent, callback);
      return 2;
    }
    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
      if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function")
        try {
          injectedHook.onScheduleFiberRoot(rendererID, container, element);
        } catch (err) {
          hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %o", err));
        }
      parentComponent = getContextForSubtree(parentComponent);
      container.context === null ? container.context = parentComponent : container.pendingContext = parentComponent;
      isRendering && current !== null && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = true, console.error(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, getComponentNameFromFiber(current) || "Unknown"));
      container = createUpdate(lane);
      container.payload = { element };
      callback = callback === undefined ? null : callback;
      callback !== null && (typeof callback !== "function" && console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback), container.callback = callback);
      element = enqueueUpdate(rootFiber, container, lane);
      element !== null && (startUpdateTimerByLane(lane, "root.render()", null), scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
    }
    function markRetryLaneImpl(fiber, retryLane) {
      fiber = fiber.memoizedState;
      if (fiber !== null && fiber.dehydrated !== null) {
        var a = fiber.retryLane;
        fiber.retryLane = a !== 0 && a < retryLane ? a : retryLane;
      }
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane);
      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
    }
    function getCurrentFiberForDevTools() {
      return current;
    }
    var exports2 = {};
    var assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
    Symbol.for("react.scope");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    Symbol.for("react.legacy_hidden");
    Symbol.for("react.tracing_marker");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
    Symbol.for("react.view_transition");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, rendererVersion = $$$config.rendererVersion, rendererPackageName = $$$config.rendererPackageName, extraDevToolsConfig = $$$config.extraDevToolsConfig, getPublicInstance = $$$config.getPublicInstance, getRootHostContext = $$$config.getRootHostContext, getChildHostContext = $$$config.getChildHostContext, prepareForCommit = $$$config.prepareForCommit, resetAfterCommit = $$$config.resetAfterCommit, createInstance = $$$config.createInstance;
    $$$config.cloneMutableInstance;
    var { appendInitialChild, finalizeInitialChildren, shouldSetTextContent, createTextInstance } = $$$config;
    $$$config.cloneMutableTextInstance;
    var { scheduleTimeout, cancelTimeout, noTimeout, isPrimaryRenderer } = $$$config;
    $$$config.warnsIfNotActing;
    var { supportsMutation, supportsPersistence, supportsHydration, getInstanceFromNode } = $$$config;
    $$$config.beforeActiveInstanceBlur;
    var preparePortalMount = $$$config.preparePortalMount;
    $$$config.prepareScopeUpdate;
    $$$config.getInstanceFromScope;
    var { setCurrentUpdatePriority, getCurrentUpdatePriority, resolveUpdatePriority, trackSchedulerEvent, resolveEventType, resolveEventTimeStamp, shouldAttemptEagerTransition, detachDeletedInstance } = $$$config;
    $$$config.requestPostPaintCallback;
    var { maySuspendCommit, maySuspendCommitOnUpdate, maySuspendCommitInSyncRender, preloadInstance, startSuspendingCommit, suspendInstance } = $$$config;
    $$$config.suspendOnActiveViewTransition;
    var { waitForCommitToBeReady, getSuspendedCommitReason, NotPendingTransition, HostTransitionContext, resetFormInstance, bindToConsole, supportsMicrotasks, scheduleMicrotask, supportsTestSelectors, findFiberRoot, getBoundingRect, getTextContent, isHiddenSubtree, matchAccessibilityRole, setFocusIfFocusable, setupIntersectionObserver, appendChild, appendChildToContainer, commitTextUpdate, commitMount, commitUpdate, insertBefore, insertInContainerBefore, removeChild, removeChildFromContainer, resetTextContent, hideInstance, hideTextInstance, unhideInstance, unhideTextInstance } = $$$config;
    $$$config.cancelViewTransitionName;
    $$$config.cancelRootViewTransitionName;
    $$$config.restoreRootViewTransitionName;
    $$$config.cloneRootViewTransitionContainer;
    $$$config.removeRootViewTransitionClone;
    $$$config.measureClonedInstance;
    $$$config.hasInstanceChanged;
    $$$config.hasInstanceAffectedParent;
    $$$config.startViewTransition;
    $$$config.startGestureTransition;
    $$$config.stopViewTransition;
    $$$config.getCurrentGestureOffset;
    $$$config.createViewTransitionInstance;
    var clearContainer = $$$config.clearContainer;
    $$$config.createFragmentInstance;
    $$$config.updateFragmentInstanceFiber;
    $$$config.commitNewChildToFragmentInstance;
    $$$config.deleteChildFromFragmentInstance;
    var { cloneInstance, createContainerChildSet, appendChildToContainerChildSet, finalizeContainerChildren, replaceContainerChildren, cloneHiddenInstance, cloneHiddenTextInstance, isSuspenseInstancePending, isSuspenseInstanceFallback, getSuspenseInstanceFallbackErrorDetails, registerSuspenseInstanceRetry, canHydrateFormStateMarker, isFormStateMarkerMatching, getNextHydratableSibling, getNextHydratableSiblingAfterSingleton, getFirstHydratableChild, getFirstHydratableChildWithinContainer, getFirstHydratableChildWithinActivityInstance, getFirstHydratableChildWithinSuspenseInstance, getFirstHydratableChildWithinSingleton, canHydrateInstance, canHydrateTextInstance, canHydrateActivityInstance, canHydrateSuspenseInstance, hydrateInstance, hydrateTextInstance, hydrateActivityInstance, hydrateSuspenseInstance, getNextHydratableInstanceAfterActivityInstance, getNextHydratableInstanceAfterSuspenseInstance, commitHydratedInstance, commitHydratedContainer, commitHydratedActivityInstance, commitHydratedSuspenseInstance, finalizeHydratedChildren, flushHydrationEvents } = $$$config;
    $$$config.clearActivityBoundary;
    var clearSuspenseBoundary = $$$config.clearSuspenseBoundary;
    $$$config.clearActivityBoundaryFromContainer;
    var { clearSuspenseBoundaryFromContainer, hideDehydratedBoundary, unhideDehydratedBoundary, shouldDeleteUnhydratedTailInstances, diffHydratedPropsForDevWarnings, diffHydratedTextForDevWarnings, describeHydratableInstanceForDevWarnings, validateHydratableInstance, validateHydratableTextInstance, supportsResources, isHostHoistableType, getHoistableRoot, getResource, acquireResource, releaseResource, hydrateHoistable, mountHoistable, unmountHoistable, createHoistableInstance, prepareToCommitHoistables, mayResourceSuspendCommit, preloadResource, suspendResource, supportsSingletons, resolveSingletonInstance, acquireSingletonInstance, releaseSingletonInstance, isHostSingletonType, isSingletonScope } = $$$config, valueStack = [];
    var fiberStack = [];
    var index$jscomp$0 = -1, emptyContextObject = {};
    Object.freeze(emptyContextObject);
    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log$1 = Math.log, LN2 = Math.LN2, nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, IdlePriority = Scheduler.unstable_IdlePriority, log2 = Scheduler.log, unstable_setDisableYieldValue2 = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, hasLoggedError = false, isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined", lastResetTime = 0;
    if (typeof performance === "object" && typeof performance.now === "function") {
      var localPerformance = performance;
      var getCurrentTime = function() {
        return localPerformance.now();
      };
    } else {
      var localDate = Date;
      getCurrentTime = function() {
        return localDate.now();
      };
    }
    var objectIs = typeof Object.is === "function" ? Object.is : is, reportGlobalError = typeof reportError === "function" ? reportError : function(error) {
      if (typeof window === "object" && typeof window.ErrorEvent === "function") {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event))
          return;
      } else if (typeof process === "object" && typeof process.emit === "function") {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    }, hasOwnProperty = Object.prototype.hasOwnProperty, supportsUserTiming = typeof console !== "undefined" && typeof console.timeStamp === "function" && typeof performance !== "undefined" && typeof performance.measure === "function", currentTrack = "Blocking", alreadyWarnedForDeepEquality = false, reusableComponentDevToolDetails = {
      color: "primary",
      properties: null,
      tooltipText: "",
      track: "Components "
    }, reusableComponentOptions = {
      start: -0,
      end: -0,
      detail: { devtools: reusableComponentDevToolDetails }
    }, resuableChangedPropsEntry = ["Changed Props", ""], reusableDeeplyEqualPropsEntry = [
      "Changed Props",
      "This component received deeply equal props. It might benefit from useMemo or the React Compiler in its owner."
    ], disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
    disabledLog.__reactDisabledLog = true;
    var prefix, suffix, reentry = false;
    var componentFrameCache = new (typeof WeakMap === "function" ? WeakMap : Map);
    var CapturedStacks = new WeakMap, forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), needsEscaping = /["'&<>\n\t]|^\s|\s$/, current = null, isRendering = false, hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error("Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."), NoMode = 0, valueCursor = createCursor(null);
    var rendererCursorDEV = createCursor(null);
    var renderer2CursorDEV = createCursor(null);
    var rendererSigil = {};
    var currentlyRenderingFiber$1 = null, lastContextDependency = null, isDisallowedContextReadInDEV = false, AbortControllerLocal = typeof AbortController !== "undefined" ? AbortController : function() {
      var listeners = [], signal = this.signal = {
        aborted: false,
        addEventListener: function(type, listener) {
          listeners.push(listener);
        }
      };
      this.abort = function() {
        signal.aborted = true;
        listeners.forEach(function(listener) {
          return listener();
        });
      };
    }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0,
      _currentRenderer: null,
      _currentRenderer2: null
    }, now2 = Scheduler.unstable_now, createTask = console.createTask ? console.createTask : function() {
      return null;
    }, renderStartTime = -0, commitStartTime = -0, commitEndTime = -0, commitErrors = null, profilerStartTime = -1.1, profilerEffectDuration = -0, componentEffectDuration = -0, componentEffectStartTime = -1.1, componentEffectEndTime = -1.1, componentEffectErrors = null, componentEffectSpawnedUpdate = false, blockingClampTime = -0, blockingUpdateTime = -1.1, blockingUpdateTask = null, blockingUpdateType = 0, blockingUpdateMethodName = null, blockingUpdateComponentName = null, blockingEventTime = -1.1, blockingEventType = null, blockingEventRepeatTime = -1.1, blockingSuspendedTime = -1.1, transitionClampTime = -0, transitionStartTime = -1.1, transitionUpdateTime = -1.1, transitionUpdateType = 0, transitionUpdateTask = null, transitionUpdateMethodName = null, transitionUpdateComponentName = null, transitionEventTime = -1.1, transitionEventType = null, transitionEventRepeatTime = -1.1, transitionSuspendedTime = -1.1, animatingTask = null, yieldReason = 0, yieldStartTime = -1.1, currentUpdateIsNested = false, nestedUpdateScheduled = false, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, didScheduleMicrotask_act = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, fakeActCallbackNode$1 = {}, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;
    ReactSharedInternals.S = function(transition, returnValue) {
      globalMostRecentTransitionTime = now$1();
      if (typeof returnValue === "object" && returnValue !== null && typeof returnValue.then === "function") {
        if (0 > transitionStartTime && 0 > transitionUpdateTime) {
          transitionStartTime = now2();
          var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();
          if (newEventTime !== transitionEventRepeatTime || newEventType !== transitionEventType)
            transitionEventRepeatTime = -1.1;
          transitionEventTime = newEventTime;
          transitionEventType = newEventType;
        }
        entangleAsyncAction(transition, returnValue);
      }
      prevOnStartTransitionFinish !== null && prevOnStartTransitionFinish(transition, returnValue);
    };
    var resumedCache = createCursor(null), ReactStrictModeWarnings = {
      recordUnsafeLifecycleWarnings: function() {},
      flushPendingUnsafeLifecycleWarnings: function() {},
      recordLegacyContextWarning: function() {},
      flushLegacyContextWarning: function() {},
      discardPendingWarnings: function() {}
    }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = new Set;
    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
      didWarnAboutUnsafeLifecycles.has(fiber.type) || (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true && pendingComponentWillMountWarnings.push(fiber), fiber.mode & 8 && typeof instance.UNSAFE_componentWillMount === "function" && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & 8 && typeof instance.UNSAFE_componentWillReceiveProps === "function" && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & 8 && typeof instance.UNSAFE_componentWillUpdate === "function" && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
    };
    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
      var componentWillMountUniqueNames = new Set;
      0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {
        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingComponentWillMountWarnings = []);
      var UNSAFE_componentWillMountUniqueNames = new Set;
      0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingUNSAFE_ComponentWillMountWarnings = []);
      var componentWillReceivePropsUniqueNames = new Set;
      0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
        componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingComponentWillReceivePropsWarnings = []);
      var UNSAFE_componentWillReceivePropsUniqueNames = new Set;
      0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
      var componentWillUpdateUniqueNames = new Set;
      0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingComponentWillUpdateWarnings = []);
      var UNSAFE_componentWillUpdateUniqueNames = new Set;
      0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
      if (0 < UNSAFE_componentWillMountUniqueNames.size) {
        var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
        console.error(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, sortedNames);
      }
      0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames), console.error(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state

Please update the following components: %s`, sortedNames));
      0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillUpdateUniqueNames), console.error(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, sortedNames));
      0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(`componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, sortedNames));
      0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(componentWillReceivePropsUniqueNames), console.warn(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, sortedNames));
      0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(`componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, sortedNames));
    };
    var pendingLegacyContextWarning = new Map, didWarnAboutLegacyContext = new Set;
    ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
      var strictRoot = null;
      for (var node = fiber;node !== null; )
        node.mode & 8 && (strictRoot = node), node = node.return;
      strictRoot === null ? console.error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.") : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") && (node === undefined && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
    };
    ReactStrictModeWarnings.flushLegacyContextWarning = function() {
      pendingLegacyContextWarning.forEach(function(fiberArray) {
        if (fiberArray.length !== 0) {
          var firstFiber = fiberArray[0], uniqueNames = new Set;
          fiberArray.forEach(function(fiber) {
            uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
            didWarnAboutLegacyContext.add(fiber.type);
          });
          var sortedNames = setToSortedString(uniqueNames);
          runWithFiberInDEV(firstFiber, function() {
            console.error(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://react.dev/link/legacy-context`, sortedNames);
          });
        }
      });
    };
    ReactStrictModeWarnings.discardPendingWarnings = function() {
      pendingComponentWillMountWarnings = [];
      pendingUNSAFE_ComponentWillMountWarnings = [];
      pendingComponentWillReceivePropsWarnings = [];
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
      pendingComponentWillUpdateWarnings = [];
      pendingUNSAFE_ComponentWillUpdateWarnings = [];
      pendingLegacyContextWarning = new Map;
    };
    var callComponent = {
      react_stack_bottom_frame: function(Component, props, secondArg) {
        var wasRendering = isRendering;
        isRendering = true;
        try {
          return Component(props, secondArg);
        } finally {
          isRendering = wasRendering;
        }
      }
    }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = {
      react_stack_bottom_frame: function(instance) {
        var wasRendering = isRendering;
        isRendering = true;
        try {
          return instance.render();
        } finally {
          isRendering = wasRendering;
        }
      }
    }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callComponentDidMount = {
      react_stack_bottom_frame: function(finishedWork, instance) {
        try {
          instance.componentDidMount();
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }, callComponentDidMountInDEV = callComponentDidMount.react_stack_bottom_frame.bind(callComponentDidMount), callComponentDidUpdate = {
      react_stack_bottom_frame: function(finishedWork, instance, prevProps, prevState, snapshot) {
        try {
          instance.componentDidUpdate(prevProps, prevState, snapshot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }, callComponentDidUpdateInDEV = callComponentDidUpdate.react_stack_bottom_frame.bind(callComponentDidUpdate), callComponentDidCatch = {
      react_stack_bottom_frame: function(instance, errorInfo) {
        var stack = errorInfo.stack;
        instance.componentDidCatch(errorInfo.value, {
          componentStack: stack !== null ? stack : ""
        });
      }
    }, callComponentDidCatchInDEV = callComponentDidCatch.react_stack_bottom_frame.bind(callComponentDidCatch), callComponentWillUnmount = {
      react_stack_bottom_frame: function(current2, nearestMountedAncestor, instance) {
        try {
          instance.componentWillUnmount();
        } catch (error) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error);
        }
      }
    }, callComponentWillUnmountInDEV = callComponentWillUnmount.react_stack_bottom_frame.bind(callComponentWillUnmount), callCreate = {
      react_stack_bottom_frame: function(effect) {
        var create = effect.create;
        effect = effect.inst;
        create = create();
        return effect.destroy = create;
      }
    }, callCreateInDEV = callCreate.react_stack_bottom_frame.bind(callCreate), callDestroy = {
      react_stack_bottom_frame: function(current2, nearestMountedAncestor, destroy) {
        try {
          destroy();
        } catch (error) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error);
        }
      }
    }, callDestroyInDEV = callDestroy.react_stack_bottom_frame.bind(callDestroy), callLazyInit = {
      react_stack_bottom_frame: function(lazy) {
        var init = lazy._init;
        return init(lazy._payload);
      }
    }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), SuspenseException = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."), SuspenseyCommitException = Error("Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."), SuspenseActionException = Error("Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."), noopSuspenseyCommitThenable = {
      then: function() {
        console.error('Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.');
      }
    }, suspendedThenable = null, needsToResetSuspendedThenableDEV = false, thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;
    var didWarnAboutGenerators = didWarnAboutMaps = false;
    var ownerHasKeyUseWarning = {};
    var ownerHasFunctionTypeWarning = {};
    var ownerHasSymbolTypeWarning = {};
    warnForMissingKey = function(returnFiber, workInProgress2, child) {
      if (child !== null && typeof child === "object" && child._store && (!child._store.validated && child.key == null || child._store.validated === 2)) {
        if (typeof child._store !== "object")
          throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        child._store.validated = 1;
        var componentName2 = getComponentNameFromFiber(returnFiber), componentKey = componentName2 || "null";
        if (!ownerHasKeyUseWarning[componentKey]) {
          ownerHasKeyUseWarning[componentKey] = true;
          child = child._owner;
          returnFiber = returnFiber._debugOwner;
          var currentComponentErrorInfo = "";
          returnFiber && typeof returnFiber.tag === "number" && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = `

Check the render method of \`` + componentKey + "`.");
          currentComponentErrorInfo || componentName2 && (currentComponentErrorInfo = `

Check the top-level render call using <` + componentName2 + ">.");
          var childOwnerAppendix = "";
          child != null && returnFiber !== child && (componentName2 = null, typeof child.tag === "number" ? componentName2 = getComponentNameFromFiber(child) : typeof child.name === "string" && (componentName2 = child.name), componentName2 && (childOwnerAppendix = " It was passed a child from " + componentName2 + "."));
          runWithFiberInDEV(workInProgress2, function() {
            console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);
          });
        }
      }
    };
    var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), OffscreenVisible = 1, OffscreenPassiveEffectsConnected = 2, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = false;
    var didWarnUpdateInsideUpdate = false;
    var currentlyProcessingQueue = null;
    var didReadFromEntangledAsyncAction = false, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, didWarnUncachedGetSnapshot;
    var didWarnAboutMismatchedHooksForComponent = new Set;
    var didWarnAboutUseWrappedInTryCatch = new Set;
    var didWarnAboutAsyncClientComponent = new Set;
    var didWarnAboutUseFormState = new Set;
    var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = false, ContextOnlyDispatcher = {
      readContext,
      use,
      useCallback: throwInvalidHookError,
      useContext: throwInvalidHookError,
      useEffect: throwInvalidHookError,
      useImperativeHandle: throwInvalidHookError,
      useLayoutEffect: throwInvalidHookError,
      useInsertionEffect: throwInvalidHookError,
      useMemo: throwInvalidHookError,
      useReducer: throwInvalidHookError,
      useRef: throwInvalidHookError,
      useState: throwInvalidHookError,
      useDebugValue: throwInvalidHookError,
      useDeferredValue: throwInvalidHookError,
      useTransition: throwInvalidHookError,
      useSyncExternalStore: throwInvalidHookError,
      useId: throwInvalidHookError,
      useHostTransitionStatus: throwInvalidHookError,
      useFormState: throwInvalidHookError,
      useActionState: throwInvalidHookError,
      useOptimistic: throwInvalidHookError,
      useMemoCache: throwInvalidHookError,
      useCacheRefresh: throwInvalidHookError
    };
    ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
    var HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
    HooksDispatcherOnMountInDEV = {
      readContext: function(context) {
        return readContext(context);
      },
      use,
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        mountHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountEffect(create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountLayoutEffect(create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function(initialValue) {
        currentHookNameInDev = "useRef";
        mountHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function(initialState) {
        currentHookNameInDev = "useState";
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        mountHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        mountHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        mountHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        mountHookTypesDev();
        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        mountHookTypesDev();
        return mountId();
      },
      useFormState: function(action, initialState) {
        currentHookNameInDev = "useFormState";
        mountHookTypesDev();
        warnOnUseFormStateInDev();
        return mountActionState(action, initialState);
      },
      useActionState: function(action, initialState) {
        currentHookNameInDev = "useActionState";
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function(passthrough) {
        currentHookNameInDev = "useOptimistic";
        mountHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useHostTransitionStatus,
      useMemoCache,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        mountHookTypesDev();
        return mountRefresh();
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        mountHookTypesDev();
        return mountEvent(callback);
      }
    };
    HooksDispatcherOnMountWithHookTypesInDEV = {
      readContext: function(context) {
        return readContext(context);
      },
      use,
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return mountCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        return mountEffect(create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return mountLayoutEffect(create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function(initialValue) {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function(initialState) {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return mountId();
      },
      useActionState: function(action, initialState) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return mountActionState(action, initialState);
      },
      useFormState: function(action, initialState) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function(passthrough) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useHostTransitionStatus,
      useMemoCache,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return mountRefresh();
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        updateHookTypesDev();
        return mountEvent(callback);
      }
    };
    HooksDispatcherOnUpdateInDEV = {
      readContext: function(context) {
        return readContext(context);
      },
      use,
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function() {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function() {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return updateDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return updateTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function(action) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return updateActionState(action);
      },
      useActionState: function(action) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return updateActionState(action);
      },
      useOptimistic: function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return updateOptimistic(passthrough, reducer);
      },
      useHostTransitionStatus,
      useMemoCache,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        updateHookTypesDev();
        return updateEvent(callback);
      }
    };
    HooksDispatcherOnRerenderInDEV = {
      readContext: function(context) {
        return readContext(context);
      },
      use,
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return rerenderReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function() {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function() {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return rerenderReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return rerenderDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return rerenderTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function(action) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return rerenderActionState(action);
      },
      useActionState: function(action) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useOptimistic: function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return rerenderOptimistic(passthrough, reducer);
      },
      useHostTransitionStatus,
      useMemoCache,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        updateHookTypesDev();
        return updateEvent(callback);
      }
    };
    InvalidNestedHooksDispatcherOnMountInDEV = {
      readContext: function(context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function(usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountEffect(create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountLayoutEffect(create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function(initialValue) {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function(initialState) {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        mountHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountId();
      },
      useFormState: function(action, initialState) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useActionState: function(action, initialState) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function(passthrough) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useMemoCache: function(size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        mountHookTypesDev();
        return mountRefresh();
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountEvent(callback);
      }
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV = {
      readContext: function(context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function(usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function() {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function() {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function(action) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateActionState(action);
      },
      useActionState: function(action) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateActionState(action);
      },
      useOptimistic: function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateOptimistic(passthrough, reducer);
      },
      useMemoCache: function(size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEvent(callback);
      }
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV = {
      readContext: function(context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function(usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return rerenderReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function() {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function() {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return rerenderReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function(action) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useActionState: function(action) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useOptimistic: function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderOptimistic(passthrough, reducer);
      },
      useMemoCache: function(size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEvent(callback);
      }
    };
    var fakeInternalInstance = {};
    var didWarnAboutStateAssignmentForComponent = new Set;
    var didWarnAboutUninitializedState = new Set;
    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set;
    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set;
    var didWarnAboutDirectlyAssigningPropsToState = new Set;
    var didWarnAboutUndefinedDerivedState = new Set;
    var didWarnAboutContextTypes$1 = new Set;
    var didWarnAboutChildContextTypes = new Set;
    var didWarnAboutInvalidateContextType = new Set;
    var didWarnOnInvalidCallback = new Set;
    Object.freeze(fakeInternalInstance);
    var classComponentUpdater = {
      enqueueSetState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(inst), update = createUpdate(lane);
        update.payload = payload;
        callback !== undefined && callback !== null && (warnOnInvalidCallback(callback), update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        payload !== null && (startUpdateTimerByLane(lane, "this.setState()", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      },
      enqueueReplaceState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(inst), update = createUpdate(lane);
        update.tag = ReplaceState;
        update.payload = payload;
        callback !== undefined && callback !== null && (warnOnInvalidCallback(callback), update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        payload !== null && (startUpdateTimerByLane(lane, "this.replaceState()", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      },
      enqueueForceUpdate: function(inst, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(inst), update = createUpdate(lane);
        update.tag = ForceUpdate;
        callback !== undefined && callback !== null && (warnOnInvalidCallback(callback), update.callback = callback);
        callback = enqueueUpdate(inst, update, lane);
        callback !== null && (startUpdateTimerByLane(lane, "this.forceUpdate()", inst), scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
      }
    }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error("This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."), didReceiveUpdate = false;
    var didWarnAboutBadClass = {};
    var didWarnAboutContextTypeOnFunctionComponent = {};
    var didWarnAboutContextTypes = {};
    var didWarnAboutGetDerivedStateOnFunctionComponent = {};
    var didWarnAboutReassigningProps = false;
    var didWarnAboutRevealOrder = {};
    var didWarnAboutTailOptions = {};
    var SUSPENDED_MARKER = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    }, hasWarnedAboutUsingNoValuePropOnContextProvider = false, didWarnAboutUndefinedSnapshotBeforeUpdate = null;
    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set;
    var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, inHydratedSubtree = false, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {
      getCacheForType: function(resourceType) {
        var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
        cacheForType === undefined && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
        return cacheForType;
      },
      cacheSignal: function() {
        return readContext(CacheContext).controller.signal;
      },
      getOwner: function() {
        return current;
      }
    }, COMPONENT_TYPE = 0, HAS_PSEUDO_CLASS_TYPE = 1, ROLE_TYPE = 2, TEST_NAME_TYPE = 3, TEXT_TYPE = 4;
    if (typeof Symbol === "function" && Symbol.for) {
      var symbolFor = Symbol.for;
      COMPONENT_TYPE = symbolFor("selector.component");
      HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
      ROLE_TYPE = symbolFor("selector.role");
      TEST_NAME_TYPE = symbolFor("selector.test_id");
      TEXT_TYPE = symbolFor("selector.text");
    }
    var commitHooks = [], PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootSuspendedAtTheShell = 6, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, SuspendedOnAction = 9, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, workInProgressUpdateTask = null, legacyErrorBoundariesThatAlreadyFailed = null, IMMEDIATE_COMMIT = 0, ABORTED_VIEW_TRANSITION_COMMIT = 1, DELAYED_PASSIVE_COMMIT = 2, ANIMATION_STARTED_COMMIT = 3, NO_PENDING_EFFECTS = 0, PENDING_MUTATION_PHASE = 1, PENDING_LAYOUT_PHASE = 2, PENDING_AFTER_MUTATION_PHASE = 3, PENDING_SPAWNED_WORK = 4, PENDING_PASSIVE_PHASE = 5, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingEffectsRenderEndTime = -0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, pendingSuspendedCommitReason = null, pendingDelayedCommitReason = IMMEDIATE_COMMIT, pendingSuspendedViewTransitionReason = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = false, didScheduleUpdateDuringPassiveEffects = false, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = false, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = false;
    var didWarnAboutUpdateInRenderForAnotherComponent = new Set;
    var fakeActCallbackNode = {}, resolveFamily = null, failedBoundaries = null;
    var hasBadMapPolyfill = false;
    try {
      var nonExtensibleObject = Object.preventExtensions({});
      new Map([[nonExtensibleObject, null]]);
      new Set([nonExtensibleObject]);
    } catch (e) {
      hasBadMapPolyfill = true;
    }
    var didWarnAboutNestedUpdates = false;
    var didWarnAboutFindNodeInStrictMode = {};
    var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, scheduleRetry = null, setErrorHandler = null, setSuspenseHandler = null;
    overrideHookState = function(fiber, id, path, value) {
      id = findHook(fiber, id);
      id !== null && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), path !== null && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateDeletePath = function(fiber, id, path) {
      id = findHook(fiber, id);
      id !== null && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), path !== null && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
      id = findHook(fiber, id);
      id !== null && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), oldPath !== null && scheduleUpdateOnFiber(oldPath, fiber, 2));
    };
    overrideProps = function(fiber, path, value) {
      fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      path = enqueueConcurrentRenderForLane(fiber, 2);
      path !== null && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropsDeletePath = function(fiber, path) {
      fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      path = enqueueConcurrentRenderForLane(fiber, 2);
      path !== null && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropsRenamePath = function(fiber, oldPath, newPath) {
      fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      oldPath = enqueueConcurrentRenderForLane(fiber, 2);
      oldPath !== null && scheduleUpdateOnFiber(oldPath, fiber, 2);
    };
    scheduleUpdate = function(fiber) {
      var root = enqueueConcurrentRenderForLane(fiber, 2);
      root !== null && scheduleUpdateOnFiber(root, fiber, 2);
    };
    scheduleRetry = function(fiber) {
      var lane = claimNextRetryLane(), root = enqueueConcurrentRenderForLane(fiber, lane);
      root !== null && scheduleUpdateOnFiber(root, fiber, lane);
    };
    setErrorHandler = function(newShouldErrorImpl) {
      shouldErrorImpl = newShouldErrorImpl;
    };
    setSuspenseHandler = function(newShouldSuspendImpl) {
      shouldSuspendImpl = newShouldSuspendImpl;
    };
    exports2.attemptContinuousHydration = function(fiber) {
      if (fiber.tag === 13 || fiber.tag === 31) {
        var root = enqueueConcurrentRenderForLane(fiber, 67108864);
        root !== null && scheduleUpdateOnFiber(root, fiber, 67108864);
        markRetryLaneIfNotHydrated(fiber, 67108864);
      }
    };
    exports2.attemptHydrationAtCurrentPriority = function(fiber) {
      if (fiber.tag === 13 || fiber.tag === 31) {
        var lane = requestUpdateLane(fiber);
        lane = getBumpedLaneForHydrationByLane(lane);
        var root = enqueueConcurrentRenderForLane(fiber, lane);
        root !== null && scheduleUpdateOnFiber(root, fiber, lane);
        markRetryLaneIfNotHydrated(fiber, lane);
      }
    };
    exports2.attemptSynchronousHydration = function(fiber) {
      switch (fiber.tag) {
        case 3:
          fiber = fiber.stateNode;
          if (fiber.current.memoizedState.isDehydrated) {
            var lanes = getHighestPriorityLanes(fiber.pendingLanes);
            if (lanes !== 0) {
              fiber.pendingLanes |= 2;
              for (fiber.entangledLanes |= 2;lanes; ) {
                var lane = 1 << 31 - clz32(lanes);
                fiber.entanglements[1] |= lane;
                lanes &= ~lane;
              }
              ensureRootIsScheduled(fiber);
              (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, false));
            }
          }
          break;
        case 31:
        case 13:
          lanes = enqueueConcurrentRenderForLane(fiber, 2), lanes !== null && scheduleUpdateOnFiber(lanes, fiber, 2), flushSyncWork(), markRetryLaneIfNotHydrated(fiber, 2);
      }
    };
    exports2.batchedUpdates = function(fn, a) {
      return fn(a);
    };
    exports2.createComponentSelector = function(component) {
      return { $$typeof: COMPONENT_TYPE, value: component };
    };
    exports2.createContainer = function(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
      return createFiberRoot(containerInfo, tag, false, null, hydrationCallbacks, isStrictMode, identifierPrefix, null, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator);
    };
    exports2.createHasPseudoClassSelector = function(selectors) {
      return { $$typeof: HAS_PSEUDO_CLASS_TYPE, value: selectors };
    };
    exports2.createHydrationContainer = function(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, transitionCallbacks, formState) {
      initialChildren = createFiberRoot(containerInfo, tag, true, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator);
      initialChildren.context = getContextForSubtree(null);
      containerInfo = initialChildren.current;
      tag = requestUpdateLane(containerInfo);
      tag = getBumpedLaneForHydrationByLane(tag);
      hydrationCallbacks = createUpdate(tag);
      hydrationCallbacks.callback = callback !== undefined && callback !== null ? callback : null;
      enqueueUpdate(containerInfo, hydrationCallbacks, tag);
      startUpdateTimerByLane(tag, "hydrateRoot()", null);
      callback = tag;
      initialChildren.current.lanes = callback;
      markRootUpdated$1(initialChildren, callback);
      ensureRootIsScheduled(initialChildren);
      return initialChildren;
    };
    exports2.createPortal = function(children, containerInfo, implementation) {
      var key = 3 < arguments.length && arguments[3] !== undefined ? arguments[3] : null;
      try {
        testStringCoercion(key);
        var JSCompiler_inline_result = false;
      } catch (e$6) {
        JSCompiler_inline_result = true;
      }
      JSCompiler_inline_result && (console.error("The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", typeof Symbol === "function" && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"), testStringCoercion(key));
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: key == null ? null : "" + key,
        children,
        containerInfo,
        implementation
      };
    };
    exports2.createRoleSelector = function(role) {
      return { $$typeof: ROLE_TYPE, value: role };
    };
    exports2.createTestNameSelector = function(id) {
      return { $$typeof: TEST_NAME_TYPE, value: id };
    };
    exports2.createTextSelector = function(text) {
      return { $$typeof: TEXT_TYPE, value: text };
    };
    exports2.defaultOnCaughtError = function(error) {
      var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.", recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + ".");
      typeof error === "object" && error !== null && typeof error.environmentName === "string" ? bindToConsole("error", [`%o

%s

%s
`, error, componentNameMessage, recreateMessage], error.environmentName)() : console.error(`%o

%s

%s
`, error, componentNameMessage, recreateMessage);
    };
    exports2.defaultOnRecoverableError = function(error) {
      reportGlobalError(error);
    };
    exports2.defaultOnUncaughtError = function(error) {
      reportGlobalError(error);
      console.warn(`%s

%s
`, componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.", `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://react.dev/link/error-boundaries to learn more about error boundaries.`);
    };
    exports2.deferredUpdates = function(fn) {
      var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();
      try {
        return setCurrentUpdatePriority(32), ReactSharedInternals.T = null, fn();
      } finally {
        setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition;
      }
    };
    exports2.discreteUpdates = function(fn, a, b, c, d) {
      var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();
      try {
        return setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn(a, b, c, d);
      } finally {
        setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS);
      }
    };
    exports2.findAllNodes = findAllNodes;
    exports2.findBoundingRects = function(hostRoot, selectors) {
      if (!supportsTestSelectors)
        throw Error("Test selector API is not supported by this renderer.");
      selectors = findAllNodes(hostRoot, selectors);
      hostRoot = [];
      for (var i = 0;i < selectors.length; i++)
        hostRoot.push(getBoundingRect(selectors[i]));
      for (selectors = hostRoot.length - 1;0 < selectors; selectors--) {
        i = hostRoot[selectors];
        for (var targetLeft = i.x, targetRight = targetLeft + i.width, targetTop = i.y, targetBottom = targetTop + i.height, j = selectors - 1;0 <= j; j--)
          if (selectors !== j) {
            var otherRect = hostRoot[j], otherLeft = otherRect.x, otherRight = otherLeft + otherRect.width, otherTop = otherRect.y, otherBottom = otherTop + otherRect.height;
            if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {
              hostRoot.splice(selectors, 1);
              break;
            } else if (!(targetLeft !== otherLeft || i.width !== otherRect.width || otherBottom < targetTop || otherTop > targetBottom)) {
              otherTop > targetTop && (otherRect.height += otherTop - targetTop, otherRect.y = targetTop);
              otherBottom < targetBottom && (otherRect.height = targetBottom - otherTop);
              hostRoot.splice(selectors, 1);
              break;
            } else if (!(targetTop !== otherTop || i.height !== otherRect.height || otherRight < targetLeft || otherLeft > targetRight)) {
              otherLeft > targetLeft && (otherRect.width += otherLeft - targetLeft, otherRect.x = targetLeft);
              otherRight < targetRight && (otherRect.width = targetRight - otherLeft);
              hostRoot.splice(selectors, 1);
              break;
            }
          }
      }
      return hostRoot;
    };
    exports2.findHostInstance = function(component) {
      var fiber = component._reactInternals;
      if (fiber === undefined) {
        if (typeof component.render === "function")
          throw Error("Unable to find node on an unmounted component.");
        component = Object.keys(component).join(",");
        throw Error("Argument appears to not be a ReactComponent. Keys: " + component);
      }
      component = findCurrentHostFiber(fiber);
      return component === null ? null : getPublicInstance(component.stateNode);
    };
    exports2.findHostInstanceWithNoPortals = function(fiber) {
      fiber = findCurrentFiberUsingSlowPath(fiber);
      fiber = fiber !== null ? findCurrentHostFiberWithNoPortalsImpl(fiber) : null;
      return fiber === null ? null : getPublicInstance(fiber.stateNode);
    };
    exports2.findHostInstanceWithWarning = function(component, methodName) {
      var fiber = component._reactInternals;
      if (fiber === undefined) {
        if (typeof component.render === "function")
          throw Error("Unable to find node on an unmounted component.");
        component = Object.keys(component).join(",");
        throw Error("Argument appears to not be a ReactComponent. Keys: " + component);
      }
      component = findCurrentHostFiber(fiber);
      if (component === null)
        return null;
      if (component.mode & 8) {
        var componentName2 = getComponentNameFromFiber(fiber) || "Component";
        didWarnAboutFindNodeInStrictMode[componentName2] || (didWarnAboutFindNodeInStrictMode[componentName2] = true, runWithFiberInDEV(component, function() {
          fiber.mode & 8 ? console.error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node", methodName, methodName, componentName2) : console.error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node", methodName, methodName, componentName2);
        }));
      }
      return getPublicInstance(component.stateNode);
    };
    exports2.flushPassiveEffects = flushPendingEffects;
    exports2.flushSyncFromReconciler = function(fn) {
      var prevExecutionContext = executionContext;
      executionContext |= 1;
      var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();
      try {
        if (setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn)
          return fn();
      } finally {
        setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext = prevExecutionContext, (executionContext & (RenderContext | CommitContext)) === NoContext && flushSyncWorkAcrossRoots_impl(0, false);
      }
    };
    exports2.flushSyncWork = flushSyncWork;
    exports2.focusWithin = function(hostRoot, selectors) {
      if (!supportsTestSelectors)
        throw Error("Test selector API is not supported by this renderer.");
      hostRoot = findFiberRootForHostRoot(hostRoot);
      selectors = findPaths(hostRoot, selectors);
      selectors = Array.from(selectors);
      for (hostRoot = 0;hostRoot < selectors.length; ) {
        var fiber = selectors[hostRoot++], tag = fiber.tag;
        if (!isHiddenSubtree(fiber)) {
          if ((tag === 5 || tag === 26 || tag === 27) && setFocusIfFocusable(fiber.stateNode))
            return true;
          for (fiber = fiber.child;fiber !== null; )
            selectors.push(fiber), fiber = fiber.sibling;
        }
      }
      return false;
    };
    exports2.getFindAllNodesFailureDescription = function(hostRoot, selectors) {
      if (!supportsTestSelectors)
        throw Error("Test selector API is not supported by this renderer.");
      var maxSelectorIndex = 0, matchedNames = [];
      hostRoot = [findFiberRootForHostRoot(hostRoot), 0];
      for (var index = 0;index < hostRoot.length; ) {
        var fiber = hostRoot[index++], tag = fiber.tag, selectorIndex = hostRoot[index++], selector = selectors[selectorIndex];
        if (tag !== 5 && tag !== 26 && tag !== 27 || !isHiddenSubtree(fiber)) {
          if (matchSelector(fiber, selector) && (matchedNames.push(selectorToString(selector)), selectorIndex++, selectorIndex > maxSelectorIndex && (maxSelectorIndex = selectorIndex)), selectorIndex < selectors.length)
            for (fiber = fiber.child;fiber !== null; )
              hostRoot.push(fiber, selectorIndex), fiber = fiber.sibling;
        }
      }
      if (maxSelectorIndex < selectors.length) {
        for (hostRoot = [];maxSelectorIndex < selectors.length; maxSelectorIndex++)
          hostRoot.push(selectorToString(selectors[maxSelectorIndex]));
        return `findAllNodes was able to match part of the selector:
  ` + (matchedNames.join(" > ") + `

No matching component was found for:
  `) + hostRoot.join(" > ");
      }
      return null;
    };
    exports2.getPublicRootInstance = function(container) {
      container = container.current;
      if (!container.child)
        return null;
      switch (container.child.tag) {
        case 27:
        case 5:
          return getPublicInstance(container.child.stateNode);
        default:
          return container.child.stateNode;
      }
    };
    exports2.injectIntoDevTools = function() {
      var internals = {
        bundleType: 1,
        version: rendererVersion,
        rendererPackageName,
        currentDispatcherRef: ReactSharedInternals,
        reconcilerVersion: "19.2.0"
      };
      extraDevToolsConfig !== null && (internals.rendererConfig = extraDevToolsConfig);
      internals.overrideHookState = overrideHookState;
      internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
      internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
      internals.overrideProps = overrideProps;
      internals.overridePropsDeletePath = overridePropsDeletePath;
      internals.overridePropsRenamePath = overridePropsRenamePath;
      internals.scheduleUpdate = scheduleUpdate;
      internals.scheduleRetry = scheduleRetry;
      internals.setErrorHandler = setErrorHandler;
      internals.setSuspenseHandler = setSuspenseHandler;
      internals.scheduleRefresh = scheduleRefresh;
      internals.scheduleRoot = scheduleRoot;
      internals.setRefreshHandler = setRefreshHandler;
      internals.getCurrentFiber = getCurrentFiberForDevTools;
      return injectInternals(internals);
    };
    exports2.isAlreadyRendering = isAlreadyRendering;
    exports2.observeVisibleRects = function(hostRoot, selectors, callback, options) {
      function commitHook() {
        var nextInstanceRoots = findAllNodes(hostRoot, selectors);
        instanceRoots.forEach(function(target) {
          0 > nextInstanceRoots.indexOf(target) && unobserve(target);
        });
        nextInstanceRoots.forEach(function(target) {
          0 > instanceRoots.indexOf(target) && observe(target);
        });
      }
      if (!supportsTestSelectors)
        throw Error("Test selector API is not supported by this renderer.");
      var instanceRoots = findAllNodes(hostRoot, selectors);
      callback = setupIntersectionObserver(instanceRoots, callback, options);
      var { disconnect, observe, unobserve } = callback;
      commitHooks.push(commitHook);
      return {
        disconnect: function() {
          var index = commitHooks.indexOf(commitHook);
          0 <= index && commitHooks.splice(index, 1);
          disconnect();
        }
      };
    };
    exports2.shouldError = function(fiber) {
      return shouldErrorImpl(fiber);
    };
    exports2.shouldSuspend = function(fiber) {
      return shouldSuspendImpl(fiber);
    };
    exports2.startHostTransition = function(formFiber, pendingState, action, formData) {
      if (formFiber.tag !== 5)
        throw Error("Expected the form instance to be a HostComponent. This is a bug in React.");
      var queue = ensureFormComponentIsStateful(formFiber).queue;
      startHostActionTimer(formFiber);
      startTransition(formFiber, queue, pendingState, NotPendingTransition, action === null ? noop : function() {
        ReactSharedInternals.T === null && console.error("requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition.");
        var stateHook = ensureFormComponentIsStateful(formFiber);
        stateHook.next === null && (stateHook = formFiber.alternate.memoizedState);
        dispatchSetStateInternal(formFiber, stateHook.next.queue, {}, requestUpdateLane(formFiber));
        return action(formData);
      });
    };
    exports2.updateContainer = function(element, container, parentComponent, callback) {
      var current2 = container.current, lane = requestUpdateLane(current2);
      updateContainerImpl(current2, lane, element, container, parentComponent, callback);
      return lane;
    };
    exports2.updateContainerSync = updateContainerSync;
    return exports2;
  }, module.exports.default = module.exports, Object.defineProperty(module.exports, "__esModule", { value: true });
});

// ../../node_modules/.pnpm/react-reconciler@0.33.0_react@19.2.3/node_modules/react-reconciler/index.js
var require_react_reconciler = __commonJS((exports, module) => {
  if (false) {} else {
    module.exports = require_react_reconciler_development();
  }
});

// ../../node_modules/.pnpm/react-reconciler@0.33.0_react@19.2.3/node_modules/react-reconciler/cjs/react-reconciler-constants.development.js
var require_react_reconciler_constants_development = __commonJS((exports) => {
  exports.ConcurrentRoot = 1, exports.ContinuousEventPriority = 8, exports.DefaultEventPriority = 32, exports.DiscreteEventPriority = 2, exports.IdleEventPriority = 268435456, exports.LegacyRoot = 0, exports.NoEventPriority = 0;
});

// ../../node_modules/.pnpm/react-reconciler@0.33.0_react@19.2.3/node_modules/react-reconciler/constants.js
var require_constants = __commonJS((exports, module) => {
  if (false) {} else {
    module.exports = require_react_reconciler_constants_development();
  }
});

// ../../node_modules/.pnpm/react@19.2.3/node_modules/react/cjs/react-jsx-dev-runtime.development.js
var require_react_jsx_dev_runtime_development = __commonJS((exports) => {
  var React3 = __toESM(require_react());
  (function() {
    function getComponentNameFromType(type) {
      if (type == null)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x2) {}
        }
      return null;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = false;
      } catch (e) {
        JSCompiler_inline_result = true;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
        return testStringCoercion(value);
      }
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE)
        return "<>";
      if (typeof type === "object" && type !== null && type.$$typeof === REACT_LAZY_TYPE)
        return "<...>";
      try {
        var name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x2) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return dispatcher === null ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning)
          return false;
      }
      return config.key !== undefined;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
      }
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
      componentName = this.props.ref;
      return componentName !== undefined ? componentName : null;
    }
    function ReactElement(type, key, props, owner, debugStack, debugTask) {
      var refProp = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        props,
        _owner: owner
      };
      (refProp !== undefined ? refProp : null) !== null ? Object.defineProperty(type, "ref", {
        enumerable: false,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
      var children = config.children;
      if (children !== undefined)
        if (isStaticChildren)
          if (isArrayImpl(children)) {
            for (isStaticChildren = 0;isStaticChildren < children.length; isStaticChildren++)
              validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
          } else
            console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else
          validateChildKeys(children);
      if (hasOwnProperty.call(config, "key")) {
        children = getComponentNameFromType(type);
        var keys = Object.keys(config).filter(function(k) {
          return k !== "key";
        });
        isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
        didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = true);
      }
      children = null;
      maybeKey !== undefined && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
      hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          propName !== "key" && (maybeKey[propName] = config[propName]);
      } else
        maybeKey = config;
      children && defineKeyPropWarningGetter(maybeKey, typeof type === "function" ? type.displayName || type.name || "Unknown" : type);
      return ReactElement(type, children, maybeKey, getOwner(), debugStack, debugTask);
    }
    function validateChildKeys(node) {
      isValidElement(node) ? node._store && (node._store.validated = 1) : typeof node === "object" && node !== null && node.$$typeof === REACT_LAZY_TYPE && (node._payload.status === "fulfilled" ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
    }
    function isValidElement(object) {
      return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React3.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
      return null;
    };
    React3 = {
      react_stack_bottom_frame: function(callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React3.react_stack_bottom_frame.bind(React3, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren) {
      var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(type, config, maybeKey, isStaticChildren, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
  })();
});

// ../../node_modules/.pnpm/react@19.2.3/node_modules/react/jsx-dev-runtime.js
var require_jsx_dev_runtime = __commonJS((exports, module) => {
  var react_jsx_dev_runtime_development = __toESM(require_react_jsx_dev_runtime_development());
  if (false) {} else {
    module.exports = react_jsx_dev_runtime_development;
  }
});

// ../../node_modules/.pnpm/react-dom@19.2.3_react@19.2.3/node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS((exports) => {
  var React4 = __toESM(require_react());
  (function() {
    function noop() {}
    function testStringCoercion(value) {
      return "" + value;
    }
    function createPortal$1(children, containerInfo, implementation) {
      var key = 3 < arguments.length && arguments[3] !== undefined ? arguments[3] : null;
      try {
        testStringCoercion(key);
        var JSCompiler_inline_result = false;
      } catch (e) {
        JSCompiler_inline_result = true;
      }
      JSCompiler_inline_result && (console.error("The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", typeof Symbol === "function" && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"), testStringCoercion(key));
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: key == null ? null : "" + key,
        children,
        containerInfo,
        implementation
      };
    }
    function getCrossOriginStringAs(as, input) {
      if (as === "font")
        return "";
      if (typeof input === "string")
        return input === "use-credentials" ? input : "";
    }
    function getValueDescriptorExpectingObjectForWarning(thing) {
      return thing === null ? "`null`" : thing === undefined ? "`undefined`" : thing === "" ? "an empty string" : 'something with type "' + typeof thing + '"';
    }
    function getValueDescriptorExpectingEnumForWarning(thing) {
      return thing === null ? "`null`" : thing === undefined ? "`undefined`" : thing === "" ? "an empty string" : typeof thing === "string" ? JSON.stringify(thing) : typeof thing === "number" ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      dispatcher === null && console.error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return dispatcher;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var Internals = {
      d: {
        f: noop,
        r: function() {
          throw Error("Invalid form element. requestFormReset must be passed a form that was rendered by React.");
        },
        D: noop,
        C: noop,
        L: noop,
        m: noop,
        X: noop,
        S: noop,
        M: noop
      },
      p: 0,
      findDOMNode: null
    }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React4.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    typeof Map === "function" && Map.prototype != null && typeof Map.prototype.forEach === "function" && typeof Set === "function" && Set.prototype != null && typeof Set.prototype.clear === "function" && typeof Set.prototype.forEach === "function" || console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
    exports.createPortal = function(children, container) {
      var key = 2 < arguments.length && arguments[2] !== undefined ? arguments[2] : null;
      if (!container || container.nodeType !== 1 && container.nodeType !== 9 && container.nodeType !== 11)
        throw Error("Target container is not a DOM element.");
      return createPortal$1(children, container, null, key);
    };
    exports.flushSync = function(fn) {
      var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
      try {
        if (ReactSharedInternals.T = null, Internals.p = 2, fn)
          return fn();
      } finally {
        ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
      }
    };
    exports.preconnect = function(href, options) {
      typeof href === "string" && href ? options != null && typeof options !== "object" ? console.error("ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.", getValueDescriptorExpectingEnumForWarning(options)) : options != null && typeof options.crossOrigin !== "string" && console.error("ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.", getValueDescriptorExpectingObjectForWarning(options.crossOrigin)) : console.error("ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      typeof href === "string" && (options ? (options = options.crossOrigin, options = typeof options === "string" ? options === "use-credentials" ? options : "" : undefined) : options = null, Internals.d.C(href, options));
    };
    exports.prefetchDNS = function(href) {
      if (typeof href !== "string" || !href)
        console.error("ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      else if (1 < arguments.length) {
        var options = arguments[1];
        typeof options === "object" && options.hasOwnProperty("crossOrigin") ? console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", getValueDescriptorExpectingEnumForWarning(options)) : console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", getValueDescriptorExpectingEnumForWarning(options));
      }
      typeof href === "string" && Internals.d.D(href);
    };
    exports.preinit = function(href, options) {
      typeof href === "string" && href ? options == null || typeof options !== "object" ? console.error("ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.", getValueDescriptorExpectingEnumForWarning(options)) : options.as !== "style" && options.as !== "script" && console.error('ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".', getValueDescriptorExpectingEnumForWarning(options.as)) : console.error("ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      if (typeof href === "string" && options && typeof options.as === "string") {
        var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = typeof options.integrity === "string" ? options.integrity : undefined, fetchPriority = typeof options.fetchPriority === "string" ? options.fetchPriority : undefined;
        as === "style" ? Internals.d.S(href, typeof options.precedence === "string" ? options.precedence : undefined, {
          crossOrigin,
          integrity,
          fetchPriority
        }) : as === "script" && Internals.d.X(href, {
          crossOrigin,
          integrity,
          fetchPriority,
          nonce: typeof options.nonce === "string" ? options.nonce : undefined
        });
      }
    };
    exports.preinitModule = function(href, options) {
      var encountered = "";
      typeof href === "string" && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      options !== undefined && typeof options !== "object" ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && ("as" in options) && options.as !== "script" && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
      if (encountered)
        console.error("ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s", encountered);
      else
        switch (encountered = options && typeof options.as === "string" ? options.as : "script", encountered) {
          case "script":
            break;
          default:
            encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error('ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)', encountered, href);
        }
      if (typeof href === "string")
        if (typeof options === "object" && options !== null) {
          if (options.as == null || options.as === "script")
            encountered = getCrossOriginStringAs(options.as, options.crossOrigin), Internals.d.M(href, {
              crossOrigin: encountered,
              integrity: typeof options.integrity === "string" ? options.integrity : undefined,
              nonce: typeof options.nonce === "string" ? options.nonce : undefined
            });
        } else
          options == null && Internals.d.M(href);
    };
    exports.preload = function(href, options) {
      var encountered = "";
      typeof href === "string" && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      options == null || typeof options !== "object" ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : typeof options.as === "string" && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
      encountered && console.error('ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s', encountered);
      if (typeof href === "string" && typeof options === "object" && options !== null && typeof options.as === "string") {
        encountered = options.as;
        var crossOrigin = getCrossOriginStringAs(encountered, options.crossOrigin);
        Internals.d.L(href, encountered, {
          crossOrigin,
          integrity: typeof options.integrity === "string" ? options.integrity : undefined,
          nonce: typeof options.nonce === "string" ? options.nonce : undefined,
          type: typeof options.type === "string" ? options.type : undefined,
          fetchPriority: typeof options.fetchPriority === "string" ? options.fetchPriority : undefined,
          referrerPolicy: typeof options.referrerPolicy === "string" ? options.referrerPolicy : undefined,
          imageSrcSet: typeof options.imageSrcSet === "string" ? options.imageSrcSet : undefined,
          imageSizes: typeof options.imageSizes === "string" ? options.imageSizes : undefined,
          media: typeof options.media === "string" ? options.media : undefined
        });
      }
    };
    exports.preloadModule = function(href, options) {
      var encountered = "";
      typeof href === "string" && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      options !== undefined && typeof options !== "object" ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && ("as" in options) && typeof options.as !== "string" && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
      encountered && console.error('ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s', encountered);
      typeof href === "string" && (options ? (encountered = getCrossOriginStringAs(options.as, options.crossOrigin), Internals.d.m(href, {
        as: typeof options.as === "string" && options.as !== "script" ? options.as : undefined,
        crossOrigin: encountered,
        integrity: typeof options.integrity === "string" ? options.integrity : undefined
      })) : Internals.d.m(href));
    };
    exports.requestFormReset = function(form) {
      Internals.d.r(form);
    };
    exports.unstable_batchedUpdates = function(fn, a2) {
      return fn(a2);
    };
    exports.useFormState = function(action, initialState, permalink) {
      return resolveDispatcher().useFormState(action, initialState, permalink);
    };
    exports.useFormStatus = function() {
      return resolveDispatcher().useHostTransitionStatus();
    };
    exports.version = "19.2.3";
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
});

// ../../node_modules/.pnpm/react-dom@19.2.3_react@19.2.3/node_modules/react-dom/index.js
var require_react_dom = __commonJS((exports, module) => {
  var react_dom_development = __toESM(require_react_dom_development());
  if (false) {} else {
    module.exports = react_dom_development;
  }
});

// ../../node_modules/.pnpm/react@19.2.3/node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS((exports) => {
  var React7 = __toESM(require_react());
  (function() {
    function getComponentNameFromType(type) {
      if (type == null)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x2) {}
        }
      return null;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = false;
      } catch (e) {
        JSCompiler_inline_result = true;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
        return testStringCoercion(value);
      }
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE)
        return "<>";
      if (typeof type === "object" && type !== null && type.$$typeof === REACT_LAZY_TYPE)
        return "<...>";
      try {
        var name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x2) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return dispatcher === null ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning)
          return false;
      }
      return config.key !== undefined;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
      }
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
      componentName = this.props.ref;
      return componentName !== undefined ? componentName : null;
    }
    function ReactElement(type, key, props, owner, debugStack, debugTask) {
      var refProp = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        props,
        _owner: owner
      };
      (refProp !== undefined ? refProp : null) !== null ? Object.defineProperty(type, "ref", {
        enumerable: false,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
      var children = config.children;
      if (children !== undefined)
        if (isStaticChildren)
          if (isArrayImpl(children)) {
            for (isStaticChildren = 0;isStaticChildren < children.length; isStaticChildren++)
              validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
          } else
            console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else
          validateChildKeys(children);
      if (hasOwnProperty.call(config, "key")) {
        children = getComponentNameFromType(type);
        var keys = Object.keys(config).filter(function(k) {
          return k !== "key";
        });
        isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
        didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = true);
      }
      children = null;
      maybeKey !== undefined && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
      hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          propName !== "key" && (maybeKey[propName] = config[propName]);
      } else
        maybeKey = config;
      children && defineKeyPropWarningGetter(maybeKey, typeof type === "function" ? type.displayName || type.name || "Unknown" : type);
      return ReactElement(type, children, maybeKey, getOwner(), debugStack, debugTask);
    }
    function validateChildKeys(node) {
      isValidElement(node) ? node._store && (node._store.validated = 1) : typeof node === "object" && node !== null && node.$$typeof === REACT_LAZY_TYPE && (node._payload.status === "fulfilled" ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
    }
    function isValidElement(object) {
      return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React7.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
      return null;
    };
    React7 = {
      react_stack_bottom_frame: function(callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React7.react_stack_bottom_frame.bind(React7, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsx = function(type, config, maybeKey) {
      var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(type, config, maybeKey, false, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
    exports.jsxs = function(type, config, maybeKey) {
      var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(type, config, maybeKey, true, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
  })();
});

// ../../node_modules/.pnpm/react@19.2.3/node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS((exports, module) => {
  var react_jsx_runtime_development = __toESM(require_react_jsx_runtime_development());
  if (false) {} else {
    module.exports = react_jsx_runtime_development;
  }
});

// ../../node_modules/.pnpm/use-image@1.1.4_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/use-image/index.js
var require_use_image = __commonJS((exports, module) => {
  var React58 = __toESM(require_react());
  module.exports = function useImage(url, crossOrigin, referrerpolicy) {
    const statusRef = React58.useRef("loading");
    const imageRef = React58.useRef();
    const [_2, setStateToken] = React58.useState(0);
    const oldUrl = React58.useRef();
    const oldCrossOrigin = React58.useRef();
    const oldReferrerPolicy = React58.useRef();
    if (oldUrl.current !== url || oldCrossOrigin.current !== crossOrigin || oldReferrerPolicy.current !== referrerpolicy) {
      statusRef.current = "loading";
      imageRef.current = undefined;
      oldUrl.current = url;
      oldCrossOrigin.current = crossOrigin;
      oldReferrerPolicy.current = referrerpolicy;
    }
    React58.useLayoutEffect(function() {
      if (!url)
        return;
      var img = document.createElement("img");
      function onload() {
        img.decode().catch(() => {}).finally(() => {
          statusRef.current = "loaded";
          imageRef.current = img;
          setStateToken(Math.random());
        });
      }
      function onerror() {
        statusRef.current = "failed";
        imageRef.current = undefined;
        setStateToken(Math.random());
      }
      img.addEventListener("load", onload);
      img.addEventListener("error", onerror);
      crossOrigin && (img.crossOrigin = crossOrigin);
      referrerpolicy && (img.referrerPolicy = referrerpolicy);
      img.src = url;
      return function cleanup() {
        img.removeEventListener("load", onload);
        img.removeEventListener("error", onerror);
      };
    }, [url, crossOrigin, referrerpolicy]);
    return [imageRef.current, statusRef.current];
  };
});

// node:buffer
var exports_buffer = {};
__export(exports_buffer, {
  transcode: () => transcode,
  resolveObjectURL: () => resolveObjectURL,
  kStringMaxLength: () => kStringMaxLength,
  kMaxLength: () => kMaxLength,
  isUtf8: () => isUtf8,
  isAscii: () => isAscii,
  default: () => buffer_default,
  constants: () => constants,
  btoa: () => btoa,
  atob: () => atob2,
  INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
  File: () => File,
  Buffer: () => Buffer2,
  Blob: () => Blob2
});
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0)
    throw Error("Invalid string. Length must be a multiple of 4");
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function _byteLength(validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp, lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1], arr = new Uint8Array(_byteLength(validLen, placeHoldersLen)), curByte = 0, len2 = placeHoldersLen > 0 ? validLen - 4 : validLen, i22;
  for (i22 = 0;i22 < len2; i22 += 4)
    tmp = revLookup[b64.charCodeAt(i22)] << 18 | revLookup[b64.charCodeAt(i22 + 1)] << 12 | revLookup[b64.charCodeAt(i22 + 2)] << 6 | revLookup[b64.charCodeAt(i22 + 3)], arr[curByte++] = tmp >> 16 & 255, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255;
  if (placeHoldersLen === 2)
    tmp = revLookup[b64.charCodeAt(i22)] << 2 | revLookup[b64.charCodeAt(i22 + 1)] >> 4, arr[curByte++] = tmp & 255;
  if (placeHoldersLen === 1)
    tmp = revLookup[b64.charCodeAt(i22)] << 10 | revLookup[b64.charCodeAt(i22 + 1)] << 4 | revLookup[b64.charCodeAt(i22 + 2)] >> 2, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255;
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp, output = [];
  for (var i22 = start;i22 < end; i22 += 3)
    tmp = (uint8[i22] << 16 & 16711680) + (uint8[i22 + 1] << 8 & 65280) + (uint8[i22 + 2] & 255), output.push(tripletToBase64(tmp));
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp, len2 = uint8.length, extraBytes = len2 % 3, parts = [], maxChunkLength = 16383;
  for (var i22 = 0, len22 = len2 - extraBytes;i22 < len22; i22 += maxChunkLength)
    parts.push(encodeChunk(uint8, i22, i22 + maxChunkLength > len22 ? len22 : i22 + maxChunkLength));
  if (extraBytes === 1)
    tmp = uint8[len2 - 1], parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  else if (extraBytes === 2)
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1], parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  return parts.join("");
}
function read(buffer, offset4, isLE, mLen, nBytes) {
  var e2, m3, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i22 = isLE ? nBytes - 1 : 0, d2 = isLE ? -1 : 1, s2 = buffer[offset4 + i22];
  i22 += d2, e2 = s2 & (1 << -nBits) - 1, s2 >>= -nBits, nBits += eLen;
  for (;nBits > 0; e2 = e2 * 256 + buffer[offset4 + i22], i22 += d2, nBits -= 8)
    ;
  m3 = e2 & (1 << -nBits) - 1, e2 >>= -nBits, nBits += mLen;
  for (;nBits > 0; m3 = m3 * 256 + buffer[offset4 + i22], i22 += d2, nBits -= 8)
    ;
  if (e2 === 0)
    e2 = 1 - eBias;
  else if (e2 === eMax)
    return m3 ? NaN : (s2 ? -1 : 1) * (1 / 0);
  else
    m3 = m3 + Math.pow(2, mLen), e2 = e2 - eBias;
  return (s2 ? -1 : 1) * m3 * Math.pow(2, e2 - mLen);
}
function write(buffer, value, offset4, isLE, mLen, nBytes) {
  var e2, m3, c3, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i22 = isLE ? 0 : nBytes - 1, d2 = isLE ? 1 : -1, s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  if (value = Math.abs(value), isNaN(value) || value === 1 / 0)
    m3 = isNaN(value) ? 1 : 0, e2 = eMax;
  else {
    if (e2 = Math.floor(Math.log(value) / Math.LN2), value * (c3 = Math.pow(2, -e2)) < 1)
      e2--, c3 *= 2;
    if (e2 + eBias >= 1)
      value += rt / c3;
    else
      value += rt * Math.pow(2, 1 - eBias);
    if (value * c3 >= 2)
      e2++, c3 /= 2;
    if (e2 + eBias >= eMax)
      m3 = 0, e2 = eMax;
    else if (e2 + eBias >= 1)
      m3 = (value * c3 - 1) * Math.pow(2, mLen), e2 = e2 + eBias;
    else
      m3 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen), e2 = 0;
  }
  for (;mLen >= 8; buffer[offset4 + i22] = m3 & 255, i22 += d2, m3 /= 256, mLen -= 8)
    ;
  e2 = e2 << mLen | m3, eLen += mLen;
  for (;eLen > 0; buffer[offset4 + i22] = e2 & 255, i22 += d2, e2 /= 256, eLen -= 8)
    ;
  buffer[offset4 + i22 - d2] |= s2 * 128;
}
function createBuffer(length) {
  if (length > kMaxLength)
    throw RangeError('The value "' + length + '" is invalid for option "size"');
  let buf = new Uint8Array(length);
  return Object.setPrototypeOf(buf, Buffer2.prototype), buf;
}
function E(sym, getMessage, Base) {
  return class extends Base {
    constructor() {
      super();
      Object.defineProperty(this, "message", { value: getMessage.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${sym}]`, this.stack, delete this.name;
    }
    get code() {
      return sym;
    }
    set code(value) {
      Object.defineProperty(this, "code", { configurable: true, enumerable: true, value, writable: true });
    }
    toString() {
      return `${this.name} [${sym}]: ${this.message}`;
    }
  };
}
function Buffer2(arg, encodingOrOffset, length) {
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string")
      throw TypeError('The "string" argument must be of type string. Received type number');
    return allocUnsafe(arg);
  }
  return from(arg, encodingOrOffset, length);
}
function from(value, encodingOrOffset, length) {
  if (typeof value === "string")
    return fromString(value, encodingOrOffset);
  if (ArrayBuffer.isView(value))
    return fromArrayView(value);
  if (value == null)
    throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer))
    return fromArrayBuffer(value, encodingOrOffset, length);
  if (typeof SharedArrayBuffer < "u" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer)))
    return fromArrayBuffer(value, encodingOrOffset, length);
  if (typeof value === "number")
    throw TypeError('The "value" argument must not be of type number. Received type number');
  let valueOf = value.valueOf && value.valueOf();
  if (valueOf != null && valueOf !== value)
    return Buffer2.from(valueOf, encodingOrOffset, length);
  let b4 = fromObject(value);
  if (b4)
    return b4;
  if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function")
    return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
  throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
function assertSize(size4) {
  if (typeof size4 !== "number")
    throw TypeError('"size" argument must be of type number');
  else if (size4 < 0)
    throw RangeError('The value "' + size4 + '" is invalid for option "size"');
}
function alloc(size4, fill, encoding) {
  if (assertSize(size4), size4 <= 0)
    return createBuffer(size4);
  if (fill !== undefined)
    return typeof encoding === "string" ? createBuffer(size4).fill(fill, encoding) : createBuffer(size4).fill(fill);
  return createBuffer(size4);
}
function allocUnsafe(size4) {
  return assertSize(size4), createBuffer(size4 < 0 ? 0 : checked(size4) | 0);
}
function fromString(string, encoding) {
  if (typeof encoding !== "string" || encoding === "")
    encoding = "utf8";
  if (!Buffer2.isEncoding(encoding))
    throw TypeError("Unknown encoding: " + encoding);
  let length = byteLength(string, encoding) | 0, buf = createBuffer(length), actual = buf.write(string, encoding);
  if (actual !== length)
    buf = buf.slice(0, actual);
  return buf;
}
function fromArrayLike(array) {
  let length = array.length < 0 ? 0 : checked(array.length) | 0, buf = createBuffer(length);
  for (let i22 = 0;i22 < length; i22 += 1)
    buf[i22] = array[i22] & 255;
  return buf;
}
function fromArrayView(arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    let copy = new Uint8Array(arrayView);
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
  }
  return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset)
    throw RangeError('"offset" is outside of buffer bounds');
  if (array.byteLength < byteOffset + (length || 0))
    throw RangeError('"length" is outside of buffer bounds');
  let buf;
  if (byteOffset === undefined && length === undefined)
    buf = new Uint8Array(array);
  else if (length === undefined)
    buf = new Uint8Array(array, byteOffset);
  else
    buf = new Uint8Array(array, byteOffset, length);
  return Object.setPrototypeOf(buf, Buffer2.prototype), buf;
}
function fromObject(obj) {
  if (Buffer2.isBuffer(obj)) {
    let len2 = checked(obj.length) | 0, buf = createBuffer(len2);
    if (buf.length === 0)
      return buf;
    return obj.copy(buf, 0, 0, len2), buf;
  }
  if (obj.length !== undefined) {
    if (typeof obj.length !== "number" || Number.isNaN(obj.length))
      return createBuffer(0);
    return fromArrayLike(obj);
  }
  if (obj.type === "Buffer" && Array.isArray(obj.data))
    return fromArrayLike(obj.data);
}
function checked(length) {
  if (length >= kMaxLength)
    throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength.toString(16) + " bytes");
  return length | 0;
}
function byteLength(string, encoding) {
  if (Buffer2.isBuffer(string))
    return string.length;
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer))
    return string.byteLength;
  if (typeof string !== "string")
    throw TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
  let len2 = string.length, mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len2 === 0)
    return 0;
  let loweredCase = false;
  for (;; )
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len2;
      case "utf8":
      case "utf-8":
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len2 * 2;
      case "hex":
        return len2 >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return mustMatch ? -1 : utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase(), loweredCase = true;
    }
}
function slowToString(encoding, start, end) {
  let loweredCase = false;
  if (start === undefined || start < 0)
    start = 0;
  if (start > this.length)
    return "";
  if (end === undefined || end > this.length)
    end = this.length;
  if (end <= 0)
    return "";
  if (end >>>= 0, start >>>= 0, end <= start)
    return "";
  if (!encoding)
    encoding = "utf8";
  while (true)
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase(), loweredCase = true;
    }
}
function swap(b4, n2, m3) {
  let i22 = b4[n2];
  b4[n2] = b4[m3], b4[m3] = i22;
}
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string")
    encoding = byteOffset, byteOffset = 0;
  else if (byteOffset > 2147483647)
    byteOffset = 2147483647;
  else if (byteOffset < -2147483648)
    byteOffset = -2147483648;
  if (byteOffset = +byteOffset, Number.isNaN(byteOffset))
    byteOffset = dir ? 0 : buffer.length - 1;
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length)
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  else if (byteOffset < 0)
    if (dir)
      byteOffset = 0;
    else
      return -1;
  if (typeof val === "string")
    val = Buffer2.from(val, encoding);
  if (Buffer2.isBuffer(val)) {
    if (val.length === 0)
      return -1;
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    if (val = val & 255, typeof Uint8Array.prototype.indexOf === "function")
      if (dir)
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      else
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  let indexSize = 1, arrLength = arr.length, valLength = val.length;
  if (encoding !== undefined) {
    if (encoding = String(encoding).toLowerCase(), encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2)
        return -1;
      indexSize = 2, arrLength /= 2, valLength /= 2, byteOffset /= 2;
    }
  }
  function read2(buf, i32) {
    if (indexSize === 1)
      return buf[i32];
    else
      return buf.readUInt16BE(i32 * indexSize);
  }
  let i22;
  if (dir) {
    let foundIndex = -1;
    for (i22 = byteOffset;i22 < arrLength; i22++)
      if (read2(arr, i22) === read2(val, foundIndex === -1 ? 0 : i22 - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i22;
        if (i22 - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i22 -= i22 - foundIndex;
        foundIndex = -1;
      }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i22 = byteOffset;i22 >= 0; i22--) {
      let found = true;
      for (let j = 0;j < valLength; j++)
        if (read2(arr, i22 + j) !== read2(val, j)) {
          found = false;
          break;
        }
      if (found)
        return i22;
    }
  }
  return -1;
}
function hexWrite(buf, string, offset4, length) {
  offset4 = Number(offset4) || 0;
  let remaining = buf.length - offset4;
  if (!length)
    length = remaining;
  else if (length = Number(length), length > remaining)
    length = remaining;
  let strLen = string.length;
  if (length > strLen / 2)
    length = strLen / 2;
  let i22;
  for (i22 = 0;i22 < length; ++i22) {
    let parsed = parseInt(string.substr(i22 * 2, 2), 16);
    if (Number.isNaN(parsed))
      return i22;
    buf[offset4 + i22] = parsed;
  }
  return i22;
}
function utf8Write(buf, string, offset4, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset4), buf, offset4, length);
}
function asciiWrite(buf, string, offset4, length) {
  return blitBuffer(asciiToBytes(string), buf, offset4, length);
}
function base64Write(buf, string, offset4, length) {
  return blitBuffer(base64ToBytes(string), buf, offset4, length);
}
function ucs2Write(buf, string, offset4, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset4), buf, offset4, length);
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length)
    return fromByteArray(buf);
  else
    return fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  let res = [], i22 = start;
  while (i22 < end) {
    let firstByte = buf[i22], codePoint = null, bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i22 + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128)
            codePoint = firstByte;
          break;
        case 2:
          if (secondByte = buf[i22 + 1], (secondByte & 192) === 128) {
            if (tempCodePoint = (firstByte & 31) << 6 | secondByte & 63, tempCodePoint > 127)
              codePoint = tempCodePoint;
          }
          break;
        case 3:
          if (secondByte = buf[i22 + 1], thirdByte = buf[i22 + 2], (secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            if (tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63, tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343))
              codePoint = tempCodePoint;
          }
          break;
        case 4:
          if (secondByte = buf[i22 + 1], thirdByte = buf[i22 + 2], fourthByte = buf[i22 + 3], (secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            if (tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63, tempCodePoint > 65535 && tempCodePoint < 1114112)
              codePoint = tempCodePoint;
          }
      }
    }
    if (codePoint === null)
      codePoint = 65533, bytesPerSequence = 1;
    else if (codePoint > 65535)
      codePoint -= 65536, res.push(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023;
    res.push(codePoint), i22 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  let len2 = codePoints.length;
  if (len2 <= MAX_ARGUMENTS_LENGTH)
    return String.fromCharCode.apply(String, codePoints);
  let res = "", i22 = 0;
  while (i22 < len2)
    res += String.fromCharCode.apply(String, codePoints.slice(i22, i22 += MAX_ARGUMENTS_LENGTH));
  return res;
}
function asciiSlice(buf, start, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i22 = start;i22 < end; ++i22)
    ret += String.fromCharCode(buf[i22] & 127);
  return ret;
}
function latin1Slice(buf, start, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i22 = start;i22 < end; ++i22)
    ret += String.fromCharCode(buf[i22]);
  return ret;
}
function hexSlice(buf, start, end) {
  let len2 = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len2)
    end = len2;
  let out = "";
  for (let i22 = start;i22 < end; ++i22)
    out += hexSliceLookupTable[buf[i22]];
  return out;
}
function utf16leSlice(buf, start, end) {
  let bytes = buf.slice(start, end), res = "";
  for (let i22 = 0;i22 < bytes.length - 1; i22 += 2)
    res += String.fromCharCode(bytes[i22] + bytes[i22 + 1] * 256);
  return res;
}
function checkOffset(offset4, ext, length) {
  if (offset4 % 1 !== 0 || offset4 < 0)
    throw RangeError("offset is not uint");
  if (offset4 + ext > length)
    throw RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset4, ext, max3, min3) {
  if (!Buffer2.isBuffer(buf))
    throw TypeError('"buffer" argument must be a Buffer instance');
  if (value > max3 || value < min3)
    throw RangeError('"value" argument is out of bounds');
  if (offset4 + ext > buf.length)
    throw RangeError("Index out of range");
}
function wrtBigUInt64LE(buf, value, offset4, min3, max3) {
  checkIntBI(value, min3, max3, buf, offset4, 7);
  let lo = Number(value & BigInt(4294967295));
  buf[offset4++] = lo, lo = lo >> 8, buf[offset4++] = lo, lo = lo >> 8, buf[offset4++] = lo, lo = lo >> 8, buf[offset4++] = lo;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  return buf[offset4++] = hi, hi = hi >> 8, buf[offset4++] = hi, hi = hi >> 8, buf[offset4++] = hi, hi = hi >> 8, buf[offset4++] = hi, offset4;
}
function wrtBigUInt64BE(buf, value, offset4, min3, max3) {
  checkIntBI(value, min3, max3, buf, offset4, 7);
  let lo = Number(value & BigInt(4294967295));
  buf[offset4 + 7] = lo, lo = lo >> 8, buf[offset4 + 6] = lo, lo = lo >> 8, buf[offset4 + 5] = lo, lo = lo >> 8, buf[offset4 + 4] = lo;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  return buf[offset4 + 3] = hi, hi = hi >> 8, buf[offset4 + 2] = hi, hi = hi >> 8, buf[offset4 + 1] = hi, hi = hi >> 8, buf[offset4] = hi, offset4 + 8;
}
function checkIEEE754(buf, value, offset4, ext, max3, min3) {
  if (offset4 + ext > buf.length)
    throw RangeError("Index out of range");
  if (offset4 < 0)
    throw RangeError("Index out of range");
}
function writeFloat(buf, value, offset4, littleEndian, noAssert) {
  if (value = +value, offset4 = offset4 >>> 0, !noAssert)
    checkIEEE754(buf, value, offset4, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000);
  return write(buf, value, offset4, littleEndian, 23, 4), offset4 + 4;
}
function writeDouble(buf, value, offset4, littleEndian, noAssert) {
  if (value = +value, offset4 = offset4 >>> 0, !noAssert)
    checkIEEE754(buf, value, offset4, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
  return write(buf, value, offset4, littleEndian, 52, 8), offset4 + 8;
}
function addNumericalSeparator(val) {
  let res = "", i22 = val.length, start = val[0] === "-" ? 1 : 0;
  for (;i22 >= start + 4; i22 -= 3)
    res = `_${val.slice(i22 - 3, i22)}${res}`;
  return `${val.slice(0, i22)}${res}`;
}
function checkBounds(buf, offset4, byteLength2) {
  if (validateNumber(offset4, "offset"), buf[offset4] === undefined || buf[offset4 + byteLength2] === undefined)
    boundsError(offset4, buf.length - (byteLength2 + 1));
}
function checkIntBI(value, min3, max3, buf, offset4, byteLength2) {
  if (value > max3 || value < min3) {
    let n2 = typeof min3 === "bigint" ? "n" : "", range;
    if (byteLength2 > 3)
      if (min3 === 0 || min3 === BigInt(0))
        range = `>= 0${n2} and < 2${n2} ** ${(byteLength2 + 1) * 8}${n2}`;
      else
        range = `>= -(2${n2} ** ${(byteLength2 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n2}`;
    else
      range = `>= ${min3}${n2} and <= ${max3}${n2}`;
    throw new ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds(buf, offset4, byteLength2);
}
function validateNumber(value, name) {
  if (typeof value !== "number")
    throw new ERR_INVALID_ARG_TYPE(name, "number", value);
}
function boundsError(value, length, type) {
  if (Math.floor(value) !== value)
    throw validateNumber(value, type), new ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
  if (length < 0)
    throw new ERR_BUFFER_OUT_OF_BOUNDS;
  throw new ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function base64clean(str) {
  if (str = str.split("=")[0], str = str.trim().replace(INVALID_BASE64_RE, ""), str.length < 2)
    return "";
  while (str.length % 4 !== 0)
    str = str + "=";
  return str;
}
function utf8ToBytes(string, units) {
  units = units || 1 / 0;
  let codePoint, length = string.length, leadSurrogate = null, bytes = [];
  for (let i22 = 0;i22 < length; ++i22) {
    if (codePoint = string.charCodeAt(i22), codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i22 + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    if (leadSurrogate = null, codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else
      throw Error("Invalid code point");
  }
  return bytes;
}
function asciiToBytes(str) {
  let byteArray = [];
  for (let i22 = 0;i22 < str.length; ++i22)
    byteArray.push(str.charCodeAt(i22) & 255);
  return byteArray;
}
function utf16leToBytes(str, units) {
  let c3, hi, lo, byteArray = [];
  for (let i22 = 0;i22 < str.length; ++i22) {
    if ((units -= 2) < 0)
      break;
    c3 = str.charCodeAt(i22), hi = c3 >> 8, lo = c3 % 256, byteArray.push(lo), byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset4, length) {
  let i22;
  for (i22 = 0;i22 < length; ++i22) {
    if (i22 + offset4 >= dst.length || i22 >= src.length)
      break;
    dst[i22 + offset4] = src[i22];
  }
  return i22;
}
function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function defineBigIntMethod(fn) {
  return typeof BigInt > "u" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
  throw Error("BigInt not supported");
}
function notimpl(name) {
  return () => {
    throw Error(name + " is not implemented for node:buffer browser polyfill");
  };
}
var lookup, revLookup, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i3, len, customInspectSymbol, INSPECT_MAX_BYTES = 50, kMaxLength = 2147483647, kStringMaxLength = 536870888, btoa, atob2, File, Blob2, constants, ERR_BUFFER_OUT_OF_BOUNDS, ERR_INVALID_ARG_TYPE, ERR_OUT_OF_RANGE, MAX_ARGUMENTS_LENGTH = 4096, INVALID_BASE64_RE, hexSliceLookupTable, resolveObjectURL, isUtf8, isAscii = (str) => {
  for (let char of str)
    if (char.charCodeAt(0) > 127)
      return false;
  return true;
}, transcode, buffer_default;
var init_buffer = __esm(() => {
  lookup = [];
  revLookup = [];
  for (i3 = 0, len = code.length;i3 < len; ++i3)
    lookup[i3] = code[i3], revLookup[code.charCodeAt(i3)] = i3;
  revLookup[45] = 62;
  revLookup[95] = 63;
  customInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  btoa = globalThis.btoa;
  atob2 = globalThis.atob;
  File = globalThis.File;
  Blob2 = globalThis.Blob;
  constants = { MAX_LENGTH: kMaxLength, MAX_STRING_LENGTH: kStringMaxLength };
  ERR_BUFFER_OUT_OF_BOUNDS = E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name)
      return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  ERR_INVALID_ARG_TYPE = E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  ERR_OUT_OF_RANGE = E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`, received = input;
    if (Number.isInteger(input) && Math.abs(input) > 4294967296)
      received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
      if (received = String(input), input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32)))
        received = addNumericalSeparator(received);
      received += "n";
    }
    return msg += ` It must be ${range}. Received ${received}`, msg;
  }, RangeError);
  Object.defineProperty(Buffer2.prototype, "parent", { enumerable: true, get: function() {
    if (!Buffer2.isBuffer(this))
      return;
    return this.buffer;
  } });
  Object.defineProperty(Buffer2.prototype, "offset", { enumerable: true, get: function() {
    if (!Buffer2.isBuffer(this))
      return;
    return this.byteOffset;
  } });
  Buffer2.poolSize = 8192;
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  Buffer2.alloc = function(size4, fill, encoding) {
    return alloc(size4, fill, encoding);
  };
  Buffer2.allocUnsafe = function(size4) {
    return allocUnsafe(size4);
  };
  Buffer2.allocUnsafeSlow = function(size4) {
    return allocUnsafe(size4);
  };
  Buffer2.isBuffer = function(b4) {
    return b4 != null && b4._isBuffer === true && b4 !== Buffer2.prototype;
  };
  Buffer2.compare = function(a4, b4) {
    if (isInstance(a4, Uint8Array))
      a4 = Buffer2.from(a4, a4.offset, a4.byteLength);
    if (isInstance(b4, Uint8Array))
      b4 = Buffer2.from(b4, b4.offset, b4.byteLength);
    if (!Buffer2.isBuffer(a4) || !Buffer2.isBuffer(b4))
      throw TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a4 === b4)
      return 0;
    let x3 = a4.length, y2 = b4.length;
    for (let i22 = 0, len2 = Math.min(x3, y2);i22 < len2; ++i22)
      if (a4[i22] !== b4[i22]) {
        x3 = a4[i22], y2 = b4[i22];
        break;
      }
    if (x3 < y2)
      return -1;
    if (y2 < x3)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function(list, length) {
    if (!Array.isArray(list))
      throw TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0)
      return Buffer2.alloc(0);
    let i22;
    if (length === undefined) {
      length = 0;
      for (i22 = 0;i22 < list.length; ++i22)
        length += list[i22].length;
    }
    let buffer = Buffer2.allocUnsafe(length), pos = 0;
    for (i22 = 0;i22 < list.length; ++i22) {
      let buf = list[i22];
      if (isInstance(buf, Uint8Array))
        if (pos + buf.length > buffer.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer, pos);
        } else
          Uint8Array.prototype.set.call(buffer, buf, pos);
      else if (!Buffer2.isBuffer(buf))
        throw TypeError('"list" argument must be an Array of Buffers');
      else
        buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer;
  };
  Buffer2.byteLength = byteLength;
  Buffer2.prototype._isBuffer = true;
  Buffer2.prototype.swap16 = function() {
    let len2 = this.length;
    if (len2 % 2 !== 0)
      throw RangeError("Buffer size must be a multiple of 16-bits");
    for (let i22 = 0;i22 < len2; i22 += 2)
      swap(this, i22, i22 + 1);
    return this;
  };
  Buffer2.prototype.swap32 = function() {
    let len2 = this.length;
    if (len2 % 4 !== 0)
      throw RangeError("Buffer size must be a multiple of 32-bits");
    for (let i22 = 0;i22 < len2; i22 += 4)
      swap(this, i22, i22 + 3), swap(this, i22 + 1, i22 + 2);
    return this;
  };
  Buffer2.prototype.swap64 = function() {
    let len2 = this.length;
    if (len2 % 8 !== 0)
      throw RangeError("Buffer size must be a multiple of 64-bits");
    for (let i22 = 0;i22 < len2; i22 += 8)
      swap(this, i22, i22 + 7), swap(this, i22 + 1, i22 + 6), swap(this, i22 + 2, i22 + 5), swap(this, i22 + 3, i22 + 4);
    return this;
  };
  Buffer2.prototype.toString = function() {
    let length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function(b4) {
    if (!Buffer2.isBuffer(b4))
      throw TypeError("Argument must be a Buffer");
    if (this === b4)
      return true;
    return Buffer2.compare(this, b4) === 0;
  };
  Buffer2.prototype.inspect = function() {
    let str = "", max3 = INSPECT_MAX_BYTES;
    if (str = this.toString("hex", 0, max3).replace(/(.{2})/g, "$1 ").trim(), this.length > max3)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol)
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  Buffer2.prototype.compare = function(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array))
      target = Buffer2.from(target, target.offset, target.byteLength);
    if (!Buffer2.isBuffer(target))
      throw TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined)
      start = 0;
    if (end === undefined)
      end = target ? target.length : 0;
    if (thisStart === undefined)
      thisStart = 0;
    if (thisEnd === undefined)
      thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length)
      throw RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end)
      return 0;
    if (thisStart >= thisEnd)
      return -1;
    if (start >= end)
      return 1;
    if (start >>>= 0, end >>>= 0, thisStart >>>= 0, thisEnd >>>= 0, this === target)
      return 0;
    let x3 = thisEnd - thisStart, y2 = end - start, len2 = Math.min(x3, y2), thisCopy = this.slice(thisStart, thisEnd), targetCopy = target.slice(start, end);
    for (let i22 = 0;i22 < len2; ++i22)
      if (thisCopy[i22] !== targetCopy[i22]) {
        x3 = thisCopy[i22], y2 = targetCopy[i22];
        break;
      }
    if (x3 < y2)
      return -1;
    if (y2 < x3)
      return 1;
    return 0;
  };
  Buffer2.prototype.includes = function(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  Buffer2.prototype.write = function(string, offset4, length, encoding) {
    if (offset4 === undefined)
      encoding = "utf8", length = this.length, offset4 = 0;
    else if (length === undefined && typeof offset4 === "string")
      encoding = offset4, length = this.length, offset4 = 0;
    else if (isFinite(offset4))
      if (offset4 = offset4 >>> 0, isFinite(length)) {
        if (length = length >>> 0, encoding === undefined)
          encoding = "utf8";
      } else
        encoding = length, length = undefined;
    else
      throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let remaining = this.length - offset4;
    if (length === undefined || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset4 < 0) || offset4 > this.length)
      throw RangeError("Attempt to write outside buffer bounds");
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (;; )
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset4, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset4, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset4, length);
        case "base64":
          return base64Write(this, string, offset4, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset4, length);
        default:
          if (loweredCase)
            throw TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase(), loweredCase = true;
      }
  };
  Buffer2.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  Buffer2.prototype.slice = function(start, end) {
    let len2 = this.length;
    if (start = ~~start, end = end === undefined ? len2 : ~~end, start < 0) {
      if (start += len2, start < 0)
        start = 0;
    } else if (start > len2)
      start = len2;
    if (end < 0) {
      if (end += len2, end < 0)
        end = 0;
    } else if (end > len2)
      end = len2;
    if (end < start)
      end = start;
    let newBuf = this.subarray(start, end);
    return Object.setPrototypeOf(newBuf, Buffer2.prototype), newBuf;
  };
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function(offset4, byteLength2, noAssert) {
    if (offset4 = offset4 >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset4, byteLength2, this.length);
    let val = this[offset4], mul = 1, i22 = 0;
    while (++i22 < byteLength2 && (mul *= 256))
      val += this[offset4 + i22] * mul;
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function(offset4, byteLength2, noAssert) {
    if (offset4 = offset4 >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset4, byteLength2, this.length);
    let val = this[offset4 + --byteLength2], mul = 1;
    while (byteLength2 > 0 && (mul *= 256))
      val += this[offset4 + --byteLength2] * mul;
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function(offset4, noAssert) {
    if (offset4 = offset4 >>> 0, !noAssert)
      checkOffset(offset4, 1, this.length);
    return this[offset4];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function(offset4, noAssert) {
    if (offset4 = offset4 >>> 0, !noAssert)
      checkOffset(offset4, 2, this.length);
    return this[offset4] | this[offset4 + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function(offset4, noAssert) {
    if (offset4 = offset4 >>> 0, !noAssert)
      checkOffset(offset4, 2, this.length);
    return this[offset4] << 8 | this[offset4 + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function(offset4, noAssert) {
    if (offset4 = offset4 >>> 0, !noAssert)
      checkOffset(offset4, 4, this.length);
    return (this[offset4] | this[offset4 + 1] << 8 | this[offset4 + 2] << 16) + this[offset4 + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function(offset4, noAssert) {
    if (offset4 = offset4 >>> 0, !noAssert)
      checkOffset(offset4, 4, this.length);
    return this[offset4] * 16777216 + (this[offset4 + 1] << 16 | this[offset4 + 2] << 8 | this[offset4 + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function(offset4) {
    offset4 = offset4 >>> 0, validateNumber(offset4, "offset");
    let first = this[offset4], last = this[offset4 + 7];
    if (first === undefined || last === undefined)
      boundsError(offset4, this.length - 8);
    let lo = first + this[++offset4] * 256 + this[++offset4] * 65536 + this[++offset4] * 16777216, hi = this[++offset4] + this[++offset4] * 256 + this[++offset4] * 65536 + last * 16777216;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function(offset4) {
    offset4 = offset4 >>> 0, validateNumber(offset4, "offset");
    let first = this[offset4], last = this[offset4 + 7];
    if (first === undefined || last === undefined)
      boundsError(offset4, this.length - 8);
    let hi = first * 16777216 + this[++offset4] * 65536 + this[++offset4] * 256 + this[++offset4], lo = this[++offset4] * 16777216 + this[++offset4] * 65536 + this[++offset4] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function(offset4, byteLength2, noAssert) {
    if (offset4 = offset4 >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset4, byteLength2, this.length);
    let val = this[offset4], mul = 1, i22 = 0;
    while (++i22 < byteLength2 && (mul *= 256))
      val += this[offset4 + i22] * mul;
    if (mul *= 128, val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer2.prototype.readIntBE = function(offset4, byteLength2, noAssert) {
    if (offset4 = offset4 >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset4, byteLength2, this.length);
    let i22 = byteLength2, mul = 1, val = this[offset4 + --i22];
    while (i22 > 0 && (mul *= 256))
      val += this[offset4 + --i22] * mul;
    if (mul *= 128, val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer2.prototype.readInt8 = function(offset4, noAssert) {
    if (offset4 = offset4 >>> 0, !noAssert)
      checkOffset(offset4, 1, this.length);
    if (!(this[offset4] & 128))
      return this[offset4];
    return (255 - this[offset4] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function(offset4, noAssert) {
    if (offset4 = offset4 >>> 0, !noAssert)
      checkOffset(offset4, 2, this.length);
    let val = this[offset4] | this[offset4 + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function(offset4, noAssert) {
    if (offset4 = offset4 >>> 0, !noAssert)
      checkOffset(offset4, 2, this.length);
    let val = this[offset4 + 1] | this[offset4] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function(offset4, noAssert) {
    if (offset4 = offset4 >>> 0, !noAssert)
      checkOffset(offset4, 4, this.length);
    return this[offset4] | this[offset4 + 1] << 8 | this[offset4 + 2] << 16 | this[offset4 + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function(offset4, noAssert) {
    if (offset4 = offset4 >>> 0, !noAssert)
      checkOffset(offset4, 4, this.length);
    return this[offset4] << 24 | this[offset4 + 1] << 16 | this[offset4 + 2] << 8 | this[offset4 + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function(offset4) {
    offset4 = offset4 >>> 0, validateNumber(offset4, "offset");
    let first = this[offset4], last = this[offset4 + 7];
    if (first === undefined || last === undefined)
      boundsError(offset4, this.length - 8);
    let val = this[offset4 + 4] + this[offset4 + 5] * 256 + this[offset4 + 6] * 65536 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset4] * 256 + this[++offset4] * 65536 + this[++offset4] * 16777216);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function(offset4) {
    offset4 = offset4 >>> 0, validateNumber(offset4, "offset");
    let first = this[offset4], last = this[offset4 + 7];
    if (first === undefined || last === undefined)
      boundsError(offset4, this.length - 8);
    let val = (first << 24) + this[++offset4] * 65536 + this[++offset4] * 256 + this[++offset4];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset4] * 16777216 + this[++offset4] * 65536 + this[++offset4] * 256 + last);
  });
  Buffer2.prototype.readFloatLE = function(offset4, noAssert) {
    if (offset4 = offset4 >>> 0, !noAssert)
      checkOffset(offset4, 4, this.length);
    return read(this, offset4, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function(offset4, noAssert) {
    if (offset4 = offset4 >>> 0, !noAssert)
      checkOffset(offset4, 4, this.length);
    return read(this, offset4, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function(offset4, noAssert) {
    if (offset4 = offset4 >>> 0, !noAssert)
      checkOffset(offset4, 8, this.length);
    return read(this, offset4, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function(offset4, noAssert) {
    if (offset4 = offset4 >>> 0, !noAssert)
      checkOffset(offset4, 8, this.length);
    return read(this, offset4, false, 52, 8);
  };
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function(value, offset4, byteLength2, noAssert) {
    if (value = +value, offset4 = offset4 >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert) {
      let maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset4, byteLength2, maxBytes, 0);
    }
    let mul = 1, i22 = 0;
    this[offset4] = value & 255;
    while (++i22 < byteLength2 && (mul *= 256))
      this[offset4 + i22] = value / mul & 255;
    return offset4 + byteLength2;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function(value, offset4, byteLength2, noAssert) {
    if (value = +value, offset4 = offset4 >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert) {
      let maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset4, byteLength2, maxBytes, 0);
    }
    let i22 = byteLength2 - 1, mul = 1;
    this[offset4 + i22] = value & 255;
    while (--i22 >= 0 && (mul *= 256))
      this[offset4 + i22] = value / mul & 255;
    return offset4 + byteLength2;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function(value, offset4, noAssert) {
    if (value = +value, offset4 = offset4 >>> 0, !noAssert)
      checkInt(this, value, offset4, 1, 255, 0);
    return this[offset4] = value & 255, offset4 + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function(value, offset4, noAssert) {
    if (value = +value, offset4 = offset4 >>> 0, !noAssert)
      checkInt(this, value, offset4, 2, 65535, 0);
    return this[offset4] = value & 255, this[offset4 + 1] = value >>> 8, offset4 + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function(value, offset4, noAssert) {
    if (value = +value, offset4 = offset4 >>> 0, !noAssert)
      checkInt(this, value, offset4, 2, 65535, 0);
    return this[offset4] = value >>> 8, this[offset4 + 1] = value & 255, offset4 + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function(value, offset4, noAssert) {
    if (value = +value, offset4 = offset4 >>> 0, !noAssert)
      checkInt(this, value, offset4, 4, 4294967295, 0);
    return this[offset4 + 3] = value >>> 24, this[offset4 + 2] = value >>> 16, this[offset4 + 1] = value >>> 8, this[offset4] = value & 255, offset4 + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function(value, offset4, noAssert) {
    if (value = +value, offset4 = offset4 >>> 0, !noAssert)
      checkInt(this, value, offset4, 4, 4294967295, 0);
    return this[offset4] = value >>> 24, this[offset4 + 1] = value >>> 16, this[offset4 + 2] = value >>> 8, this[offset4 + 3] = value & 255, offset4 + 4;
  };
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function(value, offset4 = 0) {
    return wrtBigUInt64LE(this, value, offset4, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function(value, offset4 = 0) {
    return wrtBigUInt64BE(this, value, offset4, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function(value, offset4, byteLength2, noAssert) {
    if (value = +value, offset4 = offset4 >>> 0, !noAssert) {
      let limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset4, byteLength2, limit - 1, -limit);
    }
    let i22 = 0, mul = 1, sub = 0;
    this[offset4] = value & 255;
    while (++i22 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset4 + i22 - 1] !== 0)
        sub = 1;
      this[offset4 + i22] = (value / mul >> 0) - sub & 255;
    }
    return offset4 + byteLength2;
  };
  Buffer2.prototype.writeIntBE = function(value, offset4, byteLength2, noAssert) {
    if (value = +value, offset4 = offset4 >>> 0, !noAssert) {
      let limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset4, byteLength2, limit - 1, -limit);
    }
    let i22 = byteLength2 - 1, mul = 1, sub = 0;
    this[offset4 + i22] = value & 255;
    while (--i22 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset4 + i22 + 1] !== 0)
        sub = 1;
      this[offset4 + i22] = (value / mul >> 0) - sub & 255;
    }
    return offset4 + byteLength2;
  };
  Buffer2.prototype.writeInt8 = function(value, offset4, noAssert) {
    if (value = +value, offset4 = offset4 >>> 0, !noAssert)
      checkInt(this, value, offset4, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    return this[offset4] = value & 255, offset4 + 1;
  };
  Buffer2.prototype.writeInt16LE = function(value, offset4, noAssert) {
    if (value = +value, offset4 = offset4 >>> 0, !noAssert)
      checkInt(this, value, offset4, 2, 32767, -32768);
    return this[offset4] = value & 255, this[offset4 + 1] = value >>> 8, offset4 + 2;
  };
  Buffer2.prototype.writeInt16BE = function(value, offset4, noAssert) {
    if (value = +value, offset4 = offset4 >>> 0, !noAssert)
      checkInt(this, value, offset4, 2, 32767, -32768);
    return this[offset4] = value >>> 8, this[offset4 + 1] = value & 255, offset4 + 2;
  };
  Buffer2.prototype.writeInt32LE = function(value, offset4, noAssert) {
    if (value = +value, offset4 = offset4 >>> 0, !noAssert)
      checkInt(this, value, offset4, 4, 2147483647, -2147483648);
    return this[offset4] = value & 255, this[offset4 + 1] = value >>> 8, this[offset4 + 2] = value >>> 16, this[offset4 + 3] = value >>> 24, offset4 + 4;
  };
  Buffer2.prototype.writeInt32BE = function(value, offset4, noAssert) {
    if (value = +value, offset4 = offset4 >>> 0, !noAssert)
      checkInt(this, value, offset4, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    return this[offset4] = value >>> 24, this[offset4 + 1] = value >>> 16, this[offset4 + 2] = value >>> 8, this[offset4 + 3] = value & 255, offset4 + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function(value, offset4 = 0) {
    return wrtBigUInt64LE(this, value, offset4, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function(value, offset4 = 0) {
    return wrtBigUInt64BE(this, value, offset4, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeFloatLE = function(value, offset4, noAssert) {
    return writeFloat(this, value, offset4, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function(value, offset4, noAssert) {
    return writeFloat(this, value, offset4, false, noAssert);
  };
  Buffer2.prototype.writeDoubleLE = function(value, offset4, noAssert) {
    return writeDouble(this, value, offset4, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function(value, offset4, noAssert) {
    return writeDouble(this, value, offset4, false, noAssert);
  };
  Buffer2.prototype.copy = function(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0)
      throw RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length)
      throw RangeError("Index out of range");
    if (end < 0)
      throw RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start)
      end = target.length - targetStart + start;
    let len2 = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function")
      this.copyWithin(targetStart, start, end);
    else
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len2;
  };
  Buffer2.prototype.fill = function(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string")
        encoding = start, start = 0, end = this.length;
      else if (typeof end === "string")
        encoding = end, end = this.length;
      if (encoding !== undefined && typeof encoding !== "string")
        throw TypeError("encoding must be a string");
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding))
        throw TypeError("Unknown encoding: " + encoding);
      if (val.length === 1) {
        let code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1")
          val = code2;
      }
    } else if (typeof val === "number")
      val = val & 255;
    else if (typeof val === "boolean")
      val = Number(val);
    if (start < 0 || this.length < start || this.length < end)
      throw RangeError("Out of range index");
    if (end <= start)
      return this;
    if (start = start >>> 0, end = end === undefined ? this.length : end >>> 0, !val)
      val = 0;
    let i22;
    if (typeof val === "number")
      for (i22 = start;i22 < end; ++i22)
        this[i22] = val;
    else {
      let bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding), len2 = bytes.length;
      if (len2 === 0)
        throw TypeError('The value "' + val + '" is invalid for argument "value"');
      for (i22 = 0;i22 < end - start; ++i22)
        this[i22 + start] = bytes[i22 % len2];
    }
    return this;
  };
  INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  hexSliceLookupTable = function() {
    let table = Array(256);
    for (let i22 = 0;i22 < 16; ++i22) {
      let i16 = i22 * 16;
      for (let j = 0;j < 16; ++j)
        table[i16 + j] = "0123456789abcdef"[i22] + "0123456789abcdef"[j];
    }
    return table;
  }();
  resolveObjectURL = notimpl("resolveObjectURL");
  isUtf8 = notimpl("isUtf8");
  transcode = notimpl("transcode");
  buffer_default = Buffer2;
});

// node:events
var exports_events = {};
__export(exports_events, {
  setMaxListeners: () => setMaxListeners2,
  once: () => once2,
  listenerCount: () => listenerCount2,
  init: () => EventEmitter,
  getMaxListeners: () => getMaxListeners2,
  getEventListeners: () => getEventListeners,
  default: () => events_default,
  captureRejectionSymbol: () => captureRejectionSymbol,
  addAbortListener: () => addAbortListener,
  EventEmitter: () => EventEmitter
});
function emitError(emitter, args) {
  var { _events: events } = emitter;
  if (args[0] ??= Error("Unhandled error."), !events)
    throw args[0];
  var errorMonitor = events[kErrorMonitor];
  if (errorMonitor)
    for (var handler of ArrayPrototypeSlice.call(errorMonitor))
      handler.apply(emitter, args);
  var handlers = events.error;
  if (!handlers)
    throw args[0];
  for (var handler of ArrayPrototypeSlice.call(handlers))
    handler.apply(emitter, args);
  return true;
}
function addCatch(emitter, promise, type, args) {
  promise.then(undefined, function(err) {
    queueMicrotask(() => emitUnhandledRejectionOrErr(emitter, err, type, args));
  });
}
function emitUnhandledRejectionOrErr(emitter, err, type, args) {
  if (typeof emitter[kRejection] === "function")
    emitter[kRejection](err, type, ...args);
  else
    try {
      emitter[kCapture] = false, emitter.emit("error", err);
    } finally {
      emitter[kCapture] = true;
    }
}
function overflowWarning(emitter, type, handlers) {
  handlers.warned = true;
  let warn = Error(`Possible EventEmitter memory leak detected. ${handlers.length} ${String(type)} listeners added to [${emitter.constructor.name}]. Use emitter.setMaxListeners() to increase limit`);
  warn.name = "MaxListenersExceededWarning", warn.emitter = emitter, warn.type = type, warn.count = handlers.length, console.warn(warn);
}
function onceWrapper(type, listener, ...args) {
  this.removeListener(type, listener), listener.apply(this, args);
}
function once2(emitter, type, options2) {
  var signal = options2?.signal;
  if (validateAbortSignal(signal, "options.signal"), signal?.aborted)
    throw new AbortError(undefined, { cause: signal?.reason });
  let { resolve, reject, promise } = $newPromiseCapability(Promise), errorListener = (err) => {
    if (emitter.removeListener(type, resolver), signal != null)
      eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
    reject(err);
  }, resolver = (...args) => {
    if (typeof emitter.removeListener === "function")
      emitter.removeListener("error", errorListener);
    if (signal != null)
      eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
    resolve(args);
  };
  if (eventTargetAgnosticAddListener(emitter, type, resolver, { once: true }), type !== "error" && typeof emitter.once === "function")
    emitter.once("error", errorListener);
  function abortListener() {
    eventTargetAgnosticRemoveListener(emitter, type, resolver), eventTargetAgnosticRemoveListener(emitter, "error", errorListener), reject(new AbortError(undefined, { cause: signal?.reason }));
  }
  if (signal != null)
    eventTargetAgnosticAddListener(signal, "abort", abortListener, { once: true });
  return promise;
}
function getEventListeners(emitter, type) {
  return emitter.listeners(type);
}
function setMaxListeners2(n2, ...eventTargets) {
  validateNumber2(n2, "setMaxListeners", 0);
  var length;
  if (eventTargets && (length = eventTargets.length))
    for (let i4 = 0;i4 < length; i4++)
      eventTargets[i4].setMaxListeners(n2);
  else
    defaultMaxListeners = n2;
}
function listenerCount2(emitter, type) {
  return emitter.listenerCount(type);
}
function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
  if (typeof emitter.removeListener === "function")
    emitter.removeListener(name, listener);
  else
    emitter.removeEventListener(name, listener, flags);
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function")
    if (flags.once)
      emitter.once(name, listener);
    else
      emitter.on(name, listener);
  else
    emitter.addEventListener(name, listener, flags);
}
function ERR_INVALID_ARG_TYPE2(name, type, value) {
  let err = TypeError(`The "${name}" argument must be of type ${type}. Received ${value}`);
  return err.code = "ERR_INVALID_ARG_TYPE", err;
}
function ERR_OUT_OF_RANGE2(name, range, value) {
  let err = RangeError(`The "${name}" argument is out of range. It must be ${range}. Received ${value}`);
  return err.code = "ERR_OUT_OF_RANGE", err;
}
function validateAbortSignal(signal, name) {
  if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal)))
    throw ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
}
function validateNumber2(value, name, min3, max3) {
  if (typeof value !== "number")
    throw ERR_INVALID_ARG_TYPE2(name, "number", value);
  if (min3 != null && value < min3 || max3 != null && value > max3 || (min3 != null || max3 != null) && Number.isNaN(value))
    throw ERR_OUT_OF_RANGE2(name, `${min3 != null ? `>= ${min3}` : ""}${min3 != null && max3 != null ? " && " : ""}${max3 != null ? `<= ${max3}` : ""}`, value);
}
function checkListener(listener) {
  if (typeof listener !== "function")
    throw TypeError("The listener must be a function");
}
function validateBoolean(value, name) {
  if (typeof value !== "boolean")
    throw ERR_INVALID_ARG_TYPE2(name, "boolean", value);
}
function getMaxListeners2(emitterOrTarget) {
  return emitterOrTarget?._maxListeners ?? defaultMaxListeners;
}
function addAbortListener(signal, listener) {
  if (signal === undefined)
    throw ERR_INVALID_ARG_TYPE2("signal", "AbortSignal", signal);
  if (validateAbortSignal(signal, "signal"), typeof listener !== "function")
    throw ERR_INVALID_ARG_TYPE2("listener", "function", listener);
  let removeEventListener;
  if (signal.aborted)
    queueMicrotask(() => listener());
  else
    signal.addEventListener("abort", listener, { __proto__: null, once: true }), removeEventListener = () => {
      signal.removeEventListener("abort", listener);
    };
  return { __proto__: null, [Symbol.dispose]() {
    removeEventListener?.();
  } };
}
var SymbolFor, kCapture, kErrorMonitor, kMaxEventTargetListeners, kMaxEventTargetListenersWarned, kRejection, captureRejectionSymbol, ArrayPrototypeSlice, defaultMaxListeners = 10, EventEmitter = function(opts) {
  if (this._events === undefined || this._events === this.__proto__._events)
    this._events = { __proto__: null }, this._eventsCount = 0;
  if (this._maxListeners ??= undefined, this[kCapture] = opts?.captureRejections ? Boolean(opts?.captureRejections) : EventEmitterPrototype[kCapture])
    this.emit = emitWithRejectionCapture;
}, EventEmitterPrototype, emitWithoutRejectionCapture = function(type, ...args) {
  if (type === "error")
    return emitError(this, args);
  var { _events: events } = this;
  if (events === undefined)
    return false;
  var handlers = events[type];
  if (handlers === undefined)
    return false;
  let maybeClonedHandlers = handlers.length > 1 ? handlers.slice() : handlers;
  for (let i4 = 0, { length } = maybeClonedHandlers;i4 < length; i4++) {
    let handler = maybeClonedHandlers[i4];
    switch (args.length) {
      case 0:
        handler.call(this);
        break;
      case 1:
        handler.call(this, args[0]);
        break;
      case 2:
        handler.call(this, args[0], args[1]);
        break;
      case 3:
        handler.call(this, args[0], args[1], args[2]);
        break;
      default:
        handler.apply(this, args);
        break;
    }
  }
  return true;
}, emitWithRejectionCapture = function(type, ...args) {
  if (type === "error")
    return emitError(this, args);
  var { _events: events } = this;
  if (events === undefined)
    return false;
  var handlers = events[type];
  if (handlers === undefined)
    return false;
  let maybeClonedHandlers = handlers.length > 1 ? handlers.slice() : handlers;
  for (let i4 = 0, { length } = maybeClonedHandlers;i4 < length; i4++) {
    let handler = maybeClonedHandlers[i4], result;
    switch (args.length) {
      case 0:
        result = handler.call(this);
        break;
      case 1:
        result = handler.call(this, args[0]);
        break;
      case 2:
        result = handler.call(this, args[0], args[1]);
        break;
      case 3:
        result = handler.call(this, args[0], args[1], args[2]);
        break;
      default:
        result = handler.apply(this, args);
        break;
    }
    if (result !== undefined && typeof result?.then === "function" && result.then === Promise.prototype.then)
      addCatch(this, result, type, args);
  }
  return true;
}, AbortError, events_default;
var init_events = __esm(() => {
  SymbolFor = Symbol.for;
  kCapture = Symbol("kCapture");
  kErrorMonitor = SymbolFor("events.errorMonitor");
  kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
  kMaxEventTargetListenersWarned = Symbol("events.maxEventTargetListenersWarned");
  kRejection = SymbolFor("nodejs.rejection");
  captureRejectionSymbol = SymbolFor("nodejs.rejection");
  ArrayPrototypeSlice = Array.prototype.slice;
  EventEmitterPrototype = EventEmitter.prototype = {};
  EventEmitterPrototype._events = undefined;
  EventEmitterPrototype._eventsCount = 0;
  EventEmitterPrototype._maxListeners = undefined;
  EventEmitterPrototype.setMaxListeners = function(n2) {
    return validateNumber2(n2, "setMaxListeners", 0), this._maxListeners = n2, this;
  };
  EventEmitterPrototype.constructor = EventEmitter;
  EventEmitterPrototype.getMaxListeners = function() {
    return this?._maxListeners ?? defaultMaxListeners;
  };
  EventEmitterPrototype.emit = emitWithoutRejectionCapture;
  EventEmitterPrototype.addListener = function(type, fn) {
    checkListener(fn);
    var events = this._events;
    if (!events)
      events = this._events = { __proto__: null }, this._eventsCount = 0;
    else if (events.newListener)
      this.emit("newListener", type, fn.listener ?? fn);
    var handlers = events[type];
    if (!handlers)
      events[type] = [fn], this._eventsCount++;
    else {
      handlers.push(fn);
      var m3 = this._maxListeners ?? defaultMaxListeners;
      if (m3 > 0 && handlers.length > m3 && !handlers.warned)
        overflowWarning(this, type, handlers);
    }
    return this;
  };
  EventEmitterPrototype.on = EventEmitterPrototype.addListener;
  EventEmitterPrototype.prependListener = function(type, fn) {
    checkListener(fn);
    var events = this._events;
    if (!events)
      events = this._events = { __proto__: null }, this._eventsCount = 0;
    else if (events.newListener)
      this.emit("newListener", type, fn.listener ?? fn);
    var handlers = events[type];
    if (!handlers)
      events[type] = [fn], this._eventsCount++;
    else {
      handlers.unshift(fn);
      var m3 = this._maxListeners ?? defaultMaxListeners;
      if (m3 > 0 && handlers.length > m3 && !handlers.warned)
        overflowWarning(this, type, handlers);
    }
    return this;
  };
  EventEmitterPrototype.once = function(type, fn) {
    checkListener(fn);
    let bound = onceWrapper.bind(this, type, fn);
    return bound.listener = fn, this.addListener(type, bound), this;
  };
  EventEmitterPrototype.prependOnceListener = function(type, fn) {
    checkListener(fn);
    let bound = onceWrapper.bind(this, type, fn);
    return bound.listener = fn, this.prependListener(type, bound), this;
  };
  EventEmitterPrototype.removeListener = function(type, fn) {
    checkListener(fn);
    var { _events: events } = this;
    if (!events)
      return this;
    var handlers = events[type];
    if (!handlers)
      return this;
    var length = handlers.length;
    let position = -1;
    for (let i4 = length - 1;i4 >= 0; i4--)
      if (handlers[i4] === fn || handlers[i4].listener === fn) {
        position = i4;
        break;
      }
    if (position < 0)
      return this;
    if (position === 0)
      handlers.shift();
    else
      handlers.splice(position, 1);
    if (handlers.length === 0)
      delete events[type], this._eventsCount--;
    return this;
  };
  EventEmitterPrototype.off = EventEmitterPrototype.removeListener;
  EventEmitterPrototype.removeAllListeners = function(type) {
    var { _events: events } = this;
    if (type && events) {
      if (events[type])
        delete events[type], this._eventsCount--;
    } else
      this._events = { __proto__: null };
    return this;
  };
  EventEmitterPrototype.listeners = function(type) {
    var { _events: events } = this;
    if (!events)
      return [];
    var handlers = events[type];
    if (!handlers)
      return [];
    return handlers.map((x3) => x3.listener ?? x3);
  };
  EventEmitterPrototype.rawListeners = function(type) {
    var { _events } = this;
    if (!_events)
      return [];
    var handlers = _events[type];
    if (!handlers)
      return [];
    return handlers.slice();
  };
  EventEmitterPrototype.listenerCount = function(type) {
    var { _events: events } = this;
    if (!events)
      return 0;
    return events[type]?.length ?? 0;
  };
  EventEmitterPrototype.eventNames = function() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  };
  EventEmitterPrototype[kCapture] = false;
  AbortError = class AbortError extends Error {
    constructor(message = "The operation was aborted", options2 = undefined) {
      if (options2 !== undefined && typeof options2 !== "object")
        throw ERR_INVALID_ARG_TYPE2("options", "Object", options2);
      super(message, options2);
      this.code = "ABORT_ERR", this.name = "AbortError";
    }
  };
  Object.defineProperties(EventEmitter, { captureRejections: { get() {
    return EventEmitterPrototype[kCapture];
  }, set(value) {
    validateBoolean(value, "EventEmitter.captureRejections"), EventEmitterPrototype[kCapture] = value;
  }, enumerable: true }, defaultMaxListeners: { enumerable: true, get: () => {
    return defaultMaxListeners;
  }, set: (arg) => {
    validateNumber2(arg, "defaultMaxListeners", 0), defaultMaxListeners = arg;
  } }, kMaxEventTargetListeners: { value: kMaxEventTargetListeners, enumerable: false, configurable: false, writable: false }, kMaxEventTargetListenersWarned: { value: kMaxEventTargetListenersWarned, enumerable: false, configurable: false, writable: false } });
  Object.assign(EventEmitter, { once: once2, getEventListeners, getMaxListeners: getMaxListeners2, setMaxListeners: setMaxListeners2, EventEmitter, usingDomains: false, captureRejectionSymbol, errorMonitor: kErrorMonitor, addAbortListener, init: EventEmitter, listenerCount: listenerCount2 });
  events_default = EventEmitter;
});

// node:stream
var require_stream = __commonJS((exports, module) => {
  var __commonJS2 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
  var require_primordials = __commonJS2((exports2, module2) => {

    class AggregateError2 extends Error {
      constructor(errors2) {
        if (!Array.isArray(errors2))
          throw TypeError(`Expected input to be an Array, got ${typeof errors2}`);
        let message = "";
        for (let i4 = 0;i4 < errors2.length; i4++)
          message += `    ${errors2[i4].stack}
`;
        super(message);
        this.name = "AggregateError", this.errors = errors2;
      }
    }
    module2.exports = { AggregateError: AggregateError2, ArrayIsArray(self2) {
      return Array.isArray(self2);
    }, ArrayPrototypeIncludes(self2, el) {
      return self2.includes(el);
    }, ArrayPrototypeIndexOf(self2, el) {
      return self2.indexOf(el);
    }, ArrayPrototypeJoin(self2, sep) {
      return self2.join(sep);
    }, ArrayPrototypeMap(self2, fn) {
      return self2.map(fn);
    }, ArrayPrototypePop(self2, el) {
      return self2.pop(el);
    }, ArrayPrototypePush(self2, el) {
      return self2.push(el);
    }, ArrayPrototypeSlice(self2, start, end) {
      return self2.slice(start, end);
    }, Error, FunctionPrototypeCall(fn, thisArgs, ...args) {
      return fn.call(thisArgs, ...args);
    }, FunctionPrototypeSymbolHasInstance(self2, instance) {
      return Function.prototype[Symbol.hasInstance].call(self2, instance);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(self2, props) {
      return Object.defineProperties(self2, props);
    }, ObjectDefineProperty(self2, name, prop) {
      return Object.defineProperty(self2, name, prop);
    }, ObjectGetOwnPropertyDescriptor(self2, name) {
      return Object.getOwnPropertyDescriptor(self2, name);
    }, ObjectKeys(obj) {
      return Object.keys(obj);
    }, ObjectSetPrototypeOf(target, proto) {
      return Object.setPrototypeOf(target, proto);
    }, Promise, PromisePrototypeCatch(self2, fn) {
      return self2.catch(fn);
    }, PromisePrototypeThen(self2, thenFn, catchFn) {
      return self2.then(thenFn, catchFn);
    }, PromiseReject(err) {
      return Promise.reject(err);
    }, PromiseResolve(val) {
      return Promise.resolve(val);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(self2, value) {
      return self2.test(value);
    }, SafeSet: Set, String, StringPrototypeSlice(self2, start, end) {
      return self2.slice(start, end);
    }, StringPrototypeToLowerCase(self2) {
      return self2.toLowerCase();
    }, StringPrototypeToUpperCase(self2) {
      return self2.toUpperCase();
    }, StringPrototypeTrim(self2) {
      return self2.trim();
    }, Symbol, SymbolFor: Symbol.for, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"), SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"), TypedArrayPrototypeSet(self2, buf, len2) {
      return self2.set(buf, len2);
    }, Boolean, Uint8Array };
  });
  var require_inspect = __commonJS2((exports2, module2) => {
    module2.exports = { format(format, ...args) {
      return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
        let replacement = args.shift();
        if (type === "f")
          return replacement.toFixed(6);
        else if (type === "j")
          return JSON.stringify(replacement);
        else if (type === "s" && typeof replacement === "object")
          return `${replacement.constructor !== Object ? replacement.constructor.name : ""} {}`.trim();
        else
          return replacement.toString();
      });
    }, inspect(value) {
      switch (typeof value) {
        case "string":
          if (value.includes("'")) {
            if (!value.includes('"'))
              return `"${value}"`;
            else if (!value.includes("`") && !value.includes("${"))
              return `\`${value}\``;
          }
          return `'${value}'`;
        case "number":
          if (isNaN(value))
            return "NaN";
          else if (Object.is(value, -0))
            return String(value);
          return value;
        case "bigint":
          return `${String(value)}n`;
        case "boolean":
        case "undefined":
          return String(value);
        case "object":
          return "{}";
      }
    } };
  });
  var require_errors = __commonJS2((exports2, module2) => {
    var { format, inspect } = require_inspect(), { AggregateError: CustomAggregateError } = require_primordials(), AggregateError2 = globalThis.AggregateError || CustomAggregateError, kIsNodeError = Symbol("kIsNodeError"), kTypes = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], classRegExp = /^([A-Z][a-z0-9]*)+$/, codes = {};
    function assert(value, message) {
      if (!value)
        throw new codes.ERR_INTERNAL_ASSERTION(message);
    }
    function addNumericalSeparator2(val) {
      let res = "", i4 = val.length, start = val[0] === "-" ? 1 : 0;
      for (;i4 >= start + 4; i4 -= 3)
        res = `_${val.slice(i4 - 3, i4)}${res}`;
      return `${val.slice(0, i4)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function")
        return assert(msg.length <= args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`), msg(...args);
      let expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      if (assert(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`), args.length === 0)
        return msg;
      return format(msg, ...args);
    }
    function E2(code2, message, Base) {
      if (!Base)
        Base = Error;

      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code2, message, args));
        }
        toString() {
          return `${this.name} [${code2}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, { name: { value: Base.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${code2}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), NodeError.prototype.code = code2, NodeError.prototype[kIsNodeError] = true, codes[code2] = NodeError;
    }
    function hideStackFrames(fn) {
      let hidden = "__node_internal_" + fn.name;
      return Object.defineProperty(fn, "name", { value: hidden }), fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors))
          return outerError.errors.push(innerError), outerError;
        let err = new AggregateError2([outerError, innerError], outerError.message);
        return err.code = outerError.code, err;
      }
      return innerError || outerError;
    }

    class AbortError2 extends Error {
      constructor(message = "The operation was aborted", options2 = undefined) {
        if (options2 !== undefined && typeof options2 !== "object")
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options2);
        super(message, options2);
        this.code = "ABORT_ERR", this.name = "AbortError";
      }
    }
    E2("ERR_ASSERTION", "%s", Error);
    E2("ERR_INVALID_ARG_TYPE", (name, expected, actual) => {
      if (assert(typeof name === "string", "'name' must be a string"), !Array.isArray(expected))
        expected = [expected];
      let msg = "The ";
      if (name.endsWith(" argument"))
        msg += `${name} `;
      else
        msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
      msg += "must be ";
      let types2 = [], instances = [], other = [];
      for (let value of expected)
        if (assert(typeof value === "string", "All expected entries have to be of type string"), kTypes.includes(value))
          types2.push(value.toLowerCase());
        else if (classRegExp.test(value))
          instances.push(value);
        else
          assert(value !== "object", 'The value "object" should be written as "Object"'), other.push(value);
      if (instances.length > 0) {
        let pos = types2.indexOf("object");
        if (pos !== -1)
          types2.splice(types2, pos, 1), instances.push("Object");
      }
      if (types2.length > 0) {
        switch (types2.length) {
          case 1:
            msg += `of type ${types2[0]}`;
            break;
          case 2:
            msg += `one of type ${types2[0]} or ${types2[1]}`;
            break;
          default: {
            let last = types2.pop();
            msg += `one of type ${types2.join(", ")}, or ${last}`;
          }
        }
        if (instances.length > 0 || other.length > 0)
          msg += " or ";
      }
      if (instances.length > 0) {
        switch (instances.length) {
          case 1:
            msg += `an instance of ${instances[0]}`;
            break;
          case 2:
            msg += `an instance of ${instances[0]} or ${instances[1]}`;
            break;
          default: {
            let last = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last}`;
          }
        }
        if (other.length > 0)
          msg += " or ";
      }
      switch (other.length) {
        case 0:
          break;
        case 1:
          if (other[0].toLowerCase() !== other[0])
            msg += "an ";
          msg += `${other[0]}`;
          break;
        case 2:
          msg += `one of ${other[0]} or ${other[1]}`;
          break;
        default: {
          let last = other.pop();
          msg += `one of ${other.join(", ")}, or ${last}`;
        }
      }
      if (actual == null)
        msg += `. Received ${actual}`;
      else if (typeof actual === "function" && actual.name)
        msg += `. Received function ${actual.name}`;
      else if (typeof actual === "object") {
        var _actual$constructor;
        if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== undefined && _actual$constructor.name)
          msg += `. Received an instance of ${actual.constructor.name}`;
        else {
          let inspected = inspect(actual, { depth: -1 });
          msg += `. Received ${inspected}`;
        }
      } else {
        let inspected = inspect(actual, { colors: false });
        if (inspected.length > 25)
          inspected = `${inspected.slice(0, 25)}...`;
        msg += `. Received type ${typeof actual} (${inspected})`;
      }
      return msg;
    }, TypeError);
    E2("ERR_INVALID_ARG_VALUE", (name, value, reason = "is invalid") => {
      let inspected = inspect(value);
      if (inspected.length > 128)
        inspected = inspected.slice(0, 128) + "...";
      return `The ${name.includes(".") ? "property" : "argument"} '${name}' ${reason}. Received ${inspected}`;
    }, TypeError);
    E2("ERR_INVALID_RETURN_VALUE", (input, name, value) => {
      var _value$constructor;
      let type = value !== null && value !== undefined && (_value$constructor = value.constructor) !== null && _value$constructor !== undefined && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
      return `Expected ${input} to be returned from the "${name}" function but got ${type}.`;
    }, TypeError);
    E2("ERR_MISSING_ARGS", (...args) => {
      assert(args.length > 0, "At least one arg needs to be specified");
      let msg, len2 = args.length;
      switch (args = (Array.isArray(args) ? args : [args]).map((a4) => `"${a4}"`).join(" or "), len2) {
        case 1:
          msg += `The ${args[0]} argument`;
          break;
        case 2:
          msg += `The ${args[0]} and ${args[1]} arguments`;
          break;
        default:
          {
            let last = args.pop();
            msg += `The ${args.join(", ")}, and ${last} arguments`;
          }
          break;
      }
      return `${msg} must be specified`;
    }, TypeError);
    E2("ERR_OUT_OF_RANGE", (str, range, input) => {
      assert(range, 'Missing "range" argument');
      let received;
      if (Number.isInteger(input) && Math.abs(input) > 4294967296)
        received = addNumericalSeparator2(String(input));
      else if (typeof input === "bigint") {
        received = String(input);
        let limit = BigInt(2) ** BigInt(32);
        if (input > limit || input < -limit)
          received = addNumericalSeparator2(received);
        received += "n";
      } else
        received = inspect(input);
      return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
    }, RangeError);
    E2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E2("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E2("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E2("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E2("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E2("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E2("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module2.exports = { AbortError: AbortError2, aggregateTwoErrors: hideStackFrames(aggregateTwoErrors), hideStackFrames, codes };
  });
  var require_event_target_shim = __commonJS2((exports2, module2) => {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var privateData = new WeakMap, wrappers = new WeakMap;
    function pd(event) {
      let retv = privateData.get(event);
      return console.assert(retv != null, "'this' is expected an Event object, but got", event), retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console < "u" && typeof console.error === "function")
          console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
        return;
      }
      if (!data.event.cancelable)
        return;
      if (data.canceled = true, typeof data.event.preventDefault === "function")
        data.event.preventDefault();
    }
    function Event(eventTarget, event) {
      privateData.set(this, { eventTarget, event, eventPhase: 2, currentTarget: eventTarget, canceled: false, stopped: false, immediateStopped: false, passiveListener: null, timeStamp: event.timeStamp || Date.now() }), Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      let keys = Object.keys(event);
      for (let i4 = 0;i4 < keys.length; ++i4) {
        let key = keys[i4];
        if (!(key in this))
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
      }
    }
    Event.prototype = { get type() {
      return pd(this).event.type;
    }, get target() {
      return pd(this).eventTarget;
    }, get currentTarget() {
      return pd(this).currentTarget;
    }, composedPath() {
      let currentTarget = pd(this).currentTarget;
      if (currentTarget == null)
        return [];
      return [currentTarget];
    }, get NONE() {
      return 0;
    }, get CAPTURING_PHASE() {
      return 1;
    }, get AT_TARGET() {
      return 2;
    }, get BUBBLING_PHASE() {
      return 3;
    }, get eventPhase() {
      return pd(this).eventPhase;
    }, stopPropagation() {
      let data = pd(this);
      if (data.stopped = true, typeof data.event.stopPropagation === "function")
        data.event.stopPropagation();
    }, stopImmediatePropagation() {
      let data = pd(this);
      if (data.stopped = true, data.immediateStopped = true, typeof data.event.stopImmediatePropagation === "function")
        data.event.stopImmediatePropagation();
    }, get bubbles() {
      return Boolean(pd(this).event.bubbles);
    }, get cancelable() {
      return Boolean(pd(this).event.cancelable);
    }, preventDefault() {
      setCancelFlag(pd(this));
    }, get defaultPrevented() {
      return pd(this).canceled;
    }, get composed() {
      return Boolean(pd(this).event.composed);
    }, get timeStamp() {
      return pd(this).timeStamp;
    }, get srcElement() {
      return pd(this).eventTarget;
    }, get cancelBubble() {
      return pd(this).stopped;
    }, set cancelBubble(value) {
      if (!value)
        return;
      let data = pd(this);
      if (data.stopped = true, typeof data.event.cancelBubble === "boolean")
        data.event.cancelBubble = true;
    }, get returnValue() {
      return !pd(this).canceled;
    }, set returnValue(value) {
      if (!value)
        setCancelFlag(pd(this));
    }, initEvent() {} };
    Object.defineProperty(Event.prototype, "constructor", { value: Event, configurable: true, writable: true });
    if (typeof window < "u" && typeof window.Event < "u")
      Object.setPrototypeOf(Event.prototype, window.Event.prototype), wrappers.set(window.Event.prototype, Event);
    function defineRedirectDescriptor(key) {
      return { get() {
        return pd(this).event[key];
      }, set(value) {
        pd(this).event[key] = value;
      }, configurable: true, enumerable: true };
    }
    function defineCallDescriptor(key) {
      return { value() {
        let event = pd(this).event;
        return event[key].apply(event, arguments);
      }, configurable: true, enumerable: true };
    }
    function defineWrapper(BaseEvent, proto) {
      let keys = Object.keys(proto);
      if (keys.length === 0)
        return BaseEvent;
      function CustomEvent2(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent2.prototype = Object.create(BaseEvent.prototype, { constructor: { value: CustomEvent2, configurable: true, writable: true } });
      for (let i4 = 0;i4 < keys.length; ++i4) {
        let key = keys[i4];
        if (!(key in BaseEvent.prototype)) {
          let isFunc = typeof Object.getOwnPropertyDescriptor(proto, key).value === "function";
          Object.defineProperty(CustomEvent2.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
        }
      }
      return CustomEvent2;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype)
        return Event;
      let wrapper = wrappers.get(proto);
      if (wrapper == null)
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto), wrappers.set(proto, wrapper);
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      return new (getWrapper(Object.getPrototypeOf(event)))(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = new WeakMap, CAPTURE = 1, BUBBLE = 2, ATTRIBUTE = 3;
    function isObject(x3) {
      return x3 !== null && typeof x3 === "object";
    }
    function getListeners(eventTarget) {
      let listeners = listenersMap.get(eventTarget);
      if (listeners == null)
        throw TypeError("'this' is expected an EventTarget object, but got another value.");
      return listeners;
    }
    function defineEventAttributeDescriptor(eventName) {
      return { get() {
        let node = getListeners(this).get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE)
            return node.listener;
          node = node.next;
        }
        return null;
      }, set(listener) {
        if (typeof listener !== "function" && !isObject(listener))
          listener = null;
        let listeners = getListeners(this), prev = null, node = listeners.get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE)
            if (prev !== null)
              prev.next = node.next;
            else if (node.next !== null)
              listeners.set(eventName, node.next);
            else
              listeners.delete(eventName);
          else
            prev = node;
          node = node.next;
        }
        if (listener !== null) {
          let newNode = { listener, listenerType: ATTRIBUTE, passive: false, once: false, next: null };
          if (prev === null)
            listeners.set(eventName, newNode);
          else
            prev.next = newNode;
        }
      }, configurable: true, enumerable: true };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
    }
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, { constructor: { value: CustomEventTarget, configurable: true, writable: true } });
      for (let i4 = 0;i4 < eventNames.length; ++i4)
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i4]);
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, new Map);
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0]))
        return defineCustomEventTarget(arguments[0]);
      if (arguments.length > 0) {
        let types2 = Array(arguments.length);
        for (let i4 = 0;i4 < arguments.length; ++i4)
          types2[i4] = arguments[i4];
        return defineCustomEventTarget(types2);
      }
      throw TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = { addEventListener(eventName, listener, options2) {
      if (listener == null)
        return;
      if (typeof listener !== "function" && !isObject(listener))
        throw TypeError("'listener' should be a function or an object.");
      let listeners = getListeners(this), optionsIsObj = isObject(options2), listenerType = (optionsIsObj ? Boolean(options2.capture) : Boolean(options2)) ? CAPTURE : BUBBLE, newNode = { listener, listenerType, passive: optionsIsObj && Boolean(options2.passive), once: optionsIsObj && Boolean(options2.once), next: null }, node = listeners.get(eventName);
      if (node === undefined) {
        listeners.set(eventName, newNode);
        return;
      }
      let prev = null;
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType)
          return;
        prev = node, node = node.next;
      }
      prev.next = newNode;
    }, removeEventListener(eventName, listener, options2) {
      if (listener == null)
        return;
      let listeners = getListeners(this), listenerType = (isObject(options2) ? Boolean(options2.capture) : Boolean(options2)) ? CAPTURE : BUBBLE, prev = null, node = listeners.get(eventName);
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType) {
          if (prev !== null)
            prev.next = node.next;
          else if (node.next !== null)
            listeners.set(eventName, node.next);
          else
            listeners.delete(eventName);
          return;
        }
        prev = node, node = node.next;
      }
    }, dispatchEvent(event) {
      if (event == null || typeof event.type !== "string")
        throw TypeError('"event.type" should be a string.');
      let listeners = getListeners(this), eventName = event.type, node = listeners.get(eventName);
      if (node == null)
        return true;
      let wrappedEvent = wrapEvent(this, event), prev = null;
      while (node != null) {
        if (node.once)
          if (prev !== null)
            prev.next = node.next;
          else if (node.next !== null)
            listeners.set(eventName, node.next);
          else
            listeners.delete(eventName);
        else
          prev = node;
        if (setPassiveListener(wrappedEvent, node.passive ? node.listener : null), typeof node.listener === "function")
          try {
            node.listener.call(this, wrappedEvent);
          } catch (err) {
            if (typeof console < "u" && typeof console.error === "function")
              console.error(err);
          }
        else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function")
          node.listener.handleEvent(wrappedEvent);
        if (isStopped(wrappedEvent))
          break;
        node = node.next;
      }
      return setPassiveListener(wrappedEvent, null), setEventPhase(wrappedEvent, 0), setCurrentTarget(wrappedEvent, null), !wrappedEvent.defaultPrevented;
    } };
    Object.defineProperty(EventTarget.prototype, "constructor", { value: EventTarget, configurable: true, writable: true });
    if (typeof window < "u" && typeof window.EventTarget < "u")
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    exports2.defineEventAttribute = defineEventAttribute;
    exports2.EventTarget = EventTarget;
    exports2.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports.default = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  });
  var require_abort_controller = __commonJS2((exports2, module2) => {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();

    class AbortSignal extends eventTargetShim.EventTarget {
      constructor() {
        super();
        throw TypeError("AbortSignal cannot be constructed directly");
      }
      get aborted() {
        let aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean")
          throw TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        return aborted;
      }
    }
    eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
    function createAbortSignal() {
      let signal = Object.create(AbortSignal.prototype);
      return eventTargetShim.EventTarget.call(signal), abortedFlags.set(signal, false), signal;
    }
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false)
        return;
      abortedFlags.set(signal, true), signal.dispatchEvent({ type: "abort" });
    }
    var abortedFlags = new WeakMap;
    Object.defineProperties(AbortSignal.prototype, { aborted: { enumerable: true } });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol")
      Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, { configurable: true, value: "AbortSignal" });

    class AbortController2 {
      constructor() {
        signals.set(this, createAbortSignal());
      }
      get signal() {
        return getSignal(this);
      }
      abort() {
        abortSignal(getSignal(this));
      }
    }
    var signals = new WeakMap;
    function getSignal(controller) {
      let signal = signals.get(controller);
      if (signal == null)
        throw TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      return signal;
    }
    Object.defineProperties(AbortController2.prototype, { signal: { enumerable: true }, abort: { enumerable: true } });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol")
      Object.defineProperty(AbortController2.prototype, Symbol.toStringTag, { configurable: true, value: "AbortController" });
    exports2.AbortController = AbortController2;
    exports2.AbortSignal = AbortSignal;
    exports2.default = AbortController2;
    module2.exports = AbortController2;
    module2.exports.AbortController = module2.exports.default = AbortController2;
    module2.exports.AbortSignal = AbortSignal;
  });
  var require_util = __commonJS2((exports2, module2) => {
    var bufferModule = (init_buffer(), __toCommonJS(exports_buffer)), { format, inspect } = require_inspect(), { codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3 } } = require_errors(), { kResistStopPropagation, AggregateError: AggregateError2, SymbolDispose } = require_primordials(), AbortSignal = globalThis.AbortSignal || require_abort_controller().AbortSignal, AbortController2 = globalThis.AbortController || require_abort_controller().AbortController, AsyncFunction = Object.getPrototypeOf(async function() {}).constructor, Blob3 = globalThis.Blob || bufferModule.Blob, isBlob = typeof Blob3 < "u" ? function(b4) {
      return b4 instanceof Blob3;
    } : function(b4) {
      return false;
    }, validateAbortSignal2 = (signal, name) => {
      if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal)))
        throw new ERR_INVALID_ARG_TYPE3(name, "AbortSignal", signal);
    }, validateFunction = (value, name) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE3(name, "Function", value);
    };
    module2.exports = { AggregateError: AggregateError2, kEmptyObject: Object.freeze({}), once(callback) {
      let called = false;
      return function(...args) {
        if (called)
          return;
        called = true, callback.apply(this, args);
      };
    }, createDeferredPromise: function() {
      let resolve, reject;
      return { promise: new Promise((res, rej) => {
        resolve = res, reject = rej;
      }), resolve, reject };
    }, promisify(fn) {
      return new Promise((resolve, reject) => {
        fn((err, ...args) => {
          if (err)
            return reject(err);
          return resolve(...args);
        });
      });
    }, debuglog() {
      return function() {};
    }, format, inspect, types: { isAsyncFunction(fn) {
      return fn instanceof AsyncFunction;
    }, isArrayBufferView(arr) {
      return ArrayBuffer.isView(arr);
    } }, isBlob, deprecate(fn, message) {
      return fn;
    }, addAbortListener: (init_events(), __toCommonJS(exports_events)).addAbortListener || function(signal, listener) {
      if (signal === undefined)
        throw new ERR_INVALID_ARG_TYPE3("signal", "AbortSignal", signal);
      validateAbortSignal2(signal, "signal"), validateFunction(listener, "listener");
      let removeEventListener;
      if (signal.aborted)
        queueMicrotask(() => listener());
      else
        signal.addEventListener("abort", listener, { __proto__: null, once: true, [kResistStopPropagation]: true }), removeEventListener = () => {
          signal.removeEventListener("abort", listener);
        };
      return { __proto__: null, [SymbolDispose]() {
        var _removeEventListener;
        (_removeEventListener = removeEventListener) === null || _removeEventListener === undefined || _removeEventListener();
      } };
    }, AbortSignalAny: AbortSignal.any || function(signals) {
      if (signals.length === 1)
        return signals[0];
      let ac = new AbortController2, abort = () => ac.abort();
      return signals.forEach((signal) => {
        validateAbortSignal2(signal, "signals"), signal.addEventListener("abort", abort, { once: true });
      }), ac.signal.addEventListener("abort", () => {
        signals.forEach((signal) => signal.removeEventListener("abort", abort));
      }, { once: true }), ac.signal;
    } };
    module2.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  });
  var require_validators = __commonJS2((exports2, module2) => {
    var { ArrayIsArray, ArrayPrototypeIncludes, ArrayPrototypeJoin, ArrayPrototypeMap, NumberIsInteger, NumberIsNaN, NumberMAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER, NumberParseInt, ObjectPrototypeHasOwnProperty, RegExpPrototypeExec, String: String2, StringPrototypeToUpperCase, StringPrototypeTrim } = require_primordials(), { hideStackFrames, codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE3, ERR_UNKNOWN_SIGNAL } } = require_errors(), { normalizeEncoding } = require_util(), { isAsyncFunction, isArrayBufferView } = require_util().types, signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/, modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name, def) {
      if (typeof value > "u")
        value = def;
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null)
          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        value = NumberParseInt(value, 8);
      }
      return validateUint32(value, name), value;
    }
    var validateInteger = hideStackFrames((value, name, min3 = NumberMIN_SAFE_INTEGER, max3 = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE3(name, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE3(name, "an integer", value);
      if (value < min3 || value > max3)
        throw new ERR_OUT_OF_RANGE3(name, `>= ${min3} && <= ${max3}`, value);
    }), validateInt32 = hideStackFrames((value, name, min3 = -2147483648, max3 = 2147483647) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE3(name, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE3(name, "an integer", value);
      if (value < min3 || value > max3)
        throw new ERR_OUT_OF_RANGE3(name, `>= ${min3} && <= ${max3}`, value);
    }), validateUint32 = hideStackFrames((value, name, positive = false) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE3(name, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE3(name, "an integer", value);
      let min3 = positive ? 1 : 0, max3 = 4294967295;
      if (value < min3 || value > max3)
        throw new ERR_OUT_OF_RANGE3(name, `>= ${min3} && <= ${max3}`, value);
    });
    function validateString(value, name) {
      if (typeof value !== "string")
        throw new ERR_INVALID_ARG_TYPE3(name, "string", value);
    }
    function validateNumber3(value, name, min3 = undefined, max3) {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE3(name, "number", value);
      if (min3 != null && value < min3 || max3 != null && value > max3 || (min3 != null || max3 != null) && NumberIsNaN(value))
        throw new ERR_OUT_OF_RANGE3(name, `${min3 != null ? `>= ${min3}` : ""}${min3 != null && max3 != null ? " && " : ""}${max3 != null ? `<= ${max3}` : ""}`, value);
    }
    var validateOneOf = hideStackFrames((value, name, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        let reason = "must be one of: " + ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v2) => typeof v2 === "string" ? `'${v2}'` : String2(v2)), ", ");
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateBoolean2(value, name) {
      if (typeof value !== "boolean")
        throw new ERR_INVALID_ARG_TYPE3(name, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options2, key, defaultValue) {
      return options2 == null || !ObjectPrototypeHasOwnProperty(options2, key) ? defaultValue : options2[key];
    }
    var validateObject = hideStackFrames((value, name, options2 = null) => {
      let allowArray = getOwnPropertyValueOrDefault(options2, "allowArray", false), allowFunction = getOwnPropertyValueOrDefault(options2, "allowFunction", false);
      if (!getOwnPropertyValueOrDefault(options2, "nullable", false) && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function"))
        throw new ERR_INVALID_ARG_TYPE3(name, "Object", value);
    }), validateDictionary = hideStackFrames((value, name) => {
      if (value != null && typeof value !== "object" && typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE3(name, "a dictionary", value);
    }), validateArray = hideStackFrames((value, name, minLength = 0) => {
      if (!ArrayIsArray(value))
        throw new ERR_INVALID_ARG_TYPE3(name, "Array", value);
      if (value.length < minLength) {
        let reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateStringArray(value, name) {
      validateArray(value, name);
      for (let i4 = 0;i4 < value.length; i4++)
        validateString(value[i4], `${name}[${i4}]`);
    }
    function validateBooleanArray(value, name) {
      validateArray(value, name);
      for (let i4 = 0;i4 < value.length; i4++)
        validateBoolean2(value[i4], `${name}[${i4}]`);
    }
    function validateAbortSignalArray(value, name) {
      validateArray(value, name);
      for (let i4 = 0;i4 < value.length; i4++) {
        let signal = value[i4], indexedName = `${name}[${i4}]`;
        if (signal == null)
          throw new ERR_INVALID_ARG_TYPE3(indexedName, "AbortSignal", signal);
        validateAbortSignal2(signal, indexedName);
      }
    }
    function validateSignalName(signal, name = "signal") {
      if (validateString(signal, name), signals[signal] === undefined) {
        if (signals[StringPrototypeToUpperCase(signal)] !== undefined)
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
      if (!isArrayBufferView(buffer))
        throw new ERR_INVALID_ARG_TYPE3(name, ["Buffer", "TypedArray", "DataView"], buffer);
    });
    function validateEncoding(data, encoding) {
      let normalizedEncoding = normalizeEncoding(encoding), length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0)
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
    }
    function validatePort(port, name = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero)
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
      return port | 0;
    }
    var validateAbortSignal2 = hideStackFrames((signal, name) => {
      if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal)))
        throw new ERR_INVALID_ARG_TYPE3(name, "AbortSignal", signal);
    }), validateFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE3(name, "Function", value);
    }), validatePlainFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function" || isAsyncFunction(value))
        throw new ERR_INVALID_ARG_TYPE3(name, "Function", value);
    }), validateUndefined = hideStackFrames((value, name) => {
      if (value !== undefined)
        throw new ERR_INVALID_ARG_TYPE3(name, "undefined", value);
    });
    function validateUnion(value, name, union) {
      if (!ArrayPrototypeIncludes(union, value))
        throw new ERR_INVALID_ARG_TYPE3(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name) {
      if (typeof value > "u" || !RegExpPrototypeExec(linkValueRegExp, value))
        throw new ERR_INVALID_ARG_VALUE(name, value, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string")
        return validateLinkHeaderFormat(hints, "hints"), hints;
      else if (ArrayIsArray(hints)) {
        let hintsLength = hints.length, result = "";
        if (hintsLength === 0)
          return result;
        for (let i4 = 0;i4 < hintsLength; i4++) {
          let link = hints[i4];
          if (validateLinkHeaderFormat(link, "hints"), result += link, i4 !== hintsLength - 1)
            result += ", ";
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE("hints", hints, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    module2.exports = { isInt32, isUint32, parseFileMode, validateArray, validateStringArray, validateBooleanArray, validateAbortSignalArray, validateBoolean: validateBoolean2, validateBuffer, validateDictionary, validateEncoding, validateFunction, validateInt32, validateInteger, validateNumber: validateNumber3, validateObject, validateOneOf, validatePlainFunction, validatePort, validateSignalName, validateString, validateUint32, validateUndefined, validateUnion, validateAbortSignal: validateAbortSignal2, validateLinkHeaderValue };
  });
  var require_process = __commonJS2((exports2, module2) => {
    module2.exports = globalThis.process;
  });
  var require_utils = __commonJS2((exports2, module2) => {
    var { SymbolAsyncIterator, SymbolIterator, SymbolFor: SymbolFor2 } = require_primordials(), kIsDestroyed = SymbolFor2("nodejs.stream.destroyed"), kIsErrored = SymbolFor2("nodejs.stream.errored"), kIsReadable = SymbolFor2("nodejs.stream.readable"), kIsWritable = SymbolFor2("nodejs.stream.writable"), kIsDisturbed = SymbolFor2("nodejs.stream.disturbed"), kIsClosedPromise = SymbolFor2("nodejs.webstream.isClosedPromise"), kControllerErrorFunction = SymbolFor2("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined ? undefined : _obj$_readableState.readable) !== false) && (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined ? undefined : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync2) {
      if (obj == null)
        return false;
      if (isAsync2 === true)
        return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync2 === false)
        return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream))
        return null;
      let { _writableState: wState, _readableState: rState } = stream, state = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== undefined && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableEnded === true)
        return true;
      let wState = stream._writableState;
      if (wState !== null && wState !== undefined && wState.errored)
        return false;
      if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== "boolean")
        return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableFinished === true)
        return true;
      let wState = stream._writableState;
      if (wState !== null && wState !== undefined && wState.errored)
        return false;
      if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== "boolean")
        return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream))
        return null;
      if (stream.readableEnded === true)
        return true;
      let rState = stream._readableState;
      if (!rState || rState.errored)
        return false;
      if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== "boolean")
        return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream))
        return null;
      let rState = stream._readableState;
      if (rState !== null && rState !== undefined && rState.errored)
        return false;
      if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== "boolean")
        return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null)
        return stream[kIsReadable];
      if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null)
        return stream[kIsWritable];
      if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream))
        return null;
      if (isDestroyed(stream))
        return true;
      if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream))
        return false;
      if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream))
        return false;
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream))
        return null;
      if (stream.writableErrored)
        return stream.writableErrored;
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined ? undefined : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream))
        return null;
      if (stream.readableErrored)
        return stream.readableErrored;
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined ? undefined : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream))
        return null;
      if (typeof stream.closed === "boolean")
        return stream.closed;
      let { _writableState: wState, _readableState: rState } = stream;
      if (typeof (wState === null || wState === undefined ? undefined : wState.closed) === "boolean" || typeof (rState === null || rState === undefined ? undefined : rState.closed) === "boolean")
        return (wState === null || wState === undefined ? undefined : wState.closed) || (rState === null || rState === undefined ? undefined : rState.closed);
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream))
        return stream._closed;
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) === undefined;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream))
        return null;
      let { _writableState: wState, _readableState: rState } = stream, state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== undefined ? _ref5 : stream.writableErrored) !== null && _ref4 !== undefined ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined ? undefined : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined ? undefined : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined ? undefined : _stream$_readableStat4.errored) !== null && _ref !== undefined ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined ? undefined : _stream$_writableStat4.errored));
    }
    module2.exports = { isDestroyed, kIsDestroyed, isDisturbed, kIsDisturbed, isErrored, kIsErrored, isReadable, kIsReadable, kIsClosedPromise, kControllerErrorFunction, kIsWritable, isClosed, isDuplexNodeStream, isFinished, isIterable, isReadableNodeStream, isReadableStream, isReadableEnded, isReadableFinished, isReadableErrored, isNodeStream, isWebStream, isWritable, isWritableNodeStream, isWritableStream, isWritableEnded, isWritableFinished, isWritableErrored, isServerRequest, isServerResponse, willEmitClose, isTransformStream };
  });
  var require_end_of_stream = __commonJS2((exports2, module2) => {
    var process2 = require_process(), { AbortError: AbortError2, codes } = require_errors(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_STREAM_PREMATURE_CLOSE } = codes, { kEmptyObject, once } = require_util(), { validateAbortSignal: validateAbortSignal2, validateFunction, validateObject, validateBoolean: validateBoolean2 } = require_validators(), { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials(), { isClosed, isReadable, isReadableNodeStream, isReadableStream, isReadableFinished, isReadableErrored, isWritable, isWritableNodeStream, isWritableStream, isWritableFinished, isWritableErrored, isNodeStream, willEmitClose: _willEmitClose, kIsClosedPromise } = require_utils(), addAbortListener2;
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {};
    function eos(stream, options2, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2)
        callback = options2, options2 = kEmptyObject;
      else if (options2 == null)
        options2 = kEmptyObject;
      else
        validateObject(options2, "options");
      if (validateFunction(callback, "callback"), validateAbortSignal2(options2.signal, "options.signal"), callback = once(callback), isReadableStream(stream) || isWritableStream(stream))
        return eosWeb(stream, options2, callback);
      if (!isNodeStream(stream))
        throw new ERR_INVALID_ARG_TYPE3("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      let readable = (_options$readable = options2.readable) !== null && _options$readable !== undefined ? _options$readable : isReadableNodeStream(stream), writable = (_options$writable = options2.writable) !== null && _options$writable !== undefined ? _options$writable : isWritableNodeStream(stream), wState = stream._writableState, rState = stream._readableState, onlegacyfinish = () => {
        if (!stream.writable)
          onfinish();
      }, willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable, writableFinished = isWritableFinished(stream, false), onfinish = () => {
        if (writableFinished = true, stream.destroyed)
          willEmitClose = false;
        if (willEmitClose && (!stream.readable || readable))
          return;
        if (!readable || readableFinished)
          callback.call(stream);
      }, readableFinished = isReadableFinished(stream, false), onend = () => {
        if (readableFinished = true, stream.destroyed)
          willEmitClose = false;
        if (willEmitClose && (!stream.writable || writable))
          return;
        if (!writable || writableFinished)
          callback.call(stream);
      }, onerror = (err) => {
        callback.call(stream, err);
      }, closed = isClosed(stream), onclose = () => {
        closed = true;
        let errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean")
          return callback.call(stream, errored);
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);
        }
        callback.call(stream);
      }, onclosed = () => {
        closed = true;
        let errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean")
          return callback.call(stream, errored);
        callback.call(stream);
      }, onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        if (stream.on("complete", onfinish), !willEmitClose)
          stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !wState)
        stream.on("end", onlegacyfinish), stream.on("close", onlegacyfinish);
      if (!willEmitClose && typeof stream.aborted === "boolean")
        stream.on("aborted", onclose);
      if (stream.on("end", onend), stream.on("finish", onfinish), options2.error !== false)
        stream.on("error", onerror);
      if (stream.on("close", onclose), closed)
        process2.nextTick(onclose);
      else if (wState !== null && wState !== undefined && wState.errorEmitted || rState !== null && rState !== undefined && rState.errorEmitted) {
        if (!willEmitClose)
          process2.nextTick(onclosed);
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false))
        process2.nextTick(onclosed);
      else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false))
        process2.nextTick(onclosed);
      else if (rState && stream.req && stream.aborted)
        process2.nextTick(onclosed);
      let cleanup = () => {
        if (callback = nop, stream.removeListener("aborted", onclose), stream.removeListener("complete", onfinish), stream.removeListener("abort", onclose), stream.removeListener("request", onrequest), stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish), stream.removeListener("close", onlegacyfinish), stream.removeListener("finish", onfinish), stream.removeListener("end", onend), stream.removeListener("error", onerror), stream.removeListener("close", onclose);
      };
      if (options2.signal && !closed) {
        let abort = () => {
          let endCallback = callback;
          cleanup(), endCallback.call(stream, new AbortError2(undefined, { cause: options2.signal.reason }));
        };
        if (options2.signal.aborted)
          process2.nextTick(abort);
        else {
          addAbortListener2 = addAbortListener2 || require_util().addAbortListener;
          let disposable = addAbortListener2(options2.signal, abort), originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose](), originalCallback.apply(stream, args);
          });
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options2, callback) {
      let isAborted2 = false, abort = nop;
      if (options2.signal)
        if (abort = () => {
          isAborted2 = true, callback.call(stream, new AbortError2(undefined, { cause: options2.signal.reason }));
        }, options2.signal.aborted)
          process2.nextTick(abort);
        else {
          addAbortListener2 = addAbortListener2 || require_util().addAbortListener;
          let disposable = addAbortListener2(options2.signal, abort), originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose](), originalCallback.apply(stream, args);
          });
        }
      let resolverFn = (...args) => {
        if (!isAborted2)
          process2.nextTick(() => callback.apply(stream, args));
      };
      return PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn), nop;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null)
        opts = kEmptyObject;
      if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup)
        validateBoolean2(opts.cleanup, "cleanup"), autoCleanup = opts.cleanup;
      return new Promise2((resolve, reject) => {
        let cleanup = eos(stream, opts, (err) => {
          if (autoCleanup)
            cleanup();
          if (err)
            reject(err);
          else
            resolve();
        });
      });
    }
    module2.exports = eos;
    module2.exports.finished = finished;
  });
  var require_destroy = __commonJS2((exports2, module2) => {
    var process2 = require_process(), { aggregateTwoErrors, codes: { ERR_MULTIPLE_CALLBACK }, AbortError: AbortError2 } = require_errors(), { Symbol: Symbol2 } = require_primordials(), { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils(), kDestroy = Symbol2("kDestroy"), kConstruct = Symbol2("kConstruct");
    function checkError(err, w2, r3) {
      if (err) {
        if (err.stack, w2 && !w2.errored)
          w2.errored = err;
        if (r3 && !r3.errored)
          r3.errored = err;
      }
    }
    function destroy(err, cb) {
      let r3 = this._readableState, w2 = this._writableState, s2 = w2 || r3;
      if (w2 !== null && w2 !== undefined && w2.destroyed || r3 !== null && r3 !== undefined && r3.destroyed) {
        if (typeof cb === "function")
          cb();
        return this;
      }
      if (checkError(err, w2, r3), w2)
        w2.destroyed = true;
      if (r3)
        r3.destroyed = true;
      if (!s2.constructed)
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      else
        _destroy(this, err, cb);
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called)
          return;
        called = true;
        let { _readableState: r3, _writableState: w2 } = self2;
        if (checkError(err2, w2, r3), w2)
          w2.closed = true;
        if (r3)
          r3.closed = true;
        if (typeof cb === "function")
          cb(err2);
        if (err2)
          process2.nextTick(emitErrorCloseNT, self2, err2);
        else
          process2.nextTick(emitCloseNT, self2);
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err), emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      let { _readableState: r3, _writableState: w2 } = self2;
      if (w2)
        w2.closeEmitted = true;
      if (r3)
        r3.closeEmitted = true;
      if (w2 !== null && w2 !== undefined && w2.emitClose || r3 !== null && r3 !== undefined && r3.emitClose)
        self2.emit("close");
    }
    function emitErrorNT(self2, err) {
      let { _readableState: r3, _writableState: w2 } = self2;
      if (w2 !== null && w2 !== undefined && w2.errorEmitted || r3 !== null && r3 !== undefined && r3.errorEmitted)
        return;
      if (w2)
        w2.errorEmitted = true;
      if (r3)
        r3.errorEmitted = true;
      self2.emit("error", err);
    }
    function undestroy() {
      let r3 = this._readableState, w2 = this._writableState;
      if (r3)
        r3.constructed = true, r3.closed = false, r3.closeEmitted = false, r3.destroyed = false, r3.errored = null, r3.errorEmitted = false, r3.reading = false, r3.ended = r3.readable === false, r3.endEmitted = r3.readable === false;
      if (w2)
        w2.constructed = true, w2.destroyed = false, w2.closed = false, w2.closeEmitted = false, w2.errored = null, w2.errorEmitted = false, w2.finalCalled = false, w2.prefinished = false, w2.ended = w2.writable === false, w2.ending = w2.writable === false, w2.finished = w2.writable === false;
    }
    function errorOrDestroy(stream, err, sync) {
      let { _readableState: r3, _writableState: w2 } = stream;
      if (w2 !== null && w2 !== undefined && w2.destroyed || r3 !== null && r3 !== undefined && r3.destroyed)
        return this;
      if (r3 !== null && r3 !== undefined && r3.autoDestroy || w2 !== null && w2 !== undefined && w2.autoDestroy)
        stream.destroy(err);
      else if (err) {
        if (err.stack, w2 && !w2.errored)
          w2.errored = err;
        if (r3 && !r3.errored)
          r3.errored = err;
        if (sync)
          process2.nextTick(emitErrorNT, stream, err);
        else
          emitErrorNT(stream, err);
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function")
        return;
      let { _readableState: r3, _writableState: w2 } = stream;
      if (r3)
        r3.constructed = false;
      if (w2)
        w2.constructed = false;
      if (stream.once(kConstruct, cb), stream.listenerCount(kConstruct) > 1)
        return;
      process2.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK);
          return;
        }
        called = true;
        let { _readableState: r3, _writableState: w2 } = stream, s2 = w2 || r3;
        if (r3)
          r3.constructed = true;
        if (w2)
          w2.constructed = true;
        if (s2.destroyed)
          stream.emit(kDestroy, err);
        else if (err)
          errorOrDestroy(stream, err, true);
        else
          process2.nextTick(emitConstructNT, stream);
      }
      try {
        stream._construct((err) => {
          process2.nextTick(onConstruct, err);
        });
      } catch (err) {
        process2.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err), process2.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream))
        return;
      if (!err && !isFinished(stream))
        err = new AbortError2;
      if (isServerRequest(stream))
        stream.socket = null, stream.destroy(err);
      else if (isRequest(stream))
        stream.abort();
      else if (isRequest(stream.req))
        stream.req.abort();
      else if (typeof stream.destroy === "function")
        stream.destroy(err);
      else if (typeof stream.close === "function")
        stream.close();
      else if (err)
        process2.nextTick(emitErrorCloseLegacy, stream, err);
      else
        process2.nextTick(emitCloseLegacy, stream);
      if (!stream.destroyed)
        stream[kIsDestroyed] = true;
    }
    module2.exports = { construct, destroyer, destroy, undestroy, errorOrDestroy };
  });
  var require_legacy = __commonJS2((exports2, module2) => {
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials(), { EventEmitter: EE } = (init_events(), __toCommonJS(exports_events));
    function Stream(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options2) {
      let source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause)
          source.pause();
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume)
          source.resume();
      }
      if (dest.on("drain", ondrain), !dest._isStdio && (!options2 || options2.end !== false))
        source.on("end", onend), source.on("close", onclose);
      let didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true, dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        if (didOnEnd = true, typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        if (cleanup(), EE.listenerCount(this, "error") === 0)
          this.emit("error", er);
      }
      prependListener(source, "error", onerror), prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata), dest.removeListener("drain", ondrain), source.removeListener("end", onend), source.removeListener("close", onclose), source.removeListener("error", onerror), dest.removeListener("error", onerror), source.removeListener("end", cleanup), source.removeListener("close", cleanup), dest.removeListener("close", cleanup);
      }
      return source.on("end", cleanup), source.on("close", cleanup), dest.on("close", cleanup), dest.emit("pipe", source), dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    module2.exports = { Stream, prependListener };
  });
  var require_add_abort_signal = __commonJS2((exports2, module2) => {
    var { SymbolDispose } = require_primordials(), { AbortError: AbortError2, codes } = require_errors(), { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils(), eos = require_end_of_stream(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3 } = codes, addAbortListener2, validateAbortSignal2 = (signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal))
        throw new ERR_INVALID_ARG_TYPE3(name, "AbortSignal", signal);
    };
    module2.exports.addAbortSignal = function(signal, stream) {
      if (validateAbortSignal2(signal, "signal"), !isNodeStream(stream) && !isWebStream(stream))
        throw new ERR_INVALID_ARG_TYPE3("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      return module2.exports.addAbortSignalNoValidate(signal, stream);
    };
    module2.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal))
        return stream;
      let onAbort = isNodeStream(stream) ? () => {
        stream.destroy(new AbortError2(undefined, { cause: signal.reason }));
      } : () => {
        stream[kControllerErrorFunction](new AbortError2(undefined, { cause: signal.reason }));
      };
      if (signal.aborted)
        onAbort();
      else {
        addAbortListener2 = addAbortListener2 || require_util().addAbortListener;
        let disposable = addAbortListener2(signal, onAbort);
        eos(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
  });
  var require_buffer_list = __commonJS2((exports2, module2) => {
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials(), { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer)), { inspect } = require_util();
    module2.exports = class {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(v2) {
        let entry = { data: v2, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry, ++this.length;
      }
      unshift(v2) {
        let entry = { data: v2, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry, ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        let ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        return --this.length, ret;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(s2) {
        if (this.length === 0)
          return "";
        let p3 = this.head, ret = "" + p3.data;
        while ((p3 = p3.next) !== null)
          ret += s2 + p3.data;
        return ret;
      }
      concat(n2) {
        if (this.length === 0)
          return Buffer3.alloc(0);
        let ret = Buffer3.allocUnsafe(n2 >>> 0), p3 = this.head, i4 = 0;
        while (p3)
          TypedArrayPrototypeSet(ret, p3.data, i4), i4 += p3.data.length, p3 = p3.next;
        return ret;
      }
      consume(n2, hasStrings) {
        let data = this.head.data;
        if (n2 < data.length) {
          let slice = data.slice(0, n2);
          return this.head.data = data.slice(n2), slice;
        }
        if (n2 === data.length)
          return this.shift();
        return hasStrings ? this._getString(n2) : this._getBuffer(n2);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p3 = this.head;p3; p3 = p3.next)
          yield p3.data;
      }
      _getString(n2) {
        let ret = "", p3 = this.head, c3 = 0;
        do {
          let str = p3.data;
          if (n2 > str.length)
            ret += str, n2 -= str.length;
          else {
            if (n2 === str.length)
              if (ret += str, ++c3, p3.next)
                this.head = p3.next;
              else
                this.head = this.tail = null;
            else
              ret += StringPrototypeSlice(str, 0, n2), this.head = p3, p3.data = StringPrototypeSlice(str, n2);
            break;
          }
          ++c3;
        } while ((p3 = p3.next) !== null);
        return this.length -= c3, ret;
      }
      _getBuffer(n2) {
        let ret = Buffer3.allocUnsafe(n2), retLen = n2, p3 = this.head, c3 = 0;
        do {
          let buf = p3.data;
          if (n2 > buf.length)
            TypedArrayPrototypeSet(ret, buf, retLen - n2), n2 -= buf.length;
          else {
            if (n2 === buf.length)
              if (TypedArrayPrototypeSet(ret, buf, retLen - n2), ++c3, p3.next)
                this.head = p3.next;
              else
                this.head = this.tail = null;
            else
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n2), retLen - n2), this.head = p3, p3.data = buf.slice(n2);
            break;
          }
          ++c3;
        } while ((p3 = p3.next) !== null);
        return this.length -= c3, ret;
      }
      [Symbol.for("nodejs.util.inspect.custom")](_2, options2) {
        return inspect(this, { ...options2, depth: 0, customInspect: false });
      }
    };
  });
  var require_state = __commonJS2((exports2, module2) => {
    var { MathFloor, NumberIsInteger } = require_primordials(), { validateInteger } = require_validators(), { ERR_INVALID_ARG_VALUE } = require_errors().codes, defaultHighWaterMarkBytes = 16384, defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options2, isDuplex, duplexKey) {
      return options2.highWaterMark != null ? options2.highWaterMark : isDuplex ? options2[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    function setDefaultHighWaterMark(objectMode, value) {
      if (validateInteger(value, "value", 0), objectMode)
        defaultHighWaterMarkObjectMode = value;
      else
        defaultHighWaterMarkBytes = value;
    }
    function getHighWaterMark(state, options2, duplexKey, isDuplex) {
      let hwm = highWaterMarkFrom(options2, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          let name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module2.exports = { getHighWaterMark, getDefaultHighWaterMark, setDefaultHighWaterMark };
  });
  var require_safe_buffer = __commonJS2((exports2, module2) => {
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var buffer = (init_buffer(), __toCommonJS(exports_buffer)), Buffer3 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src)
        dst[key] = src[key];
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow)
      module2.exports = buffer;
    else
      copyProps(buffer, exports2), exports2.Buffer = SafeBuffer;
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number")
        throw TypeError("Argument must not be a number");
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size4, fill, encoding) {
      if (typeof size4 !== "number")
        throw TypeError("Argument must be a number");
      var buf = Buffer3(size4);
      if (fill !== undefined)
        if (typeof encoding === "string")
          buf.fill(fill, encoding);
        else
          buf.fill(fill);
      else
        buf.fill(0);
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size4) {
      if (typeof size4 !== "number")
        throw TypeError("Argument must be a number");
      return Buffer3(size4);
    };
    SafeBuffer.allocUnsafeSlow = function(size4) {
      if (typeof size4 !== "number")
        throw TypeError("Argument must be a number");
      return buffer.SlowBuffer(size4);
    };
  });
  var require_string_decoder = __commonJS2((exports2) => {
    var Buffer3 = require_safe_buffer().Buffer, isEncoding = Buffer3.isEncoding || function(encoding) {
      switch (encoding = "" + encoding, encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true)
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase(), retried = true;
        }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding || !isEncoding(enc)))
        throw Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text, this.end = utf16End, nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast, nb = 4;
          break;
        case "base64":
          this.text = base64Text, this.end = base64End, nb = 3;
          break;
        default:
          this.write = simpleWrite, this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer3.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r3, i4;
      if (this.lastNeed) {
        if (r3 = this.fillLast(buf), r3 === undefined)
          return "";
        i4 = this.lastNeed, this.lastNeed = 0;
      } else
        i4 = 0;
      if (i4 < buf.length)
        return r3 ? r3 + this.text(buf, i4) : this.text(buf, i4);
      return r3 || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length)
        return buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length), this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i4) {
      var j = buf.length - 1;
      if (j < i4)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i4 || nb === -2)
        return 0;
      if (nb = utf8CheckByte(buf[j]), nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i4 || nb === -2)
        return 0;
      if (nb = utf8CheckByte(buf[j]), nb >= 0) {
        if (nb > 0)
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p3) {
      if ((buf[0] & 192) !== 128)
        return self2.lastNeed = 0, "";
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128)
          return self2.lastNeed = 1, "";
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128)
            return self2.lastNeed = 2, "";
        }
      }
    }
    function utf8FillLast(buf) {
      var p3 = this.lastTotal - this.lastNeed, r3 = utf8CheckExtraBytes(this, buf, p3);
      if (r3 !== undefined)
        return r3;
      if (this.lastNeed <= buf.length)
        return buf.copy(this.lastChar, p3, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      buf.copy(this.lastChar, p3, 0, buf.length), this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i4) {
      var total = utf8CheckIncomplete(this, buf, i4);
      if (!this.lastNeed)
        return buf.toString("utf8", i4);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      return buf.copy(this.lastChar, 0, end), buf.toString("utf8", i4, end);
    }
    function utf8End(buf) {
      var r3 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r3 + "";
      return r3;
    }
    function utf16Text(buf, i4) {
      if ((buf.length - i4) % 2 === 0) {
        var r3 = buf.toString("utf16le", i4);
        if (r3) {
          var c3 = r3.charCodeAt(r3.length - 1);
          if (c3 >= 55296 && c3 <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1], r3.slice(0, -1);
        }
        return r3;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = buf[buf.length - 1], buf.toString("utf16le", i4, buf.length - 1);
    }
    function utf16End(buf) {
      var r3 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r3 + this.lastChar.toString("utf16le", 0, end);
      }
      return r3;
    }
    function base64Text(buf, i4) {
      var n2 = (buf.length - i4) % 3;
      if (n2 === 0)
        return buf.toString("base64", i4);
      if (this.lastNeed = 3 - n2, this.lastTotal = 3, n2 === 1)
        this.lastChar[0] = buf[buf.length - 1];
      else
        this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1];
      return buf.toString("base64", i4, buf.length - n2);
    }
    function base64End(buf) {
      var r3 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r3 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r3;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  });
  var require_from = __commonJS2((exports2, module2) => {
    var process2 = require_process(), { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials(), { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer)), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_STREAM_NULL_VALUES } = require_errors().codes;
    function from2(Readable, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer3)
        return new Readable({ objectMode: true, ...opts, read() {
          this.push(iterable), this.push(null);
        } });
      let isAsync2;
      if (iterable && iterable[SymbolAsyncIterator])
        isAsync2 = true, iterator = iterable[SymbolAsyncIterator]();
      else if (iterable && iterable[SymbolIterator])
        isAsync2 = false, iterator = iterable[SymbolIterator]();
      else
        throw new ERR_INVALID_ARG_TYPE3("iterable", ["Iterable"], iterable);
      let readable = new Readable({ objectMode: true, highWaterMark: 1, ...opts }), reading = false;
      readable._read = function() {
        if (!reading)
          reading = true, next();
      }, readable._destroy = function(error, cb) {
        PromisePrototypeThen(close(error), () => process2.nextTick(cb, error), (e2) => process2.nextTick(cb, e2 || error));
      };
      async function close(error) {
        let hadError = error !== undefined && error !== null, hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          let { value, done } = await iterator.throw(error);
          if (await value, done)
            return;
        }
        if (typeof iterator.return === "function") {
          let { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (;; ) {
          try {
            let { value, done } = isAsync2 ? await iterator.next() : iterator.next();
            if (done)
              readable.push(null);
            else {
              let res = value && typeof value.then === "function" ? await value : value;
              if (res === null)
                throw reading = false, new ERR_STREAM_NULL_VALUES;
              else if (readable.push(res))
                continue;
              else
                reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module2.exports = from2;
  });
  var require_readable = __commonJS2((exports2, module2) => {
    var process2 = require_process(), { ArrayPrototypeIndexOf, NumberIsInteger, NumberIsNaN, NumberParseInt, ObjectDefineProperties, ObjectKeys, ObjectSetPrototypeOf, Promise: Promise2, SafeSet, SymbolAsyncDispose, SymbolAsyncIterator, Symbol: Symbol2 } = require_primordials();
    module2.exports = Readable;
    Readable.ReadableState = ReadableState;
    var { EventEmitter: EE } = (init_events(), __toCommonJS(exports_events)), { Stream, prependListener } = require_legacy(), { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer)), { addAbortSignal } = require_add_abort_signal(), eos = require_end_of_stream(), debug2 = require_util().debuglog("stream", (fn) => {
      debug2 = fn;
    }), BufferList = require_buffer_list(), destroyImpl = require_destroy(), { getHighWaterMark, getDefaultHighWaterMark } = require_state(), { aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_METHOD_NOT_IMPLEMENTED, ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE3, ERR_STREAM_PUSH_AFTER_EOF, ERR_STREAM_UNSHIFT_AFTER_END_EVENT }, AbortError: AbortError2 } = require_errors(), { validateObject } = require_validators(), kPaused = Symbol2("kPaused"), { StringDecoder } = require_string_decoder(), from2 = require_from();
    ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable, Stream);
    var nop = () => {}, { errorOrDestroy } = destroyImpl, kObjectMode = 1, kEnded = 2, kEndEmitted = 4, kReading = 8, kConstructed = 16, kSync = 32, kNeedReadable = 64, kEmittedReadable = 128, kReadableListening = 256, kResumeScheduled = 512, kErrorEmitted = 1024, kEmitClose = 2048, kAutoDestroy = 4096, kDestroyed = 8192, kClosed = 16384, kCloseEmitted = 32768, kMultiAwaitDrain = 65536, kReadingMore = 131072, kDataEmitted = 262144;
    function makeBitMapDescriptor(bit) {
      return { enumerable: false, get() {
        return (this.state & bit) !== 0;
      }, set(value) {
        if (value)
          this.state |= bit;
        else
          this.state &= ~bit;
      } };
    }
    ObjectDefineProperties(ReadableState.prototype, { objectMode: makeBitMapDescriptor(kObjectMode), ended: makeBitMapDescriptor(kEnded), endEmitted: makeBitMapDescriptor(kEndEmitted), reading: makeBitMapDescriptor(kReading), constructed: makeBitMapDescriptor(kConstructed), sync: makeBitMapDescriptor(kSync), needReadable: makeBitMapDescriptor(kNeedReadable), emittedReadable: makeBitMapDescriptor(kEmittedReadable), readableListening: makeBitMapDescriptor(kReadableListening), resumeScheduled: makeBitMapDescriptor(kResumeScheduled), errorEmitted: makeBitMapDescriptor(kErrorEmitted), emitClose: makeBitMapDescriptor(kEmitClose), autoDestroy: makeBitMapDescriptor(kAutoDestroy), destroyed: makeBitMapDescriptor(kDestroyed), closed: makeBitMapDescriptor(kClosed), closeEmitted: makeBitMapDescriptor(kCloseEmitted), multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain), readingMore: makeBitMapDescriptor(kReadingMore), dataEmitted: makeBitMapDescriptor(kDataEmitted) });
    function ReadableState(options2, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      if (this.state = kEmitClose | kAutoDestroy | kConstructed | kSync, options2 && options2.objectMode)
        this.state |= kObjectMode;
      if (isDuplex && options2 && options2.readableObjectMode)
        this.state |= kObjectMode;
      if (this.highWaterMark = options2 ? getHighWaterMark(this, options2, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false), this.buffer = new BufferList, this.length = 0, this.pipes = [], this.flowing = null, this[kPaused] = null, options2 && options2.emitClose === false)
        this.state &= ~kEmitClose;
      if (options2 && options2.autoDestroy === false)
        this.state &= ~kAutoDestroy;
      if (this.errored = null, this.defaultEncoding = options2 && options2.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, options2 && options2.encoding)
        this.decoder = new StringDecoder(options2.encoding), this.encoding = options2.encoding;
    }
    function Readable(options2) {
      if (!(this instanceof Readable))
        return new Readable(options2);
      let isDuplex = this instanceof require_duplex();
      if (this._readableState = new ReadableState(options2, this, isDuplex), options2) {
        if (typeof options2.read === "function")
          this._read = options2.read;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
        if (typeof options2.construct === "function")
          this._construct = options2.construct;
        if (options2.signal && !isDuplex)
          addAbortSignal(options2.signal, this);
      }
      Stream.call(this, options2), destroyImpl.construct(this, () => {
        if (this._readableState.needReadable)
          maybeReadMore(this, this._readableState);
      });
    }
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable.prototype[SymbolAsyncDispose] = function() {
      let error;
      if (!this.destroyed)
        error = this.readableEnded ? null : new AbortError2, this.destroy(error);
      return new Promise2((resolve, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve(null)));
    };
    Readable.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug2("readableAddChunk", chunk);
      let state = stream._readableState, err;
      if ((state.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          if (encoding = encoding || state.defaultEncoding, state.encoding !== encoding)
            if (addToFront && state.encoding)
              chunk = Buffer3.from(chunk, encoding).toString(state.encoding);
            else
              chunk = Buffer3.from(chunk, encoding), encoding = "";
        } else if (chunk instanceof Buffer3)
          encoding = "";
        else if (Stream._isUint8Array(chunk))
          chunk = Stream._uint8ArrayToBuffer(chunk), encoding = "";
        else if (chunk != null)
          err = new ERR_INVALID_ARG_TYPE3("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      if (err)
        errorOrDestroy(stream, err);
      else if (chunk === null)
        state.state &= ~kReading, onEofChunk(stream, state);
      else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0)
        if (addToFront)
          if ((state.state & kEndEmitted) !== 0)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
          else if (state.destroyed || state.errored)
            return false;
          else
            addChunk(stream, state, chunk, true);
        else if (state.ended)
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF);
        else if (state.destroyed || state.errored)
          return false;
        else if (state.state &= ~kReading, state.decoder && !encoding)
          if (chunk = state.decoder.write(chunk), state.objectMode || chunk.length !== 0)
            addChunk(stream, state, chunk, false);
          else
            maybeReadMore(stream, state);
        else
          addChunk(stream, state, chunk, false);
      else if (!addToFront)
        state.state &= ~kReading, maybeReadMore(stream, state);
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if ((state.state & kMultiAwaitDrain) !== 0)
          state.awaitDrainWriters.clear();
        else
          state.awaitDrainWriters = null;
        state.dataEmitted = true, stream.emit("data", chunk);
      } else {
        if (state.length += state.objectMode ? 1 : chunk.length, addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if ((state.state & kNeedReadable) !== 0)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable.prototype.isPaused = function() {
      let state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      let decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder, this._readableState.encoding = this._readableState.decoder.encoding;
      let buffer = this._readableState.buffer, content = "";
      for (let data of buffer)
        content += decoder.write(data);
      if (buffer.clear(), content !== "")
        buffer.push(content);
      return this._readableState.length = content.length, this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n2) {
      if (n2 > MAX_HWM)
        throw new ERR_OUT_OF_RANGE3("size", "<= 1GiB", n2);
      else
        n2--, n2 |= n2 >>> 1, n2 |= n2 >>> 2, n2 |= n2 >>> 4, n2 |= n2 >>> 8, n2 |= n2 >>> 16, n2++;
      return n2;
    }
    function howMuchToRead(n2, state) {
      if (n2 <= 0 || state.length === 0 && state.ended)
        return 0;
      if ((state.state & kObjectMode) !== 0)
        return 1;
      if (NumberIsNaN(n2)) {
        if (state.flowing && state.length)
          return state.buffer.first().length;
        return state.length;
      }
      if (n2 <= state.length)
        return n2;
      return state.ended ? state.length : 0;
    }
    Readable.prototype.read = function(n2) {
      if (debug2("read", n2), n2 === undefined)
        n2 = NaN;
      else if (!NumberIsInteger(n2))
        n2 = NumberParseInt(n2, 10);
      let state = this._readableState, nOrig = n2;
      if (n2 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n2);
      if (n2 !== 0)
        state.state &= ~kEmittedReadable;
      if (n2 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        if (debug2("read: emitReadable", state.length, state.ended), state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      if (n2 = howMuchToRead(n2, state), n2 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      let doRead = (state.state & kNeedReadable) !== 0;
      if (debug2("need readable", doRead), state.length === 0 || state.length - n2 < state.highWaterMark)
        doRead = true, debug2("length less than watermark", doRead);
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed)
        doRead = false, debug2("reading, ended or constructing", doRead);
      else if (doRead) {
        if (debug2("do read"), state.state |= kReading | kSync, state.length === 0)
          state.state |= kNeedReadable;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        if (state.state &= ~kSync, !state.reading)
          n2 = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n2 > 0)
        ret = fromList(n2, state);
      else
        ret = null;
      if (ret === null)
        state.needReadable = state.length <= state.highWaterMark, n2 = 0;
      else if (state.length -= n2, state.multiAwaitDrain)
        state.awaitDrainWriters.clear();
      else
        state.awaitDrainWriters = null;
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n2 && state.ended)
          endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted)
        state.dataEmitted = true, this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (debug2("onEofChunk"), state.ended)
        return;
      if (state.decoder) {
        let chunk = state.decoder.end();
        if (chunk && chunk.length)
          state.buffer.push(chunk), state.length += state.objectMode ? 1 : chunk.length;
      }
      if (state.ended = true, state.sync)
        emitReadable(stream);
      else
        state.needReadable = false, state.emittedReadable = true, emitReadable_(stream);
    }
    function emitReadable(stream) {
      let state = stream._readableState;
      if (debug2("emitReadable", state.needReadable, state.emittedReadable), state.needReadable = false, !state.emittedReadable)
        debug2("emitReadable", state.flowing), state.emittedReadable = true, process2.nextTick(emitReadable_, stream);
    }
    function emitReadable_(stream) {
      let state = stream._readableState;
      if (debug2("emitReadable_", state.destroyed, state.length, state.ended), !state.destroyed && !state.errored && (state.length || state.ended))
        stream.emit("readable"), state.emittedReadable = false;
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark, flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed)
        state.readingMore = true, process2.nextTick(maybeReadMore_, stream, state);
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        let len2 = state.length;
        if (debug2("maybeReadMore read 0"), stream.read(0), len2 === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n2) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      let src = this, state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain)
          state.multiAwaitDrain = true, state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
      }
      state.pipes.push(dest), debug2("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      let endFn = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr ? onend : unpipe;
      if (state.endEmitted)
        process2.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        if (debug2("onunpipe"), readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false)
            unpipeInfo.hasUnpiped = true, cleanup();
        }
      }
      function onend() {
        debug2("onend"), dest.end();
      }
      let ondrain, cleanedUp = false;
      function cleanup() {
        if (debug2("cleanup"), dest.removeListener("close", onclose), dest.removeListener("finish", onfinish), ondrain)
          dest.removeListener("drain", ondrain);
        if (dest.removeListener("error", onerror), dest.removeListener("unpipe", onunpipe), src.removeListener("end", onend), src.removeListener("end", unpipe), src.removeListener("data", ondata), cleanedUp = true, ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest)
            debug2("false write response, pause", 0), state.awaitDrainWriters = dest, state.multiAwaitDrain = false;
          else if (state.pipes.length > 1 && state.pipes.includes(dest))
            debug2("false write response, pause", state.awaitDrainWriters.size), state.awaitDrainWriters.add(dest);
          src.pause();
        }
        if (!ondrain)
          ondrain = pipeOnDrain(src, dest), dest.on("drain", ondrain);
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug2("ondata");
        let ret = dest.write(chunk);
        if (debug2("dest.write", ret), ret === false)
          pause();
      }
      function onerror(er) {
        if (debug2("onerror", er), unpipe(), dest.removeListener("error", onerror), dest.listenerCount("error") === 0) {
          let s2 = dest._writableState || dest._readableState;
          if (s2 && !s2.errorEmitted)
            errorOrDestroy(dest, er);
          else
            dest.emit("error", er);
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish), unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug2("onfinish"), dest.removeListener("close", onclose), unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug2("unpipe"), src.unpipe(dest);
      }
      if (dest.emit("pipe", src), dest.writableNeedDrain === true)
        pause();
      else if (!state.flowing)
        debug2("pipe resume"), src.resume();
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function() {
        let state = src._readableState;
        if (state.awaitDrainWriters === dest)
          debug2("pipeOnDrain", 1), state.awaitDrainWriters = null;
        else if (state.multiAwaitDrain)
          debug2("pipeOnDrain", state.awaitDrainWriters.size), state.awaitDrainWriters.delete(dest);
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data"))
          src.resume();
      };
    }
    Readable.prototype.unpipe = function(dest) {
      let state = this._readableState, unpipeInfo = { hasUnpiped: false };
      if (state.pipes.length === 0)
        return this;
      if (!dest) {
        let dests = state.pipes;
        state.pipes = [], this.pause();
        for (let i4 = 0;i4 < dests.length; i4++)
          dests[i4].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let index2 = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index2 === -1)
        return this;
      if (state.pipes.splice(index2, 1), state.pipes.length === 0)
        this.pause();
      return dest.emit("unpipe", this, unpipeInfo), this;
    };
    Readable.prototype.on = function(ev, fn) {
      let res = Stream.prototype.on.call(this, ev, fn), state = this._readableState;
      if (ev === "data") {
        if (state.readableListening = this.listenerCount("readable") > 0, state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          if (state.readableListening = state.needReadable = true, state.flowing = false, state.emittedReadable = false, debug2("on readable", state.length, state.reading), state.length)
            emitReadable(this);
          else if (!state.reading)
            process2.nextTick(nReadingNextTick, this);
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      let res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable")
        process2.nextTick(updateReadableListening, this);
      return res;
    };
    Readable.prototype.off = Readable.prototype.removeListener;
    Readable.prototype.removeAllListeners = function(ev) {
      let res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === undefined)
        process2.nextTick(updateReadableListening, this);
      return res;
    };
    function updateReadableListening(self2) {
      let state = self2._readableState;
      if (state.readableListening = self2.listenerCount("readable") > 0, state.resumeScheduled && state[kPaused] === false)
        state.flowing = true;
      else if (self2.listenerCount("data") > 0)
        self2.resume();
      else if (!state.readableListening)
        state.flowing = null;
    }
    function nReadingNextTick(self2) {
      debug2("readable nexttick read 0"), self2.read(0);
    }
    Readable.prototype.resume = function() {
      let state = this._readableState;
      if (!state.flowing)
        debug2("resume"), state.flowing = !state.readableListening, resume(this, state);
      return state[kPaused] = false, this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled)
        state.resumeScheduled = true, process2.nextTick(resume_, stream, state);
    }
    function resume_(stream, state) {
      if (debug2("resume", state.reading), !state.reading)
        stream.read(0);
      if (state.resumeScheduled = false, stream.emit("resume"), flow(stream), state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      if (debug2("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false)
        debug2("pause"), this._readableState.flowing = false, this.emit("pause");
      return this._readableState[kPaused] = true, this;
    };
    function flow(stream) {
      let state = stream._readableState;
      debug2("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause)
          paused = true, stream.pause();
      }), stream.on("end", () => {
        this.push(null);
      }), stream.on("error", (err) => {
        errorOrDestroy(this, err);
      }), stream.on("close", () => {
        this.destroy();
      }), stream.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        if (paused && stream.resume)
          paused = false, stream.resume();
      };
      let streamKeys = ObjectKeys(stream);
      for (let j = 1;j < streamKeys.length; j++) {
        let i4 = streamKeys[j];
        if (this[i4] === undefined && typeof stream[i4] === "function")
          this[i4] = stream[i4].bind(stream);
      }
      return this;
    };
    Readable.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable.prototype.iterator = function(options2) {
      if (options2 !== undefined)
        validateObject(options2, "options");
      return streamToAsyncIterator(this, options2);
    };
    function streamToAsyncIterator(stream, options2) {
      if (typeof stream.read !== "function")
        stream = Readable.wrap(stream, { objectMode: true });
      let iter = createAsyncIterator(stream, options2);
      return iter.stream = stream, iter;
    }
    async function* createAsyncIterator(stream, options2) {
      let callback = nop;
      function next(resolve) {
        if (this === stream)
          callback(), callback = nop;
        else
          callback = resolve;
      }
      stream.on("readable", next);
      let error, cleanup = eos(stream, { writable: false }, (err) => {
        error = err ? aggregateTwoErrors(error, err) : null, callback(), callback = nop;
      });
      try {
        while (true) {
          let chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null)
            yield chunk;
          else if (error)
            throw error;
          else if (error === null)
            return;
          else
            await new Promise2(next);
        }
      } catch (err) {
        throw error = aggregateTwoErrors(error, err), error;
      } finally {
        if ((error || (options2 === null || options2 === undefined ? undefined : options2.destroyOnReturn) !== false) && (error === undefined || stream._readableState.autoDestroy))
          destroyImpl.destroyer(stream, null);
        else
          stream.off("readable", next), cleanup();
      }
    }
    ObjectDefineProperties(Readable.prototype, { readable: { __proto__: null, get() {
      let r3 = this._readableState;
      return !!r3 && r3.readable !== false && !r3.destroyed && !r3.errorEmitted && !r3.endEmitted;
    }, set(val) {
      if (this._readableState)
        this._readableState.readable = !!val;
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(state) {
      if (this._readableState)
        this._readableState.flowing = state;
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(value) {
      if (!this._readableState)
        return;
      this._readableState.destroyed = value;
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } });
    ObjectDefineProperties(ReadableState.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[kPaused] !== false;
    }, set(value) {
      this[kPaused] = !!value;
    } } });
    Readable._fromList = fromList;
    function fromList(n2, state) {
      if (state.length === 0)
        return null;
      let ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n2 || n2 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else
        ret = state.buffer.consume(n2, state.decoder);
      return ret;
    }
    function endReadable(stream) {
      let state = stream._readableState;
      if (debug2("endReadable", state.endEmitted), !state.endEmitted)
        state.ended = true, process2.nextTick(endReadableNT, state, stream);
    }
    function endReadableNT(state, stream) {
      if (debug2("endReadableNT", state.endEmitted, state.length), !state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        if (state.endEmitted = true, stream.emit("end"), stream.writable && stream.allowHalfOpen === false)
          process2.nextTick(endWritableNT, stream);
        else if (state.autoDestroy) {
          let wState = stream._writableState;
          if (!wState || wState.autoDestroy && (wState.finished || wState.writable === false))
            stream.destroy();
        }
      }
    }
    function endWritableNT(stream) {
      if (stream.writable && !stream.writableEnded && !stream.destroyed)
        stream.end();
    }
    Readable.from = function(iterable, opts) {
      return from2(Readable, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === undefined)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable.fromWeb = function(readableStream, options2) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options2);
    };
    Readable.toWeb = function(streamReadable, options2) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options2);
    };
    Readable.wrap = function(src, options2) {
      var _ref, _src$readableObjectMo;
      return new Readable({ objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined ? _src$readableObjectMo : src.objectMode) !== null && _ref !== undefined ? _ref : true, ...options2, destroy(err, callback) {
        destroyImpl.destroyer(src, err), callback(err);
      } }).wrap(src);
    };
  });
  var require_writable = __commonJS2((exports2, module2) => {
    var process2 = require_process(), { ArrayPrototypeSlice: ArrayPrototypeSlice2, Error: Error2, FunctionPrototypeSymbolHasInstance, ObjectDefineProperty, ObjectDefineProperties, ObjectSetPrototypeOf, StringPrototypeToLowerCase, Symbol: Symbol2, SymbolHasInstance } = require_primordials();
    module2.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = (init_events(), __toCommonJS(exports_events)), Stream = require_legacy().Stream, { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer)), destroyImpl = require_destroy(), { addAbortSignal } = require_add_abort_signal(), { getHighWaterMark, getDefaultHighWaterMark } = require_state(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED, ERR_STREAM_ALREADY_FINISHED, ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING } = require_errors().codes, { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable, Stream);
    function nop() {}
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options2, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      if (this.objectMode = !!(options2 && options2.objectMode), isDuplex)
        this.objectMode = this.objectMode || !!(options2 && options2.writableObjectMode);
      this.highWaterMark = options2 ? getHighWaterMark(this, options2, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let noDecode = !!(options2 && options2.decodeStrings === false);
      this.decodeStrings = !noDecode, this.defaultEncoding = options2 && options2.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = onwrite.bind(undefined, stream), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, resetBuffer(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !options2 || options2.emitClose !== false, this.autoDestroy = !options2 || options2.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [], state.bufferedIndex = 0, state.allBuffers = true, state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function() {
      return ArrayPrototypeSlice2(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function Writable(options2) {
      let isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
        return new Writable(options2);
      if (this._writableState = new WritableState(options2, this, isDuplex), options2) {
        if (typeof options2.write === "function")
          this._write = options2.write;
        if (typeof options2.writev === "function")
          this._writev = options2.writev;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
        if (typeof options2.final === "function")
          this._final = options2.final;
        if (typeof options2.construct === "function")
          this._construct = options2.construct;
        if (options2.signal)
          addAbortSignal(options2.signal, this);
      }
      Stream.call(this, options2), destroyImpl.construct(this, () => {
        let state = this._writableState;
        if (!state.writing)
          clearBuffer(this, state);
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, { __proto__: null, value: function(object) {
      if (FunctionPrototypeSymbolHasInstance(this, object))
        return true;
      if (this !== Writable)
        return false;
      return object && object._writableState instanceof WritableState;
    } });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
    };
    function _write(stream, chunk, encoding, cb) {
      let state = stream._writableState;
      if (typeof encoding === "function")
        cb = encoding, encoding = state.defaultEncoding;
      else {
        if (!encoding)
          encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer3.isEncoding(encoding))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function")
          cb = nop;
      }
      if (chunk === null)
        throw new ERR_STREAM_NULL_VALUES;
      else if (!state.objectMode)
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false)
            chunk = Buffer3.from(chunk, encoding), encoding = "buffer";
        } else if (chunk instanceof Buffer3)
          encoding = "buffer";
        else if (Stream._isUint8Array(chunk))
          chunk = Stream._uint8ArrayToBuffer(chunk), encoding = "buffer";
        else
          throw new ERR_INVALID_ARG_TYPE3("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      let err;
      if (state.ending)
        err = new ERR_STREAM_WRITE_AFTER_END;
      else if (state.destroyed)
        err = new ERR_STREAM_DESTROYED("write");
      if (err)
        return process2.nextTick(cb, err), errorOrDestroy(stream, err, true), err;
      return state.pendingcb++, writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      let state = this._writableState;
      if (state.corked) {
        if (state.corked--, !state.writing)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function(encoding) {
      if (typeof encoding === "string")
        encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer3.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      return this._writableState.defaultEncoding = encoding, this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      let len2 = state.objectMode ? 1 : chunk.length;
      state.length += len2;
      let ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        if (state.buffered.push({ chunk, encoding, callback }), state.allBuffers && encoding !== "buffer")
          state.allBuffers = false;
        if (state.allNoop && callback !== nop)
          state.allNoop = false;
      } else
        state.writelen = len2, state.writecb = callback, state.writing = true, state.sync = true, stream._write(chunk, encoding, state.onwrite), state.sync = false;
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len2, chunk, encoding, cb) {
      if (state.writelen = len2, state.writecb = cb, state.writing = true, state.sync = true, state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb, cb(er), errorBuffer(state), errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      let state = stream._writableState, sync = state.sync, cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK);
        return;
      }
      if (state.writing = false, state.writecb = null, state.length -= state.writelen, state.writelen = 0, er) {
        if (er.stack, !state.errored)
          state.errored = er;
        if (stream._readableState && !stream._readableState.errored)
          stream._readableState.errored = er;
        if (sync)
          process2.nextTick(onwriteError, stream, state, er, cb);
        else
          onwriteError(stream, state, er, cb);
      } else {
        if (state.buffered.length > state.bufferedIndex)
          clearBuffer(stream, state);
        if (sync)
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb)
            state.afterWriteTickInfo.count++;
          else
            state.afterWriteTickInfo = { count: 1, cb, stream, state }, process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
        else
          afterWrite(stream, state, 1, cb);
      }
    }
    function afterWriteTick({ stream, state, count: count4, cb }) {
      return state.afterWriteTickInfo = null, afterWrite(stream, state, count4, cb);
    }
    function afterWrite(stream, state, count4, cb) {
      if (!state.ending && !stream.destroyed && state.length === 0 && state.needDrain)
        state.needDrain = false, stream.emit("drain");
      while (count4-- > 0)
        state.pendingcb--, cb();
      if (state.destroyed)
        errorBuffer(state);
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing)
        return;
      for (let n2 = state.bufferedIndex;n2 < state.buffered.length; ++n2) {
        var _state$errored;
        let { chunk, callback } = state.buffered[n2], len2 = state.objectMode ? 1 : chunk.length;
        state.length -= len2, callback((_state$errored = state.errored) !== null && _state$errored !== undefined ? _state$errored : new ERR_STREAM_DESTROYED("write"));
      }
      let onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i4 = 0;i4 < onfinishCallbacks.length; i4++) {
        var _state$errored2;
        onfinishCallbacks[i4]((_state$errored2 = state.errored) !== null && _state$errored2 !== undefined ? _state$errored2 : new ERR_STREAM_DESTROYED("end"));
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed)
        return;
      let { buffered, bufferedIndex, objectMode } = state, bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength)
        return;
      let i4 = bufferedIndex;
      if (state.bufferProcessing = true, bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        let callback = state.allNoop ? nop : (err) => {
          for (let n2 = i4;n2 < buffered.length; ++n2)
            buffered[n2].callback(err);
        }, chunks = state.allNoop && i4 === 0 ? buffered : ArrayPrototypeSlice2(buffered, i4);
        chunks.allBuffers = state.allBuffers, doWrite(stream, state, true, state.length, chunks, "", callback), resetBuffer(state);
      } else {
        do {
          let { chunk, encoding, callback } = buffered[i4];
          buffered[i4++] = null;
          let len2 = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len2, chunk, encoding, callback);
        } while (i4 < buffered.length && !state.writing);
        if (i4 === buffered.length)
          resetBuffer(state);
        else if (i4 > 256)
          buffered.splice(0, i4), state.bufferedIndex = 0;
        else
          state.bufferedIndex = i4;
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev)
        this._writev([{ chunk, encoding }], cb);
      else
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      let state = this._writableState;
      if (typeof chunk === "function")
        cb = chunk, chunk = null, encoding = null;
      else if (typeof encoding === "function")
        cb = encoding, encoding = null;
      let err;
      if (chunk !== null && chunk !== undefined) {
        let ret = _write(this, chunk, encoding);
        if (ret instanceof Error2)
          err = ret;
      }
      if (state.corked)
        state.corked = 1, this.uncork();
      if (err)
        ;
      else if (!state.errored && !state.ending)
        state.ending = true, finishMaybe(this, state, true), state.ended = true;
      else if (state.finished)
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      else if (state.destroyed)
        err = new ERR_STREAM_DESTROYED("end");
      if (typeof cb === "function")
        if (err || state.finished)
          process2.nextTick(cb, err);
        else
          state[kOnFinished].push(cb);
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        if (called = true, state.pendingcb--, err) {
          let onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i4 = 0;i4 < onfinishCallbacks.length; i4++)
            onfinishCallbacks[i4](err);
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state))
          state.prefinished = true, stream.emit("prefinish"), state.pendingcb++, process2.nextTick(finish, stream, state);
      }
      state.sync = true, state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled)
        if (typeof stream._final === "function" && !state.destroyed)
          state.finalCalled = true, callFinal(stream, state);
        else
          state.prefinished = true, stream.emit("prefinish");
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        if (prefinish(stream, state), state.pendingcb === 0) {
          if (sync)
            state.pendingcb++, process2.nextTick((stream2, state2) => {
              if (needFinish(state2))
                finish(stream2, state2);
              else
                state2.pendingcb--;
            }, stream, state);
          else if (needFinish(state))
            state.pendingcb++, finish(stream, state);
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--, state.finished = true;
      let onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i4 = 0;i4 < onfinishCallbacks.length; i4++)
        onfinishCallbacks[i4]();
      if (stream.emit("finish"), state.autoDestroy) {
        let rState = stream._readableState;
        if (!rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false))
          stream.destroy();
      }
    }
    ObjectDefineProperties(Writable.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(value) {
      if (this._writableState)
        this._writableState.destroyed = value;
    } }, writable: { __proto__: null, get() {
      let w2 = this._writableState;
      return !!w2 && w2.writable !== false && !w2.destroyed && !w2.errored && !w2.ending && !w2.ended;
    }, set(val) {
      if (this._writableState)
        this._writableState.writable = !!val;
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let wState = this._writableState;
      if (!wState)
        return false;
      return !wState.destroyed && !wState.ending && wState.needDrain;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    } } });
    var destroy = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      let state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length))
        process2.nextTick(errorBuffer, state);
      return destroy.call(this, err, cb), this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === undefined)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options2) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options2);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  });
  var require_duplexify = __commonJS2((exports2, module2) => {
    var process2 = require_process(), bufferModule = (init_buffer(), __toCommonJS(exports_buffer)), { isReadable, isWritable, isIterable, isNodeStream, isReadableNodeStream, isWritableNodeStream, isDuplexNodeStream, isReadableStream, isWritableStream } = require_utils(), eos = require_end_of_stream(), { AbortError: AbortError2, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_INVALID_RETURN_VALUE } } = require_errors(), { destroyer } = require_destroy(), Duplex = require_duplex(), Readable = require_readable(), Writable = require_writable(), { createDeferredPromise } = require_util(), from2 = require_from(), Blob3 = globalThis.Blob || bufferModule.Blob, isBlob = typeof Blob3 < "u" ? function(b4) {
      return b4 instanceof Blob3;
    } : function(b4) {
      return false;
    }, AbortController2 = globalThis.AbortController || require_abort_controller().AbortController, { FunctionPrototypeCall } = require_primordials();

    class Duplexify extends Duplex {
      constructor(options2) {
        super(options2);
        if ((options2 === null || options2 === undefined ? undefined : options2.readable) === false)
          this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true;
        if ((options2 === null || options2 === undefined ? undefined : options2.writable) === false)
          this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true;
      }
    }
    module2.exports = function duplexify(body, name) {
      if (isDuplexNodeStream(body))
        return body;
      if (isReadableNodeStream(body))
        return _duplexify({ readable: body });
      if (isWritableNodeStream(body))
        return _duplexify({ writable: body });
      if (isNodeStream(body))
        return _duplexify({ writable: false, readable: false });
      if (isReadableStream(body))
        return _duplexify({ readable: Readable.fromWeb(body) });
      if (isWritableStream(body))
        return _duplexify({ writable: Writable.fromWeb(body) });
      if (typeof body === "function") {
        let { value, write: write2, final, destroy } = fromAsyncGen(body);
        if (isIterable(value))
          return from2(Duplexify, value, { objectMode: true, write: write2, final, destroy });
        let then2 = value === null || value === undefined ? undefined : value.then;
        if (typeof then2 === "function") {
          let d2, promise = FunctionPrototypeCall(then2, value, (val) => {
            if (val != null)
              throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
          }, (err) => {
            destroyer(d2, err);
          });
          return d2 = new Duplexify({ objectMode: true, readable: false, write: write2, final(cb) {
            final(async () => {
              try {
                await promise, process2.nextTick(cb, null);
              } catch (err) {
                process2.nextTick(cb, err);
              }
            });
          }, destroy });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
      }
      if (isBlob(body))
        return duplexify(body.arrayBuffer());
      if (isIterable(body))
        return from2(Duplexify, body, { objectMode: true, writable: false });
      if (isReadableStream(body === null || body === undefined ? undefined : body.readable) && isWritableStream(body === null || body === undefined ? undefined : body.writable))
        return Duplexify.fromWeb(body);
      if (typeof (body === null || body === undefined ? undefined : body.writable) === "object" || typeof (body === null || body === undefined ? undefined : body.readable) === "object") {
        let readable = body !== null && body !== undefined && body.readable ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable) ? body === null || body === undefined ? undefined : body.readable : duplexify(body.readable) : undefined, writable = body !== null && body !== undefined && body.writable ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable) ? body === null || body === undefined ? undefined : body.writable : duplexify(body.writable) : undefined;
        return _duplexify({ readable, writable });
      }
      let then = body === null || body === undefined ? undefined : body.then;
      if (typeof then === "function") {
        let d2;
        return FunctionPrototypeCall(then, body, (val) => {
          if (val != null)
            d2.push(val);
          d2.push(null);
        }, (err) => {
          destroyer(d2, err);
        }), d2 = new Duplexify({ objectMode: true, writable: false, read() {} });
      }
      throw new ERR_INVALID_ARG_TYPE3(name, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], body);
    };
    function fromAsyncGen(fn) {
      let { promise, resolve } = createDeferredPromise(), ac = new AbortController2, signal = ac.signal;
      return { value: fn(async function* () {
        while (true) {
          let _promise = promise;
          promise = null;
          let { chunk, done, cb } = await _promise;
          if (process2.nextTick(cb), done)
            return;
          if (signal.aborted)
            throw new AbortError2(undefined, { cause: signal.reason });
          ({ promise, resolve } = createDeferredPromise()), yield chunk;
        }
      }(), { signal }), write(chunk, encoding, cb) {
        let _resolve = resolve;
        resolve = null, _resolve({ chunk, done: false, cb });
      }, final(cb) {
        let _resolve = resolve;
        resolve = null, _resolve({ done: true, cb });
      }, destroy(err, cb) {
        ac.abort(), cb(err);
      } };
    }
    function _duplexify(pair) {
      let r3 = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable, w2 = pair.writable, readable = !!isReadable(r3), writable = !!isWritable(w2), ondrain, onfinish, onreadable, onclose, d2;
      function onfinished(err) {
        let cb = onclose;
        if (onclose = null, cb)
          cb(err);
        else if (err)
          d2.destroy(err);
      }
      if (d2 = new Duplexify({ readableObjectMode: !!(r3 !== null && r3 !== undefined && r3.readableObjectMode), writableObjectMode: !!(w2 !== null && w2 !== undefined && w2.writableObjectMode), readable, writable }), writable)
        eos(w2, (err) => {
          if (writable = false, err)
            destroyer(r3, err);
          onfinished(err);
        }), d2._write = function(chunk, encoding, callback) {
          if (w2.write(chunk, encoding))
            callback();
          else
            ondrain = callback;
        }, d2._final = function(callback) {
          w2.end(), onfinish = callback;
        }, w2.on("drain", function() {
          if (ondrain) {
            let cb = ondrain;
            ondrain = null, cb();
          }
        }), w2.on("finish", function() {
          if (onfinish) {
            let cb = onfinish;
            onfinish = null, cb();
          }
        });
      if (readable)
        eos(r3, (err) => {
          if (readable = false, err)
            destroyer(r3, err);
          onfinished(err);
        }), r3.on("readable", function() {
          if (onreadable) {
            let cb = onreadable;
            onreadable = null, cb();
          }
        }), r3.on("end", function() {
          d2.push(null);
        }), d2._read = function() {
          while (true) {
            let buf = r3.read();
            if (buf === null) {
              onreadable = d2._read;
              return;
            }
            if (!d2.push(buf))
              return;
          }
        };
      return d2._destroy = function(err, callback) {
        if (!err && onclose !== null)
          err = new AbortError2;
        if (onreadable = null, ondrain = null, onfinish = null, onclose === null)
          callback(err);
        else
          onclose = callback, destroyer(w2, err), destroyer(r3, err);
      }, d2;
    }
  });
  var require_duplex = __commonJS2((exports2, module2) => {
    var { ObjectDefineProperties, ObjectGetOwnPropertyDescriptor, ObjectKeys, ObjectSetPrototypeOf } = require_primordials();
    module2.exports = Duplex;
    var Readable = require_readable(), Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
    ObjectSetPrototypeOf(Duplex, Readable);
    {
      let keys = ObjectKeys(Writable.prototype);
      for (let i4 = 0;i4 < keys.length; i4++) {
        let method = keys[i4];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options2) {
      if (!(this instanceof Duplex))
        return new Duplex(options2);
      if (Readable.call(this, options2), Writable.call(this, options2), options2) {
        if (this.allowHalfOpen = options2.allowHalfOpen !== false, options2.readable === false)
          this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true;
        if (options2.writable === false)
          this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true;
      } else
        this.allowHalfOpen = true;
    }
    ObjectDefineProperties(Duplex.prototype, { writable: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength") }, writableFinished: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      if (this._readableState === undefined || this._writableState === undefined)
        return false;
      return this._readableState.destroyed && this._writableState.destroyed;
    }, set(value) {
      if (this._readableState && this._writableState)
        this._readableState.destroyed = value, this._writableState.destroyed = value;
    } } });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === undefined)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options2) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options2);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify)
        duplexify = require_duplexify();
      return duplexify(body, "body");
    };
  });
  var require_transform = __commonJS2((exports2, module2) => {
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module2.exports = Transform2;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes, Duplex = require_duplex(), { getHighWaterMark } = require_state();
    ObjectSetPrototypeOf(Transform2.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform2, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform2(options2) {
      if (!(this instanceof Transform2))
        return new Transform2(options2);
      let readableHighWaterMark = options2 ? getHighWaterMark(this, options2, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0)
        options2 = { ...options2, highWaterMark: null, readableHighWaterMark, writableHighWaterMark: options2.writableHighWaterMark || 0 };
      if (Duplex.call(this, options2), this._readableState.sync = false, this[kCallback] = null, options2) {
        if (typeof options2.transform === "function")
          this._transform = options2.transform;
        if (typeof options2.flush === "function")
          this._flush = options2.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed)
        this._flush((er, data) => {
          if (er) {
            if (cb)
              cb(er);
            else
              this.destroy(er);
            return;
          }
          if (data != null)
            this.push(data);
          if (this.push(null), cb)
            cb();
        });
      else if (this.push(null), cb)
        cb();
    }
    function prefinish() {
      if (this._final !== final)
        final.call(this);
    }
    Transform2.prototype._final = final;
    Transform2.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform2.prototype._write = function(chunk, encoding, callback) {
      let rState = this._readableState, wState = this._writableState, length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null)
          this.push(val);
        if (wState.ended || length === rState.length || rState.length < rState.highWaterMark)
          callback();
        else
          this[kCallback] = callback;
      });
    };
    Transform2.prototype._read = function() {
      if (this[kCallback]) {
        let callback = this[kCallback];
        this[kCallback] = null, callback();
      }
    };
  });
  var require_passthrough = __commonJS2((exports2, module2) => {
    var { ObjectSetPrototypeOf } = require_primordials();
    module2.exports = PassThrough;
    var Transform2 = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform2.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform2);
    function PassThrough(options2) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options2);
      Transform2.call(this, options2);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  });
  var require_pipeline = __commonJS2((exports2, module2) => {
    var process2 = require_process(), { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials(), eos = require_end_of_stream(), { once } = require_util(), destroyImpl = require_destroy(), Duplex = require_duplex(), { aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS, ERR_STREAM_DESTROYED, ERR_STREAM_PREMATURE_CLOSE }, AbortError: AbortError2 } = require_errors(), { validateFunction, validateAbortSignal: validateAbortSignal2 } = require_validators(), { isIterable, isReadable, isReadableNodeStream, isNodeStream, isTransformStream, isWebStream, isReadableStream, isReadableFinished } = require_utils(), AbortController2 = globalThis.AbortController || require_abort_controller().AbortController, PassThrough, Readable, addAbortListener2;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      let cleanup = eos(stream, { readable: reading, writable: writing }, (err) => {
        finished = !err;
      });
      return { destroy: (err) => {
        if (finished)
          return;
        finished = true, destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
      }, cleanup };
    }
    function popCallback(streams) {
      return validateFunction(streams[streams.length - 1], "streams[stream.length - 1]"), streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val))
        return val;
      else if (isReadableNodeStream(val))
        return fromReadable(val);
      throw new ERR_INVALID_ARG_TYPE3("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable)
        Readable = require_readable();
      yield* Readable.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error, onresolve = null, resume = (err) => {
        if (err)
          error = err;
        if (onresolve) {
          let callback = onresolve;
          onresolve = null, callback();
        }
      }, wait = () => new Promise2((resolve, reject) => {
        if (error)
          reject(error);
        else
          onresolve = () => {
            if (error)
              reject(error);
            else
              resolve();
          };
      });
      writable.on("drain", resume);
      let cleanup = eos(writable, { readable: false }, resume);
      try {
        if (writable.writableNeedDrain)
          await wait();
        for await (let chunk of iterable)
          if (!writable.write(chunk))
            await wait();
        if (end)
          writable.end(), await wait();
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup(), writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable))
        writable = writable.writable;
      let writer = writable.getWriter();
      try {
        for await (let chunk of readable)
          await writer.ready, writer.write(chunk).catch(() => {});
        if (await writer.ready, end)
          await writer.close();
        finish();
      } catch (err) {
        try {
          await writer.abort(err), finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new ERR_MISSING_ARGS("streams");
      let ac = new AbortController2, signal = ac.signal, outerSignal = opts === null || opts === undefined ? undefined : opts.signal, lastStreamCleanup = [];
      validateAbortSignal2(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError2);
      }
      addAbortListener2 = addAbortListener2 || require_util().addAbortListener;
      let disposable;
      if (outerSignal)
        disposable = addAbortListener2(outerSignal, abort);
      let error, value, destroys = [], finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        var _disposable;
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE"))
          error = err;
        if (!error && !final)
          return;
        while (destroys.length)
          destroys.shift()(error);
        if ((_disposable = disposable) === null || _disposable === undefined || _disposable[SymbolDispose](), ac.abort(), final) {
          if (!error)
            lastStreamCleanup.forEach((fn) => fn());
          process2.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i4 = 0;i4 < streams.length; i4++) {
        let stream = streams[i4], reading = i4 < streams.length - 1, writing = i4 > 0, end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false, isLastStream = i4 === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE")
              finish(err);
          };
          var onError = onError2;
          if (end) {
            let { destroy, cleanup } = destroyer(stream, reading, writing);
            if (destroys.push(destroy), isReadable(stream) && isLastStream)
              lastStreamCleanup.push(cleanup);
          }
          if (stream.on("error", onError2), isReadable(stream) && isLastStream)
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
        }
        if (i4 === 0)
          if (typeof stream === "function") {
            if (ret = stream({ signal }), !isIterable(ret))
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream))
            ret = stream;
          else
            ret = Duplex.from(stream);
        else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable);
          } else
            ret = makeAsyncIterable(ret);
          if (ret = stream(ret, { signal }), reading) {
            if (!isIterable(ret, true))
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i4 - 1}]`, ret);
          } else {
            var _ret2;
            if (!PassThrough)
              PassThrough = require_passthrough();
            let pt = new PassThrough({ objectMode: true }), then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then;
            if (typeof then === "function")
              finishCount++, then.call(ret, (val) => {
                if (value = val, val != null)
                  pt.write(val);
                if (end)
                  pt.end();
                process2.nextTick(finish);
              }, (err) => {
                pt.destroy(err), process2.nextTick(finish, err);
              });
            else if (isIterable(ret, true))
              finishCount++, pumpToNode(ret, pt, finish, { end });
            else if (isReadableStream(ret) || isTransformStream(ret)) {
              let toRead = ret.readable || ret;
              finishCount++, pumpToNode(toRead, pt, finish, { end });
            } else
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            ret = pt;
            let { destroy, cleanup } = destroyer(ret, false, true);
            if (destroys.push(destroy), isLastStream)
              lastStreamCleanup.push(cleanup);
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            let cleanup = pipe(ret, stream, finish, { end });
            if (isReadable(stream) && isLastStream)
              lastStreamCleanup.push(cleanup);
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            let toRead = ret.readable || ret;
            finishCount++, pumpToNode(toRead, stream, finish, { end });
          } else if (isIterable(ret))
            finishCount++, pumpToNode(ret, stream, finish, { end });
          else
            throw new ERR_INVALID_ARG_TYPE3("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret))
            finishCount++, pumpToWeb(makeAsyncIterable(ret), stream, finish, { end });
          else if (isReadableStream(ret) || isIterable(ret))
            finishCount++, pumpToWeb(ret, stream, finish, { end });
          else if (isTransformStream(ret))
            finishCount++, pumpToWeb(ret.readable, stream, finish, { end });
          else
            throw new ERR_INVALID_ARG_TYPE3("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
          ret = stream;
        } else
          ret = Duplex.from(stream);
      }
      if (signal !== null && signal !== undefined && signal.aborted || outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)
        process2.nextTick(abort);
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      if (dst.on("close", () => {
        if (!ended)
          finish(new ERR_STREAM_PREMATURE_CLOSE);
      }), src.pipe(dst, { end: false }), end) {
        let endFn2 = function() {
          ended = true, dst.end();
        };
        var endFn = endFn2;
        if (isReadableFinished(src))
          process2.nextTick(endFn2);
        else
          src.once("end", endFn2);
      } else
        finish();
      return eos(src, { readable: true, writable: false }, (err) => {
        let rState = src._readableState;
        if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted)
          src.once("end", finish).once("error", finish);
        else
          finish(err);
      }), eos(dst, { readable: false, writable: true }, finish);
    }
    module2.exports = { pipelineImpl, pipeline };
  });
  var require_compose = __commonJS2((exports2, module2) => {
    var { pipeline } = require_pipeline(), Duplex = require_duplex(), { destroyer } = require_destroy(), { isNodeStream, isReadable, isWritable, isWebStream, isTransformStream, isWritableStream, isReadableStream } = require_utils(), { AbortError: AbortError2, codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS } } = require_errors(), eos = require_end_of_stream();
    module2.exports = function(...streams) {
      if (streams.length === 0)
        throw new ERR_MISSING_ARGS("streams");
      if (streams.length === 1)
        return Duplex.from(streams[0]);
      let orgStreams = [...streams];
      if (typeof streams[0] === "function")
        streams[0] = Duplex.from(streams[0]);
      if (typeof streams[streams.length - 1] === "function") {
        let idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n2 = 0;n2 < streams.length; ++n2) {
        if (!isNodeStream(streams[n2]) && !isWebStream(streams[n2]))
          continue;
        if (n2 < streams.length - 1 && !(isReadable(streams[n2]) || isReadableStream(streams[n2]) || isTransformStream(streams[n2])))
          throw new ERR_INVALID_ARG_VALUE(`streams[${n2}]`, orgStreams[n2], "must be readable");
        if (n2 > 0 && !(isWritable(streams[n2]) || isWritableStream(streams[n2]) || isTransformStream(streams[n2])))
          throw new ERR_INVALID_ARG_VALUE(`streams[${n2}]`, orgStreams[n2], "must be writable");
      }
      let ondrain, onfinish, onreadable, onclose, d2;
      function onfinished(err) {
        let cb = onclose;
        if (onclose = null, cb)
          cb(err);
        else if (err)
          d2.destroy(err);
        else if (!readable && !writable)
          d2.destroy();
      }
      let head = streams[0], tail = pipeline(streams, onfinished), writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head)), readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      if (d2 = new Duplex({ writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode), readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode), writable, readable }), writable) {
        if (isNodeStream(head))
          d2._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding))
              callback();
            else
              ondrain = callback;
          }, d2._final = function(callback) {
            head.end(), onfinish = callback;
          }, head.on("drain", function() {
            if (ondrain) {
              let cb = ondrain;
              ondrain = null, cb();
            }
          });
        else if (isWebStream(head)) {
          let writer = (isTransformStream(head) ? head.writable : head).getWriter();
          d2._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready, writer.write(chunk).catch(() => {}), callback();
            } catch (err) {
              callback(err);
            }
          }, d2._final = async function(callback) {
            try {
              await writer.ready, writer.close().catch(() => {}), onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        let toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            let cb = onfinish;
            onfinish = null, cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail))
          tail.on("readable", function() {
            if (onreadable) {
              let cb = onreadable;
              onreadable = null, cb();
            }
          }), tail.on("end", function() {
            d2.push(null);
          }), d2._read = function() {
            while (true) {
              let buf = tail.read();
              if (buf === null) {
                onreadable = d2._read;
                return;
              }
              if (!d2.push(buf))
                return;
            }
          };
        else if (isWebStream(tail)) {
          let reader = (isTransformStream(tail) ? tail.readable : tail).getReader();
          d2._read = async function() {
            while (true)
              try {
                let { value, done } = await reader.read();
                if (!d2.push(value))
                  return;
                if (done) {
                  d2.push(null);
                  return;
                }
              } catch {
                return;
              }
          };
        }
      }
      return d2._destroy = function(err, callback) {
        if (!err && onclose !== null)
          err = new AbortError2;
        if (onreadable = null, ondrain = null, onfinish = null, onclose === null)
          callback(err);
        else if (onclose = callback, isNodeStream(tail))
          destroyer(tail, err);
      }, d2;
    };
  });
  var require_operators = __commonJS2((exports2, module2) => {
    var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController, { codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE3 }, AbortError: AbortError2 } = require_errors(), { validateAbortSignal: validateAbortSignal2, validateInteger, validateObject } = require_validators(), kWeakHandler = require_primordials().Symbol("kWeak"), kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation"), { finished } = require_end_of_stream(), staticCompose = require_compose(), { addAbortSignalNoValidate } = require_add_abort_signal(), { isWritable, isNodeStream } = require_utils(), { deprecate } = require_util(), { ArrayPrototypePush, Boolean: Boolean2, MathFloor, Number: Number2, NumberIsNaN, Promise: Promise2, PromiseReject, PromiseResolve, PromisePrototypeThen, Symbol: Symbol2 } = require_primordials(), kEmpty = Symbol2("kEmpty"), kEof = Symbol2("kEof");
    function compose(stream, options2) {
      if (options2 != null)
        validateObject(options2, "options");
      if ((options2 === null || options2 === undefined ? undefined : options2.signal) != null)
        validateAbortSignal2(options2.signal, "options.signal");
      if (isNodeStream(stream) && !isWritable(stream))
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      let composedStream = staticCompose(this, stream);
      if (options2 !== null && options2 !== undefined && options2.signal)
        addAbortSignalNoValidate(options2.signal, composedStream);
      return composedStream;
    }
    function map(fn, options2) {
      if (typeof fn !== "function")
        throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn);
      if (options2 != null)
        validateObject(options2, "options");
      if ((options2 === null || options2 === undefined ? undefined : options2.signal) != null)
        validateAbortSignal2(options2.signal, "options.signal");
      let concurrency = 1;
      if ((options2 === null || options2 === undefined ? undefined : options2.concurrency) != null)
        concurrency = MathFloor(options2.concurrency);
      let highWaterMark = concurrency - 1;
      if ((options2 === null || options2 === undefined ? undefined : options2.highWaterMark) != null)
        highWaterMark = MathFloor(options2.highWaterMark);
      return validateInteger(concurrency, "options.concurrency", 1), validateInteger(highWaterMark, "options.highWaterMark", 0), highWaterMark += concurrency, async function* () {
        let signal = require_util().AbortSignalAny([options2 === null || options2 === undefined ? undefined : options2.signal].filter(Boolean2)), stream = this, queue = [], signalOpt = { signal }, next, resume, done = false, cnt = 0;
        function onCatch() {
          done = true, afterItemProcessed();
        }
        function afterItemProcessed() {
          cnt -= 1, maybeResume();
        }
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue.length < highWaterMark)
            resume(), resume = null;
        }
        async function pump() {
          try {
            for await (let val of stream) {
              if (done)
                return;
              if (signal.aborted)
                throw new AbortError2;
              try {
                if (val = fn(val, signalOpt), val === kEmpty)
                  continue;
                val = PromiseResolve(val);
              } catch (err) {
                val = PromiseReject(err);
              }
              if (cnt += 1, PromisePrototypeThen(val, afterItemProcessed, onCatch), queue.push(val), next)
                next(), next = null;
              if (!done && (queue.length >= highWaterMark || cnt >= concurrency))
                await new Promise2((resolve) => {
                  resume = resolve;
                });
            }
            queue.push(kEof);
          } catch (err) {
            let val = PromiseReject(err);
            PromisePrototypeThen(val, afterItemProcessed, onCatch), queue.push(val);
          } finally {
            if (done = true, next)
              next(), next = null;
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              let val = await queue[0];
              if (val === kEof)
                return;
              if (signal.aborted)
                throw new AbortError2;
              if (val !== kEmpty)
                yield val;
              queue.shift(), maybeResume();
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          if (done = true, resume)
            resume(), resume = null;
        }
      }.call(this);
    }
    function asIndexedPairs(options2 = undefined) {
      if (options2 != null)
        validateObject(options2, "options");
      if ((options2 === null || options2 === undefined ? undefined : options2.signal) != null)
        validateAbortSignal2(options2.signal, "options.signal");
      return async function* () {
        let index2 = 0;
        for await (let val of this) {
          var _options$signal;
          if (options2 !== null && options2 !== undefined && (_options$signal = options2.signal) !== null && _options$signal !== undefined && _options$signal.aborted)
            throw new AbortError2({ cause: options2.signal.reason });
          yield [index2++, val];
        }
      }.call(this);
    }
    async function some(fn, options2 = undefined) {
      for await (let unused of filter.call(this, fn, options2))
        return true;
      return false;
    }
    async function every(fn, options2 = undefined) {
      if (typeof fn !== "function")
        throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn);
      return !await some.call(this, async (...args) => {
        return !await fn(...args);
      }, options2);
    }
    async function find(fn, options2) {
      for await (let result of filter.call(this, fn, options2))
        return result;
      return;
    }
    async function forEach(fn, options2) {
      if (typeof fn !== "function")
        throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn);
      async function forEachFn(value, options22) {
        return await fn(value, options22), kEmpty;
      }
      for await (let unused of map.call(this, forEachFn, options2))
        ;
    }
    function filter(fn, options2) {
      if (typeof fn !== "function")
        throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn);
      async function filterFn(value, options22) {
        if (await fn(value, options22))
          return value;
        return kEmpty;
      }
      return map.call(this, filterFn, options2);
    }

    class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    }
    async function reduce(reducer, initialValue, options2) {
      var _options$signal2;
      if (typeof reducer !== "function")
        throw new ERR_INVALID_ARG_TYPE3("reducer", ["Function", "AsyncFunction"], reducer);
      if (options2 != null)
        validateObject(options2, "options");
      if ((options2 === null || options2 === undefined ? undefined : options2.signal) != null)
        validateAbortSignal2(options2.signal, "options.signal");
      let hasInitialValue = arguments.length > 1;
      if (options2 !== null && options2 !== undefined && (_options$signal2 = options2.signal) !== null && _options$signal2 !== undefined && _options$signal2.aborted) {
        let err = new AbortError2(undefined, { cause: options2.signal.reason });
        throw this.once("error", () => {}), await finished(this.destroy(err)), err;
      }
      let ac = new AbortController2, signal = ac.signal;
      if (options2 !== null && options2 !== undefined && options2.signal) {
        let opts = { once: true, [kWeakHandler]: this, [kResistStopPropagation]: true };
        options2.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (let value of this) {
          var _options$signal3;
          if (gotAnyItemFromStream = true, options2 !== null && options2 !== undefined && (_options$signal3 = options2.signal) !== null && _options$signal3 !== undefined && _options$signal3.aborted)
            throw new AbortError2;
          if (!hasInitialValue)
            initialValue = value, hasInitialValue = true;
          else
            initialValue = await reducer(initialValue, value, { signal });
        }
        if (!gotAnyItemFromStream && !hasInitialValue)
          throw new ReduceAwareErrMissingArgs;
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options2) {
      if (options2 != null)
        validateObject(options2, "options");
      if ((options2 === null || options2 === undefined ? undefined : options2.signal) != null)
        validateAbortSignal2(options2.signal, "options.signal");
      let result = [];
      for await (let val of this) {
        var _options$signal4;
        if (options2 !== null && options2 !== undefined && (_options$signal4 = options2.signal) !== null && _options$signal4 !== undefined && _options$signal4.aborted)
          throw new AbortError2(undefined, { cause: options2.signal.reason });
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options2) {
      let values = map.call(this, fn, options2);
      return async function* () {
        for await (let val of values)
          yield* val;
      }.call(this);
    }
    function toIntegerOrInfinity(number) {
      if (number = Number2(number), NumberIsNaN(number))
        return 0;
      if (number < 0)
        throw new ERR_OUT_OF_RANGE3("number", ">= 0", number);
      return number;
    }
    function drop(number, options2 = undefined) {
      if (options2 != null)
        validateObject(options2, "options");
      if ((options2 === null || options2 === undefined ? undefined : options2.signal) != null)
        validateAbortSignal2(options2.signal, "options.signal");
      return number = toIntegerOrInfinity(number), async function* () {
        var _options$signal5;
        if (options2 !== null && options2 !== undefined && (_options$signal5 = options2.signal) !== null && _options$signal5 !== undefined && _options$signal5.aborted)
          throw new AbortError2;
        for await (let val of this) {
          var _options$signal6;
          if (options2 !== null && options2 !== undefined && (_options$signal6 = options2.signal) !== null && _options$signal6 !== undefined && _options$signal6.aborted)
            throw new AbortError2;
          if (number-- <= 0)
            yield val;
        }
      }.call(this);
    }
    function take(number, options2 = undefined) {
      if (options2 != null)
        validateObject(options2, "options");
      if ((options2 === null || options2 === undefined ? undefined : options2.signal) != null)
        validateAbortSignal2(options2.signal, "options.signal");
      return number = toIntegerOrInfinity(number), async function* () {
        var _options$signal7;
        if (options2 !== null && options2 !== undefined && (_options$signal7 = options2.signal) !== null && _options$signal7 !== undefined && _options$signal7.aborted)
          throw new AbortError2;
        for await (let val of this) {
          var _options$signal8;
          if (options2 !== null && options2 !== undefined && (_options$signal8 = options2.signal) !== null && _options$signal8 !== undefined && _options$signal8.aborted)
            throw new AbortError2;
          if (number-- > 0)
            yield val;
          if (number <= 0)
            return;
        }
      }.call(this);
    }
    module2.exports.streamReturningOperators = { asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."), drop, filter, flatMap, map, take, compose };
    module2.exports.promiseReturningOperators = { every, forEach, reduce, toArray, some, find };
  });
  var require_promises = __commonJS2((exports2, module2) => {
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials(), { isIterable, isNodeStream, isWebStream } = require_utils(), { pipelineImpl: pl } = require_pipeline(), { finished } = require_end_of_stream();
    require_stream2();
    function pipeline(...streams) {
      return new Promise2((resolve, reject) => {
        let signal, end, lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          let options2 = ArrayPrototypePop(streams);
          signal = options2.signal, end = options2.end;
        }
        pl(streams, (err, value) => {
          if (err)
            reject(err);
          else
            resolve(value);
        }, { signal, end });
      });
    }
    module2.exports = { finished, pipeline };
  });
  var require_stream2 = __commonJS2((exports2, module2) => {
    var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer)), { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials(), { promisify: { custom: customPromisify } } = require_util(), { streamReturningOperators, promiseReturningOperators } = require_operators(), { codes: { ERR_ILLEGAL_CONSTRUCTOR } } = require_errors(), compose = require_compose(), { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state(), { pipeline } = require_pipeline(), { destroyer } = require_destroy(), eos = require_end_of_stream(), promises = require_promises(), utils = require_utils(), Stream = module2.exports = require_legacy().Stream;
    Stream.isDestroyed = utils.isDestroyed;
    Stream.isDisturbed = utils.isDisturbed;
    Stream.isErrored = utils.isErrored;
    Stream.isReadable = utils.isReadable;
    Stream.isWritable = utils.isWritable;
    Stream.Readable = require_readable();
    for (let key of ObjectKeys(streamReturningOperators)) {
      let fn = function(...args) {
        if (new.target)
          throw ERR_ILLEGAL_CONSTRUCTOR();
        return Stream.Readable.from(ReflectApply(op, this, args));
      }, op = streamReturningOperators[key];
      ObjectDefineProperty(fn, "name", { __proto__: null, value: op.name }), ObjectDefineProperty(fn, "length", { __proto__: null, value: op.length }), ObjectDefineProperty(Stream.Readable.prototype, key, { __proto__: null, value: fn, enumerable: false, configurable: true, writable: true });
    }
    for (let key of ObjectKeys(promiseReturningOperators)) {
      let fn = function(...args) {
        if (new.target)
          throw ERR_ILLEGAL_CONSTRUCTOR();
        return ReflectApply(op, this, args);
      }, op = promiseReturningOperators[key];
      ObjectDefineProperty(fn, "name", { __proto__: null, value: op.name }), ObjectDefineProperty(fn, "length", { __proto__: null, value: op.length }), ObjectDefineProperty(Stream.Readable.prototype, key, { __proto__: null, value: fn, enumerable: false, configurable: true, writable: true });
    }
    Stream.Writable = require_writable();
    Stream.Duplex = require_duplex();
    Stream.Transform = require_transform();
    Stream.PassThrough = require_passthrough();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return promises;
    } });
    ObjectDefineProperty(pipeline, customPromisify, { __proto__: null, enumerable: true, get() {
      return promises.pipeline;
    } });
    ObjectDefineProperty(eos, customPromisify, { __proto__: null, enumerable: true, get() {
      return promises.finished;
    } });
    Stream.Stream = Stream;
    Stream._isUint8Array = function(value) {
      return value instanceof Uint8Array;
    };
    Stream._uint8ArrayToBuffer = function(chunk) {
      return Buffer3.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  });
  var require_ours = __commonJS2((exports2, module2) => {
    var Stream = require_stream();
    {
      let CustomStream = require_stream2(), promises = require_promises(), originalDestroy = CustomStream.Readable.destroy;
      module2.exports = CustomStream.Readable, module2.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer, module2.exports._isUint8Array = CustomStream._isUint8Array, module2.exports.isDisturbed = CustomStream.isDisturbed, module2.exports.isErrored = CustomStream.isErrored, module2.exports.isReadable = CustomStream.isReadable, module2.exports.Readable = CustomStream.Readable, module2.exports.Writable = CustomStream.Writable, module2.exports.Duplex = CustomStream.Duplex, module2.exports.Transform = CustomStream.Transform, module2.exports.PassThrough = CustomStream.PassThrough, module2.exports.addAbortSignal = CustomStream.addAbortSignal, module2.exports.finished = CustomStream.finished, module2.exports.destroy = CustomStream.destroy, module2.exports.destroy = originalDestroy, module2.exports.pipeline = CustomStream.pipeline, module2.exports.compose = CustomStream.compose, Object.defineProperty(CustomStream, "promises", { configurable: true, enumerable: true, get() {
        return promises;
      } }), module2.exports.Stream = CustomStream.Stream;
    }
    module2.exports.default = module2.exports;
  });
  module.exports = require_ours();
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/support.js
var require_support = __commonJS((exports) => {
  exports.base64 = true;
  exports.array = true;
  exports.string = true;
  exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
  exports.nodebuffer = typeof Buffer !== "undefined";
  exports.uint8array = typeof Uint8Array !== "undefined";
  if (typeof ArrayBuffer === "undefined") {
    exports.blob = false;
  } else {
    buffer = new ArrayBuffer(0);
    try {
      exports.blob = new Blob([buffer], {
        type: "application/zip"
      }).size === 0;
    } catch (e2) {
      try {
        Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
        builder = new Builder;
        builder.append(buffer);
        exports.blob = builder.getBlob("application/zip").size === 0;
      } catch (e3) {
        exports.blob = false;
      }
    }
  }
  var buffer;
  var Builder;
  var builder;
  try {
    exports.nodestream = !!require_stream().Readable;
  } catch (e2) {
    exports.nodestream = false;
  }
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/base64.js
var require_base64 = __commonJS((exports) => {
  var utils = require_utils();
  var support = require_support();
  var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  exports.encode = function(input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i4 = 0, len2 = input.length, remainingBytes = len2;
    var isArray = utils.getTypeOf(input) !== "string";
    while (i4 < input.length) {
      remainingBytes = len2 - i4;
      if (!isArray) {
        chr1 = input.charCodeAt(i4++);
        chr2 = i4 < len2 ? input.charCodeAt(i4++) : 0;
        chr3 = i4 < len2 ? input.charCodeAt(i4++) : 0;
      } else {
        chr1 = input[i4++];
        chr2 = i4 < len2 ? input[i4++] : 0;
        chr3 = i4 < len2 ? input[i4++] : 0;
      }
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
      enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
      output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
    }
    return output.join("");
  };
  exports.decode = function(input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i4 = 0, resultIndex = 0;
    var dataUrlPrefix = "data:";
    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
      throw new Error("Invalid base64 input, it looks like a data url.");
    }
    input = input.replace(/[^A-Za-z0-9+/=]/g, "");
    var totalLength = input.length * 3 / 4;
    if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
      totalLength--;
    }
    if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
      totalLength--;
    }
    if (totalLength % 1 !== 0) {
      throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support.uint8array) {
      output = new Uint8Array(totalLength | 0);
    } else {
      output = new Array(totalLength | 0);
    }
    while (i4 < input.length) {
      enc1 = _keyStr.indexOf(input.charAt(i4++));
      enc2 = _keyStr.indexOf(input.charAt(i4++));
      enc3 = _keyStr.indexOf(input.charAt(i4++));
      enc4 = _keyStr.indexOf(input.charAt(i4++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output[resultIndex++] = chr1;
      if (enc3 !== 64) {
        output[resultIndex++] = chr2;
      }
      if (enc4 !== 64) {
        output[resultIndex++] = chr3;
      }
    }
    return output;
  };
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/nodejsUtils.js
var require_nodejsUtils = __commonJS((exports, module) => {
  module.exports = {
    isNode: typeof Buffer !== "undefined",
    newBufferFrom: function(data, encoding) {
      if (Buffer.from && Buffer.from !== Uint8Array.from) {
        return Buffer.from(data, encoding);
      } else {
        if (typeof data === "number") {
          throw new Error('The "data" argument must not be a number');
        }
        return new Buffer(data, encoding);
      }
    },
    allocBuffer: function(size4) {
      if (Buffer.alloc) {
        return Buffer.alloc(size4);
      } else {
        var buf = new Buffer(size4);
        buf.fill(0);
        return buf;
      }
    },
    isBuffer: function(b4) {
      return Buffer.isBuffer(b4);
    },
    isStream: function(obj) {
      return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
    }
  };
});

// ../../node_modules/.pnpm/immediate@3.0.6/node_modules/immediate/lib/browser.js
var require_browser = __commonJS((exports, module) => {
  var Mutation = global.MutationObserver || global.WebKitMutationObserver;
  var scheduleDrain;
  {
    if (Mutation) {
      called = 0;
      observer = new Mutation(nextTick);
      element = global.document.createTextNode("");
      observer.observe(element, {
        characterData: true
      });
      scheduleDrain = function() {
        element.data = called = ++called % 2;
      };
    } else if (!global.setImmediate && typeof global.MessageChannel !== "undefined") {
      channel = new global.MessageChannel;
      channel.port1.onmessage = nextTick;
      scheduleDrain = function() {
        channel.port2.postMessage(0);
      };
    } else if ("document" in global && "onreadystatechange" in global.document.createElement("script")) {
      scheduleDrain = function() {
        var scriptEl = global.document.createElement("script");
        scriptEl.onreadystatechange = function() {
          nextTick();
          scriptEl.onreadystatechange = null;
          scriptEl.parentNode.removeChild(scriptEl);
          scriptEl = null;
        };
        global.document.documentElement.appendChild(scriptEl);
      };
    } else {
      scheduleDrain = function() {
        setTimeout(nextTick, 0);
      };
    }
  }
  var called;
  var observer;
  var element;
  var channel;
  var draining;
  var queue = [];
  function nextTick() {
    draining = true;
    var i4, oldQueue;
    var len2 = queue.length;
    while (len2) {
      oldQueue = queue;
      queue = [];
      i4 = -1;
      while (++i4 < len2) {
        oldQueue[i4]();
      }
      len2 = queue.length;
    }
    draining = false;
  }
  module.exports = immediate;
  function immediate(task) {
    if (queue.push(task) === 1 && !draining) {
      scheduleDrain();
    }
  }
});

// ../../node_modules/.pnpm/lie@3.3.0/node_modules/lie/lib/browser.js
var require_browser2 = __commonJS((exports, module) => {
  var immediate = require_browser();
  function INTERNAL() {}
  var handlers = {};
  var REJECTED = ["REJECTED"];
  var FULFILLED = ["FULFILLED"];
  var PENDING = ["PENDING"];
  module.exports = Promise2;
  function Promise2(resolver) {
    if (typeof resolver !== "function") {
      throw new TypeError("resolver must be a function");
    }
    this.state = PENDING;
    this.queue = [];
    this.outcome = undefined;
    if (resolver !== INTERNAL) {
      safelyResolveThenable(this, resolver);
    }
  }
  Promise2.prototype["finally"] = function(callback) {
    if (typeof callback !== "function") {
      return this;
    }
    var p3 = this.constructor;
    return this.then(resolve2, reject2);
    function resolve2(value) {
      function yes() {
        return value;
      }
      return p3.resolve(callback()).then(yes);
    }
    function reject2(reason) {
      function no() {
        throw reason;
      }
      return p3.resolve(callback()).then(no);
    }
  };
  Promise2.prototype["catch"] = function(onRejected) {
    return this.then(null, onRejected);
  };
  Promise2.prototype.then = function(onFulfilled, onRejected) {
    if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
      return this;
    }
    var promise = new this.constructor(INTERNAL);
    if (this.state !== PENDING) {
      var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
      unwrap(promise, resolver, this.outcome);
    } else {
      this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
    }
    return promise;
  };
  function QueueItem(promise, onFulfilled, onRejected) {
    this.promise = promise;
    if (typeof onFulfilled === "function") {
      this.onFulfilled = onFulfilled;
      this.callFulfilled = this.otherCallFulfilled;
    }
    if (typeof onRejected === "function") {
      this.onRejected = onRejected;
      this.callRejected = this.otherCallRejected;
    }
  }
  QueueItem.prototype.callFulfilled = function(value) {
    handlers.resolve(this.promise, value);
  };
  QueueItem.prototype.otherCallFulfilled = function(value) {
    unwrap(this.promise, this.onFulfilled, value);
  };
  QueueItem.prototype.callRejected = function(value) {
    handlers.reject(this.promise, value);
  };
  QueueItem.prototype.otherCallRejected = function(value) {
    unwrap(this.promise, this.onRejected, value);
  };
  function unwrap(promise, func, value) {
    immediate(function() {
      var returnValue;
      try {
        returnValue = func(value);
      } catch (e2) {
        return handlers.reject(promise, e2);
      }
      if (returnValue === promise) {
        handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
      } else {
        handlers.resolve(promise, returnValue);
      }
    });
  }
  handlers.resolve = function(self2, value) {
    var result = tryCatch(getThen, value);
    if (result.status === "error") {
      return handlers.reject(self2, result.value);
    }
    var thenable = result.value;
    if (thenable) {
      safelyResolveThenable(self2, thenable);
    } else {
      self2.state = FULFILLED;
      self2.outcome = value;
      var i4 = -1;
      var len2 = self2.queue.length;
      while (++i4 < len2) {
        self2.queue[i4].callFulfilled(value);
      }
    }
    return self2;
  };
  handlers.reject = function(self2, error) {
    self2.state = REJECTED;
    self2.outcome = error;
    var i4 = -1;
    var len2 = self2.queue.length;
    while (++i4 < len2) {
      self2.queue[i4].callRejected(error);
    }
    return self2;
  };
  function getThen(obj) {
    var then = obj && obj.then;
    if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
      return function appyThen() {
        then.apply(obj, arguments);
      };
    }
  }
  function safelyResolveThenable(self2, thenable) {
    var called = false;
    function onError(value) {
      if (called) {
        return;
      }
      called = true;
      handlers.reject(self2, value);
    }
    function onSuccess(value) {
      if (called) {
        return;
      }
      called = true;
      handlers.resolve(self2, value);
    }
    function tryToUnwrap() {
      thenable(onSuccess, onError);
    }
    var result = tryCatch(tryToUnwrap);
    if (result.status === "error") {
      onError(result.value);
    }
  }
  function tryCatch(func, value) {
    var out = {};
    try {
      out.value = func(value);
      out.status = "success";
    } catch (e2) {
      out.status = "error";
      out.value = e2;
    }
    return out;
  }
  Promise2.resolve = resolve;
  function resolve(value) {
    if (value instanceof this) {
      return value;
    }
    return handlers.resolve(new this(INTERNAL), value);
  }
  Promise2.reject = reject;
  function reject(reason) {
    var promise = new this(INTERNAL);
    return handlers.reject(promise, reason);
  }
  Promise2.all = all;
  function all(iterable) {
    var self2 = this;
    if (Object.prototype.toString.call(iterable) !== "[object Array]") {
      return this.reject(new TypeError("must be an array"));
    }
    var len2 = iterable.length;
    var called = false;
    if (!len2) {
      return this.resolve([]);
    }
    var values = new Array(len2);
    var resolved = 0;
    var i4 = -1;
    var promise = new this(INTERNAL);
    while (++i4 < len2) {
      allResolver(iterable[i4], i4);
    }
    return promise;
    function allResolver(value, i5) {
      self2.resolve(value).then(resolveFromAll, function(error) {
        if (!called) {
          called = true;
          handlers.reject(promise, error);
        }
      });
      function resolveFromAll(outValue) {
        values[i5] = outValue;
        if (++resolved === len2 && !called) {
          called = true;
          handlers.resolve(promise, values);
        }
      }
    }
  }
  Promise2.race = race;
  function race(iterable) {
    var self2 = this;
    if (Object.prototype.toString.call(iterable) !== "[object Array]") {
      return this.reject(new TypeError("must be an array"));
    }
    var len2 = iterable.length;
    var called = false;
    if (!len2) {
      return this.resolve([]);
    }
    var i4 = -1;
    var promise = new this(INTERNAL);
    while (++i4 < len2) {
      resolver(iterable[i4]);
    }
    return promise;
    function resolver(value) {
      self2.resolve(value).then(function(response) {
        if (!called) {
          called = true;
          handlers.resolve(promise, response);
        }
      }, function(error) {
        if (!called) {
          called = true;
          handlers.reject(promise, error);
        }
      });
    }
  }
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/external.js
var require_external = __commonJS((exports, module) => {
  var ES6Promise = null;
  if (typeof Promise !== "undefined") {
    ES6Promise = Promise;
  } else {
    ES6Promise = require_browser2();
  }
  module.exports = {
    Promise: ES6Promise
  };
});

// ../../node_modules/.pnpm/setimmediate@1.0.5/node_modules/setimmediate/setImmediate.js
var require_setImmediate = __commonJS((exports) => {
  (function(global2, undefined2) {
    if (global2.setImmediate) {
      return;
    }
    var nextHandle = 1;
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global2.document;
    var registerImmediate;
    function setImmediate2(callback) {
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      var args = new Array(arguments.length - 1);
      for (var i4 = 0;i4 < args.length; i4++) {
        args[i4] = arguments[i4 + 1];
      }
      var task = { callback, args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }
    function clearImmediate(handle) {
      delete tasksByHandle[handle];
    }
    function run(task) {
      var callback = task.callback;
      var args = task.args;
      switch (args.length) {
        case 0:
          callback();
          break;
        case 1:
          callback(args[0]);
          break;
        case 2:
          callback(args[0], args[1]);
          break;
        case 3:
          callback(args[0], args[1], args[2]);
          break;
        default:
          callback.apply(undefined2, args);
          break;
      }
    }
    function runIfPresent(handle) {
      if (currentlyRunningATask) {
        setTimeout(runIfPresent, 0, handle);
      } else {
        var task = tasksByHandle[handle];
        if (task) {
          currentlyRunningATask = true;
          try {
            run(task);
          } finally {
            clearImmediate(handle);
            currentlyRunningATask = false;
          }
        }
      }
    }
    function installNextTickImplementation() {
      registerImmediate = function(handle) {
        process.nextTick(function() {
          runIfPresent(handle);
        });
      };
    }
    function canUsePostMessage() {
      if (global2.postMessage && !global2.importScripts) {
        var postMessageIsAsynchronous = true;
        var oldOnMessage = global2.onmessage;
        global2.onmessage = function() {
          postMessageIsAsynchronous = false;
        };
        global2.postMessage("", "*");
        global2.onmessage = oldOnMessage;
        return postMessageIsAsynchronous;
      }
    }
    function installPostMessageImplementation() {
      var messagePrefix = "setImmediate$" + Math.random() + "$";
      var onGlobalMessage = function(event) {
        if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
          runIfPresent(+event.data.slice(messagePrefix.length));
        }
      };
      if (global2.addEventListener) {
        global2.addEventListener("message", onGlobalMessage, false);
      } else {
        global2.attachEvent("onmessage", onGlobalMessage);
      }
      registerImmediate = function(handle) {
        global2.postMessage(messagePrefix + handle, "*");
      };
    }
    function installMessageChannelImplementation() {
      var channel = new MessageChannel;
      channel.port1.onmessage = function(event) {
        var handle = event.data;
        runIfPresent(handle);
      };
      registerImmediate = function(handle) {
        channel.port2.postMessage(handle);
      };
    }
    function installReadyStateChangeImplementation() {
      var html = doc.documentElement;
      registerImmediate = function(handle) {
        var script = doc.createElement("script");
        script.onreadystatechange = function() {
          runIfPresent(handle);
          script.onreadystatechange = null;
          html.removeChild(script);
          script = null;
        };
        html.appendChild(script);
      };
    }
    function installSetTimeoutImplementation() {
      registerImmediate = function(handle) {
        setTimeout(runIfPresent, 0, handle);
      };
    }
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
    if ({}.toString.call(global2.process) === "[object process]") {
      installNextTickImplementation();
    } else if (canUsePostMessage()) {
      installPostMessageImplementation();
    } else if (global2.MessageChannel) {
      installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
      installReadyStateChangeImplementation();
    } else {
      installSetTimeoutImplementation();
    }
    attachTo.setImmediate = setImmediate2;
    attachTo.clearImmediate = clearImmediate;
  })(typeof self === "undefined" ? typeof global === "undefined" ? exports : global : self);
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/utils.js
var require_utils = __commonJS((exports) => {
  var support = require_support();
  var base64 = require_base64();
  var nodejsUtils = require_nodejsUtils();
  var external2 = require_external();
  require_setImmediate();
  function string2binary(str) {
    var result = null;
    if (support.uint8array) {
      result = new Uint8Array(str.length);
    } else {
      result = new Array(str.length);
    }
    return stringToArrayLike(str, result);
  }
  exports.newBlob = function(part, type) {
    exports.checkSupport("blob");
    try {
      return new Blob([part], {
        type
      });
    } catch (e2) {
      try {
        var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
        var builder = new Builder;
        builder.append(part);
        return builder.getBlob(type);
      } catch (e3) {
        throw new Error("Bug : can't construct the Blob.");
      }
    }
  };
  function identity(input) {
    return input;
  }
  function stringToArrayLike(str, array) {
    for (var i4 = 0;i4 < str.length; ++i4) {
      array[i4] = str.charCodeAt(i4) & 255;
    }
    return array;
  }
  var arrayToStringHelper = {
    stringifyByChunk: function(array, type, chunk) {
      var result = [], k2 = 0, len2 = array.length;
      if (len2 <= chunk) {
        return String.fromCharCode.apply(null, array);
      }
      while (k2 < len2) {
        if (type === "array" || type === "nodebuffer") {
          result.push(String.fromCharCode.apply(null, array.slice(k2, Math.min(k2 + chunk, len2))));
        } else {
          result.push(String.fromCharCode.apply(null, array.subarray(k2, Math.min(k2 + chunk, len2))));
        }
        k2 += chunk;
      }
      return result.join("");
    },
    stringifyByChar: function(array) {
      var resultStr = "";
      for (var i4 = 0;i4 < array.length; i4++) {
        resultStr += String.fromCharCode(array[i4]);
      }
      return resultStr;
    },
    applyCanBeUsed: {
      uint8array: function() {
        try {
          return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch (e2) {
          return false;
        }
      }(),
      nodebuffer: function() {
        try {
          return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
        } catch (e2) {
          return false;
        }
      }()
    }
  };
  function arrayLikeToString(array) {
    var chunk = 65536, type = exports.getTypeOf(array), canUseApply = true;
    if (type === "uint8array") {
      canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
    } else if (type === "nodebuffer") {
      canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
    }
    if (canUseApply) {
      while (chunk > 1) {
        try {
          return arrayToStringHelper.stringifyByChunk(array, type, chunk);
        } catch (e2) {
          chunk = Math.floor(chunk / 2);
        }
      }
    }
    return arrayToStringHelper.stringifyByChar(array);
  }
  exports.applyFromCharCode = arrayLikeToString;
  function arrayLikeToArrayLike(arrayFrom, arrayTo) {
    for (var i4 = 0;i4 < arrayFrom.length; i4++) {
      arrayTo[i4] = arrayFrom[i4];
    }
    return arrayTo;
  }
  var transform = {};
  transform["string"] = {
    string: identity,
    array: function(input) {
      return stringToArrayLike(input, new Array(input.length));
    },
    arraybuffer: function(input) {
      return transform["string"]["uint8array"](input).buffer;
    },
    uint8array: function(input) {
      return stringToArrayLike(input, new Uint8Array(input.length));
    },
    nodebuffer: function(input) {
      return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
    }
  };
  transform["array"] = {
    string: arrayLikeToString,
    array: identity,
    arraybuffer: function(input) {
      return new Uint8Array(input).buffer;
    },
    uint8array: function(input) {
      return new Uint8Array(input);
    },
    nodebuffer: function(input) {
      return nodejsUtils.newBufferFrom(input);
    }
  };
  transform["arraybuffer"] = {
    string: function(input) {
      return arrayLikeToString(new Uint8Array(input));
    },
    array: function(input) {
      return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    arraybuffer: identity,
    uint8array: function(input) {
      return new Uint8Array(input);
    },
    nodebuffer: function(input) {
      return nodejsUtils.newBufferFrom(new Uint8Array(input));
    }
  };
  transform["uint8array"] = {
    string: arrayLikeToString,
    array: function(input) {
      return arrayLikeToArrayLike(input, new Array(input.length));
    },
    arraybuffer: function(input) {
      return input.buffer;
    },
    uint8array: identity,
    nodebuffer: function(input) {
      return nodejsUtils.newBufferFrom(input);
    }
  };
  transform["nodebuffer"] = {
    string: arrayLikeToString,
    array: function(input) {
      return arrayLikeToArrayLike(input, new Array(input.length));
    },
    arraybuffer: function(input) {
      return transform["nodebuffer"]["uint8array"](input).buffer;
    },
    uint8array: function(input) {
      return arrayLikeToArrayLike(input, new Uint8Array(input.length));
    },
    nodebuffer: identity
  };
  exports.transformTo = function(outputType, input) {
    if (!input) {
      input = "";
    }
    if (!outputType) {
      return input;
    }
    exports.checkSupport(outputType);
    var inputType = exports.getTypeOf(input);
    var result = transform[inputType][outputType](input);
    return result;
  };
  exports.resolve = function(path) {
    var parts = path.split("/");
    var result = [];
    for (var index2 = 0;index2 < parts.length; index2++) {
      var part = parts[index2];
      if (part === "." || part === "" && index2 !== 0 && index2 !== parts.length - 1) {
        continue;
      } else if (part === "..") {
        result.pop();
      } else {
        result.push(part);
      }
    }
    return result.join("/");
  };
  exports.getTypeOf = function(input) {
    if (typeof input === "string") {
      return "string";
    }
    if (Object.prototype.toString.call(input) === "[object Array]") {
      return "array";
    }
    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
      return "nodebuffer";
    }
    if (support.uint8array && input instanceof Uint8Array) {
      return "uint8array";
    }
    if (support.arraybuffer && input instanceof ArrayBuffer) {
      return "arraybuffer";
    }
  };
  exports.checkSupport = function(type) {
    var supported = support[type.toLowerCase()];
    if (!supported) {
      throw new Error(type + " is not supported by this platform");
    }
  };
  exports.MAX_VALUE_16BITS = 65535;
  exports.MAX_VALUE_32BITS = -1;
  exports.pretty = function(str) {
    var res = "", code2, i4;
    for (i4 = 0;i4 < (str || "").length; i4++) {
      code2 = str.charCodeAt(i4);
      res += "\\x" + (code2 < 16 ? "0" : "") + code2.toString(16).toUpperCase();
    }
    return res;
  };
  exports.delay = function(callback, args, self2) {
    setImmediate(function() {
      callback.apply(self2 || null, args || []);
    });
  };
  exports.inherits = function(ctor, superCtor) {
    var Obj = function() {};
    Obj.prototype = superCtor.prototype;
    ctor.prototype = new Obj;
  };
  exports.extend = function() {
    var result = {}, i4, attr;
    for (i4 = 0;i4 < arguments.length; i4++) {
      for (attr in arguments[i4]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i4], attr) && typeof result[attr] === "undefined") {
          result[attr] = arguments[i4][attr];
        }
      }
    }
    return result;
  };
  exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
    var promise = external2.Promise.resolve(inputData).then(function(data) {
      var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
      if (isBlob && typeof FileReader !== "undefined") {
        return new external2.Promise(function(resolve, reject) {
          var reader = new FileReader;
          reader.onload = function(e2) {
            resolve(e2.target.result);
          };
          reader.onerror = function(e2) {
            reject(e2.target.error);
          };
          reader.readAsArrayBuffer(data);
        });
      } else {
        return data;
      }
    });
    return promise.then(function(data) {
      var dataType = exports.getTypeOf(data);
      if (!dataType) {
        return external2.Promise.reject(new Error("Can't read the data of '" + name + "'. Is it " + "in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
      }
      if (dataType === "arraybuffer") {
        data = exports.transformTo("uint8array", data);
      } else if (dataType === "string") {
        if (isBase64) {
          data = base64.decode(data);
        } else if (isBinary) {
          if (isOptimizedBinaryString !== true) {
            data = string2binary(data);
          }
        }
      }
      return data;
    });
  };
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/stream/GenericWorker.js
var require_GenericWorker = __commonJS((exports, module) => {
  function GenericWorker(name) {
    this.name = name || "default";
    this.streamInfo = {};
    this.generatedError = null;
    this.extraStreamInfo = {};
    this.isPaused = true;
    this.isFinished = false;
    this.isLocked = false;
    this._listeners = {
      data: [],
      end: [],
      error: []
    };
    this.previous = null;
  }
  GenericWorker.prototype = {
    push: function(chunk) {
      this.emit("data", chunk);
    },
    end: function() {
      if (this.isFinished) {
        return false;
      }
      this.flush();
      try {
        this.emit("end");
        this.cleanUp();
        this.isFinished = true;
      } catch (e2) {
        this.emit("error", e2);
      }
      return true;
    },
    error: function(e2) {
      if (this.isFinished) {
        return false;
      }
      if (this.isPaused) {
        this.generatedError = e2;
      } else {
        this.isFinished = true;
        this.emit("error", e2);
        if (this.previous) {
          this.previous.error(e2);
        }
        this.cleanUp();
      }
      return true;
    },
    on: function(name, listener) {
      this._listeners[name].push(listener);
      return this;
    },
    cleanUp: function() {
      this.streamInfo = this.generatedError = this.extraStreamInfo = null;
      this._listeners = [];
    },
    emit: function(name, arg) {
      if (this._listeners[name]) {
        for (var i4 = 0;i4 < this._listeners[name].length; i4++) {
          this._listeners[name][i4].call(this, arg);
        }
      }
    },
    pipe: function(next) {
      return next.registerPrevious(this);
    },
    registerPrevious: function(previous) {
      if (this.isLocked) {
        throw new Error("The stream '" + this + "' has already been used.");
      }
      this.streamInfo = previous.streamInfo;
      this.mergeStreamInfo();
      this.previous = previous;
      var self2 = this;
      previous.on("data", function(chunk) {
        self2.processChunk(chunk);
      });
      previous.on("end", function() {
        self2.end();
      });
      previous.on("error", function(e2) {
        self2.error(e2);
      });
      return this;
    },
    pause: function() {
      if (this.isPaused || this.isFinished) {
        return false;
      }
      this.isPaused = true;
      if (this.previous) {
        this.previous.pause();
      }
      return true;
    },
    resume: function() {
      if (!this.isPaused || this.isFinished) {
        return false;
      }
      this.isPaused = false;
      var withError = false;
      if (this.generatedError) {
        this.error(this.generatedError);
        withError = true;
      }
      if (this.previous) {
        this.previous.resume();
      }
      return !withError;
    },
    flush: function() {},
    processChunk: function(chunk) {
      this.push(chunk);
    },
    withStreamInfo: function(key, value) {
      this.extraStreamInfo[key] = value;
      this.mergeStreamInfo();
      return this;
    },
    mergeStreamInfo: function() {
      for (var key in this.extraStreamInfo) {
        if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {
          continue;
        }
        this.streamInfo[key] = this.extraStreamInfo[key];
      }
    },
    lock: function() {
      if (this.isLocked) {
        throw new Error("The stream '" + this + "' has already been used.");
      }
      this.isLocked = true;
      if (this.previous) {
        this.previous.lock();
      }
    },
    toString: function() {
      var me2 = "Worker " + this.name;
      if (this.previous) {
        return this.previous + " -> " + me2;
      } else {
        return me2;
      }
    }
  };
  module.exports = GenericWorker;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/utf8.js
var require_utf8 = __commonJS((exports) => {
  var utils = require_utils();
  var support = require_support();
  var nodejsUtils = require_nodejsUtils();
  var GenericWorker = require_GenericWorker();
  var _utf8len = new Array(256);
  for (i4 = 0;i4 < 256; i4++) {
    _utf8len[i4] = i4 >= 252 ? 6 : i4 >= 248 ? 5 : i4 >= 240 ? 4 : i4 >= 224 ? 3 : i4 >= 192 ? 2 : 1;
  }
  var i4;
  _utf8len[254] = _utf8len[254] = 1;
  var string2buf = function(str) {
    var buf, c3, c22, m_pos, i5, str_len = str.length, buf_len = 0;
    for (m_pos = 0;m_pos < str_len; m_pos++) {
      c3 = str.charCodeAt(m_pos);
      if ((c3 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c3 = 65536 + (c3 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      buf_len += c3 < 128 ? 1 : c3 < 2048 ? 2 : c3 < 65536 ? 3 : 4;
    }
    if (support.uint8array) {
      buf = new Uint8Array(buf_len);
    } else {
      buf = new Array(buf_len);
    }
    for (i5 = 0, m_pos = 0;i5 < buf_len; m_pos++) {
      c3 = str.charCodeAt(m_pos);
      if ((c3 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c3 = 65536 + (c3 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      if (c3 < 128) {
        buf[i5++] = c3;
      } else if (c3 < 2048) {
        buf[i5++] = 192 | c3 >>> 6;
        buf[i5++] = 128 | c3 & 63;
      } else if (c3 < 65536) {
        buf[i5++] = 224 | c3 >>> 12;
        buf[i5++] = 128 | c3 >>> 6 & 63;
        buf[i5++] = 128 | c3 & 63;
      } else {
        buf[i5++] = 240 | c3 >>> 18;
        buf[i5++] = 128 | c3 >>> 12 & 63;
        buf[i5++] = 128 | c3 >>> 6 & 63;
        buf[i5++] = 128 | c3 & 63;
      }
    }
    return buf;
  };
  var utf8border = function(buf, max3) {
    var pos;
    max3 = max3 || buf.length;
    if (max3 > buf.length) {
      max3 = buf.length;
    }
    pos = max3 - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max3;
    }
    if (pos === 0) {
      return max3;
    }
    return pos + _utf8len[buf[pos]] > max3 ? pos : max3;
  };
  var buf2string = function(buf) {
    var i5, out, c3, c_len;
    var len2 = buf.length;
    var utf16buf = new Array(len2 * 2);
    for (out = 0, i5 = 0;i5 < len2; ) {
      c3 = buf[i5++];
      if (c3 < 128) {
        utf16buf[out++] = c3;
        continue;
      }
      c_len = _utf8len[c3];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i5 += c_len - 1;
        continue;
      }
      c3 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i5 < len2) {
        c3 = c3 << 6 | buf[i5++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c3 < 65536) {
        utf16buf[out++] = c3;
      } else {
        c3 -= 65536;
        utf16buf[out++] = 55296 | c3 >> 10 & 1023;
        utf16buf[out++] = 56320 | c3 & 1023;
      }
    }
    if (utf16buf.length !== out) {
      if (utf16buf.subarray) {
        utf16buf = utf16buf.subarray(0, out);
      } else {
        utf16buf.length = out;
      }
    }
    return utils.applyFromCharCode(utf16buf);
  };
  exports.utf8encode = function utf8encode(str) {
    if (support.nodebuffer) {
      return nodejsUtils.newBufferFrom(str, "utf-8");
    }
    return string2buf(str);
  };
  exports.utf8decode = function utf8decode(buf) {
    if (support.nodebuffer) {
      return utils.transformTo("nodebuffer", buf).toString("utf-8");
    }
    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
    return buf2string(buf);
  };
  function Utf8DecodeWorker() {
    GenericWorker.call(this, "utf-8 decode");
    this.leftOver = null;
  }
  utils.inherits(Utf8DecodeWorker, GenericWorker);
  Utf8DecodeWorker.prototype.processChunk = function(chunk) {
    var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
    if (this.leftOver && this.leftOver.length) {
      if (support.uint8array) {
        var previousData = data;
        data = new Uint8Array(previousData.length + this.leftOver.length);
        data.set(this.leftOver, 0);
        data.set(previousData, this.leftOver.length);
      } else {
        data = this.leftOver.concat(data);
      }
      this.leftOver = null;
    }
    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
      if (support.uint8array) {
        usableData = data.subarray(0, nextBoundary);
        this.leftOver = data.subarray(nextBoundary, data.length);
      } else {
        usableData = data.slice(0, nextBoundary);
        this.leftOver = data.slice(nextBoundary, data.length);
      }
    }
    this.push({
      data: exports.utf8decode(usableData),
      meta: chunk.meta
    });
  };
  Utf8DecodeWorker.prototype.flush = function() {
    if (this.leftOver && this.leftOver.length) {
      this.push({
        data: exports.utf8decode(this.leftOver),
        meta: {}
      });
      this.leftOver = null;
    }
  };
  exports.Utf8DecodeWorker = Utf8DecodeWorker;
  function Utf8EncodeWorker() {
    GenericWorker.call(this, "utf-8 encode");
  }
  utils.inherits(Utf8EncodeWorker, GenericWorker);
  Utf8EncodeWorker.prototype.processChunk = function(chunk) {
    this.push({
      data: exports.utf8encode(chunk.data),
      meta: chunk.meta
    });
  };
  exports.Utf8EncodeWorker = Utf8EncodeWorker;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/stream/ConvertWorker.js
var require_ConvertWorker = __commonJS((exports, module) => {
  var GenericWorker = require_GenericWorker();
  var utils = require_utils();
  function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
  }
  utils.inherits(ConvertWorker, GenericWorker);
  ConvertWorker.prototype.processChunk = function(chunk) {
    this.push({
      data: utils.transformTo(this.destType, chunk.data),
      meta: chunk.meta
    });
  };
  module.exports = ConvertWorker;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js
var require_NodejsStreamOutputAdapter = __commonJS((exports, module) => {
  var Readable = require_stream().Readable;
  var utils = require_utils();
  utils.inherits(NodejsStreamOutputAdapter, Readable);
  function NodejsStreamOutputAdapter(helper, options2, updateCb) {
    Readable.call(this, options2);
    this._helper = helper;
    var self2 = this;
    helper.on("data", function(data, meta) {
      if (!self2.push(data)) {
        self2._helper.pause();
      }
      if (updateCb) {
        updateCb(meta);
      }
    }).on("error", function(e2) {
      self2.emit("error", e2);
    }).on("end", function() {
      self2.push(null);
    });
  }
  NodejsStreamOutputAdapter.prototype._read = function() {
    this._helper.resume();
  };
  module.exports = NodejsStreamOutputAdapter;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/stream/StreamHelper.js
var require_StreamHelper = __commonJS((exports, module) => {
  var utils = require_utils();
  var ConvertWorker = require_ConvertWorker();
  var GenericWorker = require_GenericWorker();
  var base64 = require_base64();
  var support = require_support();
  var external2 = require_external();
  var NodejsStreamOutputAdapter = null;
  if (support.nodestream) {
    try {
      NodejsStreamOutputAdapter = require_NodejsStreamOutputAdapter();
    } catch (e2) {}
  }
  function transformZipOutput(type, content, mimeType) {
    switch (type) {
      case "blob":
        return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
      case "base64":
        return base64.encode(content);
      default:
        return utils.transformTo(type, content);
    }
  }
  function concat(type, dataArray) {
    var i4, index2 = 0, res = null, totalLength = 0;
    for (i4 = 0;i4 < dataArray.length; i4++) {
      totalLength += dataArray[i4].length;
    }
    switch (type) {
      case "string":
        return dataArray.join("");
      case "array":
        return Array.prototype.concat.apply([], dataArray);
      case "uint8array":
        res = new Uint8Array(totalLength);
        for (i4 = 0;i4 < dataArray.length; i4++) {
          res.set(dataArray[i4], index2);
          index2 += dataArray[i4].length;
        }
        return res;
      case "nodebuffer":
        return Buffer.concat(dataArray);
      default:
        throw new Error("concat : unsupported type '" + type + "'");
    }
  }
  function accumulate(helper, updateCallback) {
    return new external2.Promise(function(resolve, reject) {
      var dataArray = [];
      var { _internalType: chunkType, _outputType: resultType, _mimeType: mimeType } = helper;
      helper.on("data", function(data, meta) {
        dataArray.push(data);
        if (updateCallback) {
          updateCallback(meta);
        }
      }).on("error", function(err) {
        dataArray = [];
        reject(err);
      }).on("end", function() {
        try {
          var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
          resolve(result);
        } catch (e2) {
          reject(e2);
        }
        dataArray = [];
      }).resume();
    });
  }
  function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch (outputType) {
      case "blob":
      case "arraybuffer":
        internalType = "uint8array";
        break;
      case "base64":
        internalType = "string";
        break;
    }
    try {
      this._internalType = internalType;
      this._outputType = outputType;
      this._mimeType = mimeType;
      utils.checkSupport(internalType);
      this._worker = worker.pipe(new ConvertWorker(internalType));
      worker.lock();
    } catch (e2) {
      this._worker = new GenericWorker("error");
      this._worker.error(e2);
    }
  }
  StreamHelper.prototype = {
    accumulate: function(updateCb) {
      return accumulate(this, updateCb);
    },
    on: function(evt, fn) {
      var self2 = this;
      if (evt === "data") {
        this._worker.on(evt, function(chunk) {
          fn.call(self2, chunk.data, chunk.meta);
        });
      } else {
        this._worker.on(evt, function() {
          utils.delay(fn, arguments, self2);
        });
      }
      return this;
    },
    resume: function() {
      utils.delay(this._worker.resume, [], this._worker);
      return this;
    },
    pause: function() {
      this._worker.pause();
      return this;
    },
    toNodejsStream: function(updateCb) {
      utils.checkSupport("nodestream");
      if (this._outputType !== "nodebuffer") {
        throw new Error(this._outputType + " is not supported by this method");
      }
      return new NodejsStreamOutputAdapter(this, {
        objectMode: this._outputType !== "nodebuffer"
      }, updateCb);
    }
  };
  module.exports = StreamHelper;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/defaults.js
var require_defaults = __commonJS((exports) => {
  exports.base64 = false;
  exports.binary = false;
  exports.dir = false;
  exports.createFolders = true;
  exports.date = null;
  exports.compression = null;
  exports.compressionOptions = null;
  exports.comment = null;
  exports.unixPermissions = null;
  exports.dosPermissions = null;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/stream/DataWorker.js
var require_DataWorker = __commonJS((exports, module) => {
  var utils = require_utils();
  var GenericWorker = require_GenericWorker();
  var DEFAULT_BLOCK_SIZE = 16 * 1024;
  function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self2 = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";
    this._tickScheduled = false;
    dataP.then(function(data) {
      self2.dataIsReady = true;
      self2.data = data;
      self2.max = data && data.length || 0;
      self2.type = utils.getTypeOf(data);
      if (!self2.isPaused) {
        self2._tickAndRepeat();
      }
    }, function(e2) {
      self2.error(e2);
    });
  }
  utils.inherits(DataWorker, GenericWorker);
  DataWorker.prototype.cleanUp = function() {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
  };
  DataWorker.prototype.resume = function() {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (!this._tickScheduled && this.dataIsReady) {
      this._tickScheduled = true;
      utils.delay(this._tickAndRepeat, [], this);
    }
    return true;
  };
  DataWorker.prototype._tickAndRepeat = function() {
    this._tickScheduled = false;
    if (this.isPaused || this.isFinished) {
      return;
    }
    this._tick();
    if (!this.isFinished) {
      utils.delay(this._tickAndRepeat, [], this);
      this._tickScheduled = true;
    }
  };
  DataWorker.prototype._tick = function() {
    if (this.isPaused || this.isFinished) {
      return false;
    }
    var size4 = DEFAULT_BLOCK_SIZE;
    var data = null, nextIndex = Math.min(this.max, this.index + size4);
    if (this.index >= this.max) {
      return this.end();
    } else {
      switch (this.type) {
        case "string":
          data = this.data.substring(this.index, nextIndex);
          break;
        case "uint8array":
          data = this.data.subarray(this.index, nextIndex);
          break;
        case "array":
        case "nodebuffer":
          data = this.data.slice(this.index, nextIndex);
          break;
      }
      this.index = nextIndex;
      return this.push({
        data,
        meta: {
          percent: this.max ? this.index / this.max * 100 : 0
        }
      });
    }
  };
  module.exports = DataWorker;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/crc32.js
var require_crc32 = __commonJS((exports, module) => {
  var utils = require_utils();
  function makeTable() {
    var c3, table = [];
    for (var n2 = 0;n2 < 256; n2++) {
      c3 = n2;
      for (var k2 = 0;k2 < 8; k2++) {
        c3 = c3 & 1 ? 3988292384 ^ c3 >>> 1 : c3 >>> 1;
      }
      table[n2] = c3;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len2, pos) {
    var t2 = crcTable, end = pos + len2;
    crc = crc ^ -1;
    for (var i4 = pos;i4 < end; i4++) {
      crc = crc >>> 8 ^ t2[(crc ^ buf[i4]) & 255];
    }
    return crc ^ -1;
  }
  function crc32str(crc, str, len2, pos) {
    var t2 = crcTable, end = pos + len2;
    crc = crc ^ -1;
    for (var i4 = pos;i4 < end; i4++) {
      crc = crc >>> 8 ^ t2[(crc ^ str.charCodeAt(i4)) & 255];
    }
    return crc ^ -1;
  }
  module.exports = function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
      return 0;
    }
    var isArray = utils.getTypeOf(input) !== "string";
    if (isArray) {
      return crc32(crc | 0, input, input.length, 0);
    } else {
      return crc32str(crc | 0, input, input.length, 0);
    }
  };
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/stream/Crc32Probe.js
var require_Crc32Probe = __commonJS((exports, module) => {
  var GenericWorker = require_GenericWorker();
  var crc32 = require_crc32();
  var utils = require_utils();
  function Crc32Probe() {
    GenericWorker.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
  }
  utils.inherits(Crc32Probe, GenericWorker);
  Crc32Probe.prototype.processChunk = function(chunk) {
    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
  };
  module.exports = Crc32Probe;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/stream/DataLengthProbe.js
var require_DataLengthProbe = __commonJS((exports, module) => {
  var utils = require_utils();
  var GenericWorker = require_GenericWorker();
  function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
  }
  utils.inherits(DataLengthProbe, GenericWorker);
  DataLengthProbe.prototype.processChunk = function(chunk) {
    if (chunk) {
      var length = this.streamInfo[this.propName] || 0;
      this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
  };
  module.exports = DataLengthProbe;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/compressedObject.js
var require_compressedObject = __commonJS((exports, module) => {
  var external2 = require_external();
  var DataWorker = require_DataWorker();
  var Crc32Probe = require_Crc32Probe();
  var DataLengthProbe = require_DataLengthProbe();
  function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
  }
  CompressedObject.prototype = {
    getContentWorker: function() {
      var worker = new DataWorker(external2.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
      var that = this;
      worker.on("end", function() {
        if (this.streamInfo["data_length"] !== that.uncompressedSize) {
          throw new Error("Bug : uncompressed data size mismatch");
        }
      });
      return worker;
    },
    getCompressedWorker: function() {
      return new DataWorker(external2.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
    }
  };
  CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker.pipe(new Crc32Probe).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
  };
  module.exports = CompressedObject;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/zipObject.js
var require_zipObject = __commonJS((exports, module) => {
  var StreamHelper = require_StreamHelper();
  var DataWorker = require_DataWorker();
  var utf8 = require_utf8();
  var CompressedObject = require_compressedObject();
  var GenericWorker = require_GenericWorker();
  var ZipObject = function(name, data, options2) {
    this.name = name;
    this.dir = options2.dir;
    this.date = options2.date;
    this.comment = options2.comment;
    this.unixPermissions = options2.unixPermissions;
    this.dosPermissions = options2.dosPermissions;
    this._data = data;
    this._dataBinary = options2.binary;
    this.options = {
      compression: options2.compression,
      compressionOptions: options2.compressionOptions
    };
  };
  ZipObject.prototype = {
    internalStream: function(type) {
      var result = null, outputType = "string";
      try {
        if (!type) {
          throw new Error("No output type specified.");
        }
        outputType = type.toLowerCase();
        var askUnicodeString = outputType === "string" || outputType === "text";
        if (outputType === "binarystring" || outputType === "text") {
          outputType = "string";
        }
        result = this._decompressWorker();
        var isUnicodeString = !this._dataBinary;
        if (isUnicodeString && !askUnicodeString) {
          result = result.pipe(new utf8.Utf8EncodeWorker);
        }
        if (!isUnicodeString && askUnicodeString) {
          result = result.pipe(new utf8.Utf8DecodeWorker);
        }
      } catch (e2) {
        result = new GenericWorker("error");
        result.error(e2);
      }
      return new StreamHelper(result, outputType, "");
    },
    async: function(type, onUpdate) {
      return this.internalStream(type).accumulate(onUpdate);
    },
    nodeStream: function(type, onUpdate) {
      return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
    },
    _compressWorker: function(compression, compressionOptions) {
      if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
        return this._data.getCompressedWorker();
      } else {
        var result = this._decompressWorker();
        if (!this._dataBinary) {
          result = result.pipe(new utf8.Utf8EncodeWorker);
        }
        return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
      }
    },
    _decompressWorker: function() {
      if (this._data instanceof CompressedObject) {
        return this._data.getContentWorker();
      } else if (this._data instanceof GenericWorker) {
        return this._data;
      } else {
        return new DataWorker(this._data);
      }
    }
  };
  var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
  var removedFn = function() {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
  };
  for (i4 = 0;i4 < removedMethods.length; i4++) {
    ZipObject.prototype[removedMethods[i4]] = removedFn;
  }
  var i4;
  module.exports = ZipObject;
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js
var require_common = __commonJS((exports) => {
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  exports.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p3 in source) {
        if (_has(source, p3)) {
          obj[p3] = source[p3];
        }
      }
    }
    return obj;
  };
  exports.shrinkBuf = function(buf, size4) {
    if (buf.length === size4) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size4);
    }
    buf.length = size4;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src, src_offs, len2, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len2), dest_offs);
        return;
      }
      for (var i4 = 0;i4 < len2; i4++) {
        dest[dest_offs + i4] = src[src_offs + i4];
      }
    },
    flattenChunks: function(chunks) {
      var i4, l4, len2, pos, chunk, result;
      len2 = 0;
      for (i4 = 0, l4 = chunks.length;i4 < l4; i4++) {
        len2 += chunks[i4].length;
      }
      result = new Uint8Array(len2);
      pos = 0;
      for (i4 = 0, l4 = chunks.length;i4 < l4; i4++) {
        chunk = chunks[i4];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src, src_offs, len2, dest_offs) {
      for (var i4 = 0;i4 < len2; i4++) {
        dest[dest_offs + i4] = src[src_offs + i4];
      }
    },
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports.setTyped = function(on) {
    if (on) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };
  exports.setTyped(TYPED_OK);
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS((exports) => {
  var utils = require_common();
  var Z_FIXED = 4;
  var Z_BINARY = 0;
  var Z_TEXT = 1;
  var Z_UNKNOWN = 2;
  function zero(buf) {
    var len2 = buf.length;
    while (--len2 >= 0) {
      buf[len2] = 0;
    }
  }
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
  var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
  var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  var base_dist = new Array(D_CODES);
  zero(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  function d_code(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  }
  function put_short(s2, w2) {
    s2.pending_buf[s2.pending++] = w2 & 255;
    s2.pending_buf[s2.pending++] = w2 >>> 8 & 255;
  }
  function send_bits(s2, value, length) {
    if (s2.bi_valid > Buf_size - length) {
      s2.bi_buf |= value << s2.bi_valid & 65535;
      put_short(s2, s2.bi_buf);
      s2.bi_buf = value >> Buf_size - s2.bi_valid;
      s2.bi_valid += length - Buf_size;
    } else {
      s2.bi_buf |= value << s2.bi_valid & 65535;
      s2.bi_valid += length;
    }
  }
  function send_code(s2, c3, tree) {
    send_bits(s2, tree[c3 * 2], tree[c3 * 2 + 1]);
  }
  function bi_reverse(code2, len2) {
    var res = 0;
    do {
      res |= code2 & 1;
      code2 >>>= 1;
      res <<= 1;
    } while (--len2 > 0);
    return res >>> 1;
  }
  function bi_flush(s2) {
    if (s2.bi_valid === 16) {
      put_short(s2, s2.bi_buf);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    } else if (s2.bi_valid >= 8) {
      s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
      s2.bi_buf >>= 8;
      s2.bi_valid -= 8;
    }
  }
  function gen_bitlen(s2, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h3;
    var n2, m3;
    var bits;
    var xbits;
    var f2;
    var overflow = 0;
    for (bits = 0;bits <= MAX_BITS; bits++) {
      s2.bl_count[bits] = 0;
    }
    tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
    for (h3 = s2.heap_max + 1;h3 < HEAP_SIZE; h3++) {
      n2 = s2.heap[h3];
      bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n2 * 2 + 1] = bits;
      if (n2 > max_code) {
        continue;
      }
      s2.bl_count[bits]++;
      xbits = 0;
      if (n2 >= base) {
        xbits = extra[n2 - base];
      }
      f2 = tree[n2 * 2];
      s2.opt_len += f2 * (bits + xbits);
      if (has_stree) {
        s2.static_len += f2 * (stree[n2 * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s2.bl_count[bits] === 0) {
        bits--;
      }
      s2.bl_count[bits]--;
      s2.bl_count[bits + 1] += 2;
      s2.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length;bits !== 0; bits--) {
      n2 = s2.bl_count[bits];
      while (n2 !== 0) {
        m3 = s2.heap[--h3];
        if (m3 > max_code) {
          continue;
        }
        if (tree[m3 * 2 + 1] !== bits) {
          s2.opt_len += (bits - tree[m3 * 2 + 1]) * tree[m3 * 2];
          tree[m3 * 2 + 1] = bits;
        }
        n2--;
      }
    }
  }
  function gen_codes(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code2 = 0;
    var bits;
    var n2;
    for (bits = 1;bits <= MAX_BITS; bits++) {
      next_code[bits] = code2 = code2 + bl_count[bits - 1] << 1;
    }
    for (n2 = 0;n2 <= max_code; n2++) {
      var len2 = tree[n2 * 2 + 1];
      if (len2 === 0) {
        continue;
      }
      tree[n2 * 2] = bi_reverse(next_code[len2]++, len2);
    }
  }
  function tr_static_init() {
    var n2;
    var bits;
    var length;
    var code2;
    var dist;
    var bl_count = new Array(MAX_BITS + 1);
    length = 0;
    for (code2 = 0;code2 < LENGTH_CODES - 1; code2++) {
      base_length[code2] = length;
      for (n2 = 0;n2 < 1 << extra_lbits[code2]; n2++) {
        _length_code[length++] = code2;
      }
    }
    _length_code[length - 1] = code2;
    dist = 0;
    for (code2 = 0;code2 < 16; code2++) {
      base_dist[code2] = dist;
      for (n2 = 0;n2 < 1 << extra_dbits[code2]; n2++) {
        _dist_code[dist++] = code2;
      }
    }
    dist >>= 7;
    for (;code2 < D_CODES; code2++) {
      base_dist[code2] = dist << 7;
      for (n2 = 0;n2 < 1 << extra_dbits[code2] - 7; n2++) {
        _dist_code[256 + dist++] = code2;
      }
    }
    for (bits = 0;bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n2 = 0;
    while (n2 <= 143) {
      static_ltree[n2 * 2 + 1] = 8;
      n2++;
      bl_count[8]++;
    }
    while (n2 <= 255) {
      static_ltree[n2 * 2 + 1] = 9;
      n2++;
      bl_count[9]++;
    }
    while (n2 <= 279) {
      static_ltree[n2 * 2 + 1] = 7;
      n2++;
      bl_count[7]++;
    }
    while (n2 <= 287) {
      static_ltree[n2 * 2 + 1] = 8;
      n2++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n2 = 0;n2 < D_CODES; n2++) {
      static_dtree[n2 * 2 + 1] = 5;
      static_dtree[n2 * 2] = bi_reverse(n2, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  }
  function init_block(s2) {
    var n2;
    for (n2 = 0;n2 < L_CODES; n2++) {
      s2.dyn_ltree[n2 * 2] = 0;
    }
    for (n2 = 0;n2 < D_CODES; n2++) {
      s2.dyn_dtree[n2 * 2] = 0;
    }
    for (n2 = 0;n2 < BL_CODES; n2++) {
      s2.bl_tree[n2 * 2] = 0;
    }
    s2.dyn_ltree[END_BLOCK * 2] = 1;
    s2.opt_len = s2.static_len = 0;
    s2.last_lit = s2.matches = 0;
  }
  function bi_windup(s2) {
    if (s2.bi_valid > 8) {
      put_short(s2, s2.bi_buf);
    } else if (s2.bi_valid > 0) {
      s2.pending_buf[s2.pending++] = s2.bi_buf;
    }
    s2.bi_buf = 0;
    s2.bi_valid = 0;
  }
  function copy_block(s2, buf, len2, header) {
    bi_windup(s2);
    if (header) {
      put_short(s2, len2);
      put_short(s2, ~len2);
    }
    utils.arraySet(s2.pending_buf, s2.window, buf, len2, s2.pending);
    s2.pending += len2;
  }
  function smaller(tree, n2, m3, depth) {
    var _n2 = n2 * 2;
    var _m2 = m3 * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m3];
  }
  function pqdownheap(s2, tree, k2) {
    var v2 = s2.heap[k2];
    var j = k2 << 1;
    while (j <= s2.heap_len) {
      if (j < s2.heap_len && smaller(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
        j++;
      }
      if (smaller(tree, v2, s2.heap[j], s2.depth)) {
        break;
      }
      s2.heap[k2] = s2.heap[j];
      k2 = j;
      j <<= 1;
    }
    s2.heap[k2] = v2;
  }
  function compress_block(s2, ltree, dtree) {
    var dist;
    var lc;
    var lx = 0;
    var code2;
    var extra;
    if (s2.last_lit !== 0) {
      do {
        dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
        lc = s2.pending_buf[s2.l_buf + lx];
        lx++;
        if (dist === 0) {
          send_code(s2, lc, ltree);
        } else {
          code2 = _length_code[lc];
          send_code(s2, code2 + LITERALS + 1, ltree);
          extra = extra_lbits[code2];
          if (extra !== 0) {
            lc -= base_length[code2];
            send_bits(s2, lc, extra);
          }
          dist--;
          code2 = d_code(dist);
          send_code(s2, code2, dtree);
          extra = extra_dbits[code2];
          if (extra !== 0) {
            dist -= base_dist[code2];
            send_bits(s2, dist, extra);
          }
        }
      } while (lx < s2.last_lit);
    }
    send_code(s2, END_BLOCK, ltree);
  }
  function build_tree(s2, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n2, m3;
    var max_code = -1;
    var node;
    s2.heap_len = 0;
    s2.heap_max = HEAP_SIZE;
    for (n2 = 0;n2 < elems; n2++) {
      if (tree[n2 * 2] !== 0) {
        s2.heap[++s2.heap_len] = max_code = n2;
        s2.depth[n2] = 0;
      } else {
        tree[n2 * 2 + 1] = 0;
      }
    }
    while (s2.heap_len < 2) {
      node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s2.depth[node] = 0;
      s2.opt_len--;
      if (has_stree) {
        s2.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n2 = s2.heap_len >> 1;n2 >= 1; n2--) {
      pqdownheap(s2, tree, n2);
    }
    node = elems;
    do {
      n2 = s2.heap[1];
      s2.heap[1] = s2.heap[s2.heap_len--];
      pqdownheap(s2, tree, 1);
      m3 = s2.heap[1];
      s2.heap[--s2.heap_max] = n2;
      s2.heap[--s2.heap_max] = m3;
      tree[node * 2] = tree[n2 * 2] + tree[m3 * 2];
      s2.depth[node] = (s2.depth[n2] >= s2.depth[m3] ? s2.depth[n2] : s2.depth[m3]) + 1;
      tree[n2 * 2 + 1] = tree[m3 * 2 + 1] = node;
      s2.heap[1] = node++;
      pqdownheap(s2, tree, 1);
    } while (s2.heap_len >= 2);
    s2.heap[--s2.heap_max] = s2.heap[1];
    gen_bitlen(s2, desc);
    gen_codes(tree, max_code, s2.bl_count);
  }
  function scan_tree(s2, tree, max_code) {
    var n2;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count4 = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n2 = 0;n2 <= max_code; n2++) {
      curlen = nextlen;
      nextlen = tree[(n2 + 1) * 2 + 1];
      if (++count4 < max_count && curlen === nextlen) {
        continue;
      } else if (count4 < min_count) {
        s2.bl_tree[curlen * 2] += count4;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s2.bl_tree[curlen * 2]++;
        }
        s2.bl_tree[REP_3_6 * 2]++;
      } else if (count4 <= 10) {
        s2.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s2.bl_tree[REPZ_11_138 * 2]++;
      }
      count4 = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function send_tree(s2, tree, max_code) {
    var n2;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count4 = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n2 = 0;n2 <= max_code; n2++) {
      curlen = nextlen;
      nextlen = tree[(n2 + 1) * 2 + 1];
      if (++count4 < max_count && curlen === nextlen) {
        continue;
      } else if (count4 < min_count) {
        do {
          send_code(s2, curlen, s2.bl_tree);
        } while (--count4 !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s2, curlen, s2.bl_tree);
          count4--;
        }
        send_code(s2, REP_3_6, s2.bl_tree);
        send_bits(s2, count4 - 3, 2);
      } else if (count4 <= 10) {
        send_code(s2, REPZ_3_10, s2.bl_tree);
        send_bits(s2, count4 - 3, 3);
      } else {
        send_code(s2, REPZ_11_138, s2.bl_tree);
        send_bits(s2, count4 - 11, 7);
      }
      count4 = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function build_bl_tree(s2) {
    var max_blindex;
    scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
    scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
    build_tree(s2, s2.bl_desc);
    for (max_blindex = BL_CODES - 1;max_blindex >= 3; max_blindex--) {
      if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  function send_all_trees(s2, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s2, lcodes - 257, 5);
    send_bits(s2, dcodes - 1, 5);
    send_bits(s2, blcodes - 4, 4);
    for (rank = 0;rank < blcodes; rank++) {
      send_bits(s2, s2.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s2, s2.dyn_ltree, lcodes - 1);
    send_tree(s2, s2.dyn_dtree, dcodes - 1);
  }
  function detect_data_type(s2) {
    var black_mask = 4093624447;
    var n2;
    for (n2 = 0;n2 <= 31; n2++, black_mask >>>= 1) {
      if (black_mask & 1 && s2.dyn_ltree[n2 * 2] !== 0) {
        return Z_BINARY;
      }
    }
    if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT;
    }
    for (n2 = 32;n2 < LITERALS; n2++) {
      if (s2.dyn_ltree[n2 * 2] !== 0) {
        return Z_TEXT;
      }
    }
    return Z_BINARY;
  }
  var static_init_done = false;
  function _tr_init(s2) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
    s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
    s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
    s2.bi_buf = 0;
    s2.bi_valid = 0;
    init_block(s2);
  }
  function _tr_stored_block(s2, buf, stored_len, last) {
    send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s2, buf, stored_len, true);
  }
  function _tr_align(s2) {
    send_bits(s2, STATIC_TREES << 1, 3);
    send_code(s2, END_BLOCK, static_ltree);
    bi_flush(s2);
  }
  function _tr_flush_block(s2, buf, stored_len, last) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s2.level > 0) {
      if (s2.strm.data_type === Z_UNKNOWN) {
        s2.strm.data_type = detect_data_type(s2);
      }
      build_tree(s2, s2.l_desc);
      build_tree(s2, s2.d_desc);
      max_blindex = build_bl_tree(s2);
      opt_lenb = s2.opt_len + 3 + 7 >>> 3;
      static_lenb = s2.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s2, buf, stored_len, last);
    } else if (s2.strategy === Z_FIXED || static_lenb === opt_lenb) {
      send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s2, static_ltree, static_dtree);
    } else {
      send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
    }
    init_block(s2);
    if (last) {
      bi_windup(s2);
    }
  }
  function _tr_tally(s2, dist, lc) {
    s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
    s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
    s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
    s2.last_lit++;
    if (dist === 0) {
      s2.dyn_ltree[lc * 2]++;
    } else {
      s2.matches++;
      dist--;
      s2.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s2.dyn_dtree[d_code(dist) * 2]++;
    }
    return s2.last_lit === s2.lit_bufsize - 1;
  }
  exports._tr_init = _tr_init;
  exports._tr_stored_block = _tr_stored_block;
  exports._tr_flush_block = _tr_flush_block;
  exports._tr_tally = _tr_tally;
  exports._tr_align = _tr_align;
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS((exports, module) => {
  function adler32(adler, buf, len2, pos) {
    var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
    while (len2 !== 0) {
      n2 = len2 > 2000 ? 2000 : len2;
      len2 -= n2;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n2);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
  module.exports = adler32;
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js
var require_crc322 = __commonJS((exports, module) => {
  function makeTable() {
    var c3, table = [];
    for (var n2 = 0;n2 < 256; n2++) {
      c3 = n2;
      for (var k2 = 0;k2 < 8; k2++) {
        c3 = c3 & 1 ? 3988292384 ^ c3 >>> 1 : c3 >>> 1;
      }
      table[n2] = c3;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len2, pos) {
    var t2 = crcTable, end = pos + len2;
    crc ^= -1;
    for (var i4 = pos;i4 < end; i4++) {
      crc = crc >>> 8 ^ t2[(crc ^ buf[i4]) & 255];
    }
    return crc ^ -1;
  }
  module.exports = crc32;
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS((exports, module) => {
  module.exports = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
  };
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS((exports) => {
  var utils = require_common();
  var trees = require_trees();
  var adler32 = require_adler32();
  var crc32 = require_crc322();
  var msg = require_messages();
  var Z_NO_FLUSH = 0;
  var Z_PARTIAL_FLUSH = 1;
  var Z_FULL_FLUSH = 3;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_BUF_ERROR = -5;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_FILTERED = 1;
  var Z_HUFFMAN_ONLY = 2;
  var Z_RLE = 3;
  var Z_FIXED = 4;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_UNKNOWN = 2;
  var Z_DEFLATED = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  function err(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  }
  function rank(f2) {
    return (f2 << 1) - (f2 > 4 ? 9 : 0);
  }
  function zero(buf) {
    var len2 = buf.length;
    while (--len2 >= 0) {
      buf[len2] = 0;
    }
  }
  function flush_pending(strm) {
    var s2 = strm.state;
    var len2 = s2.pending;
    if (len2 > strm.avail_out) {
      len2 = strm.avail_out;
    }
    if (len2 === 0) {
      return;
    }
    utils.arraySet(strm.output, s2.pending_buf, s2.pending_out, len2, strm.next_out);
    strm.next_out += len2;
    s2.pending_out += len2;
    strm.total_out += len2;
    strm.avail_out -= len2;
    s2.pending -= len2;
    if (s2.pending === 0) {
      s2.pending_out = 0;
    }
  }
  function flush_block_only(s2, last) {
    trees._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
    s2.block_start = s2.strstart;
    flush_pending(s2.strm);
  }
  function put_byte(s2, b4) {
    s2.pending_buf[s2.pending++] = b4;
  }
  function putShortMSB(s2, b4) {
    s2.pending_buf[s2.pending++] = b4 >>> 8 & 255;
    s2.pending_buf[s2.pending++] = b4 & 255;
  }
  function read_buf(strm, buf, start, size4) {
    var len2 = strm.avail_in;
    if (len2 > size4) {
      len2 = size4;
    }
    if (len2 === 0) {
      return 0;
    }
    strm.avail_in -= len2;
    utils.arraySet(buf, strm.input, strm.next_in, len2, start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len2, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len2, start);
    }
    strm.next_in += len2;
    strm.total_in += len2;
    return len2;
  }
  function longest_match(s2, cur_match) {
    var chain_length = s2.max_chain_length;
    var scan = s2.strstart;
    var match;
    var len2;
    var best_len = s2.prev_length;
    var nice_match = s2.nice_match;
    var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s2.window;
    var wmask = s2.w_mask;
    var prev = s2.prev;
    var strend = s2.strstart + MAX_MATCH;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];
    if (s2.prev_length >= s2.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s2.lookahead) {
      nice_match = s2.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len2 = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len2 > best_len) {
        s2.match_start = cur_match;
        best_len = len2;
        if (len2 >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s2.lookahead) {
      return best_len;
    }
    return s2.lookahead;
  }
  function fill_window(s2) {
    var _w_size = s2.w_size;
    var p3, n2, m3, more, str;
    do {
      more = s2.window_size - s2.lookahead - s2.strstart;
      if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
        s2.match_start -= _w_size;
        s2.strstart -= _w_size;
        s2.block_start -= _w_size;
        n2 = s2.hash_size;
        p3 = n2;
        do {
          m3 = s2.head[--p3];
          s2.head[p3] = m3 >= _w_size ? m3 - _w_size : 0;
        } while (--n2);
        n2 = _w_size;
        p3 = n2;
        do {
          m3 = s2.prev[--p3];
          s2.prev[p3] = m3 >= _w_size ? m3 - _w_size : 0;
        } while (--n2);
        more += _w_size;
      }
      if (s2.strm.avail_in === 0) {
        break;
      }
      n2 = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
      s2.lookahead += n2;
      if (s2.lookahead + s2.insert >= MIN_MATCH) {
        str = s2.strstart - s2.insert;
        s2.ins_h = s2.window[str];
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
        while (s2.insert) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
          s2.insert--;
          if (s2.lookahead + s2.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
  }
  function deflate_stored(s2, flush) {
    var max_block_size = 65535;
    if (max_block_size > s2.pending_buf_size - 5) {
      max_block_size = s2.pending_buf_size - 5;
    }
    for (;; ) {
      if (s2.lookahead <= 1) {
        fill_window(s2);
        if (s2.lookahead === 0 && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      s2.strstart += s2.lookahead;
      s2.lookahead = 0;
      var max_start = s2.block_start + max_block_size;
      if (s2.strstart === 0 || s2.strstart >= max_start) {
        s2.lookahead = s2.strstart - max_start;
        s2.strstart = max_start;
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.strstart > s2.block_start) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  }
  function deflate_fast(s2, flush) {
    var hash_head;
    var bflush;
    for (;; ) {
      if (s2.lookahead < MIN_LOOKAHEAD) {
        fill_window(s2);
        if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s2.lookahead >= MIN_MATCH) {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
        hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = s2.strstart;
      }
      if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
        s2.match_length = longest_match(s2, hash_head);
      }
      if (s2.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
        s2.lookahead -= s2.match_length;
        if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
          s2.match_length--;
          do {
            s2.strstart++;
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
            hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = s2.strstart;
          } while (--s2.match_length !== 0);
          s2.strstart++;
        } else {
          s2.strstart += s2.match_length;
          s2.match_length = 0;
          s2.ins_h = s2.window[s2.strstart];
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
        }
      } else {
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
      }
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.last_lit) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_slow(s2, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (;; ) {
      if (s2.lookahead < MIN_LOOKAHEAD) {
        fill_window(s2);
        if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s2.lookahead >= MIN_MATCH) {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
        hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = s2.strstart;
      }
      s2.prev_length = s2.match_length;
      s2.prev_match = s2.match_start;
      s2.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
        s2.match_length = longest_match(s2, hash_head);
        if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
          s2.match_length = MIN_MATCH - 1;
        }
      }
      if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
        max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
        bflush = trees._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
        s2.lookahead -= s2.prev_length - 1;
        s2.prev_length -= 2;
        do {
          if (++s2.strstart <= max_insert) {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
            hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = s2.strstart;
          }
        } while (--s2.prev_length !== 0);
        s2.match_available = 0;
        s2.match_length = MIN_MATCH - 1;
        s2.strstart++;
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s2.match_available) {
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        if (bflush) {
          flush_block_only(s2, false);
        }
        s2.strstart++;
        s2.lookahead--;
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s2.match_available = 1;
        s2.strstart++;
        s2.lookahead--;
      }
    }
    if (s2.match_available) {
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
      s2.match_available = 0;
    }
    s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.last_lit) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_rle(s2, flush) {
    var bflush;
    var prev;
    var scan, strend;
    var _win = s2.window;
    for (;; ) {
      if (s2.lookahead <= MAX_MATCH) {
        fill_window(s2);
        if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      s2.match_length = 0;
      if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
        scan = s2.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s2.strstart + MAX_MATCH;
          do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s2.match_length = MAX_MATCH - (strend - scan);
          if (s2.match_length > s2.lookahead) {
            s2.match_length = s2.lookahead;
          }
        }
      }
      if (s2.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s2, 1, s2.match_length - MIN_MATCH);
        s2.lookahead -= s2.match_length;
        s2.strstart += s2.match_length;
        s2.match_length = 0;
      } else {
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
      }
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.last_lit) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_huff(s2, flush) {
    var bflush;
    for (;; ) {
      if (s2.lookahead === 0) {
        fill_window(s2);
        if (s2.lookahead === 0) {
          if (flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s2.match_length = 0;
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.last_lit) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  var configuration_table;
  configuration_table = [
    new Config(0, 0, 0, 0, deflate_stored),
    new Config(4, 4, 8, 4, deflate_fast),
    new Config(4, 5, 16, 8, deflate_fast),
    new Config(4, 6, 32, 32, deflate_fast),
    new Config(4, 4, 16, 16, deflate_slow),
    new Config(8, 16, 32, 32, deflate_slow),
    new Config(8, 16, 128, 128, deflate_slow),
    new Config(8, 32, 128, 256, deflate_slow),
    new Config(32, 128, 258, 1024, deflate_slow),
    new Config(32, 258, 258, 4096, deflate_slow)
  ];
  function lm_init(s2) {
    s2.window_size = 2 * s2.w_size;
    zero(s2.head);
    s2.max_lazy_match = configuration_table[s2.level].max_lazy;
    s2.good_match = configuration_table[s2.level].good_length;
    s2.nice_match = configuration_table[s2.level].nice_length;
    s2.max_chain_length = configuration_table[s2.level].max_chain;
    s2.strstart = 0;
    s2.block_start = 0;
    s2.lookahead = 0;
    s2.insert = 0;
    s2.match_length = s2.prev_length = MIN_MATCH - 1;
    s2.match_available = 0;
    s2.ins_h = 0;
  }
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils.Buf16(MAX_BITS + 1);
    this.heap = new utils.Buf16(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils.Buf16(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  function deflateResetKeep(strm) {
    var s2;
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    s2 = strm.state;
    s2.pending = 0;
    s2.pending_out = 0;
    if (s2.wrap < 0) {
      s2.wrap = -s2.wrap;
    }
    s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s2.wrap === 2 ? 0 : 1;
    s2.last_flush = Z_NO_FLUSH;
    trees._tr_init(s2);
    return Z_OK;
  }
  function deflateReset(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK) {
      lm_init(strm.state);
    }
    return ret;
  }
  function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return Z_OK;
  }
  function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
      return err(strm, Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s2 = new DeflateState;
    strm.state = s2;
    s2.strm = strm;
    s2.wrap = wrap;
    s2.gzhead = null;
    s2.w_bits = windowBits;
    s2.w_size = 1 << s2.w_bits;
    s2.w_mask = s2.w_size - 1;
    s2.hash_bits = memLevel + 7;
    s2.hash_size = 1 << s2.hash_bits;
    s2.hash_mask = s2.hash_size - 1;
    s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s2.window = new utils.Buf8(s2.w_size * 2);
    s2.head = new utils.Buf16(s2.hash_size);
    s2.prev = new utils.Buf16(s2.w_size);
    s2.lit_bufsize = 1 << memLevel + 6;
    s2.pending_buf_size = s2.lit_bufsize * 4;
    s2.pending_buf = new utils.Buf8(s2.pending_buf_size);
    s2.d_buf = 1 * s2.lit_bufsize;
    s2.l_buf = (1 + 2) * s2.lit_bufsize;
    s2.level = level;
    s2.strategy = strategy;
    s2.method = method;
    return deflateReset(strm);
  }
  function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
  }
  function deflate(strm, flush) {
    var old_flush, s2;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
    }
    s2 = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush !== Z_FINISH) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
    }
    s2.strm = strm;
    old_flush = s2.last_flush;
    s2.last_flush = flush;
    if (s2.status === INIT_STATE) {
      if (s2.wrap === 2) {
        strm.adler = 0;
        put_byte(s2, 31);
        put_byte(s2, 139);
        put_byte(s2, 8);
        if (!s2.gzhead) {
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
          put_byte(s2, OS_CODE);
          s2.status = BUSY_STATE;
        } else {
          put_byte(s2, (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16));
          put_byte(s2, s2.gzhead.time & 255);
          put_byte(s2, s2.gzhead.time >> 8 & 255);
          put_byte(s2, s2.gzhead.time >> 16 & 255);
          put_byte(s2, s2.gzhead.time >> 24 & 255);
          put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
          put_byte(s2, s2.gzhead.os & 255);
          if (s2.gzhead.extra && s2.gzhead.extra.length) {
            put_byte(s2, s2.gzhead.extra.length & 255);
            put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
          }
          if (s2.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending, 0);
          }
          s2.gzindex = 0;
          s2.status = EXTRA_STATE;
        }
      } else {
        var header = Z_DEFLATED + (s2.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
          level_flags = 0;
        } else if (s2.level < 6) {
          level_flags = 1;
        } else if (s2.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s2.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s2.status = BUSY_STATE;
        putShortMSB(s2, header);
        if (s2.strstart !== 0) {
          putShortMSB(s2, strm.adler >>> 16);
          putShortMSB(s2, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s2.status === EXTRA_STATE) {
      if (s2.gzhead.extra) {
        beg = s2.pending;
        while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
          if (s2.pending === s2.pending_buf_size) {
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s2.pending;
            if (s2.pending === s2.pending_buf_size) {
              break;
            }
          }
          put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
          s2.gzindex++;
        }
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        if (s2.gzindex === s2.gzhead.extra.length) {
          s2.gzindex = 0;
          s2.status = NAME_STATE;
        }
      } else {
        s2.status = NAME_STATE;
      }
    }
    if (s2.status === NAME_STATE) {
      if (s2.gzhead.name) {
        beg = s2.pending;
        do {
          if (s2.pending === s2.pending_buf_size) {
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s2.pending;
            if (s2.pending === s2.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s2.gzindex < s2.gzhead.name.length) {
            val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s2, val);
        } while (val !== 0);
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        if (val === 0) {
          s2.gzindex = 0;
          s2.status = COMMENT_STATE;
        }
      } else {
        s2.status = COMMENT_STATE;
      }
    }
    if (s2.status === COMMENT_STATE) {
      if (s2.gzhead.comment) {
        beg = s2.pending;
        do {
          if (s2.pending === s2.pending_buf_size) {
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s2.pending;
            if (s2.pending === s2.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s2.gzindex < s2.gzhead.comment.length) {
            val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s2, val);
        } while (val !== 0);
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        if (val === 0) {
          s2.status = HCRC_STATE;
        }
      } else {
        s2.status = HCRC_STATE;
      }
    }
    if (s2.status === HCRC_STATE) {
      if (s2.gzhead.hcrc) {
        if (s2.pending + 2 > s2.pending_buf_size) {
          flush_pending(strm);
        }
        if (s2.pending + 2 <= s2.pending_buf_size) {
          put_byte(s2, strm.adler & 255);
          put_byte(s2, strm.adler >> 8 & 255);
          strm.adler = 0;
          s2.status = BUSY_STATE;
        }
      } else {
        s2.status = BUSY_STATE;
      }
    }
    if (s2.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
        return Z_OK;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
      return err(strm, Z_BUF_ERROR);
    }
    if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH && s2.status !== FINISH_STATE) {
      var bstate = s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s2.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
        }
        return Z_OK;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          trees._tr_align(s2);
        } else if (flush !== Z_BLOCK) {
          trees._tr_stored_block(s2, 0, 0, false);
          if (flush === Z_FULL_FLUSH) {
            zero(s2.head);
            if (s2.lookahead === 0) {
              s2.strstart = 0;
              s2.block_start = 0;
              s2.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK;
        }
      }
    }
    if (flush !== Z_FINISH) {
      return Z_OK;
    }
    if (s2.wrap <= 0) {
      return Z_STREAM_END;
    }
    if (s2.wrap === 2) {
      put_byte(s2, strm.adler & 255);
      put_byte(s2, strm.adler >> 8 & 255);
      put_byte(s2, strm.adler >> 16 & 255);
      put_byte(s2, strm.adler >> 24 & 255);
      put_byte(s2, strm.total_in & 255);
      put_byte(s2, strm.total_in >> 8 & 255);
      put_byte(s2, strm.total_in >> 16 & 255);
      put_byte(s2, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s2, strm.adler >>> 16);
      putShortMSB(s2, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s2.wrap > 0) {
      s2.wrap = -s2.wrap;
    }
    return s2.pending !== 0 ? Z_OK : Z_STREAM_END;
  }
  function deflateEnd(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
  }
  function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var s2;
    var str, n2;
    var wrap;
    var avail;
    var next;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    s2 = strm.state;
    wrap = s2.wrap;
    if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
      return Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s2.wrap = 0;
    if (dictLength >= s2.w_size) {
      if (wrap === 0) {
        zero(s2.head);
        s2.strstart = 0;
        s2.block_start = 0;
        s2.insert = 0;
      }
      tmpDict = new utils.Buf8(s2.w_size);
      utils.arraySet(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
      dictionary = tmpDict;
      dictLength = s2.w_size;
    }
    avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s2);
    while (s2.lookahead >= MIN_MATCH) {
      str = s2.strstart;
      n2 = s2.lookahead - (MIN_MATCH - 1);
      do {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
        s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = str;
        str++;
      } while (--n2);
      s2.strstart = str;
      s2.lookahead = MIN_MATCH - 1;
      fill_window(s2);
    }
    s2.strstart += s2.lookahead;
    s2.block_start = s2.strstart;
    s2.insert = s2.lookahead;
    s2.lookahead = 0;
    s2.match_length = s2.prev_length = MIN_MATCH - 1;
    s2.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s2.wrap = wrap;
    return Z_OK;
  }
  exports.deflateInit = deflateInit;
  exports.deflateInit2 = deflateInit2;
  exports.deflateReset = deflateReset;
  exports.deflateResetKeep = deflateResetKeep;
  exports.deflateSetHeader = deflateSetHeader;
  exports.deflate = deflate;
  exports.deflateEnd = deflateEnd;
  exports.deflateSetDictionary = deflateSetDictionary;
  exports.deflateInfo = "pako deflate (from Nodeca project)";
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS((exports) => {
  var utils = require_common();
  var STR_APPLY_OK = true;
  var STR_APPLY_UIA_OK = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (__) {
    STR_APPLY_OK = false;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  }
  var _utf8len = new utils.Buf8(256);
  for (q2 = 0;q2 < 256; q2++) {
    _utf8len[q2] = q2 >= 252 ? 6 : q2 >= 248 ? 5 : q2 >= 240 ? 4 : q2 >= 224 ? 3 : q2 >= 192 ? 2 : 1;
  }
  var q2;
  _utf8len[254] = _utf8len[254] = 1;
  exports.string2buf = function(str) {
    var buf, c3, c22, m_pos, i4, str_len = str.length, buf_len = 0;
    for (m_pos = 0;m_pos < str_len; m_pos++) {
      c3 = str.charCodeAt(m_pos);
      if ((c3 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c3 = 65536 + (c3 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      buf_len += c3 < 128 ? 1 : c3 < 2048 ? 2 : c3 < 65536 ? 3 : 4;
    }
    buf = new utils.Buf8(buf_len);
    for (i4 = 0, m_pos = 0;i4 < buf_len; m_pos++) {
      c3 = str.charCodeAt(m_pos);
      if ((c3 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c3 = 65536 + (c3 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      if (c3 < 128) {
        buf[i4++] = c3;
      } else if (c3 < 2048) {
        buf[i4++] = 192 | c3 >>> 6;
        buf[i4++] = 128 | c3 & 63;
      } else if (c3 < 65536) {
        buf[i4++] = 224 | c3 >>> 12;
        buf[i4++] = 128 | c3 >>> 6 & 63;
        buf[i4++] = 128 | c3 & 63;
      } else {
        buf[i4++] = 240 | c3 >>> 18;
        buf[i4++] = 128 | c3 >>> 12 & 63;
        buf[i4++] = 128 | c3 >>> 6 & 63;
        buf[i4++] = 128 | c3 & 63;
      }
    }
    return buf;
  };
  function buf2binstring(buf, len2) {
    if (len2 < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
        return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len2));
      }
    }
    var result = "";
    for (var i4 = 0;i4 < len2; i4++) {
      result += String.fromCharCode(buf[i4]);
    }
    return result;
  }
  exports.buf2binstring = function(buf) {
    return buf2binstring(buf, buf.length);
  };
  exports.binstring2buf = function(str) {
    var buf = new utils.Buf8(str.length);
    for (var i4 = 0, len2 = buf.length;i4 < len2; i4++) {
      buf[i4] = str.charCodeAt(i4);
    }
    return buf;
  };
  exports.buf2string = function(buf, max3) {
    var i4, out, c3, c_len;
    var len2 = max3 || buf.length;
    var utf16buf = new Array(len2 * 2);
    for (out = 0, i4 = 0;i4 < len2; ) {
      c3 = buf[i4++];
      if (c3 < 128) {
        utf16buf[out++] = c3;
        continue;
      }
      c_len = _utf8len[c3];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i4 += c_len - 1;
        continue;
      }
      c3 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i4 < len2) {
        c3 = c3 << 6 | buf[i4++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c3 < 65536) {
        utf16buf[out++] = c3;
      } else {
        c3 -= 65536;
        utf16buf[out++] = 55296 | c3 >> 10 & 1023;
        utf16buf[out++] = 56320 | c3 & 1023;
      }
    }
    return buf2binstring(utf16buf, out);
  };
  exports.utf8border = function(buf, max3) {
    var pos;
    max3 = max3 || buf.length;
    if (max3 > buf.length) {
      max3 = buf.length;
    }
    pos = max3 - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max3;
    }
    if (pos === 0) {
      return max3;
    }
    return pos + _utf8len[buf[pos]] > max3 ? pos : max3;
  };
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS((exports, module) => {
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  module.exports = ZStream;
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS((exports) => {
  var zlib_deflate = require_deflate();
  var utils = require_common();
  var strings = require_strings();
  var msg = require_messages();
  var ZStream = require_zstream();
  var toString2 = Object.prototype.toString;
  var Z_NO_FLUSH = 0;
  var Z_FINISH = 4;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_SYNC_FLUSH = 2;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_DEFLATED = 8;
  function Deflate(options2) {
    if (!(this instanceof Deflate))
      return new Deflate(options2);
    this.options = utils.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY,
      to: ""
    }, options2 || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream;
    this.strm.avail_out = 0;
    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      var dict;
      if (typeof opt.dictionary === "string") {
        dict = strings.string2buf(opt.dictionary);
      } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this._dict_set = true;
    }
  }
  Deflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var status, _mode;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings.string2buf(data);
    } else if (toString2.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_deflate.deflate(strm, _mode);
      if (status !== Z_STREAM_END && status !== Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
    if (_mode === Z_FINISH) {
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }
    if (_mode === Z_SYNC_FLUSH) {
      this.onEnd(Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Deflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Deflate.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function deflate(input, options2) {
    var deflator = new Deflate(options2);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || msg[deflator.err];
    }
    return deflator.result;
  }
  function deflateRaw(input, options2) {
    options2 = options2 || {};
    options2.raw = true;
    return deflate(input, options2);
  }
  function gzip(input, options2) {
    options2 = options2 || {};
    options2.gzip = true;
    return deflate(input, options2);
  }
  exports.Deflate = Deflate;
  exports.deflate = deflate;
  exports.deflateRaw = deflateRaw;
  exports.gzip = gzip;
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS((exports, module) => {
  var BAD = 30;
  var TYPE = 12;
  module.exports = function inflate_fast(strm, start) {
    var state;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len2;
    var dist;
    var from2;
    var from_source;
    var input, output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (;; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len2 = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len2 += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (;; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    if (dist > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                      }
                      from2 = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from2 += wsize - op;
                        if (op < len2) {
                          len2 -= op;
                          do {
                            output[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from2 += wsize + wnext - op;
                        op -= wnext;
                        if (op < len2) {
                          len2 -= op;
                          do {
                            output[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = 0;
                          if (wnext < len2) {
                            op = wnext;
                            len2 -= op;
                            do {
                              output[_out++] = s_window[from2++];
                            } while (--op);
                            from2 = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from2 += wnext - op;
                        if (op < len2) {
                          len2 -= op;
                          do {
                            output[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len2 > 2) {
                        output[_out++] = from_source[from2++];
                        output[_out++] = from_source[from2++];
                        output[_out++] = from_source[from2++];
                        len2 -= 3;
                      }
                      if (len2) {
                        output[_out++] = from_source[from2++];
                        if (len2 > 1) {
                          output[_out++] = from_source[from2++];
                        }
                      }
                    } else {
                      from2 = _out - dist;
                      do {
                        output[_out++] = output[from2++];
                        output[_out++] = output[from2++];
                        output[_out++] = output[from2++];
                        len2 -= 3;
                      } while (len2 > 2);
                      if (len2) {
                        output[_out++] = output[from2++];
                        if (len2 > 1) {
                          output[_out++] = output[from2++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len2 = bits >> 3;
    _in -= len2;
    bits -= len2 << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS((exports, module) => {
  var utils = require_common();
  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext = [
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase = [
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext = [
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    var bits = opts.bits;
    var len2 = 0;
    var sym = 0;
    var min3 = 0, max3 = 0;
    var root = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask;
    var next;
    var base = null;
    var base_index = 0;
    var end;
    var count4 = new utils.Buf16(MAXBITS + 1);
    var offs = new utils.Buf16(MAXBITS + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len2 = 0;len2 <= MAXBITS; len2++) {
      count4[len2] = 0;
    }
    for (sym = 0;sym < codes; sym++) {
      count4[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max3 = MAXBITS;max3 >= 1; max3--) {
      if (count4[max3] !== 0) {
        break;
      }
    }
    if (root > max3) {
      root = max3;
    }
    if (max3 === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min3 = 1;min3 < max3; min3++) {
      if (count4[min3] !== 0) {
        break;
      }
    }
    if (root < min3) {
      root = min3;
    }
    left = 1;
    for (len2 = 1;len2 <= MAXBITS; len2++) {
      left <<= 1;
      left -= count4[len2];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === CODES || max3 !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len2 = 1;len2 < MAXBITS; len2++) {
      offs[len2 + 1] = offs[len2] + count4[len2];
    }
    for (sym = 0;sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === CODES) {
      base = extra = work;
      end = 19;
    } else if (type === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = dbase;
      extra = dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len2 = min3;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    for (;; ) {
      here_bits = len2 - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len2 - drop;
      fill = 1 << curr;
      min3 = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len2 - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count4[len2] === 0) {
        if (len2 === max3) {
          break;
        }
        len2 = lens[lens_index + work[sym]];
      }
      if (len2 > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min3;
        curr = len2 - drop;
        left = 1 << curr;
        while (curr + drop < max3) {
          left -= count4[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len2 - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS((exports) => {
  var utils = require_common();
  var adler32 = require_adler32();
  var crc32 = require_crc322();
  var inflate_fast = require_inffast();
  var inflate_table = require_inftrees();
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_TREES = 6;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_NEED_DICT = 2;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR = -5;
  var Z_DEFLATED = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME3 = 7;
  var COMMENT = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  function zswap32(q2) {
    return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
  }
  function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils.Buf16(320);
    this.work = new utils.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  function inflateResetKeep(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK;
  }
  function inflateReset(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  }
  function inflateReset2(strm, windowBits) {
    var wrap;
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  }
  function inflateInit2(strm, windowBits) {
    var ret;
    var state;
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    state = new InflateState;
    strm.state = state;
    state.window = null;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
  }
  var virgin = true;
  var lenfix;
  var distfix;
  function fixedtables(state) {
    if (virgin) {
      var sym;
      lenfix = new utils.Buf32(512);
      distfix = new utils.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  }
  function updatewindow(strm, src, end, copy) {
    var dist;
    var state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new utils.Buf8(state.wsize);
    }
    if (copy >= state.wsize) {
      utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      utils.arraySet(state.window, src, end - copy, dist, state.wnext);
      copy -= dist;
      if (copy) {
        utils.arraySet(state.window, src, end - copy, copy, 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  function inflate(strm, flush) {
    var state;
    var input, output;
    var next;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy;
    var from2;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len2;
    var ret;
    var hbuf = new utils.Buf8(4);
    var opts;
    var n2;
    var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK;
    inf_leave:
      for (;; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len2 = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len2;
            } else if (len2 > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len2;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len2 = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(state.head.extra, input, next, copy, len2);
                }
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME3;
          case NAME3:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len2 = input[next + copy++];
                if (state.head && len2 && state.length < 65536) {
                  state.head.name += String.fromCharCode(len2);
                }
              } while (len2 && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len2) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len2 = input[next + copy++];
                if (state.head && len2 && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len2);
                }
              } while (len2 && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len2) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (;; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n2 = here_bits + 2;
                  while (bits < n2) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len2 = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n2 = here_bits + 3;
                  while (bits < n2) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len2 = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n2 = here_bits + 7;
                  while (bits < n2) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len2 = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len2;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (;; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n2 = state.extra;
              while (bits < n2) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (;; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n2 = state.extra;
              while (bits < n2) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from2 = state.wsize - copy;
              } else {
                from2 = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from2 = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from2++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  }
  function inflateEnd(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    var state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK;
  }
  function inflateGetHeader(strm, head) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return Z_OK;
  }
  function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
    state.havedict = 1;
    return Z_OK;
  }
  exports.inflateReset = inflateReset;
  exports.inflateReset2 = inflateReset2;
  exports.inflateResetKeep = inflateResetKeep;
  exports.inflateInit = inflateInit;
  exports.inflateInit2 = inflateInit2;
  exports.inflate = inflate;
  exports.inflateEnd = inflateEnd;
  exports.inflateGetHeader = inflateGetHeader;
  exports.inflateSetDictionary = inflateSetDictionary;
  exports.inflateInfo = "pako inflate (from Nodeca project)";
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/constants.js
var require_constants2 = __commonJS((exports, module) => {
  module.exports = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
  };
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS((exports, module) => {
  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
  module.exports = GZheader;
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS((exports) => {
  var zlib_inflate = require_inflate();
  var utils = require_common();
  var strings = require_strings();
  var c3 = require_constants2();
  var msg = require_messages();
  var ZStream = require_zstream();
  var GZheader = require_gzheader();
  var toString2 = Object.prototype.toString;
  function Inflate(options2) {
    if (!(this instanceof Inflate))
      return new Inflate(options2);
    this.options = utils.assign({
      chunkSize: 16384,
      windowBits: 0,
      to: ""
    }, options2 || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream;
    this.strm.avail_out = 0;
    var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== c3.Z_OK) {
      throw new Error(msg[status]);
    }
    this.header = new GZheader;
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = strings.string2buf(opt.dictionary);
      } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== c3.Z_OK) {
          throw new Error(msg[status]);
        }
      }
    }
  }
  Inflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var dictionary = this.options.dictionary;
    var status, _mode;
    var next_out_utf8, tail, utf8str;
    var allowBufError = false;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? c3.Z_FINISH : c3.Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings.binstring2buf(data);
    } else if (toString2.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, c3.Z_NO_FLUSH);
      if (status === c3.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
      }
      if (status === c3.Z_BUF_ERROR && allowBufError === true) {
        status = c3.Z_OK;
        allowBufError = false;
      }
      if (status !== c3.Z_STREAM_END && status !== c3.Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === c3.Z_STREAM_END || strm.avail_in === 0 && (_mode === c3.Z_FINISH || _mode === c3.Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
            tail = strm.next_out - next_out_utf8;
            utf8str = strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) {
              utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
            }
            this.onData(utf8str);
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      }
      if (strm.avail_in === 0 && strm.avail_out === 0) {
        allowBufError = true;
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c3.Z_STREAM_END);
    if (status === c3.Z_STREAM_END) {
      _mode = c3.Z_FINISH;
    }
    if (_mode === c3.Z_FINISH) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === c3.Z_OK;
    }
    if (_mode === c3.Z_SYNC_FLUSH) {
      this.onEnd(c3.Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Inflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Inflate.prototype.onEnd = function(status) {
    if (status === c3.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function inflate(input, options2) {
    var inflator = new Inflate(options2);
    inflator.push(input, true);
    if (inflator.err) {
      throw inflator.msg || msg[inflator.err];
    }
    return inflator.result;
  }
  function inflateRaw(input, options2) {
    options2 = options2 || {};
    options2.raw = true;
    return inflate(input, options2);
  }
  exports.Inflate = Inflate;
  exports.inflate = inflate;
  exports.inflateRaw = inflateRaw;
  exports.ungzip = inflate;
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/index.js
var require_pako = __commonJS((exports, module) => {
  var assign = require_common().assign;
  var deflate = require_deflate2();
  var inflate = require_inflate2();
  var constants2 = require_constants2();
  var pako = {};
  assign(pako, deflate, inflate, constants2);
  module.exports = pako;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/flate.js
var require_flate = __commonJS((exports) => {
  var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
  var pako = require_pako();
  var utils = require_utils();
  var GenericWorker = require_GenericWorker();
  var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
  exports.magic = "\b\x00";
  function FlateWorker(action, options2) {
    GenericWorker.call(this, "FlateWorker/" + action);
    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options2;
    this.meta = {};
  }
  utils.inherits(FlateWorker, GenericWorker);
  FlateWorker.prototype.processChunk = function(chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
  };
  FlateWorker.prototype.flush = function() {
    GenericWorker.prototype.flush.call(this);
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push([], true);
  };
  FlateWorker.prototype.cleanUp = function() {
    GenericWorker.prototype.cleanUp.call(this);
    this._pako = null;
  };
  FlateWorker.prototype._createPako = function() {
    this._pako = new pako[this._pakoAction]({
      raw: true,
      level: this._pakoOptions.level || -1
    });
    var self2 = this;
    this._pako.onData = function(data) {
      self2.push({
        data,
        meta: self2.meta
      });
    };
  };
  exports.compressWorker = function(compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
  };
  exports.uncompressWorker = function() {
    return new FlateWorker("Inflate", {});
  };
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/compressions.js
var require_compressions = __commonJS((exports) => {
  var GenericWorker = require_GenericWorker();
  exports.STORE = {
    magic: "\x00\x00",
    compressWorker: function() {
      return new GenericWorker("STORE compression");
    },
    uncompressWorker: function() {
      return new GenericWorker("STORE decompression");
    }
  };
  exports.DEFLATE = require_flate();
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/signature.js
var require_signature = __commonJS((exports) => {
  exports.LOCAL_FILE_HEADER = "PK\x03\x04";
  exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
  exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
  exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
  exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
  exports.DATA_DESCRIPTOR = "PK\x07\b";
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/generate/ZipFileWorker.js
var require_ZipFileWorker = __commonJS((exports, module) => {
  var utils = require_utils();
  var GenericWorker = require_GenericWorker();
  var utf8 = require_utf8();
  var crc32 = require_crc32();
  var signature = require_signature();
  var decToHex = function(dec, bytes) {
    var hex = "", i4;
    for (i4 = 0;i4 < bytes; i4++) {
      hex += String.fromCharCode(dec & 255);
      dec = dec >>> 8;
    }
    return hex;
  };
  var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
    var result = unixPermissions;
    if (!unixPermissions) {
      result = isDir ? 16893 : 33204;
    }
    return (result & 65535) << 16;
  };
  var generateDosExternalFileAttr = function(dosPermissions) {
    return (dosPermissions || 0) & 63;
  };
  var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset4, platform2, encodeFileName) {
    var file = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo("string", encodeFileName(file.name)), utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir = file.dir, date = file.date;
    var dataInfo = {
      crc32: 0,
      compressedSize: 0,
      uncompressedSize: 0
    };
    if (!streamedContent || streamingEnded) {
      dataInfo.crc32 = streamInfo["crc32"];
      dataInfo.compressedSize = streamInfo["compressedSize"];
      dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
    }
    var bitflag = 0;
    if (streamedContent) {
      bitflag |= 8;
    }
    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
      bitflag |= 2048;
    }
    var extFileAttr = 0;
    var versionMadeBy = 0;
    if (dir) {
      extFileAttr |= 16;
    }
    if (platform2 === "UNIX") {
      versionMadeBy = 798;
      extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
    } else {
      versionMadeBy = 20;
      extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
    }
    dosTime = date.getUTCHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date.getUTCMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date.getUTCSeconds() / 2;
    dosDate = date.getUTCFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | date.getUTCMonth() + 1;
    dosDate = dosDate << 5;
    dosDate = dosDate | date.getUTCDate();
    if (useUTF8ForFileName) {
      unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(encodedFileName), 4) + utfEncodedFileName;
      extraFields += "up" + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField;
    }
    if (useUTF8ForComment) {
      unicodeCommentExtraField = decToHex(1, 1) + decToHex(crc32(encodedComment), 4) + utfEncodedComment;
      extraFields += "uc" + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField;
    }
    var header = "";
    header += `
\x00`;
    header += decToHex(bitflag, 2);
    header += compression.magic;
    header += decToHex(dosTime, 2);
    header += decToHex(dosDate, 2);
    header += decToHex(dataInfo.crc32, 4);
    header += decToHex(dataInfo.compressedSize, 4);
    header += decToHex(dataInfo.uncompressedSize, 4);
    header += decToHex(encodedFileName.length, 2);
    header += decToHex(extraFields.length, 2);
    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
    var dirRecord = signature.CENTRAL_FILE_HEADER + decToHex(versionMadeBy, 2) + header + decToHex(encodedComment.length, 2) + "\x00\x00" + "\x00\x00" + decToHex(extFileAttr, 4) + decToHex(offset4, 4) + encodedFileName + extraFields + encodedComment;
    return {
      fileRecord,
      dirRecord
    };
  };
  var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
    var dirEnd = "";
    var encodedComment = utils.transformTo("string", encodeFileName(comment));
    dirEnd = signature.CENTRAL_DIRECTORY_END + "\x00\x00" + "\x00\x00" + decToHex(entriesCount, 2) + decToHex(entriesCount, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(encodedComment.length, 2) + encodedComment;
    return dirEnd;
  };
  var generateDataDescriptors = function(streamInfo) {
    var descriptor = "";
    descriptor = signature.DATA_DESCRIPTOR + decToHex(streamInfo["crc32"], 4) + decToHex(streamInfo["compressedSize"], 4) + decToHex(streamInfo["uncompressedSize"], 4);
    return descriptor;
  };
  function ZipFileWorker(streamFiles, comment, platform2, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    this.bytesWritten = 0;
    this.zipComment = comment;
    this.zipPlatform = platform2;
    this.encodeFileName = encodeFileName;
    this.streamFiles = streamFiles;
    this.accumulate = false;
    this.contentBuffer = [];
    this.dirRecords = [];
    this.currentSourceOffset = 0;
    this.entriesCount = 0;
    this.currentFile = null;
    this._sources = [];
  }
  utils.inherits(ZipFileWorker, GenericWorker);
  ZipFileWorker.prototype.push = function(chunk) {
    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;
    if (this.accumulate) {
      this.contentBuffer.push(chunk);
    } else {
      this.bytesWritten += chunk.data.length;
      GenericWorker.prototype.push.call(this, {
        data: chunk.data,
        meta: {
          currentFile: this.currentFile,
          percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
        }
      });
    }
  };
  ZipFileWorker.prototype.openedSource = function(streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo["file"].name;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    if (streamedContent) {
      var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.push({
        data: record.fileRecord,
        meta: { percent: 0 }
      });
    } else {
      this.accumulate = true;
    }
  };
  ZipFileWorker.prototype.closedSource = function(streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
    this.dirRecords.push(record.dirRecord);
    if (streamedContent) {
      this.push({
        data: generateDataDescriptors(streamInfo),
        meta: { percent: 100 }
      });
    } else {
      this.push({
        data: record.fileRecord,
        meta: { percent: 0 }
      });
      while (this.contentBuffer.length) {
        this.push(this.contentBuffer.shift());
      }
    }
    this.currentFile = null;
  };
  ZipFileWorker.prototype.flush = function() {
    var localDirLength = this.bytesWritten;
    for (var i4 = 0;i4 < this.dirRecords.length; i4++) {
      this.push({
        data: this.dirRecords[i4],
        meta: { percent: 100 }
      });
    }
    var centralDirLength = this.bytesWritten - localDirLength;
    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
    this.push({
      data: dirEnd,
      meta: { percent: 100 }
    });
  };
  ZipFileWorker.prototype.prepareNextSource = function() {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
      this.previous.pause();
    } else {
      this.previous.resume();
    }
  };
  ZipFileWorker.prototype.registerPrevious = function(previous) {
    this._sources.push(previous);
    var self2 = this;
    previous.on("data", function(chunk) {
      self2.processChunk(chunk);
    });
    previous.on("end", function() {
      self2.closedSource(self2.previous.streamInfo);
      if (self2._sources.length) {
        self2.prepareNextSource();
      } else {
        self2.end();
      }
    });
    previous.on("error", function(e2) {
      self2.error(e2);
    });
    return this;
  };
  ZipFileWorker.prototype.resume = function() {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (!this.previous && this._sources.length) {
      this.prepareNextSource();
      return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
      this.end();
      return true;
    }
  };
  ZipFileWorker.prototype.error = function(e2) {
    var sources = this._sources;
    if (!GenericWorker.prototype.error.call(this, e2)) {
      return false;
    }
    for (var i4 = 0;i4 < sources.length; i4++) {
      try {
        sources[i4].error(e2);
      } catch (e3) {}
    }
    return true;
  };
  ZipFileWorker.prototype.lock = function() {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for (var i4 = 0;i4 < sources.length; i4++) {
      sources[i4].lock();
    }
  };
  module.exports = ZipFileWorker;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/generate/index.js
var require_generate = __commonJS((exports) => {
  var compressions = require_compressions();
  var ZipFileWorker = require_ZipFileWorker();
  var getCompression = function(fileCompression, zipCompression) {
    var compressionName = fileCompression || zipCompression;
    var compression = compressions[compressionName];
    if (!compression) {
      throw new Error(compressionName + " is not a valid compression method !");
    }
    return compression;
  };
  exports.generateWorker = function(zip, options2, comment) {
    var zipFileWorker = new ZipFileWorker(options2.streamFiles, comment, options2.platform, options2.encodeFileName);
    var entriesCount = 0;
    try {
      zip.forEach(function(relativePath, file) {
        entriesCount++;
        var compression = getCompression(file.options.compression, options2.compression);
        var compressionOptions = file.options.compressionOptions || options2.compressionOptions || {};
        var { dir, date } = file;
        file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
          name: relativePath,
          dir,
          date,
          comment: file.comment || "",
          unixPermissions: file.unixPermissions,
          dosPermissions: file.dosPermissions
        }).pipe(zipFileWorker);
      });
      zipFileWorker.entriesCount = entriesCount;
    } catch (e2) {
      zipFileWorker.error(e2);
    }
    return zipFileWorker;
  };
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js
var require_NodejsStreamInputAdapter = __commonJS((exports, module) => {
  var utils = require_utils();
  var GenericWorker = require_GenericWorker();
  function NodejsStreamInputAdapter(filename, stream) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream);
  }
  utils.inherits(NodejsStreamInputAdapter, GenericWorker);
  NodejsStreamInputAdapter.prototype._bindStream = function(stream) {
    var self2 = this;
    this._stream = stream;
    stream.pause();
    stream.on("data", function(chunk) {
      self2.push({
        data: chunk,
        meta: {
          percent: 0
        }
      });
    }).on("error", function(e2) {
      if (self2.isPaused) {
        this.generatedError = e2;
      } else {
        self2.error(e2);
      }
    }).on("end", function() {
      if (self2.isPaused) {
        self2._upstreamEnded = true;
      } else {
        self2.end();
      }
    });
  };
  NodejsStreamInputAdapter.prototype.pause = function() {
    if (!GenericWorker.prototype.pause.call(this)) {
      return false;
    }
    this._stream.pause();
    return true;
  };
  NodejsStreamInputAdapter.prototype.resume = function() {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (this._upstreamEnded) {
      this.end();
    } else {
      this._stream.resume();
    }
    return true;
  };
  module.exports = NodejsStreamInputAdapter;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/object.js
var require_object = __commonJS((exports, module) => {
  var utf8 = require_utf8();
  var utils = require_utils();
  var GenericWorker = require_GenericWorker();
  var StreamHelper = require_StreamHelper();
  var defaults = require_defaults();
  var CompressedObject = require_compressedObject();
  var ZipObject = require_zipObject();
  var generate = require_generate();
  var nodejsUtils = require_nodejsUtils();
  var NodejsStreamInputAdapter = require_NodejsStreamInputAdapter();
  var fileAdd = function(name, data, originalOptions) {
    var dataType = utils.getTypeOf(data), parent;
    var o3 = utils.extend(originalOptions || {}, defaults);
    o3.date = o3.date || new Date;
    if (o3.compression !== null) {
      o3.compression = o3.compression.toUpperCase();
    }
    if (typeof o3.unixPermissions === "string") {
      o3.unixPermissions = parseInt(o3.unixPermissions, 8);
    }
    if (o3.unixPermissions && o3.unixPermissions & 16384) {
      o3.dir = true;
    }
    if (o3.dosPermissions && o3.dosPermissions & 16) {
      o3.dir = true;
    }
    if (o3.dir) {
      name = forceTrailingSlash(name);
    }
    if (o3.createFolders && (parent = parentFolder(name))) {
      folderAdd.call(this, parent, true);
    }
    var isUnicodeString = dataType === "string" && o3.binary === false && o3.base64 === false;
    if (!originalOptions || typeof originalOptions.binary === "undefined") {
      o3.binary = !isUnicodeString;
    }
    var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
    if (isCompressedEmpty || o3.dir || !data || data.length === 0) {
      o3.base64 = false;
      o3.binary = true;
      data = "";
      o3.compression = "STORE";
      dataType = "string";
    }
    var zipObjectContent = null;
    if (data instanceof CompressedObject || data instanceof GenericWorker) {
      zipObjectContent = data;
    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
      zipObjectContent = new NodejsStreamInputAdapter(name, data);
    } else {
      zipObjectContent = utils.prepareContent(name, data, o3.binary, o3.optimizedBinaryString, o3.base64);
    }
    var object = new ZipObject(name, zipObjectContent, o3);
    this.files[name] = object;
  };
  var parentFolder = function(path) {
    if (path.slice(-1) === "/") {
      path = path.substring(0, path.length - 1);
    }
    var lastSlash = path.lastIndexOf("/");
    return lastSlash > 0 ? path.substring(0, lastSlash) : "";
  };
  var forceTrailingSlash = function(path) {
    if (path.slice(-1) !== "/") {
      path += "/";
    }
    return path;
  };
  var folderAdd = function(name, createFolders) {
    createFolders = typeof createFolders !== "undefined" ? createFolders : defaults.createFolders;
    name = forceTrailingSlash(name);
    if (!this.files[name]) {
      fileAdd.call(this, name, null, {
        dir: true,
        createFolders
      });
    }
    return this.files[name];
  };
  function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
  }
  var out = {
    load: function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },
    forEach: function(cb) {
      var filename, relativePath, file;
      for (filename in this.files) {
        file = this.files[filename];
        relativePath = filename.slice(this.root.length, filename.length);
        if (relativePath && filename.slice(0, this.root.length) === this.root) {
          cb(relativePath, file);
        }
      }
    },
    filter: function(search) {
      var result = [];
      this.forEach(function(relativePath, entry) {
        if (search(relativePath, entry)) {
          result.push(entry);
        }
      });
      return result;
    },
    file: function(name, data, o3) {
      if (arguments.length === 1) {
        if (isRegExp(name)) {
          var regexp = name;
          return this.filter(function(relativePath, file) {
            return !file.dir && regexp.test(relativePath);
          });
        } else {
          var obj = this.files[this.root + name];
          if (obj && !obj.dir) {
            return obj;
          } else {
            return null;
          }
        }
      } else {
        name = this.root + name;
        fileAdd.call(this, name, data, o3);
      }
      return this;
    },
    folder: function(arg) {
      if (!arg) {
        return this;
      }
      if (isRegExp(arg)) {
        return this.filter(function(relativePath, file) {
          return file.dir && arg.test(relativePath);
        });
      }
      var name = this.root + arg;
      var newFolder = folderAdd.call(this, name);
      var ret = this.clone();
      ret.root = newFolder.name;
      return ret;
    },
    remove: function(name) {
      name = this.root + name;
      var file = this.files[name];
      if (!file) {
        if (name.slice(-1) !== "/") {
          name += "/";
        }
        file = this.files[name];
      }
      if (file && !file.dir) {
        delete this.files[name];
      } else {
        var kids = this.filter(function(relativePath, file2) {
          return file2.name.slice(0, name.length) === name;
        });
        for (var i4 = 0;i4 < kids.length; i4++) {
          delete this.files[kids[i4].name];
        }
      }
      return this;
    },
    generate: function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },
    generateInternalStream: function(options2) {
      var worker, opts = {};
      try {
        opts = utils.extend(options2 || {}, {
          streamFiles: false,
          compression: "STORE",
          compressionOptions: null,
          type: "",
          platform: "DOS",
          comment: null,
          mimeType: "application/zip",
          encodeFileName: utf8.utf8encode
        });
        opts.type = opts.type.toLowerCase();
        opts.compression = opts.compression.toUpperCase();
        if (opts.type === "binarystring") {
          opts.type = "string";
        }
        if (!opts.type) {
          throw new Error("No output type specified.");
        }
        utils.checkSupport(opts.type);
        if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
          opts.platform = "UNIX";
        }
        if (opts.platform === "win32") {
          opts.platform = "DOS";
        }
        var comment = opts.comment || this.comment || "";
        worker = generate.generateWorker(this, opts, comment);
      } catch (e2) {
        worker = new GenericWorker("error");
        worker.error(e2);
      }
      return new StreamHelper(worker, opts.type || "string", opts.mimeType);
    },
    generateAsync: function(options2, onUpdate) {
      return this.generateInternalStream(options2).accumulate(onUpdate);
    },
    generateNodeStream: function(options2, onUpdate) {
      options2 = options2 || {};
      if (!options2.type) {
        options2.type = "nodebuffer";
      }
      return this.generateInternalStream(options2).toNodejsStream(onUpdate);
    }
  };
  module.exports = out;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/reader/DataReader.js
var require_DataReader = __commonJS((exports, module) => {
  var utils = require_utils();
  function DataReader(data) {
    this.data = data;
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
  }
  DataReader.prototype = {
    checkOffset: function(offset4) {
      this.checkIndex(this.index + offset4);
    },
    checkIndex: function(newIndex) {
      if (this.length < this.zero + newIndex || newIndex < 0) {
        throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
      }
    },
    setIndex: function(newIndex) {
      this.checkIndex(newIndex);
      this.index = newIndex;
    },
    skip: function(n2) {
      this.setIndex(this.index + n2);
    },
    byteAt: function() {},
    readInt: function(size4) {
      var result = 0, i4;
      this.checkOffset(size4);
      for (i4 = this.index + size4 - 1;i4 >= this.index; i4--) {
        result = (result << 8) + this.byteAt(i4);
      }
      this.index += size4;
      return result;
    },
    readString: function(size4) {
      return utils.transformTo("string", this.readData(size4));
    },
    readData: function() {},
    lastIndexOfSignature: function() {},
    readAndCheckSignature: function() {},
    readDate: function() {
      var dostime = this.readInt(4);
      return new Date(Date.UTC((dostime >> 25 & 127) + 1980, (dostime >> 21 & 15) - 1, dostime >> 16 & 31, dostime >> 11 & 31, dostime >> 5 & 63, (dostime & 31) << 1));
    }
  };
  module.exports = DataReader;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/reader/ArrayReader.js
var require_ArrayReader = __commonJS((exports, module) => {
  var DataReader = require_DataReader();
  var utils = require_utils();
  function ArrayReader(data) {
    DataReader.call(this, data);
    for (var i4 = 0;i4 < this.data.length; i4++) {
      data[i4] = data[i4] & 255;
    }
  }
  utils.inherits(ArrayReader, DataReader);
  ArrayReader.prototype.byteAt = function(i4) {
    return this.data[this.zero + i4];
  };
  ArrayReader.prototype.lastIndexOfSignature = function(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
    for (var i4 = this.length - 4;i4 >= 0; --i4) {
      if (this.data[i4] === sig0 && this.data[i4 + 1] === sig1 && this.data[i4 + 2] === sig2 && this.data[i4 + 3] === sig3) {
        return i4 - this.zero;
      }
    }
    return -1;
  };
  ArrayReader.prototype.readAndCheckSignature = function(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
  };
  ArrayReader.prototype.readData = function(size4) {
    this.checkOffset(size4);
    if (size4 === 0) {
      return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size4);
    this.index += size4;
    return result;
  };
  module.exports = ArrayReader;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/reader/StringReader.js
var require_StringReader = __commonJS((exports, module) => {
  var DataReader = require_DataReader();
  var utils = require_utils();
  function StringReader(data) {
    DataReader.call(this, data);
  }
  utils.inherits(StringReader, DataReader);
  StringReader.prototype.byteAt = function(i4) {
    return this.data.charCodeAt(this.zero + i4);
  };
  StringReader.prototype.lastIndexOfSignature = function(sig) {
    return this.data.lastIndexOf(sig) - this.zero;
  };
  StringReader.prototype.readAndCheckSignature = function(sig) {
    var data = this.readData(4);
    return sig === data;
  };
  StringReader.prototype.readData = function(size4) {
    this.checkOffset(size4);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size4);
    this.index += size4;
    return result;
  };
  module.exports = StringReader;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/reader/Uint8ArrayReader.js
var require_Uint8ArrayReader = __commonJS((exports, module) => {
  var ArrayReader = require_ArrayReader();
  var utils = require_utils();
  function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
  }
  utils.inherits(Uint8ArrayReader, ArrayReader);
  Uint8ArrayReader.prototype.readData = function(size4) {
    this.checkOffset(size4);
    if (size4 === 0) {
      return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size4);
    this.index += size4;
    return result;
  };
  module.exports = Uint8ArrayReader;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/reader/NodeBufferReader.js
var require_NodeBufferReader = __commonJS((exports, module) => {
  var Uint8ArrayReader = require_Uint8ArrayReader();
  var utils = require_utils();
  function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
  }
  utils.inherits(NodeBufferReader, Uint8ArrayReader);
  NodeBufferReader.prototype.readData = function(size4) {
    this.checkOffset(size4);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size4);
    this.index += size4;
    return result;
  };
  module.exports = NodeBufferReader;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/reader/readerFor.js
var require_readerFor = __commonJS((exports, module) => {
  var utils = require_utils();
  var support = require_support();
  var ArrayReader = require_ArrayReader();
  var StringReader = require_StringReader();
  var NodeBufferReader = require_NodeBufferReader();
  var Uint8ArrayReader = require_Uint8ArrayReader();
  module.exports = function(data) {
    var type = utils.getTypeOf(data);
    utils.checkSupport(type);
    if (type === "string" && !support.uint8array) {
      return new StringReader(data);
    }
    if (type === "nodebuffer") {
      return new NodeBufferReader(data);
    }
    if (support.uint8array) {
      return new Uint8ArrayReader(utils.transformTo("uint8array", data));
    }
    return new ArrayReader(utils.transformTo("array", data));
  };
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/zipEntry.js
var require_zipEntry = __commonJS((exports, module) => {
  var readerFor = require_readerFor();
  var utils = require_utils();
  var CompressedObject = require_compressedObject();
  var crc32fn = require_crc32();
  var utf8 = require_utf8();
  var compressions = require_compressions();
  var support = require_support();
  var MADE_BY_DOS = 0;
  var MADE_BY_UNIX = 3;
  var findCompression = function(compressionMethod) {
    for (var method in compressions) {
      if (!Object.prototype.hasOwnProperty.call(compressions, method)) {
        continue;
      }
      if (compressions[method].magic === compressionMethod) {
        return compressions[method];
      }
    }
    return null;
  };
  function ZipEntry(options2, loadOptions) {
    this.options = options2;
    this.loadOptions = loadOptions;
  }
  ZipEntry.prototype = {
    isEncrypted: function() {
      return (this.bitFlag & 1) === 1;
    },
    useUTF8: function() {
      return (this.bitFlag & 2048) === 2048;
    },
    readLocalPart: function(reader) {
      var compression, localExtraFieldsLength;
      reader.skip(22);
      this.fileNameLength = reader.readInt(2);
      localExtraFieldsLength = reader.readInt(2);
      this.fileName = reader.readData(this.fileNameLength);
      reader.skip(localExtraFieldsLength);
      if (this.compressedSize === -1 || this.uncompressedSize === -1) {
        throw new Error("Bug or corrupted zip : didn't get enough information from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
      }
      compression = findCompression(this.compressionMethod);
      if (compression === null) {
        throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
      }
      this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
    },
    readCentralPart: function(reader) {
      this.versionMadeBy = reader.readInt(2);
      reader.skip(2);
      this.bitFlag = reader.readInt(2);
      this.compressionMethod = reader.readString(2);
      this.date = reader.readDate();
      this.crc32 = reader.readInt(4);
      this.compressedSize = reader.readInt(4);
      this.uncompressedSize = reader.readInt(4);
      var fileNameLength = reader.readInt(2);
      this.extraFieldsLength = reader.readInt(2);
      this.fileCommentLength = reader.readInt(2);
      this.diskNumberStart = reader.readInt(2);
      this.internalFileAttributes = reader.readInt(2);
      this.externalFileAttributes = reader.readInt(4);
      this.localHeaderOffset = reader.readInt(4);
      if (this.isEncrypted()) {
        throw new Error("Encrypted zip are not supported");
      }
      reader.skip(fileNameLength);
      this.readExtraFields(reader);
      this.parseZIP64ExtraField(reader);
      this.fileComment = reader.readData(this.fileCommentLength);
    },
    processAttributes: function() {
      this.unixPermissions = null;
      this.dosPermissions = null;
      var madeBy = this.versionMadeBy >> 8;
      this.dir = this.externalFileAttributes & 16 ? true : false;
      if (madeBy === MADE_BY_DOS) {
        this.dosPermissions = this.externalFileAttributes & 63;
      }
      if (madeBy === MADE_BY_UNIX) {
        this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
      }
      if (!this.dir && this.fileNameStr.slice(-1) === "/") {
        this.dir = true;
      }
    },
    parseZIP64ExtraField: function() {
      if (!this.extraFields[1]) {
        return;
      }
      var extraReader = readerFor(this.extraFields[1].value);
      if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
        this.uncompressedSize = extraReader.readInt(8);
      }
      if (this.compressedSize === utils.MAX_VALUE_32BITS) {
        this.compressedSize = extraReader.readInt(8);
      }
      if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
        this.localHeaderOffset = extraReader.readInt(8);
      }
      if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
        this.diskNumberStart = extraReader.readInt(4);
      }
    },
    readExtraFields: function(reader) {
      var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
      if (!this.extraFields) {
        this.extraFields = {};
      }
      while (reader.index + 4 < end) {
        extraFieldId = reader.readInt(2);
        extraFieldLength = reader.readInt(2);
        extraFieldValue = reader.readData(extraFieldLength);
        this.extraFields[extraFieldId] = {
          id: extraFieldId,
          length: extraFieldLength,
          value: extraFieldValue
        };
      }
      reader.setIndex(end);
    },
    handleUTF8: function() {
      var decodeParamType = support.uint8array ? "uint8array" : "array";
      if (this.useUTF8()) {
        this.fileNameStr = utf8.utf8decode(this.fileName);
        this.fileCommentStr = utf8.utf8decode(this.fileComment);
      } else {
        var upath = this.findExtraFieldUnicodePath();
        if (upath !== null) {
          this.fileNameStr = upath;
        } else {
          var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
          this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
        }
        var ucomment = this.findExtraFieldUnicodeComment();
        if (ucomment !== null) {
          this.fileCommentStr = ucomment;
        } else {
          var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
          this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
        }
      }
    },
    findExtraFieldUnicodePath: function() {
      var upathField = this.extraFields[28789];
      if (upathField) {
        var extraReader = readerFor(upathField.value);
        if (extraReader.readInt(1) !== 1) {
          return null;
        }
        if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
          return null;
        }
        return utf8.utf8decode(extraReader.readData(upathField.length - 5));
      }
      return null;
    },
    findExtraFieldUnicodeComment: function() {
      var ucommentField = this.extraFields[25461];
      if (ucommentField) {
        var extraReader = readerFor(ucommentField.value);
        if (extraReader.readInt(1) !== 1) {
          return null;
        }
        if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
          return null;
        }
        return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
      }
      return null;
    }
  };
  module.exports = ZipEntry;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/zipEntries.js
var require_zipEntries = __commonJS((exports, module) => {
  var readerFor = require_readerFor();
  var utils = require_utils();
  var sig = require_signature();
  var ZipEntry = require_zipEntry();
  var support = require_support();
  function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
  }
  ZipEntries.prototype = {
    checkSignature: function(expectedSignature) {
      if (!this.reader.readAndCheckSignature(expectedSignature)) {
        this.reader.index -= 4;
        var signature = this.reader.readString(4);
        throw new Error("Corrupted zip or bug: unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
      }
    },
    isSignature: function(askedIndex, expectedSignature) {
      var currentIndex = this.reader.index;
      this.reader.setIndex(askedIndex);
      var signature = this.reader.readString(4);
      var result = signature === expectedSignature;
      this.reader.setIndex(currentIndex);
      return result;
    },
    readBlockEndOfCentral: function() {
      this.diskNumber = this.reader.readInt(2);
      this.diskWithCentralDirStart = this.reader.readInt(2);
      this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
      this.centralDirRecords = this.reader.readInt(2);
      this.centralDirSize = this.reader.readInt(4);
      this.centralDirOffset = this.reader.readInt(4);
      this.zipCommentLength = this.reader.readInt(2);
      var zipComment = this.reader.readData(this.zipCommentLength);
      var decodeParamType = support.uint8array ? "uint8array" : "array";
      var decodeContent = utils.transformTo(decodeParamType, zipComment);
      this.zipComment = this.loadOptions.decodeFileName(decodeContent);
    },
    readBlockZip64EndOfCentral: function() {
      this.zip64EndOfCentralSize = this.reader.readInt(8);
      this.reader.skip(4);
      this.diskNumber = this.reader.readInt(4);
      this.diskWithCentralDirStart = this.reader.readInt(4);
      this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
      this.centralDirRecords = this.reader.readInt(8);
      this.centralDirSize = this.reader.readInt(8);
      this.centralDirOffset = this.reader.readInt(8);
      this.zip64ExtensibleData = {};
      var extraDataSize = this.zip64EndOfCentralSize - 44, index2 = 0, extraFieldId, extraFieldLength, extraFieldValue;
      while (index2 < extraDataSize) {
        extraFieldId = this.reader.readInt(2);
        extraFieldLength = this.reader.readInt(4);
        extraFieldValue = this.reader.readData(extraFieldLength);
        this.zip64ExtensibleData[extraFieldId] = {
          id: extraFieldId,
          length: extraFieldLength,
          value: extraFieldValue
        };
      }
    },
    readBlockZip64EndOfCentralLocator: function() {
      this.diskWithZip64CentralDirStart = this.reader.readInt(4);
      this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
      this.disksCount = this.reader.readInt(4);
      if (this.disksCount > 1) {
        throw new Error("Multi-volumes zip are not supported");
      }
    },
    readLocalFiles: function() {
      var i4, file;
      for (i4 = 0;i4 < this.files.length; i4++) {
        file = this.files[i4];
        this.reader.setIndex(file.localHeaderOffset);
        this.checkSignature(sig.LOCAL_FILE_HEADER);
        file.readLocalPart(this.reader);
        file.handleUTF8();
        file.processAttributes();
      }
    },
    readCentralDir: function() {
      var file;
      this.reader.setIndex(this.centralDirOffset);
      while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
        file = new ZipEntry({
          zip64: this.zip64
        }, this.loadOptions);
        file.readCentralPart(this.reader);
        this.files.push(file);
      }
      if (this.centralDirRecords !== this.files.length) {
        if (this.centralDirRecords !== 0 && this.files.length === 0) {
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        } else {}
      }
    },
    readEndOfCentral: function() {
      var offset4 = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
      if (offset4 < 0) {
        var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
        if (isGarbage) {
          throw new Error("Can't find end of central directory : is this a zip file ? " + "If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        } else {
          throw new Error("Corrupted zip: can't find end of central directory");
        }
      }
      this.reader.setIndex(offset4);
      var endOfCentralDirOffset = offset4;
      this.checkSignature(sig.CENTRAL_DIRECTORY_END);
      this.readBlockEndOfCentral();
      if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
        this.zip64 = true;
        offset4 = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
        if (offset4 < 0) {
          throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
        }
        this.reader.setIndex(offset4);
        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
        this.readBlockZip64EndOfCentralLocator();
        if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
          this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
          if (this.relativeOffsetEndOfZip64CentralDir < 0) {
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          }
        }
        this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
        this.readBlockZip64EndOfCentral();
      }
      var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
      if (this.zip64) {
        expectedEndOfCentralDirOffset += 20;
        expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
      }
      var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
      if (extraBytes > 0) {
        if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {} else {
          this.reader.zero = extraBytes;
        }
      } else if (extraBytes < 0) {
        throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
      }
    },
    prepareReader: function(data) {
      this.reader = readerFor(data);
    },
    load: function(data) {
      this.prepareReader(data);
      this.readEndOfCentral();
      this.readCentralDir();
      this.readLocalFiles();
    }
  };
  module.exports = ZipEntries;
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/load.js
var require_load = __commonJS((exports, module) => {
  var utils = require_utils();
  var external2 = require_external();
  var utf8 = require_utf8();
  var ZipEntries = require_zipEntries();
  var Crc32Probe = require_Crc32Probe();
  var nodejsUtils = require_nodejsUtils();
  function checkEntryCRC32(zipEntry) {
    return new external2.Promise(function(resolve, reject) {
      var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe);
      worker.on("error", function(e2) {
        reject(e2);
      }).on("end", function() {
        if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
          reject(new Error("Corrupted zip : CRC32 mismatch"));
        } else {
          resolve();
        }
      }).resume();
    });
  }
  module.exports = function(data, options2) {
    var zip = this;
    options2 = utils.extend(options2 || {}, {
      base64: false,
      checkCRC32: false,
      optimizedBinaryString: false,
      createFolders: false,
      decodeFileName: utf8.utf8decode
    });
    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
      return external2.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }
    return utils.prepareContent("the loaded zip file", data, true, options2.optimizedBinaryString, options2.base64).then(function(data2) {
      var zipEntries = new ZipEntries(options2);
      zipEntries.load(data2);
      return zipEntries;
    }).then(function checkCRC32(zipEntries) {
      var promises = [external2.Promise.resolve(zipEntries)];
      var files = zipEntries.files;
      if (options2.checkCRC32) {
        for (var i4 = 0;i4 < files.length; i4++) {
          promises.push(checkEntryCRC32(files[i4]));
        }
      }
      return external2.Promise.all(promises);
    }).then(function addFiles(results) {
      var zipEntries = results.shift();
      var files = zipEntries.files;
      for (var i4 = 0;i4 < files.length; i4++) {
        var input = files[i4];
        var unsafeName = input.fileNameStr;
        var safeName = utils.resolve(input.fileNameStr);
        zip.file(safeName, input.decompressed, {
          binary: true,
          optimizedBinaryString: true,
          date: input.date,
          dir: input.dir,
          comment: input.fileCommentStr.length ? input.fileCommentStr : null,
          unixPermissions: input.unixPermissions,
          dosPermissions: input.dosPermissions,
          createFolders: options2.createFolders
        });
        if (!input.dir) {
          zip.file(safeName).unsafeOriginalName = unsafeName;
        }
      }
      if (zipEntries.zipComment.length) {
        zip.comment = zipEntries.zipComment;
      }
      return zip;
    });
  };
});

// ../../node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/index.js
var require_lib = __commonJS((exports, module) => {
  function JSZip() {
    if (!(this instanceof JSZip)) {
      return new JSZip;
    }
    if (arguments.length) {
      throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }
    this.files = Object.create(null);
    this.comment = null;
    this.root = "";
    this.clone = function() {
      var newObj = new JSZip;
      for (var i4 in this) {
        if (typeof this[i4] !== "function") {
          newObj[i4] = this[i4];
        }
      }
      return newObj;
    };
  }
  JSZip.prototype = require_object();
  JSZip.prototype.loadAsync = require_load();
  JSZip.support = require_support();
  JSZip.defaults = require_defaults();
  JSZip.version = "3.10.1";
  JSZip.loadAsync = function(content, options2) {
    return new JSZip().loadAsync(content, options2);
  };
  JSZip.external = require_external();
  module.exports = JSZip;
});

// node:util
var exports_util = {};
__export(exports_util, {
  types: () => types2,
  promisify: () => promisify,
  log: () => log4,
  isUndefined: () => isUndefined,
  isSymbol: () => isSymbol,
  isString: () => isString,
  isRegExp: () => isRegExp,
  isPrimitive: () => isPrimitive,
  isObject: () => isObject,
  isNumber: () => isNumber2,
  isNullOrUndefined: () => isNullOrUndefined,
  isNull: () => isNull,
  isFunction: () => isFunction3,
  isError: () => isError,
  isDate: () => isDate,
  isBuffer: () => isBuffer,
  isBoolean: () => isBoolean,
  isArray: () => isArray,
  inspect: () => inspect,
  inherits: () => inherits,
  format: () => format,
  deprecate: () => deprecate,
  default: () => util_default,
  debuglog: () => debuglog,
  callbackifyOnRejected: () => callbackifyOnRejected,
  callbackify: () => callbackify,
  _extend: () => _extend,
  TextEncoder: () => TextEncoder,
  TextDecoder: () => TextDecoder
});
function format(f2, ...args) {
  if (!isString(f2)) {
    var objects = [f2];
    for (var i4 = 0;i4 < args.length; i4++)
      objects.push(inspect(args[i4]));
    return objects.join(" ");
  }
  var i4 = 0, len2 = args.length, str = String(f2).replace(formatRegExp, function(x22) {
    if (x22 === "%%")
      return "%";
    if (i4 >= len2)
      return x22;
    switch (x22) {
      case "%s":
        return String(args[i4++]);
      case "%d":
        return Number(args[i4++]);
      case "%j":
        try {
          return JSON.stringify(args[i4++]);
        } catch (_2) {
          return "[Circular]";
        }
      default:
        return x22;
    }
  });
  for (var x3 = args[i4];i4 < len2; x3 = args[++i4])
    if (isNull(x3) || !isObject(x3))
      str += " " + x3;
    else
      str += " " + inspect(x3);
  return str;
}
function deprecate(fn, msg) {
  if (typeof process > "u" || process?.noDeprecation === true)
    return fn;
  var warned = false;
  function deprecated(...args) {
    if (!warned) {
      if (process.throwDeprecation)
        throw Error(msg);
      else if (process.traceDeprecation)
        console.trace(msg);
      else
        console.error(msg);
      warned = true;
    }
    return fn.apply(this, ...args);
  }
  return deprecated;
}
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style)
    return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
  else
    return str;
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  return array.forEach(function(val, idx) {
    hash[val] = true;
  }), hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction3(value.inspect) && value.inspect !== inspect && !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret))
      ret = formatValue(ctx, ret, recurseTimes);
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive)
    return primitive;
  var keys = Object.keys(value), visibleKeys = arrayToHash(keys);
  if (ctx.showHidden)
    keys = Object.getOwnPropertyNames(value);
  if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0))
    return formatError(value);
  if (keys.length === 0) {
    if (isFunction3(value)) {
      var name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value))
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    if (isDate(value))
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    if (isError(value))
      return formatError(value);
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray(value))
    array = true, braces = ["[", "]"];
  if (isFunction3(value)) {
    var n2 = value.name ? ": " + value.name : "";
    base = " [Function" + n2 + "]";
  }
  if (isRegExp(value))
    base = " " + RegExp.prototype.toString.call(value);
  if (isDate(value))
    base = " " + Date.prototype.toUTCString.call(value);
  if (isError(value))
    base = " " + formatError(value);
  if (keys.length === 0 && (!array || value.length == 0))
    return braces[0] + base + braces[1];
  if (recurseTimes < 0)
    if (isRegExp(value))
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    else
      return ctx.stylize("[Object]", "special");
  ctx.seen.push(value);
  var output;
  if (array)
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  else
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  return ctx.seen.pop(), reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber2(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i4 = 0, l4 = value.length;i4 < l4; ++i4)
    if (hasOwnProperty(value, String(i4)))
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i4), true));
    else
      output.push("");
  return keys.forEach(function(key) {
    if (!key.match(/^\d+$/))
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
  }), output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  if (desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] }, desc.get)
    if (desc.set)
      str = ctx.stylize("[Getter/Setter]", "special");
    else
      str = ctx.stylize("[Getter]", "special");
  else if (desc.set)
    str = ctx.stylize("[Setter]", "special");
  if (!hasOwnProperty(visibleKeys, key))
    name = "[" + key + "]";
  if (!str)
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes))
        str = formatValue(ctx, desc.value, null);
      else
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      if (str.indexOf(`
`) > -1)
        if (array)
          str = str.split(`
`).map(function(line) {
            return "  " + line;
          }).join(`
`).slice(2);
        else
          str = `
` + str.split(`
`).map(function(line) {
            return "   " + line;
          }).join(`
`);
    } else
      str = ctx.stylize("[Circular]", "special");
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/))
      return str;
    if (name = JSON.stringify("" + key), name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/))
      name = name.slice(1, -1), name = ctx.stylize(name, "name");
    else
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), name = ctx.stylize(name, "string");
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0, length = output.reduce(function(prev, cur) {
    if (numLinesEst++, cur.indexOf(`
`) >= 0)
      numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60)
    return braces[0] + (base === "" ? "" : base + `
 `) + " " + output.join(`,
  `) + " " + braces[1];
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber2(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isSymbol(arg) {
  return typeof arg === "symbol";
}
function isUndefined(arg) {
  return arg === undefined;
}
function isRegExp(re2) {
  return isObject(re2) && objectToString(re2) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d2) {
  return isObject(d2) && objectToString(d2) === "[object Date]";
}
function isError(e2) {
  return isObject(e2) && (objectToString(e2) === "[object Error]" || e2 instanceof Error);
}
function isFunction3(arg) {
  return typeof arg === "function";
}
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg > "u";
}
function isBuffer(arg) {
  return arg instanceof Buffer;
}
function objectToString(o3) {
  return Object.prototype.toString.call(o3);
}
function pad(n2) {
  return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
}
function timestamp() {
  var d2 = new Date, time = [pad(d2.getHours()), pad(d2.getMinutes()), pad(d2.getSeconds())].join(":");
  return [d2.getDate(), months[d2.getMonth()], time].join(" ");
}
function log4(...args) {
  console.log("%s - %s", timestamp(), format.apply(null, args));
}
function inherits(ctor, superCtor) {
  if (superCtor)
    ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
}
function _extend(origin, add) {
  if (!add || !isObject(add))
    return origin;
  var keys = Object.keys(add), i4 = keys.length;
  while (i4--)
    origin[keys[i4]] = add[keys[i4]];
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function callbackifyOnRejected(reason, cb) {
  if (!reason) {
    var newReason = Error("Promise was rejected with a falsy value");
    newReason.reason = reason, reason = newReason;
  }
  return cb(reason);
}
function callbackify(original) {
  if (typeof original !== "function")
    throw TypeError('The "original" argument must be of type Function');
  function callbackified(...args) {
    var maybeCb = args.pop();
    if (typeof maybeCb !== "function")
      throw TypeError("The last argument must be of type Function");
    var self2 = this, cb = function(...args2) {
      return maybeCb.apply(self2, ...args2);
    };
    original.apply(this, args).then(function(ret) {
      process.nextTick(cb.bind(null, null, ret));
    }, function(rej) {
      process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
    });
  }
  return Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original)), Object.defineProperties(callbackified, Object.getOwnPropertyDescriptors(original)), callbackified;
}
var formatRegExp, debuglog, inspect, types2 = () => {}, months, promisify, TextEncoder, TextDecoder, util_default;
var init_util = __esm(() => {
  formatRegExp = /%[sdj%]/g;
  debuglog = ((debugs = {}, debugEnvRegex = {}, debugEnv) => ((debugEnv = typeof process < "u" && false) && (debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase()), debugEnvRegex = new RegExp("^" + debugEnv + "$", "i"), (set) => {
    if (set = set.toUpperCase(), !debugs[set])
      if (debugEnvRegex.test(set))
        debugs[set] = function(...args) {
          console.error("%s: %s", set, pid, format.apply(null, ...args));
        };
      else
        debugs[set] = function() {};
    return debugs[set];
  }))();
  inspect = ((i4) => (i4.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, i4.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, i4.custom = Symbol.for("nodejs.util.inspect.custom"), i4))(function(obj, opts, ...rest) {
    var ctx = { seen: [], stylize: stylizeNoColor };
    if (rest.length >= 1)
      ctx.depth = rest[0];
    if (rest.length >= 2)
      ctx.colors = rest[1];
    if (isBoolean(opts))
      ctx.showHidden = opts;
    else if (opts)
      _extend(ctx, opts);
    if (isUndefined(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined(ctx.depth))
      ctx.depth = 2;
    if (isUndefined(ctx.colors))
      ctx.colors = false;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  });
  months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  promisify = ((x3) => (x3.custom = Symbol.for("nodejs.util.promisify.custom"), x3))(function(original) {
    if (typeof original !== "function")
      throw TypeError('The "original" argument must be of type Function');
    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
      var fn = original[kCustomPromisifiedSymbol];
      if (typeof fn !== "function")
        throw TypeError('The "nodejs.util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(fn, kCustomPromisifiedSymbol, { value: fn, enumerable: false, writable: false, configurable: true }), fn;
    }
    function fn(...args) {
      var promiseResolve, promiseReject, promise = new Promise(function(resolve, reject) {
        promiseResolve = resolve, promiseReject = reject;
      });
      args.push(function(err, value) {
        if (err)
          promiseReject(err);
        else
          promiseResolve(value);
      });
      try {
        original.apply(this, args);
      } catch (err) {
        promiseReject(err);
      }
      return promise;
    }
    if (Object.setPrototypeOf(fn, Object.getPrototypeOf(original)), kCustomPromisifiedSymbol)
      Object.defineProperty(fn, kCustomPromisifiedSymbol, { value: fn, enumerable: false, writable: false, configurable: true });
    return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(original));
  });
  ({ TextEncoder, TextDecoder } = globalThis);
  util_default = { TextEncoder, TextDecoder, promisify, log: log4, inherits, _extend, callbackifyOnRejected, callbackify };
});

// node:url
var exports_url = {};
__export(exports_url, {
  resolveObject: () => urlResolveObject,
  resolve: () => urlResolve,
  parse: () => urlParse,
  format: () => urlFormat,
  default: () => url_default,
  Url: () => Url,
  URLSearchParams: () => URLSearchParams,
  URL: () => URL2
});
function util_isString(arg) {
  return typeof arg === "string";
}
function util_isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function util_isNull(arg) {
  return arg === null;
}
function util_isNullOrUndefined(arg) {
  return arg == null;
}
function Url() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util_isObject(url) && url instanceof Url)
    return url;
  var u2 = new Url;
  return u2.parse(url, parseQueryString, slashesDenoteHost), u2;
}
function urlFormat(obj) {
  if (util_isString(obj))
    obj = urlParse(obj);
  if (!(obj instanceof Url))
    return Url.prototype.format.call(obj);
  return obj.format();
}
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
function urlResolveObject(source, relative) {
  if (!source)
    return relative;
  return urlParse(source, false, true).resolveObject(relative);
}
var URL2, URLSearchParams, protocolPattern, portPattern, simplePathPattern, delims, unwise, autoEscape, nonHostChars, hostEndingChars, hostnameMaxLen = 255, hostnamePartPattern, hostnamePartStart, unsafeProtocol, hostlessProtocol, slashedProtocol, querystring, url_default;
var init_url = __esm(() => {
  ({ URL: URL2, URLSearchParams } = globalThis);
  protocolPattern = /^([a-z0-9.+-]+:)/i;
  portPattern = /:[0-9]*$/;
  simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
  delims = ["<", ">", '"', "`", " ", "\r", `
`, "\t"];
  unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
  autoEscape = ["'"].concat(unwise);
  nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
  hostEndingChars = ["/", "?", "#"];
  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
  unsafeProtocol = { javascript: true, "javascript:": true };
  hostlessProtocol = { javascript: true, "javascript:": true };
  slashedProtocol = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
  querystring = { parse(str) {
    var decode = decodeURIComponent;
    return (str + "").replace(/\+/g, " ").split("&").filter(Boolean).reduce(function(obj, item, index2) {
      var ref = item.split("="), key = decode(ref[0] || ""), val = decode(ref[1] || ""), prev = obj[key];
      return obj[key] = prev === undefined ? val : [].concat(prev, val), obj;
    }, {});
  }, stringify(obj) {
    var encode = encodeURIComponent;
    return Object.keys(obj || {}).reduce(function(arr, key) {
      return [].concat(obj[key]).forEach(function(v2) {
        arr.push(encode(key) + "=" + encode(v2));
      }), arr;
    }, []).join("&").replace(/\s/g, "+");
  } };
  Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
    if (!util_isString(url))
      throw TypeError("Parameter 'url' must be a string, not " + typeof url);
    var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
    uSplit[0] = uSplit[0].replace(slashRegex, "/"), url = uSplit.join(splitter);
    var rest = url;
    if (rest = rest.trim(), !slashesDenoteHost && url.split("#").length === 1) {
      var simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        if (this.path = rest, this.href = rest, this.pathname = simplePath[1], simplePath[2])
          if (this.search = simplePath[2], parseQueryString)
            this.query = querystring.parse(this.search.substr(1));
          else
            this.query = this.search.substr(1);
        else if (parseQueryString)
          this.search = "", this.query = {};
        return this;
      }
    }
    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      var lowerProto = proto.toLowerCase();
      this.protocol = lowerProto, rest = rest.substr(proto.length);
    }
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var slashes = rest.substr(0, 2) === "//";
      if (slashes && !(proto && hostlessProtocol[proto]))
        rest = rest.substr(2), this.slashes = true;
    }
    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
      var hostEnd = -1;
      for (var i4 = 0;i4 < hostEndingChars.length; i4++) {
        var hec = rest.indexOf(hostEndingChars[i4]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      var auth, atSign;
      if (hostEnd === -1)
        atSign = rest.lastIndexOf("@");
      else
        atSign = rest.lastIndexOf("@", hostEnd);
      if (atSign !== -1)
        auth = rest.slice(0, atSign), rest = rest.slice(atSign + 1), this.auth = decodeURIComponent(auth);
      hostEnd = -1;
      for (var i4 = 0;i4 < nonHostChars.length; i4++) {
        var hec = rest.indexOf(nonHostChars[i4]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      if (hostEnd === -1)
        hostEnd = rest.length;
      this.host = rest.slice(0, hostEnd), rest = rest.slice(hostEnd), this.parseHost(), this.hostname = this.hostname || "";
      var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!ipv6Hostname) {
        var hostparts = this.hostname.split(/\./);
        for (var i4 = 0, l4 = hostparts.length;i4 < l4; i4++) {
          var part = hostparts[i4];
          if (!part)
            continue;
          if (!part.match(hostnamePartPattern)) {
            var newpart = "";
            for (var j = 0, k2 = part.length;j < k2; j++)
              if (part.charCodeAt(j) > 127)
                newpart += "x";
              else
                newpart += part[j];
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i4), notHost = hostparts.slice(i4 + 1), bit = part.match(hostnamePartStart);
              if (bit)
                validParts.push(bit[1]), notHost.unshift(bit[2]);
              if (notHost.length)
                rest = "/" + notHost.join(".") + rest;
              this.hostname = validParts.join(".");
              break;
            }
          }
        }
      }
      if (this.hostname.length > hostnameMaxLen)
        this.hostname = "";
      else
        this.hostname = this.hostname.toLowerCase();
      if (!ipv6Hostname)
        this.hostname = new URL2(`https://${this.hostname}`).hostname;
      var p3 = this.port ? ":" + this.port : "", h3 = this.hostname || "";
      if (this.host = h3 + p3, this.href += this.host, ipv6Hostname) {
        if (this.hostname = this.hostname.substr(1, this.hostname.length - 2), rest[0] !== "/")
          rest = "/" + rest;
      }
    }
    if (!unsafeProtocol[lowerProto])
      for (var i4 = 0, l4 = autoEscape.length;i4 < l4; i4++) {
        var ae2 = autoEscape[i4];
        if (rest.indexOf(ae2) === -1)
          continue;
        var esc = encodeURIComponent(ae2);
        if (esc === ae2)
          esc = escape(ae2);
        rest = rest.split(ae2).join(esc);
      }
    var hash = rest.indexOf("#");
    if (hash !== -1)
      this.hash = rest.substr(hash), rest = rest.slice(0, hash);
    var qm = rest.indexOf("?");
    if (qm !== -1) {
      if (this.search = rest.substr(qm), this.query = rest.substr(qm + 1), parseQueryString)
        this.query = querystring.parse(this.query);
      rest = rest.slice(0, qm);
    } else if (parseQueryString)
      this.search = "", this.query = {};
    if (rest)
      this.pathname = rest;
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname)
      this.pathname = "/";
    if (this.pathname || this.search) {
      var p3 = this.pathname || "", s2 = this.search || "";
      this.path = p3 + s2;
    }
    return this.href = this.format(), this;
  };
  Url.prototype.format = function() {
    var auth = this.auth || "";
    if (auth)
      auth = encodeURIComponent(auth), auth = auth.replace(/%3A/i, ":"), auth += "@";
    var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
    if (this.host)
      host = auth + this.host;
    else if (this.hostname) {
      if (host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port)
        host += ":" + this.port;
    }
    if (this.query && util_isObject(this.query) && Object.keys(this.query).length)
      query = querystring.stringify(this.query);
    var search = this.search || query && "?" + query || "";
    if (protocol && protocol.substr(-1) !== ":")
      protocol += ":";
    if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
      if (host = "//" + (host || ""), pathname && pathname.charAt(0) !== "/")
        pathname = "/" + pathname;
    } else if (!host)
      host = "";
    if (hash && hash.charAt(0) !== "#")
      hash = "#" + hash;
    if (search && search.charAt(0) !== "?")
      search = "?" + search;
    return pathname = pathname.replace(/[?#]/g, function(match) {
      return encodeURIComponent(match);
    }), search = search.replace("#", "%23"), protocol + host + pathname + search + hash;
  };
  Url.prototype.resolve = function(relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
  };
  Url.prototype.resolveObject = function(relative) {
    if (util_isString(relative)) {
      var rel = new Url;
      rel.parse(relative, false, true), relative = rel;
    }
    var result = new Url, tkeys = Object.keys(this);
    for (var tk = 0;tk < tkeys.length; tk++) {
      var tkey = tkeys[tk];
      result[tkey] = this[tkey];
    }
    if (result.hash = relative.hash, relative.href === "")
      return result.href = result.format(), result;
    if (relative.slashes && !relative.protocol) {
      var rkeys = Object.keys(relative);
      for (var rk = 0;rk < rkeys.length; rk++) {
        var rkey = rkeys[rk];
        if (rkey !== "protocol")
          result[rkey] = relative[rkey];
      }
      if (slashedProtocol[result.protocol] && result.hostname && !result.pathname)
        result.path = result.pathname = "/";
      return result.href = result.format(), result;
    }
    if (relative.protocol && relative.protocol !== result.protocol) {
      if (!slashedProtocol[relative.protocol]) {
        var keys = Object.keys(relative);
        for (var v2 = 0;v2 < keys.length; v2++) {
          var k2 = keys[v2];
          result[k2] = relative[k2];
        }
        return result.href = result.format(), result;
      }
      if (result.protocol = relative.protocol, !relative.host && !hostlessProtocol[relative.protocol]) {
        var relPath = (relative.pathname || "").split("/");
        while (relPath.length && !(relative.host = relPath.shift()))
          ;
        if (!relative.host)
          relative.host = "";
        if (!relative.hostname)
          relative.hostname = "";
        if (relPath[0] !== "")
          relPath.unshift("");
        if (relPath.length < 2)
          relPath.unshift("");
        result.pathname = relPath.join("/");
      } else
        result.pathname = relative.pathname;
      if (result.search = relative.search, result.query = relative.query, result.host = relative.host || "", result.auth = relative.auth, result.hostname = relative.hostname || relative.host, result.port = relative.port, result.pathname || result.search) {
        var p3 = result.pathname || "", s2 = result.search || "";
        result.path = p3 + s2;
      }
      return result.slashes = result.slashes || relative.slashes, result.href = result.format(), result;
    }
    var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
    if (psychotic) {
      if (result.hostname = "", result.port = null, result.host)
        if (srcPath[0] === "")
          srcPath[0] = result.host;
        else
          srcPath.unshift(result.host);
      if (result.host = "", relative.protocol) {
        if (relative.hostname = null, relative.port = null, relative.host)
          if (relPath[0] === "")
            relPath[0] = relative.host;
          else
            relPath.unshift(relative.host);
        relative.host = null;
      }
      mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs)
      result.host = relative.host || relative.host === "" ? relative.host : result.host, result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname, result.search = relative.search, result.query = relative.query, srcPath = relPath;
    else if (relPath.length) {
      if (!srcPath)
        srcPath = [];
      srcPath.pop(), srcPath = srcPath.concat(relPath), result.search = relative.search, result.query = relative.query;
    } else if (!util_isNullOrUndefined(relative.search)) {
      if (psychotic) {
        result.hostname = result.host = srcPath.shift();
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost)
          result.auth = authInHost.shift(), result.host = result.hostname = authInHost.shift();
      }
      if (result.search = relative.search, result.query = relative.query, !util_isNull(result.pathname) || !util_isNull(result.search))
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      return result.href = result.format(), result;
    }
    if (!srcPath.length) {
      if (result.pathname = null, result.search)
        result.path = "/" + result.search;
      else
        result.path = null;
      return result.href = result.format(), result;
    }
    var last = srcPath.slice(-1)[0], hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "", up = 0;
    for (var i4 = srcPath.length;i4 >= 0; i4--)
      if (last = srcPath[i4], last === ".")
        srcPath.splice(i4, 1);
      else if (last === "..")
        srcPath.splice(i4, 1), up++;
      else if (up)
        srcPath.splice(i4, 1), up--;
    if (!mustEndAbs && !removeAllDots)
      for (;up--; up)
        srcPath.unshift("..");
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/"))
      srcPath.unshift("");
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/")
      srcPath.push("");
    var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
    if (psychotic) {
      result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost)
        result.auth = authInHost.shift(), result.host = result.hostname = authInHost.shift();
    }
    if (mustEndAbs = mustEndAbs || result.host && srcPath.length, mustEndAbs && !isAbsolute)
      srcPath.unshift("");
    if (!srcPath.length)
      result.pathname = null, result.path = null;
    else
      result.pathname = srcPath.join("/");
    if (!util_isNull(result.pathname) || !util_isNull(result.search))
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    return result.auth = relative.auth || result.auth, result.slashes = result.slashes || relative.slashes, result.href = result.format(), result;
  };
  Url.prototype.parseHost = function() {
    var host = this.host, port = portPattern.exec(host);
    if (port) {
      if (port = port[0], port !== ":")
        this.port = port.substr(1);
      host = host.substr(0, host.length - port.length);
    }
    if (host)
      this.hostname = host;
  };
  url_default = { parse: urlParse, resolve: urlResolve, resolveObject: urlResolveObject, format: urlFormat, Url, URL: URL2, URLSearchParams };
});

// node:http
var exports_http = {};
__export(exports_http, {
  request: () => request,
  globalAgent: () => globalAgent,
  get: () => get,
  default: () => http_default,
  STATUS_CODES: () => STATUS_CODES,
  METHODS: () => METHODS,
  IncomingMessage: () => IncomingMessage,
  ClientRequest: () => ClientRequest,
  Agent: () => Agent
});
var __create2, __getProtoOf2, __defProp2, __getOwnPropNames2, __hasOwnProp2, __toESM2 = (mod, isNodeMode, target) => {
  target = mod != null ? __create2(__getProtoOf2(mod)) : {};
  let to = isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames2(mod))
    if (!__hasOwnProp2.call(to, key))
      __defProp2(to, key, { get: () => mod[key], enumerable: true });
  return to;
}, __commonJS2 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports), require_capability, require_inherits_browser, require_inherits, require_buffer_list, require_destroy, require_errors, require_state, require_node, require__stream_writable, require__stream_duplex, require_safe_buffer, require_string_decoder, require_end_of_stream, require_async_iterator, require_from, require__stream_readable, require__stream_transform, require__stream_passthrough, require_pipeline, require_readable, require_response, require_request, require_immutable, require_builtin_status_codes, require_stream_http, import_stream_http, request, get, ClientRequest, IncomingMessage, Agent, globalAgent, STATUS_CODES, METHODS, http_default;
var init_http = __esm(() => {
  __create2 = Object.create;
  ({ getPrototypeOf: __getProtoOf2, defineProperty: __defProp2, getOwnPropertyNames: __getOwnPropNames2 } = Object);
  __hasOwnProp2 = Object.prototype.hasOwnProperty;
  require_capability = __commonJS2((exports) => {
    exports.fetch = isFunction4(globalThis.fetch) && isFunction4(globalThis.ReadableStream);
    exports.writableStream = isFunction4(globalThis.WritableStream);
    exports.abortController = isFunction4(globalThis.AbortController);
    var xhr;
    function getXHR() {
      if (xhr !== undefined)
        return xhr;
      if (globalThis.XMLHttpRequest) {
        xhr = new globalThis.XMLHttpRequest;
        try {
          xhr.open("GET", globalThis.XDomainRequest ? "/" : "https://example.com");
        } catch (e2) {
          xhr = null;
        }
      } else
        xhr = null;
      return xhr;
    }
    function checkTypeSupport(type) {
      var xhr2 = getXHR();
      if (!xhr2)
        return false;
      try {
        return xhr2.responseType = type, xhr2.responseType === type;
      } catch (e2) {}
      return false;
    }
    exports.arraybuffer = exports.fetch || checkTypeSupport("arraybuffer");
    exports.msstream = !exports.fetch && checkTypeSupport("ms-stream");
    exports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport("moz-chunked-arraybuffer");
    exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction4(getXHR().overrideMimeType) : false);
    function isFunction4(value) {
      return typeof value === "function";
    }
    xhr = null;
  });
  require_inherits_browser = __commonJS2((exports, module) => {
    if (typeof Object.create === "function")
      module.exports = function(ctor, superCtor) {
        if (superCtor)
          ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
      };
    else
      module.exports = function(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {};
          TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
        }
      };
  });
  require_inherits = __commonJS2((exports, module) => {
    try {
      if (util3 = (init_util(), __toCommonJS(exports_util)), typeof util3.inherits !== "function")
        throw "";
      module.exports = util3.inherits;
    } catch (e2) {
      module.exports = require_inherits_browser();
    }
    var util3;
  });
  require_buffer_list = __commonJS2((exports, module) => {
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i4 = 1;i4 < arguments.length; i4++) {
        var source = arguments[i4] != null ? arguments[i4] : {};
        i4 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key = _toPropertyKey(key), key in obj)
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      else
        obj[key] = value;
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i4 = 0;i4 < props.length; i4++) {
        var descriptor = props[i4];
        if (descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Object.defineProperty(Constructor, "prototype", { writable: false }), Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = (init_buffer(), __toCommonJS(exports_buffer)), Buffer22 = _require.Buffer, _require2 = (init_util(), __toCommonJS(exports_util)), inspect2 = _require2.inspect, custom2 = inspect2 && inspect2.custom || "inspect";
    function copyBuffer(src, target, offset4) {
      Buffer22.prototype.copy.call(src, target, offset4);
    }
    module.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList), this.head = null, this.tail = null, this.length = 0;
      }
      return _createClass(BufferList, [{ key: "push", value: function(v2) {
        var entry = { data: v2, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry, ++this.length;
      } }, { key: "unshift", value: function(v2) {
        var entry = { data: v2, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        return --this.length, ret;
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(s2) {
        if (this.length === 0)
          return "";
        var p3 = this.head, ret = "" + p3.data;
        while (p3 = p3.next)
          ret += s2 + p3.data;
        return ret;
      } }, { key: "concat", value: function(n2) {
        if (this.length === 0)
          return Buffer22.alloc(0);
        var ret = Buffer22.allocUnsafe(n2 >>> 0), p3 = this.head, i4 = 0;
        while (p3)
          copyBuffer(p3.data, ret, i4), i4 += p3.data.length, p3 = p3.next;
        return ret;
      } }, { key: "consume", value: function(n2, hasStrings) {
        var ret;
        if (n2 < this.head.data.length)
          ret = this.head.data.slice(0, n2), this.head.data = this.head.data.slice(n2);
        else if (n2 === this.head.data.length)
          ret = this.shift();
        else
          ret = hasStrings ? this._getString(n2) : this._getBuffer(n2);
        return ret;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(n2) {
        var p3 = this.head, c3 = 1, ret = p3.data;
        n2 -= ret.length;
        while (p3 = p3.next) {
          var str = p3.data, nb = n2 > str.length ? str.length : n2;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n2);
          if (n2 -= nb, n2 === 0) {
            if (nb === str.length)
              if (++c3, p3.next)
                this.head = p3.next;
              else
                this.head = this.tail = null;
            else
              this.head = p3, p3.data = str.slice(nb);
            break;
          }
          ++c3;
        }
        return this.length -= c3, ret;
      } }, { key: "_getBuffer", value: function(n2) {
        var ret = Buffer22.allocUnsafe(n2), p3 = this.head, c3 = 1;
        p3.data.copy(ret), n2 -= p3.data.length;
        while (p3 = p3.next) {
          var buf = p3.data, nb = n2 > buf.length ? buf.length : n2;
          if (buf.copy(ret, ret.length - n2, 0, nb), n2 -= nb, n2 === 0) {
            if (nb === buf.length)
              if (++c3, p3.next)
                this.head = p3.next;
              else
                this.head = this.tail = null;
            else
              this.head = p3, p3.data = buf.slice(nb);
            break;
          }
          ++c3;
        }
        return this.length -= c3, ret;
      } }, { key: custom2, value: function(_2, options2) {
        return inspect2(this, _objectSpread(_objectSpread({}, options2), {}, { depth: 0, customInspect: false }));
      } }]), BufferList;
    }();
  });
  require_destroy = __commonJS2((exports, module) => {
    function destroy(err, cb) {
      var _this = this, readableDestroyed = this._readableState && this._readableState.destroyed, writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb)
          cb(err);
        else if (err) {
          if (!this._writableState)
            process.nextTick(emitErrorNT, this, err);
          else if (!this._writableState.errorEmitted)
            this._writableState.errorEmitted = true, process.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState)
        this._readableState.destroyed = true;
      if (this._writableState)
        this._writableState.destroyed = true;
      return this._destroy(err || null, function(err2) {
        if (!cb && err2)
          if (!_this._writableState)
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          else if (!_this._writableState.errorEmitted)
            _this._writableState.errorEmitted = true, process.nextTick(emitErrorAndCloseNT, _this, err2);
          else
            process.nextTick(emitCloseNT, _this);
        else if (cb)
          process.nextTick(emitCloseNT, _this), cb(err2);
        else
          process.nextTick(emitCloseNT, _this);
      }), this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err), emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState)
        this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false;
      if (this._writableState)
        this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false;
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var { _readableState: rState, _writableState: wState } = stream;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module.exports = { destroy, undestroy, errorOrDestroy };
  });
  require_errors = __commonJS2((exports, module) => {
    var codes = {};
    function createErrorType(code2, message, Base) {
      if (!Base)
        Base = Error;
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string")
          return message;
        else
          return message(arg1, arg2, arg3);
      }

      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name, NodeError.prototype.code = code2, codes[code2] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        let len2 = expected.length;
        if (expected = expected.map((i4) => String(i4)), len2 > 2)
          return `one of ${thing} ${expected.slice(0, len2 - 1).join(", ")}, or ` + expected[len2 - 1];
        else if (len2 === 2)
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        else
          return `of ${thing} ${expected[0]}`;
      } else
        return `of ${thing} ${String(expected)}`;
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === undefined || this_len > str.length)
        this_len = str.length;
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number")
        start = 0;
      if (start + search.length > str.length)
        return false;
      else
        return str.indexOf(search, start) !== -1;
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not "))
        determiner = "must not be", expected = expected.replace(/^not /, "");
      else
        determiner = "must be";
      let msg;
      if (endsWith(name, " argument"))
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      else {
        let type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      return msg += `. Received type ${typeof actual}`, msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    exports.codes = codes;
  });
  require_state = __commonJS2((exports, module) => {
    var ERR_INVALID_OPT_VALUE = require_errors().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options2, isDuplex, duplexKey) {
      return options2.highWaterMark != null ? options2.highWaterMark : isDuplex ? options2[duplexKey] : null;
    }
    function getHighWaterMark(state, options2, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options2, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16384;
    }
    module.exports = { getHighWaterMark };
  });
  require_node = __commonJS2((exports, module) => {
    module.exports = (init_util(), __toCommonJS(exports_util)).deprecate;
  });
  require__stream_writable = __commonJS2((exports, module) => {
    module.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null, this.entry = null, this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = { deprecate: require_node() }, Stream = require_stream(), Buffer22 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer, OurUint8Array = (typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {};
    function _uint8ArrayToBuffer(chunk) {
      return Buffer22.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer22.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy(), _require = require_state(), getHighWaterMark = _require.getHighWaterMark, _require$codes = require_errors().codes, ERR_INVALID_ARG_TYPE3 = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING, errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {}
    function WritableState(options2, stream, isDuplex) {
      if (Duplex = Duplex || require__stream_duplex(), options2 = options2 || {}, typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      if (this.objectMode = !!options2.objectMode, isDuplex)
        this.objectMode = this.objectMode || !!options2.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options2, "writableHighWaterMark", isDuplex), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var noDecode = options2.decodeStrings === false;
      this.decodeStrings = !noDecode, this.defaultEncoding = options2.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(er) {
        onwrite(stream, er);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = options2.emitClose !== false, this.autoDestroy = !!options2.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function() {
      var current = this.bufferedRequest, out = [];
      while (current)
        out.push(current), current = current.next;
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", { get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch (_2) {}
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function")
      realHasInstance = Function.prototype[Symbol.hasInstance], Object.defineProperty(Writable, Symbol.hasInstance, { value: function(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      } });
    else
      realHasInstance = function(object) {
        return object instanceof this;
      };
    function Writable(options2) {
      Duplex = Duplex || require__stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options2);
      if (this._writableState = new WritableState(options2, this, isDuplex), this.writable = true, options2) {
        if (typeof options2.write === "function")
          this._write = options2.write;
        if (typeof options2.writev === "function")
          this._writev = options2.writev;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
        if (typeof options2.final === "function")
          this._final = options2.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END;
      errorOrDestroy(stream, er), process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null)
        er = new ERR_STREAM_NULL_VALUES;
      else if (typeof chunk !== "string" && !state.objectMode)
        er = new ERR_INVALID_ARG_TYPE3("chunk", ["string", "Buffer"], chunk);
      if (er)
        return errorOrDestroy(stream, er), process.nextTick(cb, er), false;
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState, ret = false, isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer22.isBuffer(chunk))
        chunk = _uint8ArrayToBuffer(chunk);
      if (typeof encoding === "function")
        cb = encoding, encoding = null;
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb))
        state.pendingcb++, ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        if (state.corked--, !state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      return this._writableState.defaultEncoding = encoding, this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string")
        chunk = Buffer22.from(chunk, encoding);
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk)
          isBuf = true, encoding = "buffer", chunk = newChunk;
      }
      var len2 = state.objectMode ? 1 : chunk.length;
      state.length += len2;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        if (state.lastBufferedRequest = { chunk, encoding, isBuf, callback: cb, next: null }, last)
          last.next = state.lastBufferedRequest;
        else
          state.bufferedRequest = state.lastBufferedRequest;
        state.bufferedRequestCount += 1;
      } else
        doWrite(stream, state, false, len2, chunk, encoding, cb);
      return ret;
    }
    function doWrite(stream, state, writev, len2, chunk, encoding, cb) {
      if (state.writelen = len2, state.writecb = cb, state.writing = true, state.sync = true, state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      if (--state.pendingcb, sync)
        process.nextTick(cb, er), process.nextTick(finishMaybe, stream, state), stream._writableState.errorEmitted = true, errorOrDestroy(stream, er);
      else
        cb(er), stream._writableState.errorEmitted = true, errorOrDestroy(stream, er), finishMaybe(stream, state);
    }
    function onwriteStateUpdate(state) {
      state.writing = false, state.writecb = null, state.length -= state.writelen, state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState, sync = state.sync, cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK;
      if (onwriteStateUpdate(state), er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(stream, state);
        if (sync)
          process.nextTick(afterWrite, stream, state, finished, cb);
        else
          afterWrite(stream, state, finished, cb);
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--, cb(), finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain)
        state.needDrain = false, stream.emit("drain");
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l4 = state.bufferedRequestCount, buffer = Array(l4), holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count4 = 0, allBuffers = true;
        while (entry) {
          if (buffer[count4] = entry, !entry.isBuf)
            allBuffers = false;
          entry = entry.next, count4 += 1;
        }
        if (buffer.allBuffers = allBuffers, doWrite(stream, state, true, state.length, buffer, "", holder.finish), state.pendingcb++, state.lastBufferedRequest = null, holder.next)
          state.corkedRequestsFree = holder.next, holder.next = null;
        else
          state.corkedRequestsFree = new CorkedRequest(state);
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var { chunk, encoding, callback: cb } = entry, len2 = state.objectMode ? 1 : chunk.length;
          if (doWrite(stream, state, false, len2, chunk, encoding, cb), entry = entry.next, state.bufferedRequestCount--, state.writing)
            break;
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry, state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function")
        cb = chunk, chunk = null, encoding = null;
      else if (typeof encoding === "function")
        cb = encoding, encoding = null;
      if (chunk !== null && chunk !== undefined)
        this.write(chunk, encoding);
      if (state.corked)
        state.corked = 1, this.uncork();
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        if (state.pendingcb--, err)
          errorOrDestroy(stream, err);
        state.prefinished = true, stream.emit("prefinish"), finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled)
        if (typeof stream._final === "function" && !state.destroyed)
          state.pendingcb++, state.finalCalled = true, process.nextTick(callFinal, stream, state);
        else
          state.prefinished = true, stream.emit("prefinish");
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        if (prefinish(stream, state), state.pendingcb === 0) {
          if (state.finished = true, stream.emit("finish"), state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted)
              stream.destroy();
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      if (state.ending = true, finishMaybe(stream, state), cb)
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      state.ended = true, stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--, cb(err), entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", { enumerable: false, get: function() {
      if (this._writableState === undefined)
        return false;
      return this._writableState.destroyed;
    }, set: function(value) {
      if (!this._writableState)
        return;
      this._writableState.destroyed = value;
    } });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  });
  require__stream_duplex = __commonJS2((exports, module) => {
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    module.exports = Duplex;
    var Readable = require__stream_readable(), Writable = require__stream_writable();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v2 = 0;v2 < keys.length; v2++)
        if (method = keys[v2], !Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
    }
    var keys, method, v2;
    function Duplex(options2) {
      if (!(this instanceof Duplex))
        return new Duplex(options2);
      if (Readable.call(this, options2), Writable.call(this, options2), this.allowHalfOpen = true, options2) {
        if (options2.readable === false)
          this.readable = false;
        if (options2.writable === false)
          this.writable = false;
        if (options2.allowHalfOpen === false)
          this.allowHalfOpen = false, this.once("end", onend);
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty(Duplex.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty(Duplex.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", { enumerable: false, get: function() {
      if (this._readableState === undefined || this._writableState === undefined)
        return false;
      return this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(value) {
      if (this._readableState === undefined || this._writableState === undefined)
        return;
      this._readableState.destroyed = value, this._writableState.destroyed = value;
    } });
  });
  require_safe_buffer = __commonJS2((exports, module) => {
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var buffer = (init_buffer(), __toCommonJS(exports_buffer)), Buffer22 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src)
        dst[key] = src[key];
    }
    if (Buffer22.from && Buffer22.alloc && Buffer22.allocUnsafe && Buffer22.allocUnsafeSlow)
      module.exports = buffer;
    else
      copyProps(buffer, exports), exports.Buffer = SafeBuffer;
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer22(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer22.prototype);
    copyProps(Buffer22, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number")
        throw TypeError("Argument must not be a number");
      return Buffer22(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size4, fill, encoding) {
      if (typeof size4 !== "number")
        throw TypeError("Argument must be a number");
      var buf = Buffer22(size4);
      if (fill !== undefined)
        if (typeof encoding === "string")
          buf.fill(fill, encoding);
        else
          buf.fill(fill);
      else
        buf.fill(0);
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size4) {
      if (typeof size4 !== "number")
        throw TypeError("Argument must be a number");
      return Buffer22(size4);
    };
    SafeBuffer.allocUnsafeSlow = function(size4) {
      if (typeof size4 !== "number")
        throw TypeError("Argument must be a number");
      return buffer.SlowBuffer(size4);
    };
  });
  require_string_decoder = __commonJS2((exports) => {
    var Buffer22 = require_safe_buffer().Buffer, isEncoding = Buffer22.isEncoding || function(encoding) {
      switch (encoding = "" + encoding, encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true)
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase(), retried = true;
        }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer22.isEncoding === isEncoding || !isEncoding(enc)))
        throw Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text, this.end = utf16End, nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast, nb = 4;
          break;
        case "base64":
          this.text = base64Text, this.end = base64End, nb = 3;
          break;
        default:
          this.write = simpleWrite, this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer22.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r3, i4;
      if (this.lastNeed) {
        if (r3 = this.fillLast(buf), r3 === undefined)
          return "";
        i4 = this.lastNeed, this.lastNeed = 0;
      } else
        i4 = 0;
      if (i4 < buf.length)
        return r3 ? r3 + this.text(buf, i4) : this.text(buf, i4);
      return r3 || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length)
        return buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length), this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i4) {
      var j = buf.length - 1;
      if (j < i4)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i4 || nb === -2)
        return 0;
      if (nb = utf8CheckByte(buf[j]), nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i4 || nb === -2)
        return 0;
      if (nb = utf8CheckByte(buf[j]), nb >= 0) {
        if (nb > 0)
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p3) {
      if ((buf[0] & 192) !== 128)
        return self2.lastNeed = 0, "";
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128)
          return self2.lastNeed = 1, "";
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128)
            return self2.lastNeed = 2, "";
        }
      }
    }
    function utf8FillLast(buf) {
      var p3 = this.lastTotal - this.lastNeed, r3 = utf8CheckExtraBytes(this, buf, p3);
      if (r3 !== undefined)
        return r3;
      if (this.lastNeed <= buf.length)
        return buf.copy(this.lastChar, p3, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      buf.copy(this.lastChar, p3, 0, buf.length), this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i4) {
      var total = utf8CheckIncomplete(this, buf, i4);
      if (!this.lastNeed)
        return buf.toString("utf8", i4);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      return buf.copy(this.lastChar, 0, end), buf.toString("utf8", i4, end);
    }
    function utf8End(buf) {
      var r3 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r3 + "";
      return r3;
    }
    function utf16Text(buf, i4) {
      if ((buf.length - i4) % 2 === 0) {
        var r3 = buf.toString("utf16le", i4);
        if (r3) {
          var c3 = r3.charCodeAt(r3.length - 1);
          if (c3 >= 55296 && c3 <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1], r3.slice(0, -1);
        }
        return r3;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = buf[buf.length - 1], buf.toString("utf16le", i4, buf.length - 1);
    }
    function utf16End(buf) {
      var r3 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r3 + this.lastChar.toString("utf16le", 0, end);
      }
      return r3;
    }
    function base64Text(buf, i4) {
      var n2 = (buf.length - i4) % 3;
      if (n2 === 0)
        return buf.toString("base64", i4);
      if (this.lastNeed = 3 - n2, this.lastTotal = 3, n2 === 1)
        this.lastChar[0] = buf[buf.length - 1];
      else
        this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1];
      return buf.toString("base64", i4, buf.length - n2);
    }
    function base64End(buf) {
      var r3 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r3 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r3;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  });
  require_end_of_stream = __commonJS2((exports, module) => {
    var ERR_STREAM_PREMATURE_CLOSE = require_errors().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = Array(_len), _key = 0;_key < _len; _key++)
          args[_key] = arguments[_key];
        callback.apply(this, args);
      };
    }
    function noop3() {}
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop3);
      var readable = opts.readable || opts.readable !== false && stream.readable, writable = opts.writable || opts.writable !== false && stream.writable, onlegacyfinish = function() {
        if (!stream.writable)
          onfinish();
      }, writableEnded = stream._writableState && stream._writableState.finished, onfinish = function() {
        if (writable = false, writableEnded = true, !readable)
          callback.call(stream);
      }, readableEnded = stream._readableState && stream._readableState.endEmitted, onend = function() {
        if (readable = false, readableEnded = true, !writable)
          callback.call(stream);
      }, onerror = function(err) {
        callback.call(stream, err);
      }, onclose = function() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE;
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE;
          return callback.call(stream, err);
        }
      }, onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream))
        if (stream.on("complete", onfinish), stream.on("abort", onclose), stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      else if (writable && !stream._writableState)
        stream.on("end", onlegacyfinish), stream.on("close", onlegacyfinish);
      if (stream.on("end", onend), stream.on("finish", onfinish), opts.error !== false)
        stream.on("error", onerror);
      return stream.on("close", onclose), function() {
        if (stream.removeListener("complete", onfinish), stream.removeListener("abort", onclose), stream.removeListener("request", onrequest), stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish), stream.removeListener("close", onlegacyfinish), stream.removeListener("finish", onfinish), stream.removeListener("end", onend), stream.removeListener("error", onerror), stream.removeListener("close", onclose);
      };
    }
    module.exports = eos;
  });
  require_async_iterator = __commonJS2((exports, module) => {
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      if (key = _toPropertyKey(key), key in obj)
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      else
        obj[key] = value;
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream(), kLastResolve = Symbol("lastResolve"), kLastReject = Symbol("lastReject"), kError = Symbol("error"), kEnded = Symbol("ended"), kLastPromise = Symbol("lastPromise"), kHandlePromise = Symbol("handlePromise"), kStream = Symbol("stream");
    function createIterResult(value, done) {
      return { value, done };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null)
          iter[kLastPromise] = null, iter[kLastResolve] = null, iter[kLastReject] = null, resolve(createIterResult(data, false));
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(undefined, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {}), ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = { get stream() {
      return this[kStream];
    }, next: function() {
      var _this = this, error = this[kError];
      if (error !== null)
        return Promise.reject(error);
      if (this[kEnded])
        return Promise.resolve(createIterResult(undefined, true));
      if (this[kStream].destroyed)
        return new Promise(function(resolve, reject) {
          process.nextTick(function() {
            if (_this[kError])
              reject(_this[kError]);
            else
              resolve(createIterResult(undefined, true));
          });
        });
      var lastPromise = this[kLastPromise], promise;
      if (lastPromise)
        promise = new Promise(wrapForNext(lastPromise, this));
      else {
        var data = this[kStream].read();
        if (data !== null)
          return Promise.resolve(createIterResult(data, false));
        promise = new Promise(this[kHandlePromise]);
      }
      return this[kLastPromise] = promise, promise;
    } }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(undefined, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype), createReadableStreamAsyncIterator = function(stream) {
      var _Object$create, iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, { value: stream, writable: true }), _defineProperty(_Object$create, kLastResolve, { value: null, writable: true }), _defineProperty(_Object$create, kLastReject, { value: null, writable: true }), _defineProperty(_Object$create, kError, { value: null, writable: true }), _defineProperty(_Object$create, kEnded, { value: stream._readableState.endEmitted, writable: true }), _defineProperty(_Object$create, kHandlePromise, { value: function(resolve, reject) {
        var data = iterator[kStream].read();
        if (data)
          iterator[kLastPromise] = null, iterator[kLastResolve] = null, iterator[kLastReject] = null, resolve(createIterResult(data, false));
        else
          iterator[kLastResolve] = resolve, iterator[kLastReject] = reject;
      }, writable: true }), _Object$create));
      return iterator[kLastPromise] = null, finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null)
            iterator[kLastPromise] = null, iterator[kLastResolve] = null, iterator[kLastReject] = null, reject(err);
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null)
          iterator[kLastPromise] = null, iterator[kLastResolve] = null, iterator[kLastReject] = null, resolve(createIterResult(undefined, true));
        iterator[kEnded] = true;
      }), stream.on("readable", onReadable.bind(null, iterator)), iterator;
    };
    module.exports = createReadableStreamAsyncIterator;
  });
  require_from = __commonJS2((exports, module) => {
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg), value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done)
        resolve(value);
      else
        Promise.resolve(value).then(_next, _throw);
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(undefined);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i4 = 1;i4 < arguments.length; i4++) {
        var source = arguments[i4] != null ? arguments[i4] : {};
        i4 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key = _toPropertyKey(key), key in obj)
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      else
        obj[key] = value;
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE3 = require_errors().codes.ERR_INVALID_ARG_TYPE;
    function from2(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function")
        iterator = iterable;
      else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE3("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({ objectMode: true }, opts)), reading = false;
      readable._read = function() {
        if (!reading)
          reading = true, next();
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        return _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done)
              readable.push(null);
            else if (readable.push(yield value))
              next();
            else
              reading = false;
          } catch (err) {
            readable.destroy(err);
          }
        }), _next2.apply(this, arguments);
      }
      return readable;
    }
    module.exports = from2;
  });
  require__stream_readable = __commonJS2((exports, module) => {
    module.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = (init_events(), __toCommonJS(exports_events)).EventEmitter, EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    }, Stream = require_stream(), Buffer22 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer, OurUint8Array = (typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {};
    function _uint8ArrayToBuffer(chunk) {
      return Buffer22.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer22.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = (init_util(), __toCommonJS(exports_util)), debug2;
    if (debugUtil && debugUtil.debuglog)
      debug2 = debugUtil.debuglog("stream");
    else
      debug2 = function() {};
    var BufferList = require_buffer_list(), destroyImpl = require_destroy(), _require = require_state(), getHighWaterMark = _require.getHighWaterMark, _require$codes = require_errors().codes, ERR_INVALID_ARG_TYPE3 = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, StringDecoder, createReadableStreamAsyncIterator, from2;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy, kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options2, stream, isDuplex) {
      if (Duplex = Duplex || require__stream_duplex(), options2 = options2 || {}, typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      if (this.objectMode = !!options2.objectMode, isDuplex)
        this.objectMode = this.objectMode || !!options2.readableObjectMode;
      if (this.highWaterMark = getHighWaterMark(this, options2, "readableHighWaterMark", isDuplex), this.buffer = new BufferList, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = options2.emitClose !== false, this.autoDestroy = !!options2.autoDestroy, this.destroyed = false, this.defaultEncoding = options2.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, options2.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options2.encoding), this.encoding = options2.encoding;
      }
    }
    function Readable(options2) {
      if (Duplex = Duplex || require__stream_duplex(), !(this instanceof Readable))
        return new Readable(options2);
      var isDuplex = this instanceof Duplex;
      if (this._readableState = new ReadableState(options2, this, isDuplex), this.readable = true, options2) {
        if (typeof options2.read === "function")
          this._read = options2.read;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", { enumerable: false, get: function() {
      if (this._readableState === undefined)
        return false;
      return this._readableState.destroyed;
    }, set: function(value) {
      if (!this._readableState)
        return;
      this._readableState.destroyed = value;
    } });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState, skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (encoding = encoding || state.defaultEncoding, encoding !== state.encoding)
            chunk = Buffer22.from(chunk, encoding), encoding = "";
          skipChunkCheck = true;
        }
      } else
        skipChunkCheck = true;
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug2("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null)
        state.reading = false, onEofChunk(stream, state);
      else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er)
          errorOrDestroy(stream, er);
        else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer22.prototype)
            chunk = _uint8ArrayToBuffer(chunk);
          if (addToFront)
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
            else
              addChunk(stream, state, chunk, true);
          else if (state.ended)
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF);
          else if (state.destroyed)
            return false;
          else if (state.reading = false, state.decoder && !encoding)
            if (chunk = state.decoder.write(chunk), state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          else
            addChunk(stream, state, chunk, false);
        } else if (!addToFront)
          state.reading = false, maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync)
        state.awaitDrain = 0, stream.emit("data", chunk);
      else {
        if (state.length += state.objectMode ? 1 : chunk.length, addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode)
        er = new ERR_INVALID_ARG_TYPE3("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder, this._readableState.encoding = this._readableState.decoder.encoding;
      var p3 = this._readableState.buffer.head, content = "";
      while (p3 !== null)
        content += decoder.write(p3.data), p3 = p3.next;
      if (this._readableState.buffer.clear(), content !== "")
        this._readableState.buffer.push(content);
      return this._readableState.length = content.length, this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n2) {
      if (n2 >= MAX_HWM)
        n2 = MAX_HWM;
      else
        n2--, n2 |= n2 >>> 1, n2 |= n2 >>> 2, n2 |= n2 >>> 4, n2 |= n2 >>> 8, n2 |= n2 >>> 16, n2++;
      return n2;
    }
    function howMuchToRead(n2, state) {
      if (n2 <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n2 !== n2)
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      if (n2 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n2);
      if (n2 <= state.length)
        return n2;
      if (!state.ended)
        return state.needReadable = true, 0;
      return state.length;
    }
    Readable.prototype.read = function(n2) {
      debug2("read", n2), n2 = parseInt(n2, 10);
      var state = this._readableState, nOrig = n2;
      if (n2 !== 0)
        state.emittedReadable = false;
      if (n2 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        if (debug2("read: emitReadable", state.length, state.ended), state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      if (n2 = howMuchToRead(n2, state), n2 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      if (debug2("need readable", doRead), state.length === 0 || state.length - n2 < state.highWaterMark)
        doRead = true, debug2("length less than watermark", doRead);
      if (state.ended || state.reading)
        doRead = false, debug2("reading or ended", doRead);
      else if (doRead) {
        if (debug2("do read"), state.reading = true, state.sync = true, state.length === 0)
          state.needReadable = true;
        if (this._read(state.highWaterMark), state.sync = false, !state.reading)
          n2 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n2 > 0)
        ret = fromList(n2, state);
      else
        ret = null;
      if (ret === null)
        state.needReadable = state.length <= state.highWaterMark, n2 = 0;
      else
        state.length -= n2, state.awaitDrain = 0;
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n2 && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (debug2("onEofChunk"), state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          state.buffer.push(chunk), state.length += state.objectMode ? 1 : chunk.length;
      }
      if (state.ended = true, state.sync)
        emitReadable(stream);
      else if (state.needReadable = false, !state.emittedReadable)
        state.emittedReadable = true, emitReadable_(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      if (debug2("emitReadable", state.needReadable, state.emittedReadable), state.needReadable = false, !state.emittedReadable)
        debug2("emitReadable", state.flowing), state.emittedReadable = true, process.nextTick(emitReadable_, stream);
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      if (debug2("emitReadable_", state.destroyed, state.length, state.ended), !state.destroyed && (state.length || state.ended))
        stream.emit("readable"), state.emittedReadable = false;
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark, flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore)
        state.readingMore = true, process.nextTick(maybeReadMore_, stream, state);
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len2 = state.length;
        if (debug2("maybeReadMore read 0"), stream.read(0), len2 === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n2) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this, state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1, debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr, endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        if (debug2("onunpipe"), readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false)
            unpipeInfo.hasUnpiped = true, cleanup();
        }
      }
      function onend() {
        debug2("onend"), dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        if (debug2("cleanup"), dest.removeListener("close", onclose), dest.removeListener("finish", onfinish), dest.removeListener("drain", ondrain), dest.removeListener("error", onerror), dest.removeListener("unpipe", onunpipe), src.removeListener("end", onend), src.removeListener("end", unpipe), src.removeListener("data", ondata), cleanedUp = true, state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug2("ondata");
        var ret = dest.write(chunk);
        if (debug2("dest.write", ret), ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp)
            debug2("false write response, pause", state.awaitDrain), state.awaitDrain++;
          src.pause();
        }
      }
      function onerror(er) {
        if (debug2("onerror", er), unpipe(), dest.removeListener("error", onerror), EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish), unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug2("onfinish"), dest.removeListener("close", onclose), unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug2("unpipe"), src.unpipe(dest);
      }
      if (dest.emit("pipe", src), !state.flowing)
        debug2("pipe resume"), src.resume();
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        if (debug2("pipeOnDrain", state.awaitDrain), state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data"))
          state.flowing = true, flow(src);
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState, unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        if (state.pipes = null, state.pipesCount = 0, state.flowing = false, dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var { pipes: dests, pipesCount: len2 } = state;
        state.pipes = null, state.pipesCount = 0, state.flowing = false;
        for (var i4 = 0;i4 < len2; i4++)
          dests[i4].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var index2 = indexOf(state.pipes, dest);
      if (index2 === -1)
        return this;
      if (state.pipes.splice(index2, 1), state.pipesCount -= 1, state.pipesCount === 1)
        state.pipes = state.pipes[0];
      return dest.emit("unpipe", this, unpipeInfo), this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn), state = this._readableState;
      if (ev === "data") {
        if (state.readableListening = this.listenerCount("readable") > 0, state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          if (state.readableListening = state.needReadable = true, state.flowing = false, state.emittedReadable = false, debug2("on readable", state.length, state.reading), state.length)
            emitReadable(this);
          else if (!state.reading)
            process.nextTick(nReadingNextTick, this);
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable")
        process.nextTick(updateReadableListening, this);
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === undefined)
        process.nextTick(updateReadableListening, this);
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      if (state.readableListening = self2.listenerCount("readable") > 0, state.resumeScheduled && !state.paused)
        state.flowing = true;
      else if (self2.listenerCount("data") > 0)
        self2.resume();
    }
    function nReadingNextTick(self2) {
      debug2("readable nexttick read 0"), self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing)
        debug2("resume"), state.flowing = !state.readableListening, resume(this, state);
      return state.paused = false, this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled)
        state.resumeScheduled = true, process.nextTick(resume_, stream, state);
    }
    function resume_(stream, state) {
      if (debug2("resume", state.reading), !state.reading)
        stream.read(0);
      if (state.resumeScheduled = false, stream.emit("resume"), flow(stream), state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      if (debug2("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false)
        debug2("pause"), this._readableState.flowing = false, this.emit("pause");
      return this._readableState.paused = true, this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug2("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this, state = this._readableState, paused = false;
      stream.on("end", function() {
        if (debug2("wrapped end"), state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      }), stream.on("data", function(chunk) {
        if (debug2("wrapped data"), state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === undefined))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret)
          paused = true, stream.pause();
      });
      for (var i4 in stream)
        if (this[i4] === undefined && typeof stream[i4] === "function")
          this[i4] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i4);
      for (var n2 = 0;n2 < kProxyEvents.length; n2++)
        stream.on(kProxyEvents[n2], this.emit.bind(this, kProxyEvents[n2]));
      return this._read = function(n22) {
        if (debug2("wrapped _read", n22), paused)
          paused = false, stream.resume();
      }, this;
    };
    if (typeof Symbol === "function")
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === undefined)
          createReadableStreamAsyncIterator = require_async_iterator();
        return createReadableStreamAsyncIterator(this);
      };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(Readable.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(Readable.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(state) {
      if (this._readableState)
        this._readableState.flowing = state;
    } });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function fromList(n2, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n2 || n2 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else
        ret = state.buffer.consume(n2, state.decoder);
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (debug2("endReadable", state.endEmitted), !state.endEmitted)
        state.ended = true, process.nextTick(endReadableNT, state, stream);
    }
    function endReadableNT(state, stream) {
      if (debug2("endReadableNT", state.endEmitted, state.length), !state.endEmitted && state.length === 0) {
        if (state.endEmitted = true, stream.readable = false, stream.emit("end"), state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished)
            stream.destroy();
        }
      }
    }
    if (typeof Symbol === "function")
      Readable.from = function(iterable, opts) {
        if (from2 === undefined)
          from2 = require_from();
        return from2(Readable, iterable, opts);
      };
    function indexOf(xs, x3) {
      for (var i4 = 0, l4 = xs.length;i4 < l4; i4++)
        if (xs[i4] === x3)
          return i4;
      return -1;
    }
  });
  require__stream_transform = __commonJS2((exports, module) => {
    module.exports = Transform2;
    var _require$codes = require_errors().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0, Duplex = require__stream_duplex();
    require_inherits()(Transform2, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null)
        return this.emit("error", new ERR_MULTIPLE_CALLBACK);
      if (ts.writechunk = null, ts.writecb = null, data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      if (rs.reading = false, rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
    function Transform2(options2) {
      if (!(this instanceof Transform2))
        return new Transform2(options2);
      if (Duplex.call(this, options2), this._transformState = { afterTransform: afterTransform.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, options2) {
        if (typeof options2.transform === "function")
          this._transform = options2.transform;
        if (typeof options2.flush === "function")
          this._flush = options2.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed)
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      else
        done(this, null, null);
    }
    Transform2.prototype.push = function(chunk, encoding) {
      return this._transformState.needTransform = false, Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      if (ts.writecb = cb, ts.writechunk = chunk, ts.writeencoding = encoding, !ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n2) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming)
        ts.transforming = true, this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      else
        ts.needTransform = true;
    };
    Transform2.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0;
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING;
      return stream.push(null);
    }
  });
  require__stream_passthrough = __commonJS2((exports, module) => {
    module.exports = PassThrough;
    var Transform2 = require__stream_transform();
    require_inherits()(PassThrough, Transform2);
    function PassThrough(options2) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options2);
      Transform2.call(this, options2);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  });
  require_pipeline = __commonJS2((exports, module) => {
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true, callback.apply(undefined, arguments);
      };
    }
    var _require$codes = require_errors().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop3(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      if (stream.on("close", function() {
        closed = true;
      }), eos === undefined)
        eos = require_end_of_stream();
      eos(stream, { readable: reading, writable: writing }, function(err) {
        if (err)
          return callback(err);
        closed = true, callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        if (destroyed = true, isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from2, to) {
      return from2.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop3;
      if (typeof streams[streams.length - 1] !== "function")
        return noop3;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = Array(_len), _key = 0;_key < _len; _key++)
        streams[_key] = arguments[_key];
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new ERR_MISSING_ARGS("streams");
      var error, destroys = streams.map(function(stream, i4) {
        var reading = i4 < streams.length - 1, writing = i4 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call), callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module.exports = pipeline;
  });
  require_readable = __commonJS2((exports, module) => {
    var Stream = require_stream();
    exports = module.exports = require__stream_readable(), exports.Stream = Stream || exports, exports.Readable = exports, exports.Writable = require__stream_writable(), exports.Duplex = require__stream_duplex(), exports.Transform = require__stream_transform(), exports.PassThrough = require__stream_passthrough(), exports.finished = require_end_of_stream(), exports.pipeline = require_pipeline();
  });
  require_response = __commonJS2((exports) => {
    var capability = require_capability(), inherits2 = require_inherits(), stream = require_readable(), rStates = exports.readyStates = { UNSENT: 0, OPENED: 1, HEADERS_RECEIVED: 2, LOADING: 3, DONE: 4 }, IncomingMessage = exports.IncomingMessage = function(xhr, response, mode, resetTimers) {
      var self2 = this;
      if (stream.Readable.call(self2), self2._mode = mode, self2.headers = {}, self2.rawHeaders = [], self2.trailers = {}, self2.rawTrailers = [], self2.on("end", function() {
        process.nextTick(function() {
          self2.emit("close");
        });
      }), mode === "fetch") {
        let read22 = function() {
          reader.read().then(function(result) {
            if (self2._destroyed)
              return;
            if (resetTimers(result.done), result.done) {
              self2.push(null);
              return;
            }
            self2.push(Buffer.from(result.value)), read22();
          }).catch(function(err) {
            if (resetTimers(true), !self2._destroyed)
              self2.emit("error", err);
          });
        };
        var read2 = read22;
        if (self2._fetchResponse = response, self2.url = response.url, self2.statusCode = response.status, self2.statusMessage = response.statusText, response.headers.forEach(function(header, key) {
          self2.headers[key.toLowerCase()] = header, self2.rawHeaders.push(key, header);
        }), capability.writableStream) {
          var writable = new WritableStream({ write: function(chunk) {
            return resetTimers(false), new Promise(function(resolve, reject) {
              if (self2._destroyed)
                reject();
              else if (self2.push(Buffer.from(chunk)))
                resolve();
              else
                self2._resumeFetch = resolve;
            });
          }, close: function() {
            if (resetTimers(true), !self2._destroyed)
              self2.push(null);
          }, abort: function(err) {
            if (resetTimers(true), !self2._destroyed)
              self2.emit("error", err);
          } });
          try {
            response.body.pipeTo(writable).catch(function(err) {
              if (resetTimers(true), !self2._destroyed)
                self2.emit("error", err);
            });
            return;
          } catch (e2) {}
        }
        var reader = response.body.getReader();
        read22();
      } else {
        self2._xhr = xhr, self2._pos = 0, self2.url = xhr.responseURL, self2.statusCode = xhr.status, self2.statusMessage = xhr.statusText;
        var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
        if (headers.forEach(function(header) {
          var matches = header.match(/^([^:]+):\s*(.*)/);
          if (matches) {
            var key = matches[1].toLowerCase();
            if (key === "set-cookie") {
              if (self2.headers[key] === undefined)
                self2.headers[key] = [];
              self2.headers[key].push(matches[2]);
            } else if (self2.headers[key] !== undefined)
              self2.headers[key] += ", " + matches[2];
            else
              self2.headers[key] = matches[2];
            self2.rawHeaders.push(matches[1], matches[2]);
          }
        }), self2._charset = "x-user-defined", !capability.overrideMimeType) {
          var mimeType = self2.rawHeaders["mime-type"];
          if (mimeType) {
            var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
            if (charsetMatch)
              self2._charset = charsetMatch[1].toLowerCase();
          }
          if (!self2._charset)
            self2._charset = "utf-8";
        }
      }
    };
    inherits2(IncomingMessage, stream.Readable);
    IncomingMessage.prototype._read = function() {
      var self2 = this, resolve = self2._resumeFetch;
      if (resolve)
        self2._resumeFetch = null, resolve();
    };
    IncomingMessage.prototype._onXHRProgress = function(resetTimers) {
      var self2 = this, xhr = self2._xhr, response = null;
      switch (self2._mode) {
        case "text":
          if (response = xhr.responseText, response.length > self2._pos) {
            var newData = response.substr(self2._pos);
            if (self2._charset === "x-user-defined") {
              var buffer = Buffer.alloc(newData.length);
              for (var i4 = 0;i4 < newData.length; i4++)
                buffer[i4] = newData.charCodeAt(i4) & 255;
              self2.push(buffer);
            } else
              self2.push(newData, self2._charset);
            self2._pos = response.length;
          }
          break;
        case "arraybuffer":
          if (xhr.readyState !== rStates.DONE || !xhr.response)
            break;
          response = xhr.response, self2.push(Buffer.from(new Uint8Array(response)));
          break;
        case "moz-chunked-arraybuffer":
          if (response = xhr.response, xhr.readyState !== rStates.LOADING || !response)
            break;
          self2.push(Buffer.from(new Uint8Array(response)));
          break;
        case "ms-stream":
          if (response = xhr.response, xhr.readyState !== rStates.LOADING)
            break;
          var reader = new globalThis.MSStreamReader;
          reader.onprogress = function() {
            if (reader.result.byteLength > self2._pos)
              self2.push(Buffer.from(new Uint8Array(reader.result.slice(self2._pos)))), self2._pos = reader.result.byteLength;
          }, reader.onload = function() {
            resetTimers(true), self2.push(null);
          }, reader.readAsArrayBuffer(response);
          break;
      }
      if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream")
        resetTimers(true), self2.push(null);
    };
  });
  require_request = __commonJS2((exports, module) => {
    var capability = require_capability(), inherits2 = require_inherits(), response = require_response(), stream = require_readable(), IncomingMessage = response.IncomingMessage, rStates = response.readyStates;
    function decideMode(preferBinary, useFetch) {
      if (capability.fetch && useFetch)
        return "fetch";
      else if (capability.mozchunkedarraybuffer)
        return "moz-chunked-arraybuffer";
      else if (capability.msstream)
        return "ms-stream";
      else if (capability.arraybuffer && preferBinary)
        return "arraybuffer";
      else
        return "text";
    }
    var ClientRequest = module.exports = function(opts) {
      var self2 = this;
      if (stream.Writable.call(self2), self2._opts = opts, self2._body = [], self2._headers = {}, opts.auth)
        self2.setHeader("Authorization", "Basic " + Buffer.from(opts.auth).toString("base64"));
      Object.keys(opts.headers).forEach(function(name) {
        self2.setHeader(name, opts.headers[name]);
      });
      var preferBinary, useFetch = true;
      if (opts.mode === "disable-fetch" || "requestTimeout" in opts && !capability.abortController)
        useFetch = false, preferBinary = true;
      else if (opts.mode === "prefer-streaming")
        preferBinary = false;
      else if (opts.mode === "allow-wrong-content-type")
        preferBinary = !capability.overrideMimeType;
      else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast")
        preferBinary = true;
      else
        throw Error("Invalid value for opts.mode");
      self2._mode = decideMode(preferBinary, useFetch), self2._fetchTimer = null, self2._socketTimeout = null, self2._socketTimer = null, self2.on("finish", function() {
        self2._onFinish();
      });
    };
    inherits2(ClientRequest, stream.Writable);
    ClientRequest.prototype.setHeader = function(name, value) {
      var self2 = this, lowerName = name.toLowerCase();
      if (unsafeHeaders.indexOf(lowerName) !== -1)
        return;
      self2._headers[lowerName] = { name, value };
    };
    ClientRequest.prototype.getHeader = function(name) {
      var header = this._headers[name.toLowerCase()];
      if (header)
        return header.value;
      return null;
    };
    ClientRequest.prototype.removeHeader = function(name) {
      var self2 = this;
      delete self2._headers[name.toLowerCase()];
    };
    ClientRequest.prototype._onFinish = function() {
      var self2 = this;
      if (self2._destroyed)
        return;
      var opts = self2._opts;
      if ("timeout" in opts && opts.timeout !== 0)
        self2.setTimeout(opts.timeout);
      var headersObj = self2._headers, body = null;
      if (opts.method !== "GET" && opts.method !== "HEAD")
        body = new Blob(self2._body, { type: (headersObj["content-type"] || {}).value || "" });
      var headersList = [];
      if (Object.keys(headersObj).forEach(function(keyName) {
        var name = headersObj[keyName].name, value = headersObj[keyName].value;
        if (Array.isArray(value))
          value.forEach(function(v2) {
            headersList.push([name, v2]);
          });
        else
          headersList.push([name, value]);
      }), self2._mode === "fetch") {
        var signal = null;
        if (capability.abortController) {
          var controller = new AbortController;
          if (signal = controller.signal, self2._fetchAbortController = controller, "requestTimeout" in opts && opts.requestTimeout !== 0)
            self2._fetchTimer = globalThis.setTimeout(function() {
              if (self2.emit("requestTimeout"), self2._fetchAbortController)
                self2._fetchAbortController.abort();
            }, opts.requestTimeout);
        }
        globalThis.fetch(self2._opts.url, { method: self2._opts.method, headers: headersList, body: body || undefined, mode: "cors", credentials: opts.withCredentials ? "include" : "same-origin", signal }).then(function(response2) {
          self2._fetchResponse = response2, self2._resetTimers(false), self2._connect();
        }, function(reason) {
          if (self2._resetTimers(true), !self2._destroyed)
            self2.emit("error", reason);
        });
      } else {
        var xhr = self2._xhr = new globalThis.XMLHttpRequest;
        try {
          xhr.open(self2._opts.method, self2._opts.url, true);
        } catch (err) {
          process.nextTick(function() {
            self2.emit("error", err);
          });
          return;
        }
        if ("responseType" in xhr)
          xhr.responseType = self2._mode;
        if ("withCredentials" in xhr)
          xhr.withCredentials = !!opts.withCredentials;
        if (self2._mode === "text" && "overrideMimeType" in xhr)
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        if ("requestTimeout" in opts)
          xhr.timeout = opts.requestTimeout, xhr.ontimeout = function() {
            self2.emit("requestTimeout");
          };
        if (headersList.forEach(function(header) {
          xhr.setRequestHeader(header[0], header[1]);
        }), self2._response = null, xhr.onreadystatechange = function() {
          switch (xhr.readyState) {
            case rStates.LOADING:
            case rStates.DONE:
              self2._onXHRProgress();
              break;
          }
        }, self2._mode === "moz-chunked-arraybuffer")
          xhr.onprogress = function() {
            self2._onXHRProgress();
          };
        xhr.onerror = function() {
          if (self2._destroyed)
            return;
          self2._resetTimers(true), self2.emit("error", Error("XHR error"));
        };
        try {
          xhr.send(body);
        } catch (err) {
          process.nextTick(function() {
            self2.emit("error", err);
          });
          return;
        }
      }
    };
    function statusValid(xhr) {
      try {
        var status = xhr.status;
        return status !== null && status !== 0;
      } catch (e2) {
        return false;
      }
    }
    ClientRequest.prototype._onXHRProgress = function() {
      var self2 = this;
      if (self2._resetTimers(false), !statusValid(self2._xhr) || self2._destroyed)
        return;
      if (!self2._response)
        self2._connect();
      self2._response._onXHRProgress(self2._resetTimers.bind(self2));
    };
    ClientRequest.prototype._connect = function() {
      var self2 = this;
      if (self2._destroyed)
        return;
      self2._response = new IncomingMessage(self2._xhr, self2._fetchResponse, self2._mode, self2._resetTimers.bind(self2)), self2._response.on("error", function(err) {
        self2.emit("error", err);
      }), self2.emit("response", self2._response);
    };
    ClientRequest.prototype._write = function(chunk, encoding, cb) {
      var self2 = this;
      self2._body.push(chunk), cb();
    };
    ClientRequest.prototype._resetTimers = function(done) {
      var self2 = this;
      if (globalThis.clearTimeout(self2._socketTimer), self2._socketTimer = null, done)
        globalThis.clearTimeout(self2._fetchTimer), self2._fetchTimer = null;
      else if (self2._socketTimeout)
        self2._socketTimer = globalThis.setTimeout(function() {
          self2.emit("timeout");
        }, self2._socketTimeout);
    };
    ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function(err) {
      var self2 = this;
      if (self2._destroyed = true, self2._resetTimers(true), self2._response)
        self2._response._destroyed = true;
      if (self2._xhr)
        self2._xhr.abort();
      else if (self2._fetchAbortController)
        self2._fetchAbortController.abort();
      if (err)
        self2.emit("error", err);
    };
    ClientRequest.prototype.end = function(data, encoding, cb) {
      var self2 = this;
      if (typeof data === "function")
        cb = data, data = undefined;
      stream.Writable.prototype.end.call(self2, data, encoding, cb);
    };
    ClientRequest.prototype.setTimeout = function(timeout, cb) {
      var self2 = this;
      if (cb)
        self2.once("timeout", cb);
      self2._socketTimeout = timeout, self2._resetTimers(false);
    };
    ClientRequest.prototype.flushHeaders = function() {};
    ClientRequest.prototype.setNoDelay = function() {};
    ClientRequest.prototype.setSocketKeepAlive = function() {};
    var unsafeHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
  });
  require_immutable = __commonJS2((exports, module) => {
    module.exports = extend;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i4 = 0;i4 < arguments.length; i4++) {
        var source = arguments[i4];
        for (var key in source)
          if (hasOwnProperty2.call(source, key))
            target[key] = source[key];
      }
      return target;
    }
  });
  require_builtin_status_codes = __commonJS2((exports, module) => {
    module.exports = (init_http(), __toCommonJS(exports_http)).STATUS_CODES;
  });
  require_stream_http = __commonJS2((exports) => {
    var ClientRequest = require_request(), response = require_response(), extend = require_immutable(), statusCodes = require_builtin_status_codes(), url = (init_url(), __toCommonJS(exports_url)), http = exports;
    http.request = function(opts, cb) {
      if (typeof opts === "string")
        opts = url.parse(opts);
      else
        opts = extend(opts);
      var defaultProtocol = globalThis.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", protocol = opts.protocol || defaultProtocol, host = opts.hostname || opts.host, port = opts.port, path = opts.path || "/";
      if (host && host.indexOf(":") !== -1)
        host = "[" + host + "]";
      opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path, opts.method = (opts.method || "GET").toUpperCase(), opts.headers = opts.headers || {};
      var req2 = new ClientRequest(opts);
      if (cb)
        req2.on("response", cb);
      return req2;
    };
    http.get = function(opts, cb) {
      var req2 = http.request(opts, cb);
      return req2.end(), req2;
    };
    http.ClientRequest = ClientRequest;
    http.IncomingMessage = response.IncomingMessage;
    http.Agent = function() {};
    http.Agent.defaultMaxSockets = 4;
    http.globalAgent = new http.Agent;
    http.STATUS_CODES = statusCodes;
    http.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
  });
  import_stream_http = __toESM2(require_stream_http(), 1);
  ({ request, get, ClientRequest, IncomingMessage, Agent, globalAgent, STATUS_CODES, METHODS } = import_stream_http.default);
  http_default = import_stream_http.default;
});

// node:https
var exports_https = {};
__export(exports_https, {
  validateHeaderValue: () => validateHeaderValue,
  validateHeaderName: () => validateHeaderName,
  setMaxIdleHTTPParsers: () => setMaxIdleHTTPParsers,
  request: () => request2,
  maxHeaderSize: () => maxHeaderSize,
  globalAgent: () => globalAgent2,
  get: () => get2,
  default: () => https_default,
  createServer: () => createServer,
  ServerResponse: () => ServerResponse,
  Server: () => Server,
  STATUS_CODES: () => STATUS_CODES2,
  OutgoingMessage: () => OutgoingMessage,
  METHODS: () => METHODS2,
  IncomingMessage: () => IncomingMessage2,
  ClientRequest: () => ClientRequest2,
  Agent: () => Agent2
});
var __create3, __getProtoOf3, __defProp3, __getOwnPropNames3, __hasOwnProp3, __toESM3 = (mod, isNodeMode, target) => {
  target = mod != null ? __create3(__getProtoOf3(mod)) : {};
  let to = isNodeMode || !mod || !mod.__esModule ? __defProp3(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames3(mod))
    if (!__hasOwnProp3.call(to, key))
      __defProp3(to, key, { get: () => mod[key], enumerable: true });
  return to;
}, __commonJS3 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports), require_https_browserify, https, Agent2, ClientRequest2, IncomingMessage2, METHODS2, OutgoingMessage, STATUS_CODES2, Server, ServerResponse, createServer, get2, globalAgent2, maxHeaderSize, request2, setMaxIdleHTTPParsers, validateHeaderName, validateHeaderValue, https_default;
var init_https = __esm(() => {
  __create3 = Object.create;
  ({ getPrototypeOf: __getProtoOf3, defineProperty: __defProp3, getOwnPropertyNames: __getOwnPropNames3 } = Object);
  __hasOwnProp3 = Object.prototype.hasOwnProperty;
  require_https_browserify = __commonJS3((exports, module) => {
    var http = (init_http(), __toCommonJS(exports_http)), url = (init_url(), __toCommonJS(exports_url)), https = exports;
    for (key in http)
      if (http.hasOwnProperty(key))
        https[key] = http[key];
    var key;
    https.request = function(params, cb) {
      return params = validateParams(params), http.request.call(this, params, cb);
    };
    https.get = function(params, cb) {
      return params = validateParams(params), http.get.call(this, params, cb);
    };
    function validateParams(params) {
      if (typeof params === "string")
        params = url.parse(params);
      if (!params.protocol)
        params.protocol = "https:";
      if (params.protocol !== "https:")
        throw Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
      return params;
    }
  });
  https = __toESM3(require_https_browserify(), 1);
  ({ Agent: Agent2, ClientRequest: ClientRequest2, IncomingMessage: IncomingMessage2, METHODS: METHODS2, OutgoingMessage, STATUS_CODES: STATUS_CODES2, Server, ServerResponse, createServer, get: get2, globalAgent: globalAgent2, maxHeaderSize, request: request2, setMaxIdleHTTPParsers, validateHeaderName, validateHeaderValue } = https);
  https_default = https;
});

// ../../node_modules/.pnpm/pptxgenjs@3.12.0/node_modules/pptxgenjs/dist/pptxgen.es.js
var exports_pptxgen_es = {};
__export(exports_pptxgen_es, {
  default: () => PptxGenJS
});
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : undefined, done: true };
  }
}
function __spreadArray2(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i4 = 0, l4 = from2.length, ar;i4 < l4; i4++) {
      if (ar || !(i4 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i4);
        ar[i4] = from2[i4];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function getSmartParseNumber(size4, xyDir, layout) {
  if (typeof size4 === "string" && !isNaN(Number(size4)))
    size4 = Number(size4);
  if (typeof size4 === "number" && size4 < 100)
    return inch2Emu(size4);
  if (typeof size4 === "number" && size4 >= 100)
    return size4;
  if (typeof size4 === "string" && size4.includes("%")) {
    if (xyDir && xyDir === "X")
      return Math.round(parseFloat(size4) / 100 * layout.width);
    if (xyDir && xyDir === "Y")
      return Math.round(parseFloat(size4) / 100 * layout.height);
    return Math.round(parseFloat(size4) / 100 * layout.width);
  }
  return 0;
}
function getUuid(uuidFormat) {
  return uuidFormat.replace(/[xy]/g, function(c3) {
    var r3 = Math.random() * 16 | 0;
    var v2 = c3 === "x" ? r3 : r3 & 3 | 8;
    return v2.toString(16);
  });
}
function encodeXmlEntities(xml) {
  if (typeof xml === "undefined" || xml == null)
    return "";
  return xml.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
function inch2Emu(inches) {
  if (typeof inches === "number" && inches > 100)
    return inches;
  if (typeof inches === "string")
    inches = Number(inches.replace(/in*/gi, ""));
  return Math.round(EMU * inches);
}
function valToPts(pt) {
  var points = Number(pt) || 0;
  return isNaN(points) ? 0 : Math.round(points * ONEPT);
}
function convertRotationDegrees(d2) {
  d2 = d2 || 0;
  return Math.round((d2 > 360 ? d2 - 360 : d2) * 60000);
}
function componentToHex(c3) {
  var hex = c3.toString(16);
  return hex.length === 1 ? "0" + hex : hex;
}
function rgbToHex(r3, g2, b4) {
  return (componentToHex(r3) + componentToHex(g2) + componentToHex(b4)).toUpperCase();
}
function createColorElement(colorStr, innerElements) {
  var colorVal = (colorStr || "").replace("#", "");
  if (!REGEX_HEX_COLOR.test(colorVal) && colorVal !== SchemeColor.background1 && colorVal !== SchemeColor.background2 && colorVal !== SchemeColor.text1 && colorVal !== SchemeColor.text2 && colorVal !== SchemeColor.accent1 && colorVal !== SchemeColor.accent2 && colorVal !== SchemeColor.accent3 && colorVal !== SchemeColor.accent4 && colorVal !== SchemeColor.accent5 && colorVal !== SchemeColor.accent6) {
    console.warn('"'.concat(colorVal, '" is not a valid scheme color or hex RGB! "').concat(DEF_FONT_COLOR, `" used instead. Only provide 6-digit RGB or 'pptx.SchemeColor' values!`));
    colorVal = DEF_FONT_COLOR;
  }
  var tagName = REGEX_HEX_COLOR.test(colorVal) ? "srgbClr" : "schemeClr";
  var colorAttr = 'val="' + (REGEX_HEX_COLOR.test(colorVal) ? colorVal.toUpperCase() : colorVal) + '"';
  return innerElements ? "<a:".concat(tagName, " ").concat(colorAttr, ">").concat(innerElements, "</a:").concat(tagName, ">") : "<a:".concat(tagName, " ").concat(colorAttr, "/>");
}
function createGlowElement(options2, defaults) {
  var strXml = "";
  var opts = __assign2(__assign2({}, defaults), options2);
  var size4 = Math.round(opts.size * ONEPT);
  var color = opts.color;
  var opacity = Math.round(opts.opacity * 1e5);
  strXml += '<a:glow rad="'.concat(size4, '">');
  strXml += createColorElement(color, '<a:alpha val="'.concat(opacity, '"/>'));
  strXml += "</a:glow>";
  return strXml;
}
function genXmlColorSelection(props) {
  var fillType = "solid";
  var colorVal = "";
  var internalElements = "";
  var outText = "";
  if (props) {
    if (typeof props === "string")
      colorVal = props;
    else {
      if (props.type)
        fillType = props.type;
      if (props.color)
        colorVal = props.color;
      if (props.alpha)
        internalElements += '<a:alpha val="'.concat(Math.round((100 - props.alpha) * 1000), '"/>');
      if (props.transparency)
        internalElements += '<a:alpha val="'.concat(Math.round((100 - props.transparency) * 1000), '"/>');
    }
    switch (fillType) {
      case "solid":
        outText += "<a:solidFill>".concat(createColorElement(colorVal, internalElements), "</a:solidFill>");
        break;
      default:
        outText += "";
        break;
    }
  }
  return outText;
}
function getNewRelId(target) {
  return target._rels.length + target._relsChart.length + target._relsMedia.length + 1;
}
function correctShadowOptions(ShadowProps) {
  if (!ShadowProps || typeof ShadowProps !== "object") {
    return;
  }
  if (ShadowProps.type !== "outer" && ShadowProps.type !== "inner" && ShadowProps.type !== "none") {
    console.warn("Warning: shadow.type options are `outer`, `inner` or `none`.");
    ShadowProps.type = "outer";
  }
  if (ShadowProps.angle) {
    if (isNaN(Number(ShadowProps.angle)) || ShadowProps.angle < 0 || ShadowProps.angle > 359) {
      console.warn("Warning: shadow.angle can only be 0-359");
      ShadowProps.angle = 270;
    }
    ShadowProps.angle = Math.round(Number(ShadowProps.angle));
  }
  if (ShadowProps.opacity) {
    if (isNaN(Number(ShadowProps.opacity)) || ShadowProps.opacity < 0 || ShadowProps.opacity > 1) {
      console.warn("Warning: shadow.opacity can only be 0-1");
      ShadowProps.opacity = 0.75;
    }
    ShadowProps.opacity = Number(ShadowProps.opacity);
  }
  if (ShadowProps.color) {
    if (ShadowProps.color.startsWith("#")) {
      console.warn('Warning: shadow.color should not include hash (#) character, , e.g. "FF0000"');
      ShadowProps.color = ShadowProps.color.replace("#", "");
    }
  }
  return ShadowProps;
}
function parseTextToLines(cell, colWidth, verbose) {
  var _a, _b;
  var FOCO = 2.3 + (((_a = cell.options) === null || _a === undefined ? undefined : _a.autoPageCharWeight) ? cell.options.autoPageCharWeight : 0);
  var CPL = Math.floor(colWidth / ONEPT * EMU) / ((((_b = cell.options) === null || _b === undefined ? undefined : _b.fontSize) ? cell.options.fontSize : DEF_FONT_SIZE) / FOCO);
  var parsedLines = [];
  var inputCells = [];
  var inputLines1 = [];
  var inputLines2 = [];
  if (cell.text && cell.text.toString().trim().length === 0) {
    inputCells.push({ _type: SLIDE_OBJECT_TYPES.tablecell, text: " " });
  } else if (typeof cell.text === "number" || typeof cell.text === "string") {
    inputCells.push({ _type: SLIDE_OBJECT_TYPES.tablecell, text: (cell.text || "").toString().trim() });
  } else if (Array.isArray(cell.text)) {
    inputCells = cell.text;
  }
  if (verbose) {
    console.log("[1/4] inputCells");
    inputCells.forEach(function(cell2, idx) {
      return console.log("[1/4] [".concat(idx + 1, "] cell: ").concat(JSON.stringify(cell2)));
    });
  }
  var newLine = [];
  inputCells.forEach(function(cell2) {
    var _a2;
    if (typeof cell2.text === "string") {
      if (cell2.text.split(`
`).length > 1) {
        cell2.text.split(`
`).forEach(function(textLine) {
          newLine.push({
            _type: SLIDE_OBJECT_TYPES.tablecell,
            text: textLine,
            options: __assign2(__assign2({}, cell2.options), { breakLine: true })
          });
        });
      } else {
        newLine.push({
          _type: SLIDE_OBJECT_TYPES.tablecell,
          text: cell2.text.trim(),
          options: cell2.options
        });
      }
      if ((_a2 = cell2.options) === null || _a2 === undefined ? undefined : _a2.breakLine) {
        if (verbose)
          console.log("inputCells: new line > ".concat(JSON.stringify(newLine)));
        inputLines1.push(newLine);
        newLine = [];
      }
    }
    if (newLine.length > 0) {
      inputLines1.push(newLine);
      newLine = [];
    }
  });
  if (verbose) {
    console.log("[2/4] inputLines1 (".concat(inputLines1.length, ")"));
    inputLines1.forEach(function(line, idx) {
      return console.log("[2/4] [".concat(idx + 1, "] line: ").concat(JSON.stringify(line)));
    });
  }
  inputLines1.forEach(function(line) {
    line.forEach(function(cell2) {
      var lineCells = [];
      var cellTextStr = String(cell2.text);
      var lineWords = cellTextStr.split(" ");
      lineWords.forEach(function(word, idx) {
        var cellProps = __assign2({}, cell2.options);
        if (cellProps === null || cellProps === undefined ? undefined : cellProps.breakLine)
          cellProps.breakLine = idx + 1 === lineWords.length;
        lineCells.push({ _type: SLIDE_OBJECT_TYPES.tablecell, text: word + (idx + 1 < lineWords.length ? " " : ""), options: cellProps });
      });
      inputLines2.push(lineCells);
    });
  });
  if (verbose) {
    console.log("[3/4] inputLines2 (".concat(inputLines2.length, ")"));
    inputLines2.forEach(function(line) {
      return console.log("[3/4] line: ".concat(JSON.stringify(line)));
    });
  }
  inputLines2.forEach(function(line) {
    var lineCells = [];
    var strCurrLine = "";
    line.forEach(function(word) {
      if (strCurrLine.length + word.text.length > CPL) {
        parsedLines.push(lineCells);
        lineCells = [];
        strCurrLine = "";
      }
      lineCells.push(word);
      strCurrLine += word.text.toString();
    });
    if (lineCells.length > 0)
      parsedLines.push(lineCells);
  });
  if (verbose) {
    console.log("[4/4] parsedLines (".concat(parsedLines.length, ")"));
    parsedLines.forEach(function(line, idx) {
      return console.log("[4/4] [Line ".concat(idx + 1, `]:
`).concat(JSON.stringify(line)));
    });
    console.log(`...............................................

`);
  }
  return parsedLines;
}
function getSlidesForTableRows(tableRows, tableProps, presLayout, masterSlide) {
  if (tableRows === undefined) {
    tableRows = [];
  }
  if (tableProps === undefined) {
    tableProps = {};
  }
  var arrInchMargins = DEF_SLIDE_MARGIN_IN;
  var emuSlideTabW = EMU * 1;
  var emuSlideTabH = EMU * 1;
  var emuTabCurrH = 0;
  var numCols = 0;
  var tableRowSlides = [];
  var tablePropX = getSmartParseNumber(tableProps.x, "X", presLayout);
  var tablePropY = getSmartParseNumber(tableProps.y, "Y", presLayout);
  var tablePropW = getSmartParseNumber(tableProps.w, "X", presLayout);
  var tablePropH = getSmartParseNumber(tableProps.h, "Y", presLayout);
  var tableCalcW = tablePropW;
  function calcSlideTabH() {
    var emuStartY = 0;
    if (tableRowSlides.length === 0)
      emuStartY = tablePropY || inch2Emu(arrInchMargins[0]);
    if (tableRowSlides.length > 0)
      emuStartY = inch2Emu(tableProps.autoPageSlideStartY || tableProps.newSlideStartY || arrInchMargins[0]);
    emuSlideTabH = (tablePropH || presLayout.height) - emuStartY - inch2Emu(arrInchMargins[2]);
    if (tableRowSlides.length > 1) {
      if (typeof tableProps.autoPageSlideStartY === "number") {
        emuSlideTabH = (tablePropH || presLayout.height) - inch2Emu(tableProps.autoPageSlideStartY + arrInchMargins[2]);
      } else if (typeof tableProps.newSlideStartY === "number") {
        emuSlideTabH = (tablePropH || presLayout.height) - inch2Emu(tableProps.newSlideStartY + arrInchMargins[2]);
      } else if (tablePropY) {
        emuSlideTabH = (tablePropH || presLayout.height) - inch2Emu((tablePropY / EMU < arrInchMargins[0] ? tablePropY / EMU : arrInchMargins[0]) + arrInchMargins[2]);
        if (emuSlideTabH < tablePropH)
          emuSlideTabH = tablePropH;
      }
    }
  }
  if (tableProps.verbose) {
    console.log("[[VERBOSE MODE]]");
    console.log("|-- TABLE PROPS --------------------------------------------------------|");
    console.log("| presLayout.width ................................ = ".concat((presLayout.width / EMU).toFixed(1)));
    console.log("| presLayout.height ............................... = ".concat((presLayout.height / EMU).toFixed(1)));
    console.log("| tableProps.x .................................... = ".concat(typeof tableProps.x === "number" ? (tableProps.x / EMU).toFixed(1) : tableProps.x));
    console.log("| tableProps.y .................................... = ".concat(typeof tableProps.y === "number" ? (tableProps.y / EMU).toFixed(1) : tableProps.y));
    console.log("| tableProps.w .................................... = ".concat(typeof tableProps.w === "number" ? (tableProps.w / EMU).toFixed(1) : tableProps.w));
    console.log("| tableProps.h .................................... = ".concat(typeof tableProps.h === "number" ? (tableProps.h / EMU).toFixed(1) : tableProps.h));
    console.log("| tableProps.slideMargin .......................... = ".concat(tableProps.slideMargin ? String(tableProps.slideMargin) : ""));
    console.log("| tableProps.margin ............................... = ".concat(String(tableProps.margin)));
    console.log("| tableProps.colW ................................. = ".concat(String(tableProps.colW)));
    console.log("| tableProps.autoPageSlideStartY .................. = ".concat(tableProps.autoPageSlideStartY));
    console.log("| tableProps.autoPageCharWeight ................... = ".concat(tableProps.autoPageCharWeight));
    console.log("|-- CALCULATIONS -------------------------------------------------------|");
    console.log("| tablePropX ...................................... = ".concat(tablePropX / EMU));
    console.log("| tablePropY ...................................... = ".concat(tablePropY / EMU));
    console.log("| tablePropW ...................................... = ".concat(tablePropW / EMU));
    console.log("| tablePropH ...................................... = ".concat(tablePropH / EMU));
    console.log("| tableCalcW ...................................... = ".concat(tableCalcW / EMU));
  }
  {
    if (!tableProps.slideMargin && tableProps.slideMargin !== 0)
      tableProps.slideMargin = DEF_SLIDE_MARGIN_IN[0];
    if (masterSlide && typeof masterSlide._margin !== "undefined") {
      if (Array.isArray(masterSlide._margin))
        arrInchMargins = masterSlide._margin;
      else if (!isNaN(Number(masterSlide._margin))) {
        arrInchMargins = [Number(masterSlide._margin), Number(masterSlide._margin), Number(masterSlide._margin), Number(masterSlide._margin)];
      }
    } else if (tableProps.slideMargin || tableProps.slideMargin === 0) {
      if (Array.isArray(tableProps.slideMargin))
        arrInchMargins = tableProps.slideMargin;
      else if (!isNaN(tableProps.slideMargin))
        arrInchMargins = [tableProps.slideMargin, tableProps.slideMargin, tableProps.slideMargin, tableProps.slideMargin];
    }
    if (tableProps.verbose)
      console.log("| arrInchMargins .................................. = [".concat(arrInchMargins.join(", "), "]"));
  }
  {
    var firstRow = tableRows[0] || [];
    firstRow.forEach(function(cell) {
      if (!cell)
        cell = { _type: SLIDE_OBJECT_TYPES.tablecell };
      var cellOpts = cell.options || null;
      numCols += Number((cellOpts === null || cellOpts === undefined ? undefined : cellOpts.colspan) ? cellOpts.colspan : 1);
    });
    if (tableProps.verbose)
      console.log("| numCols ......................................... = ".concat(numCols));
  }
  if (!tablePropW && tableProps.colW) {
    tableCalcW = Array.isArray(tableProps.colW) ? tableProps.colW.reduce(function(p3, n2) {
      return p3 + n2;
    }) * EMU : tableProps.colW * numCols || 0;
    if (tableProps.verbose)
      console.log("| tableCalcW ...................................... = ".concat(tableCalcW / EMU));
  }
  {
    emuSlideTabW = tableCalcW || inch2Emu((tablePropX ? tablePropX / EMU : arrInchMargins[1]) + arrInchMargins[3]);
    if (tableProps.verbose)
      console.log("| emuSlideTabW .................................... = ".concat((emuSlideTabW / EMU).toFixed(1)));
  }
  if (!tableProps.colW || !Array.isArray(tableProps.colW)) {
    if (tableProps.colW && !isNaN(Number(tableProps.colW))) {
      var arrColW_1 = [];
      var firstRow = tableRows[0] || [];
      firstRow.forEach(function() {
        return arrColW_1.push(tableProps.colW);
      });
      tableProps.colW = [];
      arrColW_1.forEach(function(val) {
        if (Array.isArray(tableProps.colW))
          tableProps.colW.push(val);
      });
    } else {
      tableProps.colW = [];
      for (var iCol = 0;iCol < numCols; iCol++) {
        tableProps.colW.push(emuSlideTabW / EMU / numCols);
      }
    }
  }
  var newTableRowSlide = { rows: [] };
  tableRows.forEach(function(row, iRow) {
    var rowCellLines = [];
    var maxCellMarTopEmu = 0;
    var maxCellMarBtmEmu = 0;
    var currTableRow = [];
    row.forEach(function(cell) {
      var _a, _b, _c, _d;
      currTableRow.push({
        _type: SLIDE_OBJECT_TYPES.tablecell,
        text: [],
        options: cell.options
      });
      if (cell.options.margin && cell.options.margin[0] >= 1) {
        if (((_a = cell.options) === null || _a === undefined ? undefined : _a.margin) && cell.options.margin[0] && valToPts(cell.options.margin[0]) > maxCellMarTopEmu)
          maxCellMarTopEmu = valToPts(cell.options.margin[0]);
        else if ((tableProps === null || tableProps === undefined ? undefined : tableProps.margin) && tableProps.margin[0] && valToPts(tableProps.margin[0]) > maxCellMarTopEmu)
          maxCellMarTopEmu = valToPts(tableProps.margin[0]);
        if (((_b = cell.options) === null || _b === undefined ? undefined : _b.margin) && cell.options.margin[2] && valToPts(cell.options.margin[2]) > maxCellMarBtmEmu)
          maxCellMarBtmEmu = valToPts(cell.options.margin[2]);
        else if ((tableProps === null || tableProps === undefined ? undefined : tableProps.margin) && tableProps.margin[2] && valToPts(tableProps.margin[2]) > maxCellMarBtmEmu)
          maxCellMarBtmEmu = valToPts(tableProps.margin[2]);
      } else {
        if (((_c = cell.options) === null || _c === undefined ? undefined : _c.margin) && cell.options.margin[0] && inch2Emu(cell.options.margin[0]) > maxCellMarTopEmu)
          maxCellMarTopEmu = inch2Emu(cell.options.margin[0]);
        else if ((tableProps === null || tableProps === undefined ? undefined : tableProps.margin) && tableProps.margin[0] && inch2Emu(tableProps.margin[0]) > maxCellMarTopEmu)
          maxCellMarTopEmu = inch2Emu(tableProps.margin[0]);
        if (((_d = cell.options) === null || _d === undefined ? undefined : _d.margin) && cell.options.margin[2] && inch2Emu(cell.options.margin[2]) > maxCellMarBtmEmu)
          maxCellMarBtmEmu = inch2Emu(cell.options.margin[2]);
        else if ((tableProps === null || tableProps === undefined ? undefined : tableProps.margin) && tableProps.margin[2] && inch2Emu(tableProps.margin[2]) > maxCellMarBtmEmu)
          maxCellMarBtmEmu = inch2Emu(tableProps.margin[2]);
      }
    });
    calcSlideTabH();
    emuTabCurrH += maxCellMarTopEmu + maxCellMarBtmEmu;
    if (tableProps.verbose && iRow === 0)
      console.log("| SLIDE [".concat(tableRowSlides.length, "]: emuSlideTabH ...... = ").concat((emuSlideTabH / EMU).toFixed(1), " "));
    row.forEach(function(cell, iCell) {
      var _a;
      var newCell = {
        _type: SLIDE_OBJECT_TYPES.tablecell,
        _lines: null,
        _lineHeight: inch2Emu((((_a = cell.options) === null || _a === undefined ? undefined : _a.fontSize) ? cell.options.fontSize : tableProps.fontSize ? tableProps.fontSize : DEF_FONT_SIZE) * (LINEH_MODIFIER + (tableProps.autoPageLineWeight ? tableProps.autoPageLineWeight : 0)) / 100),
        text: [],
        options: cell.options
      };
      if (newCell.options.rowspan)
        newCell._lineHeight = 0;
      newCell.options.autoPageCharWeight = tableProps.autoPageCharWeight ? tableProps.autoPageCharWeight : null;
      var totalColW = tableProps.colW[iCell];
      if (cell.options.colspan && Array.isArray(tableProps.colW)) {
        totalColW = tableProps.colW.filter(function(_cell, idx) {
          return idx >= iCell && idx < idx + cell.options.colspan;
        }).reduce(function(prev, curr) {
          return prev + curr;
        });
      }
      newCell._lines = parseTextToLines(cell, totalColW, false);
      rowCellLines.push(newCell);
    });
    if (tableProps.verbose)
      console.log(`
| SLIDE [`.concat(tableRowSlides.length, "]: ROW [").concat(iRow, "]: START..."));
    var currCellIdx = 0;
    var emuLineMaxH = 0;
    var isDone = false;
    while (!isDone) {
      var srcCell = rowCellLines[currCellIdx];
      var tgtCell = currTableRow[currCellIdx];
      rowCellLines.forEach(function(cell) {
        if (cell._lineHeight >= emuLineMaxH)
          emuLineMaxH = cell._lineHeight;
      });
      if (emuTabCurrH + emuLineMaxH > emuSlideTabH) {
        if (tableProps.verbose) {
          console.log(`
|-----------------------------------------------------------------------|`);
          console.log("|-- NEW SLIDE CREATED (currTabH+currLineH > maxH) => ".concat((emuTabCurrH / EMU).toFixed(2), " + ").concat((srcCell._lineHeight / EMU).toFixed(2), " > ").concat(emuSlideTabH / EMU));
          console.log(`|-----------------------------------------------------------------------|

`);
        }
        if (currTableRow.length > 0 && currTableRow.map(function(cell) {
          return cell.text.length;
        }).reduce(function(p3, n2) {
          return p3 + n2;
        }) > 0)
          newTableRowSlide.rows.push(currTableRow);
        tableRowSlides.push(newTableRowSlide);
        var newRows = [];
        newTableRowSlide = { rows: newRows };
        currTableRow = [];
        row.forEach(function(cell) {
          return currTableRow.push({ _type: SLIDE_OBJECT_TYPES.tablecell, text: [], options: cell.options });
        });
        calcSlideTabH();
        emuTabCurrH += maxCellMarTopEmu + maxCellMarBtmEmu;
        if (tableProps.verbose)
          console.log("| SLIDE [".concat(tableRowSlides.length, "]: emuSlideTabH ...... = ").concat((emuSlideTabH / EMU).toFixed(1), " "));
        emuTabCurrH = 0;
        if ((tableProps.addHeaderToEach || tableProps.autoPageRepeatHeader) && tableProps._arrObjTabHeadRows) {
          tableProps._arrObjTabHeadRows.forEach(function(row2) {
            var newHeadRow = [];
            var maxLineHeight = 0;
            row2.forEach(function(cell) {
              newHeadRow.push(cell);
              if (cell._lineHeight > maxLineHeight)
                maxLineHeight = cell._lineHeight;
            });
            newTableRowSlide.rows.push(newHeadRow);
            emuTabCurrH += maxLineHeight;
          });
        }
        tgtCell = currTableRow[currCellIdx];
      }
      var currLine = srcCell._lines.shift();
      if (Array.isArray(tgtCell.text)) {
        if (currLine)
          tgtCell.text = tgtCell.text.concat(currLine);
        else if (tgtCell.text.length === 0)
          tgtCell.text = tgtCell.text.concat({ _type: SLIDE_OBJECT_TYPES.tablecell, text: "" });
      }
      if (currCellIdx === rowCellLines.length - 1)
        emuTabCurrH += emuLineMaxH;
      currCellIdx = currCellIdx < rowCellLines.length - 1 ? currCellIdx + 1 : 0;
      var brent = rowCellLines.map(function(cell) {
        return cell._lines.length;
      }).reduce(function(prev, next) {
        return prev + next;
      });
      if (brent === 0)
        isDone = true;
    }
    if (currTableRow.length > 0)
      newTableRowSlide.rows.push(currTableRow);
    if (tableProps.verbose) {
      console.log("- SLIDE [".concat(tableRowSlides.length, "]: ROW [").concat(iRow, "]: ...COMPLETE ...... emuTabCurrH = ").concat((emuTabCurrH / EMU).toFixed(2), " ( emuSlideTabH = ").concat((emuSlideTabH / EMU).toFixed(2), " )"));
    }
  });
  tableRowSlides.push(newTableRowSlide);
  if (tableProps.verbose) {
    console.log(`
|================================================|`);
    console.log("| FINAL: tableRowSlides.length = ".concat(tableRowSlides.length));
    tableRowSlides.forEach(function(slide) {
      return console.log(slide);
    });
    console.log(`|================================================|

`);
  }
  return tableRowSlides;
}
function genTableToSlides(pptx, tabEleId, options2, masterSlide) {
  if (options2 === undefined) {
    options2 = {};
  }
  var opts = options2 || {};
  opts.slideMargin = opts.slideMargin || opts.slideMargin === 0 ? opts.slideMargin : 0.5;
  var emuSlideTabW = opts.w || pptx.presLayout.width;
  var arrObjTabHeadRows = [];
  var arrObjTabBodyRows = [];
  var arrObjTabFootRows = [];
  var arrColW = [];
  var arrTabColW = [];
  var arrInchMargins = [0.5, 0.5, 0.5, 0.5];
  var intTabW = 0;
  if (!document.getElementById(tabEleId))
    throw new Error('tableToSlides: Table ID "' + tabEleId + '" does not exist!');
  if (masterSlide === null || masterSlide === undefined ? undefined : masterSlide._margin) {
    if (Array.isArray(masterSlide._margin))
      arrInchMargins = masterSlide._margin;
    else if (!isNaN(masterSlide._margin))
      arrInchMargins = [masterSlide._margin, masterSlide._margin, masterSlide._margin, masterSlide._margin];
    opts.slideMargin = arrInchMargins;
  } else if (opts === null || opts === undefined ? undefined : opts.slideMargin) {
    if (Array.isArray(opts.slideMargin))
      arrInchMargins = opts.slideMargin;
    else if (!isNaN(opts.slideMargin))
      arrInchMargins = [opts.slideMargin, opts.slideMargin, opts.slideMargin, opts.slideMargin];
  }
  emuSlideTabW = (opts.w ? inch2Emu(opts.w) : pptx.presLayout.width) - inch2Emu(arrInchMargins[1] + arrInchMargins[3]);
  if (opts.verbose) {
    console.log("[[VERBOSE MODE]]");
    console.log("|-- `tableToSlides` ----------------------------------------------------|");
    console.log("| tableProps.h .................................... = ".concat(opts.h));
    console.log("| tableProps.w .................................... = ".concat(opts.w));
    console.log("| pptx.presLayout.width ........................... = ".concat((pptx.presLayout.width / EMU).toFixed(1)));
    console.log("| pptx.presLayout.height .......................... = ".concat((pptx.presLayout.height / EMU).toFixed(1)));
    console.log("| emuSlideTabW .................................... = ".concat((emuSlideTabW / EMU).toFixed(1)));
  }
  var firstRowCells = document.querySelectorAll("#".concat(tabEleId, " tr:first-child th"));
  if (firstRowCells.length === 0)
    firstRowCells = document.querySelectorAll("#".concat(tabEleId, " tr:first-child td"));
  firstRowCells.forEach(function(cell) {
    if (cell.getAttribute("colspan")) {
      for (var idxc = 0;idxc < Number(cell.getAttribute("colspan")); idxc++) {
        arrTabColW.push(Math.round(cell.offsetWidth / Number(cell.getAttribute("colspan"))));
      }
    } else {
      arrTabColW.push(cell.offsetWidth);
    }
  });
  arrTabColW.forEach(function(colW) {
    intTabW += colW;
  });
  arrTabColW.forEach(function(colW, idxW) {
    var intCalcWidth = Number((Number(emuSlideTabW) * (colW / intTabW * 100) / 100 / EMU).toFixed(2));
    var intMinWidth = 0;
    var colSelectorMin = document.querySelector("#".concat(tabEleId, " thead tr:first-child th:nth-child(").concat(idxW + 1, ")"));
    if (colSelectorMin)
      intMinWidth = Number(colSelectorMin.getAttribute("data-pptx-min-width"));
    var colSelectorSet = document.querySelector("#".concat(tabEleId, " thead tr:first-child th:nth-child(").concat(idxW + 1, ")"));
    if (colSelectorSet)
      intMinWidth = Number(colSelectorSet.getAttribute("data-pptx-width"));
    arrColW.push(intMinWidth > intCalcWidth ? intMinWidth : intCalcWidth);
  });
  if (opts.verbose) {
    console.log("| arrColW ......................................... = [".concat(arrColW.join(", "), "]"));
  }
  var tableParts = ["thead", "tbody", "tfoot"];
  tableParts.forEach(function(part) {
    document.querySelectorAll("#".concat(tabEleId, " ").concat(part, " tr")).forEach(function(row) {
      var arrObjTabCells = [];
      Array.from(row.cells).forEach(function(cell) {
        var arrRGB1 = window.getComputedStyle(cell).getPropertyValue("color").replace(/\s+/gi, "").replace("rgba(", "").replace("rgb(", "").replace(")", "").split(",");
        var arrRGB2 = window.getComputedStyle(cell).getPropertyValue("background-color").replace(/\s+/gi, "").replace("rgba(", "").replace("rgb(", "").replace(")", "").split(",");
        if (window.getComputedStyle(cell).getPropertyValue("background-color") === "rgba(0, 0, 0, 0)" || window.getComputedStyle(cell).getPropertyValue("transparent")) {
          arrRGB2 = ["255", "255", "255"];
        }
        var cellOpts = {
          align: null,
          bold: !!(window.getComputedStyle(cell).getPropertyValue("font-weight") === "bold" || Number(window.getComputedStyle(cell).getPropertyValue("font-weight")) >= 500),
          border: null,
          color: rgbToHex(Number(arrRGB1[0]), Number(arrRGB1[1]), Number(arrRGB1[2])),
          fill: { color: rgbToHex(Number(arrRGB2[0]), Number(arrRGB2[1]), Number(arrRGB2[2])) },
          fontFace: (window.getComputedStyle(cell).getPropertyValue("font-family") || "").split(",")[0].replace(/"/g, "").replace("inherit", "").replace("initial", "") || null,
          fontSize: Number(window.getComputedStyle(cell).getPropertyValue("font-size").replace(/[a-z]/gi, "")),
          margin: null,
          colspan: Number(cell.getAttribute("colspan")) || null,
          rowspan: Number(cell.getAttribute("rowspan")) || null,
          valign: null
        };
        if (["left", "center", "right", "start", "end"].includes(window.getComputedStyle(cell).getPropertyValue("text-align"))) {
          var align = window.getComputedStyle(cell).getPropertyValue("text-align").replace("start", "left").replace("end", "right");
          cellOpts.align = align === "center" ? "center" : align === "left" ? "left" : align === "right" ? "right" : null;
        }
        if (["top", "middle", "bottom"].includes(window.getComputedStyle(cell).getPropertyValue("vertical-align"))) {
          var valign = window.getComputedStyle(cell).getPropertyValue("vertical-align");
          cellOpts.valign = valign === "top" ? "top" : valign === "middle" ? "middle" : valign === "bottom" ? "bottom" : null;
        }
        if (window.getComputedStyle(cell).getPropertyValue("padding-left")) {
          cellOpts.margin = [0, 0, 0, 0];
          var sidesPad = ["padding-top", "padding-right", "padding-bottom", "padding-left"];
          sidesPad.forEach(function(val, idxs) {
            cellOpts.margin[idxs] = Math.round(Number(window.getComputedStyle(cell).getPropertyValue(val).replace(/\D/gi, "")));
          });
        }
        if (window.getComputedStyle(cell).getPropertyValue("border-top-width") || window.getComputedStyle(cell).getPropertyValue("border-right-width") || window.getComputedStyle(cell).getPropertyValue("border-bottom-width") || window.getComputedStyle(cell).getPropertyValue("border-left-width")) {
          cellOpts.border = [null, null, null, null];
          var sidesBor = ["top", "right", "bottom", "left"];
          sidesBor.forEach(function(val, idxb) {
            var intBorderW = Math.round(Number(window.getComputedStyle(cell).getPropertyValue("border-" + val + "-width").replace("px", "")));
            var arrRGB = [];
            arrRGB = window.getComputedStyle(cell).getPropertyValue("border-" + val + "-color").replace(/\s+/gi, "").replace("rgba(", "").replace("rgb(", "").replace(")", "").split(",");
            var strBorderC = rgbToHex(Number(arrRGB[0]), Number(arrRGB[1]), Number(arrRGB[2]));
            cellOpts.border[idxb] = { pt: intBorderW, color: strBorderC };
          });
        }
        arrObjTabCells.push({
          _type: SLIDE_OBJECT_TYPES.tablecell,
          text: cell.innerText,
          options: cellOpts
        });
      });
      switch (part) {
        case "thead":
          arrObjTabHeadRows.push(arrObjTabCells);
          break;
        case "tbody":
          arrObjTabBodyRows.push(arrObjTabCells);
          break;
        case "tfoot":
          arrObjTabFootRows.push(arrObjTabCells);
          break;
        default:
          console.log("table parsing: unexpected table part: ".concat(part));
          break;
      }
    });
  });
  opts._arrObjTabHeadRows = arrObjTabHeadRows || null;
  opts.colW = arrColW;
  getSlidesForTableRows(__spreadArray2(__spreadArray2(__spreadArray2([], arrObjTabHeadRows, true), arrObjTabBodyRows, true), arrObjTabFootRows, true), opts, pptx.presLayout, masterSlide).forEach(function(slide, idxTr) {
    var newSlide = pptx.addSlide({ masterName: opts.masterSlideName || null });
    if (idxTr === 0)
      opts.y = opts.y || arrInchMargins[0];
    if (idxTr > 0)
      opts.y = opts.autoPageSlideStartY || opts.newSlideStartY || arrInchMargins[0];
    if (opts.verbose)
      console.log("| opts.autoPageSlideStartY: ".concat(opts.autoPageSlideStartY, " / arrInchMargins[0]: ").concat(arrInchMargins[0], " => opts.y = ").concat(opts.y));
    newSlide.addTable(slide.rows, { x: opts.x || arrInchMargins[3], y: opts.y, w: Number(emuSlideTabW) / EMU, colW: arrColW, autoPage: false });
    if (opts.addImage) {
      opts.addImage.options = opts.addImage.options || {};
      if (!opts.addImage.image || !opts.addImage.image.path && !opts.addImage.image.data) {
        console.warn("Warning: tableToSlides.addImage requires either `path` or `data`");
      } else {
        newSlide.addImage({
          path: opts.addImage.image.path,
          data: opts.addImage.image.data,
          x: opts.addImage.options.x,
          y: opts.addImage.options.y,
          w: opts.addImage.options.w,
          h: opts.addImage.options.h
        });
      }
    }
    if (opts.addShape)
      newSlide.addShape(opts.addShape.shapeName, opts.addShape.options || {});
    if (opts.addTable)
      newSlide.addTable(opts.addTable.rows, opts.addTable.options || {});
    if (opts.addText)
      newSlide.addText(opts.addText.text, opts.addText.options || {});
  });
}
function createSlideMaster(props, target) {
  if (props.bkgd)
    target.bkgd = props.bkgd;
  if (props.objects && Array.isArray(props.objects) && props.objects.length > 0) {
    props.objects.forEach(function(object, idx) {
      var key = Object.keys(object)[0];
      var tgt = target;
      if (MASTER_OBJECTS[key] && key === "chart")
        addChartDefinition(tgt, object[key].type, object[key].data, object[key].opts);
      else if (MASTER_OBJECTS[key] && key === "image")
        addImageDefinition(tgt, object[key]);
      else if (MASTER_OBJECTS[key] && key === "line")
        addShapeDefinition(tgt, SHAPE_TYPE.LINE, object[key]);
      else if (MASTER_OBJECTS[key] && key === "rect")
        addShapeDefinition(tgt, SHAPE_TYPE.RECTANGLE, object[key]);
      else if (MASTER_OBJECTS[key] && key === "text")
        addTextDefinition(tgt, [{ text: object[key].text }], object[key].options, false);
      else if (MASTER_OBJECTS[key] && key === "placeholder") {
        object[key].options.placeholder = object[key].options.name;
        delete object[key].options.name;
        object[key].options._placeholderType = object[key].options.type;
        delete object[key].options.type;
        object[key].options._placeholderIdx = 100 + idx;
        addTextDefinition(tgt, [{ text: object[key].text }], object[key].options, true);
      }
    });
  }
  if (props.slideNumber && typeof props.slideNumber === "object")
    target._slideNumberProps = props.slideNumber;
}
function addChartDefinition(target, type, data, opt) {
  var _a;
  function correctGridLineOptions(glOpts) {
    if (!glOpts || glOpts.style === "none")
      return;
    if (glOpts.size !== undefined && (isNaN(Number(glOpts.size)) || glOpts.size <= 0)) {
      console.warn("Warning: chart.gridLine.size must be greater than 0.");
      delete glOpts.size;
    }
    if (glOpts.style && !["solid", "dash", "dot"].includes(glOpts.style)) {
      console.warn("Warning: chart.gridLine.style options: `solid`, `dash`, `dot`.");
      delete glOpts.style;
    }
    if (glOpts.cap && !["flat", "square", "round"].includes(glOpts.cap)) {
      console.warn("Warning: chart.gridLine.cap options: `flat`, `square`, `round`.");
      delete glOpts.cap;
    }
  }
  var chartId = ++_chartCounter;
  var resultObject = {
    _type: null,
    text: null,
    options: null,
    chartRid: null
  };
  var tmpOpt = null;
  var tmpData = [];
  if (Array.isArray(type)) {
    type.forEach(function(obj) {
      tmpData = tmpData.concat(obj.data);
    });
    tmpOpt = data || opt;
  } else {
    tmpData = data;
    tmpOpt = opt;
  }
  tmpData.forEach(function(item, i4) {
    item._dataIndex = i4;
    if (item.labels !== undefined && !Array.isArray(item.labels[0])) {
      item.labels = [item.labels];
    }
  });
  var options2 = tmpOpt && typeof tmpOpt === "object" ? tmpOpt : {};
  options2._type = type;
  options2.x = typeof options2.x !== "undefined" && options2.x != null && !isNaN(Number(options2.x)) ? options2.x : 1;
  options2.y = typeof options2.y !== "undefined" && options2.y != null && !isNaN(Number(options2.y)) ? options2.y : 1;
  options2.w = options2.w || "50%";
  options2.h = options2.h || "50%";
  options2.objectName = options2.objectName ? encodeXmlEntities(options2.objectName) : "Chart ".concat(target._slideObjects.filter(function(obj) {
    return obj._type === SLIDE_OBJECT_TYPES.chart;
  }).length);
  if (!["bar", "col"].includes(options2.barDir || ""))
    options2.barDir = "col";
  if (options2._type === CHART_TYPE.AREA) {
    if (!["stacked", "standard", "percentStacked"].includes(options2.barGrouping || ""))
      options2.barGrouping = "standard";
  }
  if (options2._type === CHART_TYPE.BAR) {
    if (!["clustered", "stacked", "percentStacked"].includes(options2.barGrouping || ""))
      options2.barGrouping = "clustered";
  }
  if (options2._type === CHART_TYPE.BAR3D) {
    if (!["clustered", "stacked", "standard", "percentStacked"].includes(options2.barGrouping || ""))
      options2.barGrouping = "standard";
  }
  if ((_a = options2.barGrouping) === null || _a === undefined ? undefined : _a.includes("tacked")) {
    if (!options2.barGapWidthPct)
      options2.barGapWidthPct = 50;
  }
  if (options2.dataLabelPosition) {
    if (options2._type === CHART_TYPE.AREA || options2._type === CHART_TYPE.BAR3D || options2._type === CHART_TYPE.DOUGHNUT || options2._type === CHART_TYPE.RADAR) {
      delete options2.dataLabelPosition;
    }
    if (options2._type === CHART_TYPE.PIE) {
      if (!["bestFit", "ctr", "inEnd", "outEnd"].includes(options2.dataLabelPosition))
        delete options2.dataLabelPosition;
    }
    if (options2._type === CHART_TYPE.BUBBLE || options2._type === CHART_TYPE.BUBBLE3D || options2._type === CHART_TYPE.LINE || options2._type === CHART_TYPE.SCATTER) {
      if (!["b", "ctr", "l", "r", "t"].includes(options2.dataLabelPosition))
        delete options2.dataLabelPosition;
    }
    if (options2._type === CHART_TYPE.BAR) {
      if (!["stacked", "percentStacked"].includes(options2.barGrouping || "")) {
        if (!["ctr", "inBase", "inEnd"].includes(options2.dataLabelPosition))
          delete options2.dataLabelPosition;
      }
      if (!["clustered"].includes(options2.barGrouping || "")) {
        if (!["ctr", "inBase", "inEnd", "outEnd"].includes(options2.dataLabelPosition))
          delete options2.dataLabelPosition;
      }
    }
  }
  options2.dataLabelBkgrdColors = options2.dataLabelBkgrdColors || !options2.dataLabelBkgrdColors ? options2.dataLabelBkgrdColors : false;
  if (!["b", "l", "r", "t", "tr"].includes(options2.legendPos || ""))
    options2.legendPos = "r";
  if (!["cone", "coneToMax", "box", "cylinder", "pyramid", "pyramidToMax"].includes(options2.bar3DShape || ""))
    options2.bar3DShape = "box";
  if (!["circle", "dash", "diamond", "dot", "none", "square", "triangle"].includes(options2.lineDataSymbol || ""))
    options2.lineDataSymbol = "circle";
  if (!["gap", "span"].includes(options2.displayBlanksAs || ""))
    options2.displayBlanksAs = "span";
  if (!["standard", "marker", "filled"].includes(options2.radarStyle || ""))
    options2.radarStyle = "standard";
  options2.lineDataSymbolSize = options2.lineDataSymbolSize && !isNaN(options2.lineDataSymbolSize) ? options2.lineDataSymbolSize : 6;
  options2.lineDataSymbolLineSize = options2.lineDataSymbolLineSize && !isNaN(options2.lineDataSymbolLineSize) ? valToPts(options2.lineDataSymbolLineSize) : valToPts(0.75);
  if (options2.layout) {
    ["x", "y", "w", "h"].forEach(function(key) {
      var val = options2.layout[key];
      if (isNaN(Number(val)) || val < 0 || val > 1) {
        console.warn("Warning: chart.layout." + key + " can only be 0-1");
        delete options2.layout[key];
      }
    });
  }
  options2.catGridLine = options2.catGridLine || (options2._type === CHART_TYPE.SCATTER ? { color: "D9D9D9", size: 1 } : { style: "none" });
  options2.valGridLine = options2.valGridLine || (options2._type === CHART_TYPE.SCATTER ? { color: "D9D9D9", size: 1 } : {});
  options2.serGridLine = options2.serGridLine || (options2._type === CHART_TYPE.SCATTER ? { color: "D9D9D9", size: 1 } : { style: "none" });
  correctGridLineOptions(options2.catGridLine);
  correctGridLineOptions(options2.valGridLine);
  correctGridLineOptions(options2.serGridLine);
  correctShadowOptions(options2.shadow);
  options2.showDataTable = options2.showDataTable || !options2.showDataTable ? options2.showDataTable : false;
  options2.showDataTableHorzBorder = options2.showDataTableHorzBorder || !options2.showDataTableHorzBorder ? options2.showDataTableHorzBorder : true;
  options2.showDataTableVertBorder = options2.showDataTableVertBorder || !options2.showDataTableVertBorder ? options2.showDataTableVertBorder : true;
  options2.showDataTableOutline = options2.showDataTableOutline || !options2.showDataTableOutline ? options2.showDataTableOutline : true;
  options2.showDataTableKeys = options2.showDataTableKeys || !options2.showDataTableKeys ? options2.showDataTableKeys : true;
  options2.showLabel = options2.showLabel || !options2.showLabel ? options2.showLabel : false;
  options2.showLegend = options2.showLegend || !options2.showLegend ? options2.showLegend : false;
  options2.showPercent = options2.showPercent || !options2.showPercent ? options2.showPercent : true;
  options2.showTitle = options2.showTitle || !options2.showTitle ? options2.showTitle : false;
  options2.showValue = options2.showValue || !options2.showValue ? options2.showValue : false;
  options2.showLeaderLines = options2.showLeaderLines || !options2.showLeaderLines ? options2.showLeaderLines : false;
  options2.catAxisLineShow = typeof options2.catAxisLineShow !== "undefined" ? options2.catAxisLineShow : true;
  options2.valAxisLineShow = typeof options2.valAxisLineShow !== "undefined" ? options2.valAxisLineShow : true;
  options2.serAxisLineShow = typeof options2.serAxisLineShow !== "undefined" ? options2.serAxisLineShow : true;
  options2.v3DRotX = !isNaN(options2.v3DRotX) && options2.v3DRotX >= -90 && options2.v3DRotX <= 90 ? options2.v3DRotX : 30;
  options2.v3DRotY = !isNaN(options2.v3DRotY) && options2.v3DRotY >= 0 && options2.v3DRotY <= 360 ? options2.v3DRotY : 30;
  options2.v3DRAngAx = options2.v3DRAngAx || !options2.v3DRAngAx ? options2.v3DRAngAx : true;
  options2.v3DPerspective = !isNaN(options2.v3DPerspective) && options2.v3DPerspective >= 0 && options2.v3DPerspective <= 240 ? options2.v3DPerspective : 30;
  options2.barGapWidthPct = !isNaN(options2.barGapWidthPct) && options2.barGapWidthPct >= 0 && options2.barGapWidthPct <= 1000 ? options2.barGapWidthPct : 150;
  options2.barGapDepthPct = !isNaN(options2.barGapDepthPct) && options2.barGapDepthPct >= 0 && options2.barGapDepthPct <= 1000 ? options2.barGapDepthPct : 150;
  options2.chartColors = Array.isArray(options2.chartColors) ? options2.chartColors : options2._type === CHART_TYPE.PIE || options2._type === CHART_TYPE.DOUGHNUT ? PIECHART_COLORS : BARCHART_COLORS;
  options2.chartColorsOpacity = options2.chartColorsOpacity && !isNaN(options2.chartColorsOpacity) ? options2.chartColorsOpacity : null;
  options2.border = options2.border && typeof options2.border === "object" ? options2.border : null;
  if (options2.border && (!options2.border.pt || isNaN(options2.border.pt)))
    options2.border.pt = DEF_CHART_BORDER.pt;
  if (options2.border && (!options2.border.color || typeof options2.border.color !== "string"))
    options2.border.color = DEF_CHART_BORDER.color;
  options2.plotArea = options2.plotArea || {};
  options2.plotArea.border = options2.plotArea.border && typeof options2.plotArea.border === "object" ? options2.plotArea.border : null;
  if (options2.plotArea.border && (!options2.plotArea.border.pt || isNaN(options2.plotArea.border.pt)))
    options2.plotArea.border.pt = DEF_CHART_BORDER.pt;
  if (options2.plotArea.border && (!options2.plotArea.border.color || typeof options2.plotArea.border.color !== "string")) {
    options2.plotArea.border.color = DEF_CHART_BORDER.color;
  }
  if (options2.border)
    options2.plotArea.border = options2.border;
  options2.plotArea.fill = options2.plotArea.fill || { color: null, transparency: null };
  if (options2.fill)
    options2.plotArea.fill.color = options2.fill;
  options2.chartArea = options2.chartArea || {};
  options2.chartArea.border = options2.chartArea.border && typeof options2.chartArea.border === "object" ? options2.chartArea.border : null;
  if (options2.chartArea.border) {
    options2.chartArea.border = {
      color: options2.chartArea.border.color || DEF_CHART_BORDER.color,
      pt: options2.chartArea.border.pt || DEF_CHART_BORDER.pt
    };
  }
  options2.chartArea.roundedCorners = typeof options2.chartArea.roundedCorners === "boolean" ? options2.chartArea.roundedCorners : true;
  options2.dataBorder = options2.dataBorder && typeof options2.dataBorder === "object" ? options2.dataBorder : null;
  if (options2.dataBorder && (!options2.dataBorder.pt || isNaN(options2.dataBorder.pt)))
    options2.dataBorder.pt = 0.75;
  if (options2.dataBorder && (!options2.dataBorder.color || typeof options2.dataBorder.color !== "string" || options2.dataBorder.color.length !== 6)) {
    options2.dataBorder.color = "F9F9F9";
  }
  if (!options2.dataLabelFormatCode && options2._type === CHART_TYPE.SCATTER)
    options2.dataLabelFormatCode = "General";
  if (!options2.dataLabelFormatCode && (options2._type === CHART_TYPE.PIE || options2._type === CHART_TYPE.DOUGHNUT)) {
    options2.dataLabelFormatCode = options2.showPercent ? "0%" : "General";
  }
  options2.dataLabelFormatCode = options2.dataLabelFormatCode && typeof options2.dataLabelFormatCode === "string" ? options2.dataLabelFormatCode : "#,##0";
  if (!options2.dataLabelFormatScatter && options2._type === CHART_TYPE.SCATTER)
    options2.dataLabelFormatScatter = "custom";
  options2.lineSize = typeof options2.lineSize === "number" ? options2.lineSize : 2;
  options2.valAxisMajorUnit = typeof options2.valAxisMajorUnit === "number" ? options2.valAxisMajorUnit : null;
  if (options2._type === CHART_TYPE.AREA || options2._type === CHART_TYPE.BAR || options2._type === CHART_TYPE.BAR3D || options2._type === CHART_TYPE.LINE) {
    options2.catAxisMultiLevelLabels = !!options2.catAxisMultiLevelLabels;
  } else {
    delete options2.catAxisMultiLevelLabels;
  }
  resultObject._type = "chart";
  resultObject.options = options2;
  resultObject.chartRid = getNewRelId(target);
  target._relsChart.push({
    rId: getNewRelId(target),
    data: tmpData,
    opts: options2,
    type: options2._type,
    globalId: chartId,
    fileName: "chart".concat(chartId, ".xml"),
    Target: "/ppt/charts/chart".concat(chartId, ".xml")
  });
  target._slideObjects.push(resultObject);
  return resultObject;
}
function addImageDefinition(target, opt) {
  var newObject = {
    _type: null,
    text: null,
    options: null,
    image: null,
    imageRid: null,
    hyperlink: null
  };
  var intPosX = opt.x || 0;
  var intPosY = opt.y || 0;
  var intWidth = opt.w || 0;
  var intHeight = opt.h || 0;
  var sizing = opt.sizing || null;
  var objHyperlink = opt.hyperlink || "";
  var strImageData = opt.data || "";
  var strImagePath = opt.path || "";
  var imageRelId = getNewRelId(target);
  var objectName = opt.objectName ? encodeXmlEntities(opt.objectName) : "Image ".concat(target._slideObjects.filter(function(obj) {
    return obj._type === SLIDE_OBJECT_TYPES.image;
  }).length);
  if (!strImagePath && !strImageData) {
    console.error("ERROR: addImage() requires either 'data' or 'path' parameter!");
    return null;
  } else if (strImagePath && typeof strImagePath !== "string") {
    console.error("ERROR: addImage() 'path' should be a string, ex: {path:'/img/sample.png'} - you sent ".concat(String(strImagePath)));
    return null;
  } else if (strImageData && typeof strImageData !== "string") {
    console.error("ERROR: addImage() 'data' should be a string, ex: {data:'image/png;base64,NMP[...]'} - you sent ".concat(String(strImageData)));
    return null;
  } else if (strImageData && typeof strImageData === "string" && !strImageData.toLowerCase().includes("base64,")) {
    console.error("ERROR: Image `data` value lacks a base64 header! Ex: 'image/png;base64,NMP[...]')");
    return null;
  }
  var strImgExtn = (strImagePath.substring(strImagePath.lastIndexOf("/") + 1).split("?")[0].split(".").pop().split("#")[0] || "png").toLowerCase();
  if (strImageData && /image\/(\w+);/.exec(strImageData) && /image\/(\w+);/.exec(strImageData).length > 0) {
    strImgExtn = /image\/(\w+);/.exec(strImageData)[1];
  } else if (strImageData === null || strImageData === undefined ? undefined : strImageData.toLowerCase().includes("image/svg+xml")) {
    strImgExtn = "svg";
  }
  newObject._type = SLIDE_OBJECT_TYPES.image;
  newObject.image = strImagePath || "preencoded.png";
  newObject.options = {
    x: intPosX || 0,
    y: intPosY || 0,
    w: intWidth || 1,
    h: intHeight || 1,
    altText: opt.altText || "",
    rounding: typeof opt.rounding === "boolean" ? opt.rounding : false,
    sizing,
    placeholder: opt.placeholder,
    rotate: opt.rotate || 0,
    flipV: opt.flipV || false,
    flipH: opt.flipH || false,
    transparency: opt.transparency || 0,
    objectName,
    shadow: correctShadowOptions(opt.shadow)
  };
  if (strImgExtn === "svg") {
    target._relsMedia.push({
      path: strImagePath || strImageData + "png",
      type: "image/png",
      extn: "png",
      data: strImageData || "",
      rId: imageRelId,
      Target: "../media/image-".concat(target._slideNum, "-").concat(target._relsMedia.length + 1, ".png"),
      isSvgPng: true,
      svgSize: { w: getSmartParseNumber(newObject.options.w, "X", target._presLayout), h: getSmartParseNumber(newObject.options.h, "Y", target._presLayout) }
    });
    newObject.imageRid = imageRelId;
    target._relsMedia.push({
      path: strImagePath || strImageData,
      type: "image/svg+xml",
      extn: strImgExtn,
      data: strImageData || "",
      rId: imageRelId + 1,
      Target: "../media/image-".concat(target._slideNum, "-").concat(target._relsMedia.length + 1, ".").concat(strImgExtn)
    });
    newObject.imageRid = imageRelId + 1;
  } else {
    var dupeItem = target._relsMedia.filter(function(item) {
      return item.path && item.path === strImagePath && item.type === "image/" + strImgExtn && !item.isDuplicate;
    })[0];
    target._relsMedia.push({
      path: strImagePath || "preencoded." + strImgExtn,
      type: "image/" + strImgExtn,
      extn: strImgExtn,
      data: strImageData || "",
      rId: imageRelId,
      isDuplicate: !!(dupeItem === null || dupeItem === undefined ? undefined : dupeItem.Target),
      Target: (dupeItem === null || dupeItem === undefined ? undefined : dupeItem.Target) ? dupeItem.Target : "../media/image-".concat(target._slideNum, "-").concat(target._relsMedia.length + 1, ".").concat(strImgExtn)
    });
    newObject.imageRid = imageRelId;
  }
  if (typeof objHyperlink === "object") {
    if (!objHyperlink.url && !objHyperlink.slide)
      throw new Error("ERROR: `hyperlink` option requires either: `url` or `slide`");
    else {
      imageRelId++;
      target._rels.push({
        type: SLIDE_OBJECT_TYPES.hyperlink,
        data: objHyperlink.slide ? "slide" : "dummy",
        rId: imageRelId,
        Target: objHyperlink.url || objHyperlink.slide.toString()
      });
      objHyperlink._rId = imageRelId;
      newObject.hyperlink = objHyperlink;
    }
  }
  target._slideObjects.push(newObject);
}
function addMediaDefinition(target, opt) {
  var intPosX = opt.x || 0;
  var intPosY = opt.y || 0;
  var intSizeX = opt.w || 2;
  var intSizeY = opt.h || 2;
  var strData = opt.data || "";
  var strLink = opt.link || "";
  var strPath = opt.path || "";
  var strType = opt.type || "audio";
  var strExtn = "";
  var strCover = opt.cover || IMG_PLAYBTN;
  var objectName = opt.objectName ? encodeXmlEntities(opt.objectName) : "Media ".concat(target._slideObjects.filter(function(obj) {
    return obj._type === SLIDE_OBJECT_TYPES.media;
  }).length);
  var slideData = { _type: SLIDE_OBJECT_TYPES.media };
  if (!strPath && !strData && strType !== "online") {
    throw new Error("addMedia() error: either `data` or `path` are required!");
  } else if (strData && !strData.toLowerCase().includes("base64,")) {
    throw new Error("addMedia() error: `data` value lacks a base64 header! Ex: 'video/mpeg;base64,NMP[...]')");
  } else if (strCover && !strCover.toLowerCase().includes("base64,")) {
    throw new Error("addMedia() error: `cover` value lacks a base64 header! Ex: 'data:image/png;base64,iV[...]')");
  }
  if (strType === "online" && !strLink) {
    throw new Error("addMedia() error: online videos require `link` value");
  }
  strExtn = opt.extn || (strData ? strData.split(";")[0].split("/")[1] : strPath.split(".").pop()) || "mp3";
  slideData.mtype = strType;
  slideData.media = strPath || "preencoded.mov";
  slideData.options = {};
  slideData.options.x = intPosX;
  slideData.options.y = intPosY;
  slideData.options.w = intSizeX;
  slideData.options.h = intSizeY;
  slideData.options.objectName = objectName;
  if (strType === "online") {
    var relId1 = getNewRelId(target);
    target._relsMedia.push({
      path: strPath || "preencoded" + strExtn,
      data: "dummy",
      type: "online",
      extn: strExtn,
      rId: relId1,
      Target: strLink
    });
    slideData.mediaRid = relId1;
    target._relsMedia.push({
      path: "preencoded.png",
      data: strCover,
      type: "image/png",
      extn: "png",
      rId: getNewRelId(target),
      Target: "../media/image-".concat(target._slideNum, "-").concat(target._relsMedia.length + 1, ".png")
    });
  } else {
    var dupeItem = target._relsMedia.filter(function(item) {
      return item.path && item.path === strPath && item.type === strType + "/" + strExtn && !item.isDuplicate;
    })[0];
    var relId1 = getNewRelId(target);
    target._relsMedia.push({
      path: strPath || "preencoded" + strExtn,
      type: strType + "/" + strExtn,
      extn: strExtn,
      data: strData || "",
      rId: relId1,
      isDuplicate: !!(dupeItem === null || dupeItem === undefined ? undefined : dupeItem.Target),
      Target: (dupeItem === null || dupeItem === undefined ? undefined : dupeItem.Target) ? dupeItem.Target : "../media/media-".concat(target._slideNum, "-").concat(target._relsMedia.length + 1, ".").concat(strExtn)
    });
    slideData.mediaRid = relId1;
    target._relsMedia.push({
      path: strPath || "preencoded" + strExtn,
      type: strType + "/" + strExtn,
      extn: strExtn,
      data: strData || "",
      rId: getNewRelId(target),
      isDuplicate: !!(dupeItem === null || dupeItem === undefined ? undefined : dupeItem.Target),
      Target: (dupeItem === null || dupeItem === undefined ? undefined : dupeItem.Target) ? dupeItem.Target : "../media/media-".concat(target._slideNum, "-").concat(target._relsMedia.length + 0, ".").concat(strExtn)
    });
    target._relsMedia.push({
      path: "preencoded.png",
      type: "image/png",
      extn: "png",
      data: strCover,
      rId: getNewRelId(target),
      Target: "../media/image-".concat(target._slideNum, "-").concat(target._relsMedia.length + 1, ".png")
    });
  }
  target._slideObjects.push(slideData);
}
function addNotesDefinition(target, notes) {
  target._slideObjects.push({
    _type: SLIDE_OBJECT_TYPES.notes,
    text: [{ text: notes }]
  });
}
function addShapeDefinition(target, shapeName, opts) {
  var options2 = typeof opts === "object" ? opts : {};
  options2.line = options2.line || { type: "none" };
  var newObject = {
    _type: SLIDE_OBJECT_TYPES.text,
    shape: shapeName || SHAPE_TYPE.RECTANGLE,
    options: options2,
    text: null
  };
  if (!shapeName)
    throw new Error("Missing/Invalid shape parameter! Example: `addShape(pptxgen.shapes.LINE, {x:1, y:1, w:1, h:1});`");
  var newLineOpts = {
    type: options2.line.type || "solid",
    color: options2.line.color || DEF_SHAPE_LINE_COLOR,
    transparency: options2.line.transparency || 0,
    width: options2.line.width || 1,
    dashType: options2.line.dashType || "solid",
    beginArrowType: options2.line.beginArrowType || null,
    endArrowType: options2.line.endArrowType || null
  };
  if (typeof options2.line === "object" && options2.line.type !== "none")
    options2.line = newLineOpts;
  options2.x = options2.x || (options2.x === 0 ? 0 : 1);
  options2.y = options2.y || (options2.y === 0 ? 0 : 1);
  options2.w = options2.w || (options2.w === 0 ? 0 : 1);
  options2.h = options2.h || (options2.h === 0 ? 0 : 1);
  options2.objectName = options2.objectName ? encodeXmlEntities(options2.objectName) : "Shape ".concat(target._slideObjects.filter(function(obj) {
    return obj._type === SLIDE_OBJECT_TYPES.text;
  }).length);
  if (typeof options2.line === "string") {
    var tmpOpts = newLineOpts;
    tmpOpts.color = String(options2.line);
    options2.line = tmpOpts;
  }
  if (typeof options2.lineSize === "number")
    options2.line.width = options2.lineSize;
  if (typeof options2.lineDash === "string")
    options2.line.dashType = options2.lineDash;
  if (typeof options2.lineHead === "string")
    options2.line.beginArrowType = options2.lineHead;
  if (typeof options2.lineTail === "string")
    options2.line.endArrowType = options2.lineTail;
  createHyperlinkRels(target, newObject);
  target._slideObjects.push(newObject);
}
function addTableDefinition(target, tableRows, options2, slideLayout, presLayout, addSlide, getSlide) {
  var slides = [target];
  var opt = options2 && typeof options2 === "object" ? options2 : {};
  opt.objectName = opt.objectName ? encodeXmlEntities(opt.objectName) : "Table ".concat(target._slideObjects.filter(function(obj) {
    return obj._type === SLIDE_OBJECT_TYPES.table;
  }).length);
  {
    if (tableRows === null || tableRows.length === 0 || !Array.isArray(tableRows)) {
      throw new Error("addTable: Array expected! EX: 'slide.addTable( [rows], {options} );' (https://gitbrent.github.io/PptxGenJS/docs/api-tables.html)");
    }
    if (!tableRows[0] || !Array.isArray(tableRows[0])) {
      throw new Error("addTable: 'rows' should be an array of cells! EX: 'slide.addTable( [ ['A'], ['B'], {text:'C',options:{align:'center'}} ] );' (https://gitbrent.github.io/PptxGenJS/docs/api-tables.html)");
    }
  }
  var arrRows = [];
  tableRows.forEach(function(row) {
    var newRow = [];
    if (Array.isArray(row)) {
      row.forEach(function(cell) {
        var newCell = {
          _type: SLIDE_OBJECT_TYPES.tablecell,
          text: "",
          options: typeof cell === "object" && cell.options ? cell.options : {}
        };
        if (typeof cell === "string" || typeof cell === "number")
          newCell.text = cell.toString();
        else if (cell.text) {
          if (typeof cell.text === "string" || typeof cell.text === "number")
            newCell.text = cell.text.toString();
          else if (cell.text)
            newCell.text = cell.text;
          if (cell.options && typeof cell.options === "object")
            newCell.options = cell.options;
        }
        newCell.options.border = newCell.options.border || opt.border || [{ type: "none" }, { type: "none" }, { type: "none" }, { type: "none" }];
        var cellBorder = newCell.options.border;
        if (!Array.isArray(cellBorder) && typeof cellBorder === "object")
          newCell.options.border = [cellBorder, cellBorder, cellBorder, cellBorder];
        if (!newCell.options.border[0])
          newCell.options.border[0] = { type: "none" };
        if (!newCell.options.border[1])
          newCell.options.border[1] = { type: "none" };
        if (!newCell.options.border[2])
          newCell.options.border[2] = { type: "none" };
        if (!newCell.options.border[3])
          newCell.options.border[3] = { type: "none" };
        var arrSides = [0, 1, 2, 3];
        arrSides.forEach(function(idx) {
          newCell.options.border[idx] = {
            type: newCell.options.border[idx].type || DEF_CELL_BORDER.type,
            color: newCell.options.border[idx].color || DEF_CELL_BORDER.color,
            pt: typeof newCell.options.border[idx].pt === "number" ? newCell.options.border[idx].pt : DEF_CELL_BORDER.pt
          };
        });
        newRow.push(newCell);
      });
    } else {
      console.log("addTable: tableRows has a bad row. A row should be an array of cells. You provided:");
      console.log(row);
    }
    arrRows.push(newRow);
  });
  opt.x = getSmartParseNumber(opt.x || (opt.x === 0 ? 0 : EMU / 2), "X", presLayout);
  opt.y = getSmartParseNumber(opt.y || (opt.y === 0 ? 0 : EMU / 2), "Y", presLayout);
  if (opt.h)
    opt.h = getSmartParseNumber(opt.h, "Y", presLayout);
  opt.fontSize = opt.fontSize || DEF_FONT_SIZE;
  opt.margin = opt.margin === 0 || opt.margin ? opt.margin : DEF_CELL_MARGIN_IN;
  if (typeof opt.margin === "number")
    opt.margin = [Number(opt.margin), Number(opt.margin), Number(opt.margin), Number(opt.margin)];
  if (!opt.color)
    opt.color = opt.color || DEF_FONT_COLOR;
  if (typeof opt.border === "string") {
    console.warn("addTable `border` option must be an object. Ex: `{border: {type:'none'}}`");
    opt.border = null;
  } else if (Array.isArray(opt.border)) {
    [0, 1, 2, 3].forEach(function(idx) {
      opt.border[idx] = opt.border[idx] ? { type: opt.border[idx].type || DEF_CELL_BORDER.type, color: opt.border[idx].color || DEF_CELL_BORDER.color, pt: opt.border[idx].pt || DEF_CELL_BORDER.pt } : { type: "none" };
    });
  }
  opt.autoPage = typeof opt.autoPage === "boolean" ? opt.autoPage : false;
  opt.autoPageRepeatHeader = typeof opt.autoPageRepeatHeader === "boolean" ? opt.autoPageRepeatHeader : false;
  opt.autoPageHeaderRows = typeof opt.autoPageHeaderRows !== "undefined" && !isNaN(Number(opt.autoPageHeaderRows)) ? Number(opt.autoPageHeaderRows) : 1;
  opt.autoPageLineWeight = typeof opt.autoPageLineWeight !== "undefined" && !isNaN(Number(opt.autoPageLineWeight)) ? Number(opt.autoPageLineWeight) : 0;
  if (opt.autoPageLineWeight) {
    if (opt.autoPageLineWeight > 1)
      opt.autoPageLineWeight = 1;
    else if (opt.autoPageLineWeight < -1)
      opt.autoPageLineWeight = -1;
  }
  var arrTableMargin = DEF_SLIDE_MARGIN_IN;
  if (slideLayout && typeof slideLayout._margin !== "undefined") {
    if (Array.isArray(slideLayout._margin))
      arrTableMargin = slideLayout._margin;
    else if (!isNaN(Number(slideLayout._margin))) {
      arrTableMargin = [Number(slideLayout._margin), Number(slideLayout._margin), Number(slideLayout._margin), Number(slideLayout._margin)];
    }
  }
  if (opt.colW) {
    var firstRowColCnt = arrRows[0].reduce(function(totalLen, c3) {
      var _a;
      if (((_a = c3 === null || c3 === undefined ? undefined : c3.options) === null || _a === undefined ? undefined : _a.colspan) && typeof c3.options.colspan === "number") {
        totalLen += c3.options.colspan;
      } else {
        totalLen += 1;
      }
      return totalLen;
    }, 0);
    if (typeof opt.colW === "string" || typeof opt.colW === "number") {
      opt.w = Math.floor(Number(opt.colW) * firstRowColCnt);
      opt.colW = null;
    } else if (opt.colW && Array.isArray(opt.colW) && opt.colW.length === 1 && firstRowColCnt > 1) {
      opt.w = Math.floor(Number(opt.colW) * firstRowColCnt);
      opt.colW = null;
    } else if (opt.colW && Array.isArray(opt.colW) && opt.colW.length !== firstRowColCnt) {
      console.warn("addTable: mismatch: (colW.length != data.length) Therefore, defaulting to evenly distributed col widths.");
      opt.colW = null;
    }
  } else if (opt.w) {
    opt.w = getSmartParseNumber(opt.w, "X", presLayout);
  } else {
    opt.w = Math.floor(presLayout._sizeW / EMU - arrTableMargin[1] - arrTableMargin[3]);
  }
  if (opt.x && opt.x < 20)
    opt.x = inch2Emu(opt.x);
  if (opt.y && opt.y < 20)
    opt.y = inch2Emu(opt.y);
  if (opt.w && opt.w < 20)
    opt.w = inch2Emu(opt.w);
  if (opt.h && opt.h < 20)
    opt.h = inch2Emu(opt.h);
  arrRows.forEach(function(row) {
    row.forEach(function(cell, idy) {
      if (typeof cell === "number" || typeof cell === "string") {
        row[idy] = { _type: SLIDE_OBJECT_TYPES.tablecell, text: String(row[idy]), options: opt };
      } else if (typeof cell === "object") {
        if (typeof cell.text === "number")
          row[idy].text = row[idy].text.toString();
        else if (typeof cell.text === "undefined" || cell.text === null)
          row[idy].text = "";
        row[idy].options = cell.options || {};
        row[idy]._type = SLIDE_OBJECT_TYPES.tablecell;
      }
    });
  });
  var newAutoPagedSlides = [];
  if (opt && !opt.autoPage) {
    createHyperlinkRels(target, arrRows);
    target._slideObjects.push({
      _type: SLIDE_OBJECT_TYPES.table,
      arrTabRows: arrRows,
      options: Object.assign({}, opt)
    });
  } else {
    if (opt.autoPageRepeatHeader)
      opt._arrObjTabHeadRows = arrRows.filter(function(_row, idx) {
        return idx < opt.autoPageHeaderRows;
      });
    getSlidesForTableRows(arrRows, opt, presLayout, slideLayout).forEach(function(slide, idx) {
      if (!getSlide(target._slideNum + idx))
        slides.push(addSlide({ masterName: (slideLayout === null || slideLayout === undefined ? undefined : slideLayout._name) || null }));
      if (idx > 0)
        opt.y = inch2Emu(opt.autoPageSlideStartY || opt.newSlideStartY || arrTableMargin[0]);
      {
        var newSlide = getSlide(target._slideNum + idx);
        opt.autoPage = false;
        createHyperlinkRels(newSlide, slide.rows);
        newSlide.addTable(slide.rows, Object.assign({}, opt));
        if (idx > 0)
          newAutoPagedSlides.push(newSlide);
      }
    });
  }
  return newAutoPagedSlides;
}
function addTextDefinition(target, text2, opts, isPlaceholder) {
  var newObject = {
    _type: isPlaceholder ? SLIDE_OBJECT_TYPES.placeholder : SLIDE_OBJECT_TYPES.text,
    shape: (opts === null || opts === undefined ? undefined : opts.shape) || SHAPE_TYPE.RECTANGLE,
    text: !text2 || text2.length === 0 ? [{ text: "", options: null }] : text2,
    options: opts || {}
  };
  function cleanOpts(itemOpts) {
    {
      if (!itemOpts.placeholder) {
        itemOpts.color = itemOpts.color || newObject.options.color || target.color || DEF_FONT_COLOR;
      }
      if (itemOpts.placeholder || isPlaceholder) {
        itemOpts.bullet = itemOpts.bullet || false;
      }
      if (itemOpts.placeholder && target._slideLayout && target._slideLayout._slideObjects) {
        var placeHold = target._slideLayout._slideObjects.filter(function(item) {
          return item._type === "placeholder" && item.options && item.options.placeholder && item.options.placeholder === itemOpts.placeholder;
        })[0];
        if (placeHold === null || placeHold === undefined ? undefined : placeHold.options)
          itemOpts = __assign2(__assign2({}, itemOpts), placeHold.options);
      }
      itemOpts.objectName = itemOpts.objectName ? encodeXmlEntities(itemOpts.objectName) : "Text ".concat(target._slideObjects.filter(function(obj) {
        return obj._type === SLIDE_OBJECT_TYPES.text;
      }).length);
      if (itemOpts.shape === SHAPE_TYPE.LINE) {
        var newLineOpts = {
          type: itemOpts.line.type || "solid",
          color: itemOpts.line.color || DEF_SHAPE_LINE_COLOR,
          transparency: itemOpts.line.transparency || 0,
          width: itemOpts.line.width || 1,
          dashType: itemOpts.line.dashType || "solid",
          beginArrowType: itemOpts.line.beginArrowType || null,
          endArrowType: itemOpts.line.endArrowType || null
        };
        if (typeof itemOpts.line === "object")
          itemOpts.line = newLineOpts;
        if (typeof itemOpts.line === "string") {
          var tmpOpts = newLineOpts;
          if (typeof itemOpts.line === "string")
            tmpOpts.color = itemOpts.line;
          itemOpts.line = tmpOpts;
        }
        if (typeof itemOpts.lineSize === "number")
          itemOpts.line.width = itemOpts.lineSize;
        if (typeof itemOpts.lineDash === "string")
          itemOpts.line.dashType = itemOpts.lineDash;
        if (typeof itemOpts.lineHead === "string")
          itemOpts.line.beginArrowType = itemOpts.lineHead;
        if (typeof itemOpts.lineTail === "string")
          itemOpts.line.endArrowType = itemOpts.lineTail;
      }
      itemOpts.line = itemOpts.line || {};
      itemOpts.lineSpacing = itemOpts.lineSpacing && !isNaN(itemOpts.lineSpacing) ? itemOpts.lineSpacing : null;
      itemOpts.lineSpacingMultiple = itemOpts.lineSpacingMultiple && !isNaN(itemOpts.lineSpacingMultiple) ? itemOpts.lineSpacingMultiple : null;
      itemOpts._bodyProp = itemOpts._bodyProp || {};
      itemOpts._bodyProp.autoFit = itemOpts.autoFit || false;
      itemOpts._bodyProp.anchor = !itemOpts.placeholder ? TEXT_VALIGN.ctr : null;
      itemOpts._bodyProp.vert = itemOpts.vert || null;
      itemOpts._bodyProp.wrap = typeof itemOpts.wrap === "boolean" ? itemOpts.wrap : true;
      if (itemOpts.inset && !isNaN(Number(itemOpts.inset)) || itemOpts.inset === 0) {
        itemOpts._bodyProp.lIns = inch2Emu(itemOpts.inset);
        itemOpts._bodyProp.rIns = inch2Emu(itemOpts.inset);
        itemOpts._bodyProp.tIns = inch2Emu(itemOpts.inset);
        itemOpts._bodyProp.bIns = inch2Emu(itemOpts.inset);
      }
      if (typeof itemOpts.underline === "boolean" && itemOpts.underline === true)
        itemOpts.underline = { style: "sng" };
    }
    {
      if ((itemOpts.align || "").toLowerCase().indexOf("c") === 0)
        itemOpts._bodyProp.align = TEXT_HALIGN.center;
      else if ((itemOpts.align || "").toLowerCase().indexOf("l") === 0)
        itemOpts._bodyProp.align = TEXT_HALIGN.left;
      else if ((itemOpts.align || "").toLowerCase().indexOf("r") === 0)
        itemOpts._bodyProp.align = TEXT_HALIGN.right;
      else if ((itemOpts.align || "").toLowerCase().indexOf("j") === 0)
        itemOpts._bodyProp.align = TEXT_HALIGN.justify;
      if ((itemOpts.valign || "").toLowerCase().indexOf("b") === 0)
        itemOpts._bodyProp.anchor = TEXT_VALIGN.b;
      else if ((itemOpts.valign || "").toLowerCase().indexOf("m") === 0)
        itemOpts._bodyProp.anchor = TEXT_VALIGN.ctr;
      else if ((itemOpts.valign || "").toLowerCase().indexOf("t") === 0)
        itemOpts._bodyProp.anchor = TEXT_VALIGN.t;
    }
    correctShadowOptions(itemOpts.shadow);
    return itemOpts;
  }
  newObject.options = cleanOpts(newObject.options);
  newObject.text.forEach(function(item) {
    return item.options = cleanOpts(item.options || {});
  });
  createHyperlinkRels(target, newObject.text || "");
  target._slideObjects.push(newObject);
}
function addPlaceholdersToSlideLayouts(slide) {
  (slide._slideLayout._slideObjects || []).forEach(function(slideLayoutObj) {
    if (slideLayoutObj._type === SLIDE_OBJECT_TYPES.placeholder) {
      if (slide._slideObjects.filter(function(slideObj) {
        return slideObj.options && slideObj.options.placeholder === slideLayoutObj.options.placeholder;
      }).length === 0) {
        addTextDefinition(slide, [{ text: "" }], slideLayoutObj.options, false);
      }
    }
  });
}
function addBackgroundDefinition(props, target) {
  var _a;
  if (target.bkgd) {
    if (!target.background)
      target.background = {};
    if (typeof target.bkgd === "string")
      target.background.color = target.bkgd;
    else {
      if (target.bkgd.data)
        target.background.data = target.bkgd.data;
      if (target.bkgd.path)
        target.background.path = target.bkgd.path;
      if (target.bkgd.src)
        target.background.path = target.bkgd.src;
    }
  }
  if ((_a = target.background) === null || _a === undefined ? undefined : _a.fill)
    target.background.color = target.background.fill;
  if (props && (props.path || props.data)) {
    props.path = props.path || "preencoded.png";
    var strImgExtn = (props.path.split(".").pop() || "png").split("?")[0];
    if (strImgExtn === "jpg")
      strImgExtn = "jpeg";
    target._relsMedia = target._relsMedia || [];
    var intRels = target._relsMedia.length + 1;
    target._relsMedia.push({
      path: props.path,
      type: SLIDE_OBJECT_TYPES.image,
      extn: strImgExtn,
      data: props.data || null,
      rId: intRels,
      Target: "../media/".concat((target._name || "").replace(/\s+/gi, "-"), "-image-").concat(target._relsMedia.length + 1, ".").concat(strImgExtn)
    });
    target._bkgdImgRid = intRels;
  }
}
function createHyperlinkRels(target, text2) {
  var textObjs = [];
  if (typeof text2 === "string" || typeof text2 === "number")
    return;
  else if (Array.isArray(text2))
    textObjs = text2;
  else if (typeof text2 === "object")
    textObjs = [text2];
  textObjs.forEach(function(text3) {
    if (Array.isArray(text3)) {
      createHyperlinkRels(target, text3);
    } else if (Array.isArray(text3.text)) {
      createHyperlinkRels(target, text3.text);
    } else if (text3 && typeof text3 === "object" && text3.options && text3.options.hyperlink && !text3.options.hyperlink._rId) {
      if (typeof text3.options.hyperlink !== "object")
        console.log("ERROR: text `hyperlink` option should be an object. Ex: `hyperlink: {url:'https://github.com'}` ");
      else if (!text3.options.hyperlink.url && !text3.options.hyperlink.slide)
        console.log("ERROR: 'hyperlink requires either: `url` or `slide`'");
      else {
        var relId = getNewRelId(target);
        target._rels.push({
          type: SLIDE_OBJECT_TYPES.hyperlink,
          data: text3.options.hyperlink.slide ? "slide" : "dummy",
          rId: relId,
          Target: encodeXmlEntities(text3.options.hyperlink.url) || text3.options.hyperlink.slide.toString()
        });
        text3.options.hyperlink._rId = relId;
      }
    }
  });
}
function createExcelWorksheet(chartObject, zip) {
  return __awaiter(this, undefined, undefined, function() {
    var data;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          data = chartObject.data;
          return [4, new Promise(function(resolve, reject) {
            var _a2, _b;
            var zipExcel = new import_jszip.default;
            var intBubbleCols = (data.length - 1) * 2 + 1;
            var IS_MULTI_CAT_AXES = ((_b = (_a2 = data[0]) === null || _a2 === undefined ? undefined : _a2.labels) === null || _b === undefined ? undefined : _b.length) > 1;
            zipExcel.folder("_rels");
            zipExcel.folder("docProps");
            zipExcel.folder("xl/_rels");
            zipExcel.folder("xl/tables");
            zipExcel.folder("xl/theme");
            zipExcel.folder("xl/worksheets");
            zipExcel.folder("xl/worksheets/_rels");
            {
              zipExcel.file("[Content_Types].xml", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">' + '  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>' + '  <Default Extension="xml" ContentType="application/xml"/>' + '  <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>' + '  <Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>' + '  <Override PartName="/xl/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/>' + '  <Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>' + '  <Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/>' + '  <Override PartName="/xl/tables/table1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"/>' + '  <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>' + '  <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>' + `</Types>
`);
              zipExcel.file("_rels/.rels", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">' + '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>' + '<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>' + '<Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>' + `</Relationships>
`);
              zipExcel.file("docProps/app.xml", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">' + "<Application>Microsoft Macintosh Excel</Application>" + "<DocSecurity>0</DocSecurity>" + "<ScaleCrop>false</ScaleCrop>" + '<HeadingPairs><vt:vector size="2" baseType="variant"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs>' + '<TitlesOfParts><vt:vector size="1" baseType="lpstr"><vt:lpstr>Sheet1</vt:lpstr></vt:vector></TitlesOfParts>' + "<Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion>" + `</Properties>
`);
              zipExcel.file("docProps/core.xml", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' + "<dc:creator>PptxGenJS</dc:creator>" + "<cp:lastModifiedBy>PptxGenJS</cp:lastModifiedBy>" + '<dcterms:created xsi:type="dcterms:W3CDTF">' + new Date().toISOString() + "</dcterms:created>" + '<dcterms:modified xsi:type="dcterms:W3CDTF">' + new Date().toISOString() + "</dcterms:modified>" + "</cp:coreProperties>");
              zipExcel.file("xl/_rels/workbook.xml.rels", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">' + '<Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>' + '<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/>' + '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>' + '<Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml"/>' + "</Relationships>");
              zipExcel.file("xl/styles.xml", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"><numFmts count="1"><numFmt numFmtId="0" formatCode="General"/></numFmts><fonts count="4"><font><sz val="9"/><color indexed="8"/><name val="Geneva"/></font><font><sz val="9"/><color indexed="8"/><name val="Geneva"/></font><font><sz val="10"/><color indexed="8"/><name val="Geneva"/></font><font><sz val="18"/><color indexed="8"/>' + '<name val="Arial"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><dxfs count="0"/><tableStyles count="0"/><colors><indexedColors><rgbColor rgb="ff000000"/><rgbColor rgb="ffffffff"/><rgbColor rgb="ffff0000"/><rgbColor rgb="ff00ff00"/><rgbColor rgb="ff0000ff"/>' + `<rgbColor rgb="ffffff00"/><rgbColor rgb="ffff00ff"/><rgbColor rgb="ff00ffff"/><rgbColor rgb="ff000000"/><rgbColor rgb="ffffffff"/><rgbColor rgb="ff878787"/><rgbColor rgb="fff9f9f9"/></indexedColors></colors></styleSheet>
`);
              zipExcel.file("xl/theme/theme1.xml", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="4472C4"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="5B9BD5"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="Yu Gothic Light"/><a:font script="Hang" typeface=" "/><a:font script="Hans" typeface="DengXian Light"/><a:font script="Hant" typeface=""/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="Yu Gothic"/><a:font script="Hang" typeface=" "/><a:font script="Hans" typeface="DengXian"/><a:font script="Hant" typeface=""/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>');
              zipExcel.file("xl/workbook.xml", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x15" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main">' + '<fileVersion appName="xl" lastEdited="7" lowestEdited="6" rupBuild="10507"/>' + "<workbookPr/>" + '<bookViews><workbookView xWindow="0" yWindow="500" windowWidth="20960" windowHeight="15960"/></bookViews>' + '<sheets><sheet name="Sheet1" sheetId="1" r:id="rId1"/></sheets>' + '<calcPr calcId="0" concurrentCalc="0"/>' + `</workbook>
`);
              zipExcel.file("xl/worksheets/_rels/sheet1.xml.rels", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">' + '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/table" Target="../tables/table1.xml"/>' + `</Relationships>
`);
            }
            {
              var strSharedStrings_1 = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
              if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {
                strSharedStrings_1 += '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="'.concat(intBubbleCols, '" uniqueCount="').concat(intBubbleCols, '">');
              } else if (chartObject.opts._type === CHART_TYPE.SCATTER) {
                strSharedStrings_1 += '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="'.concat(data.length, '" uniqueCount="').concat(data.length, '">');
              } else if (IS_MULTI_CAT_AXES) {
                var totCount_1 = data.length;
                data[0].labels.forEach(function(arrLabel) {
                  return totCount_1 += arrLabel.filter(function(label) {
                    return label && label !== "";
                  }).length;
                });
                strSharedStrings_1 += '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="'.concat(totCount_1, '" uniqueCount="').concat(totCount_1, '">');
                strSharedStrings_1 += "<si><t/></si>";
              } else {
                var totCount = data.length + data[0].labels.length * data[0].labels[0].length + data[0].labels.length;
                var unqCount = data.length + data[0].labels.length * data[0].labels[0].length + 1;
                strSharedStrings_1 += '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="'.concat(totCount, '" uniqueCount="').concat(unqCount, '">');
                strSharedStrings_1 += '<si><t xml:space="preserve"></t></si>';
              }
              if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {
                data.forEach(function(objData, idx2) {
                  if (idx2 === 0)
                    strSharedStrings_1 += "<si><t>X-Axis</t></si>";
                  else {
                    strSharedStrings_1 += "<si><t>".concat(encodeXmlEntities(objData.name || "Y-Axis".concat(idx2)), "</t></si>");
                    strSharedStrings_1 += "<si><t>".concat(encodeXmlEntities("Size".concat(idx2)), "</t></si>");
                  }
                });
              } else {
                data.forEach(function(objData) {
                  strSharedStrings_1 += "<si><t>".concat(encodeXmlEntities((objData.name || " ").replace("X-Axis", "X-Values")), "</t></si>");
                });
              }
              if (chartObject.opts._type !== CHART_TYPE.BUBBLE && chartObject.opts._type !== CHART_TYPE.BUBBLE3D && chartObject.opts._type !== CHART_TYPE.SCATTER) {
                data[0].labels.slice().reverse().forEach(function(labelsGroup) {
                  labelsGroup.filter(function(label) {
                    return label && label !== "";
                  }).forEach(function(label) {
                    strSharedStrings_1 += "<si><t>".concat(encodeXmlEntities(label), "</t></si>");
                  });
                });
              }
              strSharedStrings_1 += `</sst>
`;
              zipExcel.file("xl/sharedStrings.xml", strSharedStrings_1);
            }
            {
              var strTableXml_1 = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
              if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {
                strTableXml_1 += '<table xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" id="1" name="Table1" displayName="Table1" ref="A1:'.concat(getExcelColName(intBubbleCols)).concat(intBubbleCols, '" totalsRowShown="0">');
                strTableXml_1 += '<tableColumns count="'.concat(intBubbleCols, '">');
                var idxColLtr_1 = 1;
                data.forEach(function(obj, idx2) {
                  if (idx2 === 0) {
                    strTableXml_1 += '<tableColumn id="'.concat(idx2 + 1, '" name="X-Values"/>');
                  } else {
                    strTableXml_1 += '<tableColumn id="'.concat(idx2 + idxColLtr_1, '" name="').concat(obj.name, '"/>');
                    idxColLtr_1++;
                    strTableXml_1 += '<tableColumn id="'.concat(idx2 + idxColLtr_1, '" name="Size').concat(idx2, '"/>');
                  }
                });
              } else if (chartObject.opts._type === CHART_TYPE.SCATTER) {
                strTableXml_1 += '<table xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" id="1" name="Table1" displayName="Table1" ref="A1:'.concat(getExcelColName(data.length)).concat(data[0].values.length + 1, '" totalsRowShown="0">');
                strTableXml_1 += '<tableColumns count="'.concat(data.length, '">');
                data.forEach(function(_obj, idx2) {
                  strTableXml_1 += '<tableColumn id="'.concat(idx2 + 1, '" name="').concat(idx2 === 0 ? "X-Values" : "Y-Value ").concat(idx2, '"/>');
                });
              } else {
                strTableXml_1 += '<table xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" id="1" name="Table1" displayName="Table1" ref="A1:'.concat(getExcelColName(data.length + data[0].labels.length)).concat(data[0].labels[0].length + 1, `'" totalsRowShown="0">`);
                strTableXml_1 += '<tableColumns count="'.concat(data.length + data[0].labels.length, '">');
                data[0].labels.forEach(function(_labelsGroup, idx2) {
                  strTableXml_1 += '<tableColumn id="'.concat(idx2 + 1, '" name="Column').concat(idx2 + 1, '"/>');
                });
                data.forEach(function(obj, idx2) {
                  strTableXml_1 += '<tableColumn id="'.concat(idx2 + data[0].labels.length + 1, '" name="').concat(encodeXmlEntities(obj.name), '"/>');
                });
              }
              strTableXml_1 += "</tableColumns>";
              strTableXml_1 += '<tableStyleInfo showFirstColumn="0" showLastColumn="0" showRowStripes="1" showColumnStripes="0"/>';
              strTableXml_1 += "</table>";
              zipExcel.file("xl/tables/table1.xml", strTableXml_1);
            }
            {
              var strSheetXml_1 = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
              strSheetXml_1 += '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">';
              if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {
                strSheetXml_1 += '<dimension ref="A1:'.concat(getExcelColName(intBubbleCols)).concat(data[0].values.length + 1, '"/>');
              } else if (chartObject.opts._type === CHART_TYPE.SCATTER) {
                strSheetXml_1 += '<dimension ref="A1:'.concat(getExcelColName(data.length)).concat(data[0].values.length + 1, '"/>');
              } else {
                strSheetXml_1 += '<dimension ref="A1:'.concat(getExcelColName(data.length + 1)).concat(data[0].values.length + 1, '"/>');
              }
              strSheetXml_1 += '<sheetViews><sheetView tabSelected="1" workbookViewId="0"><selection activeCell="B1" sqref="B1"/></sheetView></sheetViews>';
              strSheetXml_1 += '<sheetFormatPr baseColWidth="10" defaultRowHeight="16"/>';
              if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {
                strSheetXml_1 += "<sheetData>";
                strSheetXml_1 += '<row r="1" spans="1:'.concat(intBubbleCols, '">');
                strSheetXml_1 += '<c r="A1" t="s"><v>0</v></c>';
                for (var idx = 1;idx < intBubbleCols; idx++) {
                  strSheetXml_1 += '<c r="'.concat(getExcelColName(idx + 1), '1" t="s"><v>').concat(idx, "</v></c>");
                }
                strSheetXml_1 += "</row>";
                data[0].values.forEach(function(val, idx2) {
                  strSheetXml_1 += '<row r="'.concat(idx2 + 2, '" spans="1:').concat(intBubbleCols, '">');
                  strSheetXml_1 += '<c r="A'.concat(idx2 + 2, '"><v>').concat(val, "</v></c>");
                  var idxColLtr = 2;
                  for (var idy = 1;idy < data.length; idy++) {
                    strSheetXml_1 += '<c r="'.concat(getExcelColName(idxColLtr)).concat(idx2 + 2, '"><v>').concat(data[idy].values[idx2] || "", "</v></c>");
                    idxColLtr++;
                    strSheetXml_1 += '<c r="'.concat(getExcelColName(idxColLtr)).concat(idx2 + 2, '"><v>').concat(data[idy].sizes[idx2] || "", "</v></c>");
                    idxColLtr++;
                  }
                  strSheetXml_1 += "</row>";
                });
              } else if (chartObject.opts._type === CHART_TYPE.SCATTER) {
                strSheetXml_1 += "<sheetData>";
                strSheetXml_1 += '<row r="1" spans="1:'.concat(data.length, '">');
                for (var idx = 0;idx < data.length; idx++) {
                  strSheetXml_1 += '<c r="'.concat(getExcelColName(idx + 1), '1" t="s"><v>').concat(idx, "</v></c>");
                }
                strSheetXml_1 += "</row>";
                data[0].values.forEach(function(val, idx2) {
                  strSheetXml_1 += '<row r="'.concat(idx2 + 2, '" spans="1:').concat(data.length, '">');
                  strSheetXml_1 += '<c r="A'.concat(idx2 + 2, '"><v>').concat(val, "</v></c>");
                  for (var idy = 1;idy < data.length; idy++) {
                    strSheetXml_1 += '<c r="'.concat(getExcelColName(idy + 1)).concat(idx2 + 2, '"><v>').concat(data[idy].values[idx2] || data[idy].values[idx2] === 0 ? data[idy].values[idx2] : "", "</v></c>");
                  }
                  strSheetXml_1 += "</row>";
                });
              } else {
                strSheetXml_1 += "<sheetData>";
                if (!IS_MULTI_CAT_AXES) {
                  strSheetXml_1 += '<row r="1" spans="1:'.concat(data.length + data[0].labels.length, '">');
                  data[0].labels.forEach(function(_labelsGroup, idx2) {
                    strSheetXml_1 += '<c r="'.concat(getExcelColName(idx2 + 1), '1" t="s"><v>0</v></c>');
                  });
                  for (var idx = 0;idx < data.length; idx++) {
                    strSheetXml_1 += '<c r="'.concat(getExcelColName(idx + 1 + data[0].labels.length), '1" t="s"><v>').concat(idx + 1, "</v></c>");
                  }
                  strSheetXml_1 += "</row>";
                  data[0].labels[0].forEach(function(_cat, idx2) {
                    strSheetXml_1 += '<row r="'.concat(idx2 + 2, '" spans="1:').concat(data.length + data[0].labels.length, '">');
                    for (var idx22 = data[0].labels.length - 1;idx22 >= 0; idx22--) {
                      strSheetXml_1 += '<c r="'.concat(getExcelColName(data[0].labels.length - idx22)).concat(idx2 + 2, '" t="s">');
                      strSheetXml_1 += "<v>".concat(data.length + idx2 + 1, "</v>");
                      strSheetXml_1 += "</c>";
                    }
                    for (var idy = 0;idy < data.length; idy++) {
                      strSheetXml_1 += '<c r="'.concat(getExcelColName(data[0].labels.length + idy + 1)).concat(idx2 + 2, '"><v>').concat(data[idy].values[idx2] || "", "</v></c>");
                    }
                    strSheetXml_1 += "</row>";
                  });
                } else {
                  strSheetXml_1 += '<row r="1" spans="1:'.concat(data.length + data[0].labels.length, '">');
                  for (var idx = 0;idx < data[0].labels.length; idx++) {
                    strSheetXml_1 += '<c r="'.concat(getExcelColName(idx + 1), '1" t="s"><v>0</v></c>');
                  }
                  for (var idx = data[0].labels.length - 1;idx < data.length + data[0].labels.length - 1; idx++) {
                    strSheetXml_1 += '<c r="'.concat(getExcelColName(idx + data[0].labels.length), '1" t="s"><v>').concat(idx, "</v></c>");
                  }
                  strSheetXml_1 += "</row>";
                  var TOT_SER = data.length;
                  var TOT_CAT = data[0].labels[0].length;
                  var TOT_LVL = data[0].labels.length;
                  var _loop_1 = function(idx2) {
                    strSheetXml_1 += '<row r="'.concat(idx2 + 2, '" spans="1:').concat(TOT_SER + TOT_LVL, '">');
                    var totLabels = TOT_SER;
                    var revLabelGroups = data[0].labels.slice().reverse();
                    revLabelGroups.forEach(function(labelsGroup, idy2) {
                      var colLabel = labelsGroup[idx2];
                      if (colLabel) {
                        var totGrpLbls = idy2 === 0 ? 1 : revLabelGroups[idy2 - 1].filter(function(label) {
                          return label && label !== "";
                        }).length;
                        totLabels += totGrpLbls;
                        strSheetXml_1 += '<c r="'.concat(getExcelColName(idx2 + 1 + idy2)).concat(idx2 + 2, '" t="s"><v>').concat(totLabels, "</v></c>");
                      }
                    });
                    for (var idy = 0;idy < TOT_SER; idy++) {
                      strSheetXml_1 += '<c r="'.concat(getExcelColName(TOT_LVL + idy + 1)).concat(idx2 + 2, '"><v>').concat(data[idy].values[idx2] || 0, "</v></c>");
                    }
                    strSheetXml_1 += "</row>";
                  };
                  for (var idx = 0;idx < TOT_CAT; idx++) {
                    _loop_1(idx);
                  }
                }
              }
              strSheetXml_1 += "</sheetData>";
              strSheetXml_1 += '<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>';
              strSheetXml_1 += `</worksheet>
`;
              zipExcel.file("xl/worksheets/sheet1.xml", strSheetXml_1);
            }
            zipExcel.generateAsync({ type: "base64" }).then(function(content) {
              zip.file("ppt/embeddings/Microsoft_Excel_Worksheet".concat(chartObject.globalId, ".xlsx"), content, { base64: true });
              zip.file("ppt/charts/_rels/" + chartObject.fileName + ".rels", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">' + '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/package" Target="../embeddings/Microsoft_Excel_Worksheet'.concat(chartObject.globalId, '.xlsx"/>') + "</Relationships>");
              zip.file("ppt/charts/".concat(chartObject.fileName), makeXmlCharts(chartObject));
              resolve("");
            }).catch(function(strErr) {
              reject(strErr);
            });
          })];
        case 1:
          return [2, _a.sent()];
      }
    });
  });
}
function makeXmlCharts(rel) {
  var _a, _b, _c, _d;
  var strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
  var usesSecondaryValAxis = false;
  {
    strXml += '<c:chartSpace xmlns:c="http://schemas.openxmlformats.org/drawingml/2006/chart" xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">';
    strXml += '<c:date1904 val="0"/>';
    strXml += '<c:roundedCorners val="'.concat(rel.opts.chartArea.roundedCorners ? "1" : "0", '"/>');
    strXml += "<c:chart>";
    if (rel.opts.showTitle) {
      strXml += genXmlTitle({
        title: rel.opts.title || "Chart Title",
        color: rel.opts.titleColor,
        fontFace: rel.opts.titleFontFace,
        fontSize: rel.opts.titleFontSize || DEF_FONT_TITLE_SIZE,
        titleAlign: rel.opts.titleAlign,
        titleBold: rel.opts.titleBold,
        titlePos: rel.opts.titlePos,
        titleRotate: rel.opts.titleRotate
      }, rel.opts.x, rel.opts.y);
      strXml += '<c:autoTitleDeleted val="0"/>';
    } else {
      strXml += '<c:autoTitleDeleted val="1"/>';
    }
    if (rel.opts._type === CHART_TYPE.BAR3D) {
      strXml += '<c:view3D><c:rotX val="'.concat(rel.opts.v3DRotX, '"/><c:rotY val="').concat(rel.opts.v3DRotY, '"/><c:rAngAx val="').concat(!rel.opts.v3DRAngAx ? 0 : 1, '"/><c:perspective val="').concat(rel.opts.v3DPerspective, '"/></c:view3D>');
    }
    strXml += "<c:plotArea>";
    if (rel.opts.layout) {
      strXml += "<c:layout>";
      strXml += " <c:manualLayout>";
      strXml += '  <c:layoutTarget val="inner" />';
      strXml += '  <c:xMode val="edge" />';
      strXml += '  <c:yMode val="edge" />';
      strXml += '  <c:x val="' + (rel.opts.layout.x || 0) + '" />';
      strXml += '  <c:y val="' + (rel.opts.layout.y || 0) + '" />';
      strXml += '  <c:w val="' + (rel.opts.layout.w || 1) + '" />';
      strXml += '  <c:h val="' + (rel.opts.layout.h || 1) + '" />';
      strXml += " </c:manualLayout>";
      strXml += "</c:layout>";
    } else {
      strXml += "<c:layout/>";
    }
  }
  if (Array.isArray(rel.opts._type)) {
    rel.opts._type.forEach(function(type) {
      var options2 = __assign2(__assign2({}, rel.opts), type.options);
      var valAxisId = options2.secondaryValAxis ? AXIS_ID_VALUE_SECONDARY : AXIS_ID_VALUE_PRIMARY;
      var catAxisId = options2.secondaryCatAxis ? AXIS_ID_CATEGORY_SECONDARY : AXIS_ID_CATEGORY_PRIMARY;
      usesSecondaryValAxis = usesSecondaryValAxis || options2.secondaryValAxis;
      strXml += makeChartType(type.type, type.data, options2, valAxisId, catAxisId);
    });
  } else {
    strXml += makeChartType(rel.opts._type, rel.data, rel.opts, AXIS_ID_VALUE_PRIMARY, AXIS_ID_CATEGORY_PRIMARY);
  }
  if (rel.opts._type !== CHART_TYPE.PIE && rel.opts._type !== CHART_TYPE.DOUGHNUT) {
    if (rel.opts.valAxes && rel.opts.valAxes.length > 1 && !usesSecondaryValAxis) {
      throw new Error("Secondary axis must be used by one of the multiple charts");
    }
    if (rel.opts.catAxes) {
      if (!rel.opts.valAxes || rel.opts.valAxes.length !== rel.opts.catAxes.length) {
        throw new Error("There must be the same number of value and category axes.");
      }
      strXml += makeCatAxis(__assign2(__assign2({}, rel.opts), rel.opts.catAxes[0]), AXIS_ID_CATEGORY_PRIMARY, AXIS_ID_VALUE_PRIMARY);
    } else {
      strXml += makeCatAxis(rel.opts, AXIS_ID_CATEGORY_PRIMARY, AXIS_ID_VALUE_PRIMARY);
    }
    if (rel.opts.valAxes) {
      strXml += makeValAxis(__assign2(__assign2({}, rel.opts), rel.opts.valAxes[0]), AXIS_ID_VALUE_PRIMARY);
      if (rel.opts.valAxes[1]) {
        strXml += makeValAxis(__assign2(__assign2({}, rel.opts), rel.opts.valAxes[1]), AXIS_ID_VALUE_SECONDARY);
      }
    } else {
      strXml += makeValAxis(rel.opts, AXIS_ID_VALUE_PRIMARY);
      if (rel.opts._type === CHART_TYPE.BAR3D) {
        strXml += makeSerAxis(rel.opts, AXIS_ID_SERIES_PRIMARY, AXIS_ID_VALUE_PRIMARY);
      }
    }
    if (((_a = rel.opts) === null || _a === undefined ? undefined : _a.catAxes) && ((_b = rel.opts) === null || _b === undefined ? undefined : _b.catAxes[1])) {
      strXml += makeCatAxis(__assign2(__assign2({}, rel.opts), rel.opts.catAxes[1]), AXIS_ID_CATEGORY_SECONDARY, AXIS_ID_VALUE_SECONDARY);
    }
  }
  {
    if (rel.opts.showDataTable) {
      strXml += "<c:dTable>";
      strXml += '  <c:showHorzBorder val="'.concat(!rel.opts.showDataTableHorzBorder ? 0 : 1, '"/>');
      strXml += '  <c:showVertBorder val="'.concat(!rel.opts.showDataTableVertBorder ? 0 : 1, '"/>');
      strXml += '  <c:showOutline    val="'.concat(!rel.opts.showDataTableOutline ? 0 : 1, '"/>');
      strXml += '  <c:showKeys       val="'.concat(!rel.opts.showDataTableKeys ? 0 : 1, '"/>');
      strXml += "  <c:spPr>";
      strXml += "    <a:noFill/>";
      strXml += '    <a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="tx1"><a:lumMod val="15000"/><a:lumOff val="85000"/></a:schemeClr></a:solidFill><a:round/></a:ln>';
      strXml += "    <a:effectLst/>";
      strXml += "  </c:spPr>";
      strXml += "  <c:txPr>";
      strXml += '   <a:bodyPr rot="0" spcFirstLastPara="1" vertOverflow="ellipsis" vert="horz" wrap="square" anchor="ctr" anchorCtr="1"/>';
      strXml += "   <a:lstStyle/>";
      strXml += "   <a:p>";
      strXml += '     <a:pPr rtl="0">';
      strXml += '       <a:defRPr sz="'.concat(Math.round((rel.opts.dataTableFontSize || DEF_FONT_SIZE) * 100), '" b="0" i="0" u="none" strike="noStrike" kern="1200" baseline="0">');
      strXml += '         <a:solidFill><a:schemeClr val="tx1"><a:lumMod val="65000"/><a:lumOff val="35000"/></a:schemeClr></a:solidFill>';
      strXml += '         <a:latin typeface="+mn-lt"/>';
      strXml += '         <a:ea typeface="+mn-ea"/>';
      strXml += '         <a:cs typeface="+mn-cs"/>';
      strXml += "       </a:defRPr>";
      strXml += "     </a:pPr>";
      strXml += '    <a:endParaRPr lang="en-US"/>';
      strXml += "   </a:p>";
      strXml += " </c:txPr>";
      strXml += "</c:dTable>";
    }
    strXml += "  <c:spPr>";
    strXml += ((_c = rel.opts.plotArea.fill) === null || _c === undefined ? undefined : _c.color) ? genXmlColorSelection(rel.opts.plotArea.fill) : "<a:noFill/>";
    strXml += rel.opts.plotArea.border ? '<a:ln w="'.concat(valToPts(rel.opts.plotArea.border.pt), '" cap="flat">').concat(genXmlColorSelection(rel.opts.plotArea.border.color), "</a:ln>") : "<a:ln><a:noFill/></a:ln>";
    strXml += "    <a:effectLst/>";
    strXml += "  </c:spPr>";
    strXml += "</c:plotArea>";
    if (rel.opts.showLegend) {
      strXml += "<c:legend>";
      strXml += '<c:legendPos val="' + rel.opts.legendPos + '"/>';
      strXml += '<c:overlay val="0"/>';
      if (rel.opts.legendFontFace || rel.opts.legendFontSize || rel.opts.legendColor) {
        strXml += "<c:txPr>";
        strXml += "  <a:bodyPr/>";
        strXml += "  <a:lstStyle/>";
        strXml += "  <a:p>";
        strXml += "    <a:pPr>";
        strXml += rel.opts.legendFontSize ? '<a:defRPr sz="'.concat(Math.round(Number(rel.opts.legendFontSize) * 100), '">') : "<a:defRPr>";
        if (rel.opts.legendColor)
          strXml += genXmlColorSelection(rel.opts.legendColor);
        if (rel.opts.legendFontFace)
          strXml += '<a:latin typeface="' + rel.opts.legendFontFace + '"/>';
        if (rel.opts.legendFontFace)
          strXml += '<a:cs    typeface="' + rel.opts.legendFontFace + '"/>';
        strXml += "      </a:defRPr>";
        strXml += "    </a:pPr>";
        strXml += '    <a:endParaRPr lang="en-US"/>';
        strXml += "  </a:p>";
        strXml += "</c:txPr>";
      }
      strXml += "</c:legend>";
    }
  }
  strXml += '  <c:plotVisOnly val="1"/>';
  strXml += '  <c:dispBlanksAs val="' + rel.opts.displayBlanksAs + '"/>';
  if (rel.opts._type === CHART_TYPE.SCATTER)
    strXml += '<c:showDLblsOverMax val="1"/>';
  strXml += "</c:chart>";
  strXml += "<c:spPr>";
  strXml += ((_d = rel.opts.chartArea.fill) === null || _d === undefined ? undefined : _d.color) ? genXmlColorSelection(rel.opts.chartArea.fill) : "<a:noFill/>";
  strXml += rel.opts.chartArea.border ? '<a:ln w="'.concat(valToPts(rel.opts.chartArea.border.pt), '" cap="flat">').concat(genXmlColorSelection(rel.opts.chartArea.border.color), "</a:ln>") : "<a:ln><a:noFill/></a:ln>";
  strXml += "  <a:effectLst/>";
  strXml += "</c:spPr>";
  strXml += '<c:externalData r:id="rId1"><c:autoUpdate val="0"/></c:externalData>';
  strXml += "</c:chartSpace>";
  return strXml;
}
function makeChartType(chartType, data, opts, valAxisId, catAxisId, isMultiTypeChart) {
  var colorIndex = -1;
  var idxColLtr = 1;
  var optsChartData = null;
  var strXml = "";
  switch (chartType) {
    case CHART_TYPE.AREA:
    case CHART_TYPE.BAR:
    case CHART_TYPE.BAR3D:
    case CHART_TYPE.LINE:
    case CHART_TYPE.RADAR:
      strXml += "<c:".concat(chartType, "Chart>");
      if (chartType === CHART_TYPE.AREA && opts.barGrouping === "stacked") {
        strXml += '<c:grouping val="' + opts.barGrouping + '"/>';
      }
      if (chartType === CHART_TYPE.BAR || chartType === CHART_TYPE.BAR3D) {
        strXml += '<c:barDir val="' + opts.barDir + '"/>';
        strXml += '<c:grouping val="' + (opts.barGrouping || "clustered") + '"/>';
      }
      if (chartType === CHART_TYPE.RADAR) {
        strXml += '<c:radarStyle val="' + opts.radarStyle + '"/>';
      }
      strXml += '<c:varyColors val="0"/>';
      data.forEach(function(obj) {
        var _a;
        colorIndex++;
        strXml += "<c:ser>";
        strXml += '  <c:idx val="'.concat(obj._dataIndex, '"/><c:order val="').concat(obj._dataIndex, '"/>');
        strXml += "  <c:tx>";
        strXml += "    <c:strRef>";
        strXml += "      <c:f>Sheet1!$" + getExcelColName(obj._dataIndex + obj.labels.length + 1) + "$1</c:f>";
        strXml += '      <c:strCache><c:ptCount val="1"/><c:pt idx="0"><c:v>' + encodeXmlEntities(obj.name) + "</c:v></c:pt></c:strCache>";
        strXml += "    </c:strRef>";
        strXml += "  </c:tx>";
        var seriesColor = opts.chartColors ? opts.chartColors[colorIndex % opts.chartColors.length] : null;
        strXml += "  <c:spPr>";
        if (seriesColor === "transparent") {
          strXml += "<a:noFill/>";
        } else if (opts.chartColorsOpacity) {
          strXml += "<a:solidFill>" + createColorElement(seriesColor, '<a:alpha val="'.concat(Math.round(opts.chartColorsOpacity * 1000), '"/>')) + "</a:solidFill>";
        } else {
          strXml += "<a:solidFill>" + createColorElement(seriesColor) + "</a:solidFill>";
        }
        if (chartType === CHART_TYPE.LINE || chartType === CHART_TYPE.RADAR) {
          if (opts.lineSize === 0) {
            strXml += "<a:ln><a:noFill/></a:ln>";
          } else {
            strXml += '<a:ln w="'.concat(valToPts(opts.lineSize), '" cap="').concat(createLineCap(opts.lineCap), '"><a:solidFill>').concat(createColorElement(seriesColor), "</a:solidFill>");
            strXml += '<a:prstDash val="' + (opts.lineDash || "solid") + '"/><a:round/></a:ln>';
          }
        } else if (opts.dataBorder) {
          strXml += '<a:ln w="'.concat(valToPts(opts.dataBorder.pt), '" cap="').concat(createLineCap(opts.lineCap), '"><a:solidFill>').concat(createColorElement(opts.dataBorder.color), '</a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>');
        }
        strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
        strXml += "  </c:spPr>";
        strXml += '  <c:invertIfNegative val="0"/>';
        if (chartType !== CHART_TYPE.RADAR) {
          strXml += "<c:dLbls>";
          strXml += '<c:numFmt formatCode="'.concat(encodeXmlEntities(opts.dataLabelFormatCode) || "General", '" sourceLinked="0"/>');
          if (opts.dataLabelBkgrdColors)
            strXml += "<c:spPr><a:solidFill>".concat(createColorElement(seriesColor), "</a:solidFill></c:spPr>");
          strXml += "<c:txPr><a:bodyPr/><a:lstStyle/><a:p><a:pPr>";
          strXml += '<a:defRPr b="'.concat(opts.dataLabelFontBold ? 1 : 0, '" i="').concat(opts.dataLabelFontItalic ? 1 : 0, '" strike="noStrike" sz="').concat(Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100), '" u="none">');
          strXml += "<a:solidFill>".concat(createColorElement(opts.dataLabelColor || DEF_FONT_COLOR), "</a:solidFill>");
          strXml += '<a:latin typeface="'.concat(opts.dataLabelFontFace || "Arial", '"/>');
          strXml += "</a:defRPr></a:pPr></a:p></c:txPr>";
          if (opts.dataLabelPosition)
            strXml += '<c:dLblPos val="'.concat(opts.dataLabelPosition, '"/>');
          strXml += '<c:showLegendKey val="0"/>';
          strXml += '<c:showVal val="'.concat(opts.showValue ? "1" : "0", '"/>');
          strXml += '<c:showCatName val="0"/><c:showSerName val="'.concat(opts.showSerName ? "1" : "0", '"/><c:showPercent val="0"/><c:showBubbleSize val="0"/>');
          strXml += '<c:showLeaderLines val="'.concat(opts.showLeaderLines ? "1" : "0", '"/>');
          strXml += "</c:dLbls>";
        }
        if (chartType === CHART_TYPE.LINE || chartType === CHART_TYPE.RADAR) {
          strXml += "<c:marker>";
          strXml += '  <c:symbol val="' + opts.lineDataSymbol + '"/>';
          if (opts.lineDataSymbolSize)
            strXml += '<c:size val="'.concat(opts.lineDataSymbolSize, '"/>');
          strXml += "  <c:spPr>";
          strXml += "    <a:solidFill>".concat(createColorElement(opts.chartColors[obj._dataIndex + 1 > opts.chartColors.length ? Math.floor(Math.random() * opts.chartColors.length) : obj._dataIndex]), "</a:solidFill>");
          strXml += '    <a:ln w="'.concat(opts.lineDataSymbolLineSize, '" cap="flat"><a:solidFill>').concat(createColorElement(opts.lineDataSymbolLineColor || seriesColor), '</a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>');
          strXml += "    <a:effectLst/>";
          strXml += "  </c:spPr>";
          strXml += "</c:marker>";
        }
        if ((chartType === CHART_TYPE.BAR || chartType === CHART_TYPE.BAR3D) && data.length === 1 && (opts.chartColors && opts.chartColors !== BARCHART_COLORS && opts.chartColors.length > 1 || ((_a = opts.invertedColors) === null || _a === undefined ? undefined : _a.length))) {
          obj.values.forEach(function(value, index2) {
            var arrColors = value < 0 ? opts.invertedColors || opts.chartColors || BARCHART_COLORS : opts.chartColors || [];
            strXml += "  <c:dPt>";
            strXml += '    <c:idx val="'.concat(index2, '"/>');
            strXml += '      <c:invertIfNegative val="0"/>';
            strXml += '    <c:bubble3D val="0"/>';
            strXml += "    <c:spPr>";
            if (opts.lineSize === 0) {
              strXml += "<a:ln><a:noFill/></a:ln>";
            } else if (chartType === CHART_TYPE.BAR) {
              strXml += "<a:solidFill>";
              strXml += '  <a:srgbClr val="' + arrColors[index2 % arrColors.length] + '"/>';
              strXml += "</a:solidFill>";
            } else {
              strXml += "<a:ln>";
              strXml += "  <a:solidFill>";
              strXml += '   <a:srgbClr val="' + arrColors[index2 % arrColors.length] + '"/>';
              strXml += "  </a:solidFill>";
              strXml += "</a:ln>";
            }
            strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
            strXml += "    </c:spPr>";
            strXml += "  </c:dPt>";
          });
        }
        {
          strXml += "<c:cat>";
          if (opts.catLabelFormatCode) {
            strXml += "  <c:numRef>";
            strXml += "    <c:f>Sheet1!$A$2:$A$".concat(obj.labels[0].length + 1, "</c:f>");
            strXml += "    <c:numCache>";
            strXml += "      <c:formatCode>" + (opts.catLabelFormatCode || "General") + "</c:formatCode>";
            strXml += '      <c:ptCount val="'.concat(obj.labels[0].length, '"/>');
            obj.labels[0].forEach(function(label, idx) {
              return strXml += '<c:pt idx="'.concat(idx, '"><c:v>').concat(encodeXmlEntities(label), "</c:v></c:pt>");
            });
            strXml += "    </c:numCache>";
            strXml += "  </c:numRef>";
          } else {
            strXml += "  <c:multiLvlStrRef>";
            strXml += "    <c:f>Sheet1!$A$2:$".concat(getExcelColName(obj.labels.length), "$").concat(obj.labels[0].length + 1, "</c:f>");
            strXml += "    <c:multiLvlStrCache>";
            strXml += '      <c:ptCount val="'.concat(obj.labels[0].length, '"/>');
            obj.labels.forEach(function(labelsGroup) {
              strXml += "<c:lvl>";
              labelsGroup.forEach(function(label, idx) {
                return strXml += '<c:pt idx="'.concat(idx, '"><c:v>').concat(encodeXmlEntities(label), "</c:v></c:pt>");
              });
              strXml += "</c:lvl>";
            });
            strXml += "    </c:multiLvlStrCache>";
            strXml += "  </c:multiLvlStrRef>";
          }
          strXml += "</c:cat>";
        }
        {
          strXml += "<c:val>";
          strXml += "  <c:numRef>";
          strXml += "<c:f>Sheet1!$".concat(getExcelColName(obj._dataIndex + obj.labels.length + 1), "$2:$").concat(getExcelColName(obj._dataIndex + obj.labels.length + 1), "$").concat(obj.labels[0].length + 1, "</c:f>");
          strXml += "    <c:numCache>";
          strXml += "      <c:formatCode>" + (opts.valLabelFormatCode || opts.dataTableFormatCode || "General") + "</c:formatCode>";
          strXml += '      <c:ptCount val="'.concat(obj.labels[0].length, '"/>');
          obj.values.forEach(function(value, idx) {
            return strXml += '<c:pt idx="'.concat(idx, '"><c:v>').concat(value || value === 0 ? value : "", "</c:v></c:pt>");
          });
          strXml += "    </c:numCache>";
          strXml += "  </c:numRef>";
          strXml += "</c:val>";
        }
        if (chartType === CHART_TYPE.LINE)
          strXml += '<c:smooth val="' + (opts.lineSmooth ? "1" : "0") + '"/>';
        strXml += "</c:ser>";
      });
      {
        strXml += "  <c:dLbls>";
        strXml += '    <c:numFmt formatCode="'.concat(encodeXmlEntities(opts.dataLabelFormatCode) || "General", '" sourceLinked="0"/>');
        strXml += "    <c:txPr>";
        strXml += "      <a:bodyPr/>";
        strXml += "      <a:lstStyle/>";
        strXml += "      <a:p><a:pPr>";
        strXml += '        <a:defRPr b="'.concat(opts.dataLabelFontBold ? 1 : 0, '" i="').concat(opts.dataLabelFontItalic ? 1 : 0, '" strike="noStrike" sz="').concat(Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100), '" u="none">');
        strXml += "          <a:solidFill>" + createColorElement(opts.dataLabelColor || DEF_FONT_COLOR) + "</a:solidFill>";
        strXml += '          <a:latin typeface="' + (opts.dataLabelFontFace || "Arial") + '"/>';
        strXml += "        </a:defRPr>";
        strXml += "      </a:pPr></a:p>";
        strXml += "    </c:txPr>";
        if (opts.dataLabelPosition)
          strXml += ' <c:dLblPos val="' + opts.dataLabelPosition + '"/>';
        strXml += '    <c:showLegendKey val="0"/>';
        strXml += '    <c:showVal val="' + (opts.showValue ? "1" : "0") + '"/>';
        strXml += '    <c:showCatName val="0"/>';
        strXml += '    <c:showSerName val="' + (opts.showSerName ? "1" : "0") + '"/>';
        strXml += '    <c:showPercent val="0"/>';
        strXml += '    <c:showBubbleSize val="0"/>';
        strXml += '    <c:showLeaderLines val="'.concat(opts.showLeaderLines ? "1" : "0", '"/>');
        strXml += "  </c:dLbls>";
      }
      if (chartType === CHART_TYPE.BAR) {
        strXml += '  <c:gapWidth val="'.concat(opts.barGapWidthPct, '"/>');
        strXml += '  <c:overlap val="'.concat((opts.barGrouping || "").includes("tacked") ? 100 : opts.barOverlapPct ? opts.barOverlapPct : 0, '"/>');
      } else if (chartType === CHART_TYPE.BAR3D) {
        strXml += '  <c:gapWidth val="'.concat(opts.barGapWidthPct, '"/>');
        strXml += '  <c:gapDepth val="'.concat(opts.barGapDepthPct, '"/>');
        strXml += '  <c:shape val="' + opts.bar3DShape + '"/>';
      } else if (chartType === CHART_TYPE.LINE) {
        strXml += '  <c:marker val="1"/>';
      }
      strXml += '<c:axId val="'.concat(catAxisId, '"/><c:axId val="').concat(valAxisId, '"/><c:axId val="').concat(AXIS_ID_SERIES_PRIMARY, '"/>');
      strXml += "</c:".concat(chartType, "Chart>");
      break;
    case CHART_TYPE.SCATTER:
      strXml += "<c:" + chartType + "Chart>";
      strXml += '<c:scatterStyle val="lineMarker"/>';
      strXml += '<c:varyColors val="0"/>';
      colorIndex = -1;
      data.filter(function(_obj, idx) {
        return idx > 0;
      }).forEach(function(obj, idx) {
        colorIndex++;
        strXml += "<c:ser>";
        strXml += '  <c:idx val="'.concat(idx, '"/>');
        strXml += '  <c:order val="'.concat(idx, '"/>');
        strXml += "  <c:tx>";
        strXml += "    <c:strRef>";
        strXml += "      <c:f>Sheet1!$".concat(getExcelColName(idx + 2), "$1</c:f>");
        strXml += '      <c:strCache><c:ptCount val="1"/><c:pt idx="0"><c:v>' + encodeXmlEntities(obj.name) + "</c:v></c:pt></c:strCache>";
        strXml += "    </c:strRef>";
        strXml += "  </c:tx>";
        strXml += "  <c:spPr>";
        {
          var tmpSerColor = opts.chartColors[colorIndex % opts.chartColors.length];
          if (tmpSerColor === "transparent") {
            strXml += "<a:noFill/>";
          } else if (opts.chartColorsOpacity) {
            strXml += "<a:solidFill>" + createColorElement(tmpSerColor, '<a:alpha val="' + Math.round(opts.chartColorsOpacity * 1000).toString() + '"/>') + "</a:solidFill>";
          } else {
            strXml += "<a:solidFill>" + createColorElement(tmpSerColor) + "</a:solidFill>";
          }
          if (opts.lineSize === 0) {
            strXml += "<a:ln><a:noFill/></a:ln>";
          } else {
            strXml += '<a:ln w="'.concat(valToPts(opts.lineSize), '" cap="').concat(createLineCap(opts.lineCap), '"><a:solidFill>').concat(createColorElement(tmpSerColor), "</a:solidFill>");
            strXml += '<a:prstDash val="'.concat(opts.lineDash || "solid", '"/><a:round/></a:ln>');
          }
          strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
        }
        strXml += "  </c:spPr>";
        {
          strXml += "<c:marker>";
          strXml += '  <c:symbol val="' + opts.lineDataSymbol + '"/>';
          if (opts.lineDataSymbolSize) {
            strXml += '<c:size val="'.concat(opts.lineDataSymbolSize, '"/>');
          }
          strXml += "<c:spPr>";
          strXml += "<a:solidFill>".concat(createColorElement(opts.chartColors[idx + 1 > opts.chartColors.length ? Math.floor(Math.random() * opts.chartColors.length) : idx]), "</a:solidFill>");
          strXml += '<a:ln w="'.concat(opts.lineDataSymbolLineSize, '" cap="flat"><a:solidFill>').concat(createColorElement(opts.lineDataSymbolLineColor || opts.chartColors[colorIndex % opts.chartColors.length]), '</a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>');
          strXml += "<a:effectLst/>";
          strXml += "</c:spPr>";
          strXml += "</c:marker>";
        }
        if (opts.showLabel) {
          var chartUuid_1 = getUuid("-xxxx-xxxx-xxxx-xxxxxxxxxxxx");
          if (obj.labels[0] && (opts.dataLabelFormatScatter === "custom" || opts.dataLabelFormatScatter === "customXY")) {
            strXml += "<c:dLbls>";
            obj.labels[0].forEach(function(label, idx2) {
              if (opts.dataLabelFormatScatter === "custom" || opts.dataLabelFormatScatter === "customXY") {
                strXml += "  <c:dLbl>";
                strXml += '    <c:idx val="'.concat(idx2, '"/>');
                strXml += "    <c:tx>";
                strXml += "      <c:rich>";
                strXml += "            <a:bodyPr>";
                strXml += "                <a:spAutoFit/>";
                strXml += "            </a:bodyPr>";
                strXml += "            <a:lstStyle/>";
                strXml += "            <a:p>";
                strXml += "                <a:pPr>";
                strXml += "                    <a:defRPr/>";
                strXml += "                </a:pPr>";
                strXml += "              <a:r>";
                strXml += '                    <a:rPr lang="' + (opts.lang || "en-US") + '" dirty="0"/>';
                strXml += "                    <a:t>" + encodeXmlEntities(label) + "</a:t>";
                strXml += "              </a:r>";
                if (opts.dataLabelFormatScatter === "customXY" && !/^ *$/.test(label)) {
                  strXml += "              <a:r>";
                  strXml += '                  <a:rPr lang="' + (opts.lang || "en-US") + '" baseline="0" dirty="0"/>';
                  strXml += "                  <a:t> (</a:t>";
                  strXml += "              </a:r>";
                  strXml += '              <a:fld id="{' + getUuid("xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx") + '}" type="XVALUE">';
                  strXml += '                  <a:rPr lang="' + (opts.lang || "en-US") + '" baseline="0"/>';
                  strXml += "                  <a:pPr>";
                  strXml += "                      <a:defRPr/>";
                  strXml += "                  </a:pPr>";
                  strXml += "                  <a:t>[" + encodeXmlEntities(obj.name) + "</a:t>";
                  strXml += "              </a:fld>";
                  strXml += "              <a:r>";
                  strXml += '                  <a:rPr lang="' + (opts.lang || "en-US") + '" baseline="0" dirty="0"/>';
                  strXml += "                  <a:t>, </a:t>";
                  strXml += "              </a:r>";
                  strXml += '              <a:fld id="{' + getUuid("xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx") + '}" type="YVALUE">';
                  strXml += '                  <a:rPr lang="' + (opts.lang || "en-US") + '" baseline="0"/>';
                  strXml += "                  <a:pPr>";
                  strXml += "                      <a:defRPr/>";
                  strXml += "                  </a:pPr>";
                  strXml += "                  <a:t>[" + encodeXmlEntities(obj.name) + "]</a:t>";
                  strXml += "              </a:fld>";
                  strXml += "              <a:r>";
                  strXml += '                  <a:rPr lang="' + (opts.lang || "en-US") + '" baseline="0" dirty="0"/>';
                  strXml += "                  <a:t>)</a:t>";
                  strXml += "              </a:r>";
                  strXml += '              <a:endParaRPr lang="' + (opts.lang || "en-US") + '" dirty="0"/>';
                }
                strXml += "            </a:p>";
                strXml += "      </c:rich>";
                strXml += "    </c:tx>";
                strXml += "    <c:spPr>";
                strXml += "        <a:noFill/>";
                strXml += "        <a:ln>";
                strXml += "            <a:noFill/>";
                strXml += "        </a:ln>";
                strXml += "        <a:effectLst/>";
                strXml += "    </c:spPr>";
                if (opts.dataLabelPosition)
                  strXml += ' <c:dLblPos val="' + opts.dataLabelPosition + '"/>';
                strXml += '    <c:showLegendKey val="0"/>';
                strXml += '    <c:showVal val="0"/>';
                strXml += '    <c:showCatName val="0"/>';
                strXml += '    <c:showSerName val="0"/>';
                strXml += '    <c:showPercent val="0"/>';
                strXml += '    <c:showBubbleSize val="0"/>';
                strXml += '       <c:showLeaderLines val="1"/>';
                strXml += "    <c:extLst>";
                strXml += '      <c:ext uri="{CE6537A1-D6FC-4f65-9D91-7224C49458BB}" xmlns:c15="http://schemas.microsoft.com/office/drawing/2012/chart"/>';
                strXml += '      <c:ext uri="{C3380CC4-5D6E-409C-BE32-E72D297353CC}" xmlns:c16="http://schemas.microsoft.com/office/drawing/2014/chart">';
                strXml += '            <c16:uniqueId val="{'.concat("00000000".substring(0, 8 - (idx2 + 1).toString().length).toString()).concat(idx2 + 1).concat(chartUuid_1, '}"/>');
                strXml += "      </c:ext>";
                strXml += "        </c:extLst>";
                strXml += "</c:dLbl>";
              }
            });
            strXml += "</c:dLbls>";
          }
          if (opts.dataLabelFormatScatter === "XY") {
            strXml += "<c:dLbls>";
            strXml += "    <c:spPr>";
            strXml += "        <a:noFill/>";
            strXml += "        <a:ln>";
            strXml += "            <a:noFill/>";
            strXml += "        </a:ln>";
            strXml += "          <a:effectLst/>";
            strXml += "    </c:spPr>";
            strXml += "    <c:txPr>";
            strXml += "        <a:bodyPr>";
            strXml += "            <a:spAutoFit/>";
            strXml += "        </a:bodyPr>";
            strXml += "        <a:lstStyle/>";
            strXml += "        <a:p>";
            strXml += "            <a:pPr>";
            strXml += "                <a:defRPr/>";
            strXml += "            </a:pPr>";
            strXml += '            <a:endParaRPr lang="en-US"/>';
            strXml += "        </a:p>";
            strXml += "    </c:txPr>";
            if (opts.dataLabelPosition)
              strXml += ' <c:dLblPos val="' + opts.dataLabelPosition + '"/>';
            strXml += '    <c:showLegendKey val="0"/>';
            strXml += ' <c:showVal val="'.concat(opts.showLabel ? "1" : "0", '"/>');
            strXml += ' <c:showCatName val="'.concat(opts.showLabel ? "1" : "0", '"/>');
            strXml += ' <c:showSerName val="'.concat(opts.showSerName ? "1" : "0", '"/>');
            strXml += '    <c:showPercent val="0"/>';
            strXml += '    <c:showBubbleSize val="0"/>';
            strXml += "    <c:extLst>";
            strXml += '        <c:ext uri="{CE6537A1-D6FC-4f65-9D91-7224C49458BB}" xmlns:c15="http://schemas.microsoft.com/office/drawing/2012/chart">';
            strXml += '            <c15:showLeaderLines val="1"/>';
            strXml += "        </c:ext>";
            strXml += "    </c:extLst>";
            strXml += "</c:dLbls>";
          }
        }
        if (data.length === 1 && opts.chartColors !== BARCHART_COLORS) {
          obj.values.forEach(function(value, index2) {
            var arrColors = value < 0 ? opts.invertedColors || opts.chartColors || BARCHART_COLORS : opts.chartColors || [];
            strXml += "  <c:dPt>";
            strXml += '    <c:idx val="'.concat(index2, '"/>');
            strXml += '      <c:invertIfNegative val="0"/>';
            strXml += '    <c:bubble3D val="0"/>';
            strXml += "    <c:spPr>";
            if (opts.lineSize === 0) {
              strXml += "<a:ln><a:noFill/></a:ln>";
            } else {
              strXml += "<a:solidFill>";
              strXml += ' <a:srgbClr val="' + arrColors[index2 % arrColors.length] + '"/>';
              strXml += "</a:solidFill>";
            }
            strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
            strXml += "    </c:spPr>";
            strXml += "  </c:dPt>";
          });
        }
        {
          strXml += "<c:xVal>";
          strXml += "  <c:numRef>";
          strXml += "    <c:f>Sheet1!$A$2:$A$".concat(data[0].values.length + 1, "</c:f>");
          strXml += "    <c:numCache>";
          strXml += "      <c:formatCode>General</c:formatCode>";
          strXml += '      <c:ptCount val="'.concat(data[0].values.length, '"/>');
          data[0].values.forEach(function(value, idx2) {
            strXml += '<c:pt idx="'.concat(idx2, '"><c:v>').concat(value || value === 0 ? value : "", "</c:v></c:pt>");
          });
          strXml += "    </c:numCache>";
          strXml += "  </c:numRef>";
          strXml += "</c:xVal>";
          strXml += "<c:yVal>";
          strXml += "  <c:numRef>";
          strXml += "    <c:f>Sheet1!$".concat(getExcelColName(idx + 2), "$2:$").concat(getExcelColName(idx + 2), "$").concat(data[0].values.length + 1, "</c:f>");
          strXml += "    <c:numCache>";
          strXml += "      <c:formatCode>General</c:formatCode>";
          strXml += '      <c:ptCount val="'.concat(data[0].values.length, '"/>');
          data[0].values.forEach(function(_value, idx2) {
            strXml += '<c:pt idx="'.concat(idx2, '"><c:v>').concat(obj.values[idx2] || obj.values[idx2] === 0 ? obj.values[idx2] : "", "</c:v></c:pt>");
          });
          strXml += "    </c:numCache>";
          strXml += "  </c:numRef>";
          strXml += "</c:yVal>";
        }
        strXml += '<c:smooth val="' + (opts.lineSmooth ? "1" : "0") + '"/>';
        strXml += "</c:ser>";
      });
      {
        strXml += "  <c:dLbls>";
        strXml += '    <c:numFmt formatCode="'.concat(encodeXmlEntities(opts.dataLabelFormatCode) || "General", '" sourceLinked="0"/>');
        strXml += "    <c:txPr>";
        strXml += "      <a:bodyPr/>";
        strXml += "      <a:lstStyle/>";
        strXml += "      <a:p><a:pPr>";
        strXml += '        <a:defRPr b="'.concat(opts.dataLabelFontBold ? "1" : "0", '" i="').concat(opts.dataLabelFontItalic ? "1" : "0", '" strike="noStrike" sz="').concat(Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100), '" u="none">');
        strXml += "          <a:solidFill>" + createColorElement(opts.dataLabelColor || DEF_FONT_COLOR) + "</a:solidFill>";
        strXml += '          <a:latin typeface="' + (opts.dataLabelFontFace || "Arial") + '"/>';
        strXml += "        </a:defRPr>";
        strXml += "      </a:pPr></a:p>";
        strXml += "    </c:txPr>";
        if (opts.dataLabelPosition)
          strXml += ' <c:dLblPos val="' + opts.dataLabelPosition + '"/>';
        strXml += '    <c:showLegendKey val="0"/>';
        strXml += '    <c:showVal val="' + (opts.showValue ? "1" : "0") + '"/>';
        strXml += '    <c:showCatName val="0"/>';
        strXml += '    <c:showSerName val="' + (opts.showSerName ? "1" : "0") + '"/>';
        strXml += '    <c:showPercent val="0"/>';
        strXml += '    <c:showBubbleSize val="0"/>';
        strXml += "  </c:dLbls>";
      }
      strXml += '<c:axId val="'.concat(catAxisId, '"/><c:axId val="').concat(valAxisId, '"/>');
      strXml += "</c:" + chartType + "Chart>";
      break;
    case CHART_TYPE.BUBBLE:
    case CHART_TYPE.BUBBLE3D:
      strXml += "<c:bubbleChart>";
      strXml += '<c:varyColors val="0"/>';
      colorIndex = -1;
      data.filter(function(_obj, idx) {
        return idx > 0;
      }).forEach(function(obj, idx) {
        colorIndex++;
        strXml += "<c:ser>";
        strXml += '  <c:idx val="'.concat(idx, '"/>');
        strXml += '  <c:order val="'.concat(idx, '"/>');
        strXml += "  <c:tx>";
        strXml += "    <c:strRef>";
        strXml += "      <c:f>Sheet1!$" + getExcelColName(idxColLtr + 1) + "$1</c:f>";
        strXml += '      <c:strCache><c:ptCount val="1"/><c:pt idx="0"><c:v>' + encodeXmlEntities(obj.name) + "</c:v></c:pt></c:strCache>";
        strXml += "    </c:strRef>";
        strXml += "  </c:tx>";
        {
          strXml += "<c:spPr>";
          var tmpSerColor = opts.chartColors[colorIndex % opts.chartColors.length];
          if (tmpSerColor === "transparent") {
            strXml += "<a:noFill/>";
          } else if (opts.chartColorsOpacity) {
            strXml += "<a:solidFill>".concat(createColorElement(tmpSerColor, '<a:alpha val="' + Math.round(opts.chartColorsOpacity * 1000).toString() + '"/>'), "</a:solidFill>");
          } else {
            strXml += "<a:solidFill>" + createColorElement(tmpSerColor) + "</a:solidFill>";
          }
          if (opts.lineSize === 0) {
            strXml += "<a:ln><a:noFill/></a:ln>";
          } else if (opts.dataBorder) {
            strXml += '<a:ln w="'.concat(valToPts(opts.dataBorder.pt), '" cap="flat"><a:solidFill>').concat(createColorElement(opts.dataBorder.color), '</a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>');
          } else {
            strXml += '<a:ln w="'.concat(valToPts(opts.lineSize), '" cap="flat"><a:solidFill>').concat(createColorElement(tmpSerColor), "</a:solidFill>");
            strXml += '<a:prstDash val="'.concat(opts.lineDash || "solid", '"/><a:round/></a:ln>');
          }
          strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
          strXml += "</c:spPr>";
        }
        {
          strXml += "<c:xVal>";
          strXml += "  <c:numRef>";
          strXml += "    <c:f>Sheet1!$A$2:$A$".concat(data[0].values.length + 1, "</c:f>");
          strXml += "    <c:numCache>";
          strXml += "      <c:formatCode>General</c:formatCode>";
          strXml += '      <c:ptCount val="'.concat(data[0].values.length, '"/>');
          data[0].values.forEach(function(value, idx2) {
            strXml += '<c:pt idx="'.concat(idx2, '"><c:v>').concat(value || value === 0 ? value : "", "</c:v></c:pt>");
          });
          strXml += "    </c:numCache>";
          strXml += "  </c:numRef>";
          strXml += "</c:xVal>";
          strXml += "<c:yVal>";
          strXml += "  <c:numRef>";
          strXml += "<c:f>Sheet1!$".concat(getExcelColName(idxColLtr + 1), "$2:$").concat(getExcelColName(idxColLtr + 1), "$").concat(data[0].values.length + 1, "</c:f>");
          idxColLtr++;
          strXml += "    <c:numCache>";
          strXml += "      <c:formatCode>General</c:formatCode>";
          strXml += '      <c:ptCount val="'.concat(data[0].values.length, '"/>');
          data[0].values.forEach(function(_value, idx2) {
            strXml += '<c:pt idx="'.concat(idx2, '"><c:v>').concat(obj.values[idx2] || obj.values[idx2] === 0 ? obj.values[idx2] : "", "</c:v></c:pt>");
          });
          strXml += "    </c:numCache>";
          strXml += "  </c:numRef>";
          strXml += "</c:yVal>";
        }
        strXml += "  <c:bubbleSize>";
        strXml += "    <c:numRef>";
        strXml += "<c:f>Sheet1!$".concat(getExcelColName(idxColLtr + 1), "$2:$").concat(getExcelColName(idxColLtr + 1), "$").concat(obj.sizes.length + 1, "</c:f>");
        idxColLtr++;
        strXml += "      <c:numCache>";
        strXml += "        <c:formatCode>General</c:formatCode>";
        strXml += '           <c:ptCount val="'.concat(obj.sizes.length, '"/>');
        obj.sizes.forEach(function(value, idx2) {
          strXml += '<c:pt idx="'.concat(idx2, '"><c:v>').concat(value || "", "</c:v></c:pt>");
        });
        strXml += "      </c:numCache>";
        strXml += "    </c:numRef>";
        strXml += "  </c:bubbleSize>";
        strXml += '  <c:bubble3D val="' + (chartType === CHART_TYPE.BUBBLE3D ? "1" : "0") + '"/>';
        strXml += "</c:ser>";
      });
      {
        strXml += "<c:dLbls>";
        strXml += '<c:numFmt formatCode="'.concat(encodeXmlEntities(opts.dataLabelFormatCode) || "General", '" sourceLinked="0"/>');
        strXml += "<c:txPr><a:bodyPr/><a:lstStyle/><a:p><a:pPr>";
        strXml += '<a:defRPr b="'.concat(opts.dataLabelFontBold ? 1 : 0, '" i="').concat(opts.dataLabelFontItalic ? 1 : 0, '" strike="noStrike" sz="').concat(Math.round(Math.round(opts.dataLabelFontSize || DEF_FONT_SIZE) * 100), '" u="none">');
        strXml += "<a:solidFill>".concat(createColorElement(opts.dataLabelColor || DEF_FONT_COLOR), "</a:solidFill>");
        strXml += '<a:latin typeface="'.concat(opts.dataLabelFontFace || "Arial", '"/>');
        strXml += "</a:defRPr></a:pPr></a:p></c:txPr>";
        if (opts.dataLabelPosition)
          strXml += '<c:dLblPos val="'.concat(opts.dataLabelPosition, '"/>');
        strXml += '<c:showLegendKey val="0"/>';
        strXml += '<c:showVal val="'.concat(opts.showValue ? "1" : "0", '"/>');
        strXml += '<c:showCatName val="0"/><c:showSerName val="'.concat(opts.showSerName ? "1" : "0", '"/><c:showPercent val="0"/><c:showBubbleSize val="0"/>');
        strXml += "<c:extLst>";
        strXml += '  <c:ext uri="{CE6537A1-D6FC-4f65-9D91-7224C49458BB}" xmlns:c15="http://schemas.microsoft.com/office/drawing/2012/chart">';
        strXml += '    <c15:showLeaderLines val="' + (opts.showLeaderLines ? "1" : "0") + '"/>';
        strXml += "  </c:ext>";
        strXml += "</c:extLst>";
        strXml += "</c:dLbls>";
      }
      strXml += '<c:axId val="'.concat(catAxisId, '"/><c:axId val="').concat(valAxisId, '"/>');
      strXml += "</c:bubbleChart>";
      break;
    case CHART_TYPE.DOUGHNUT:
    case CHART_TYPE.PIE:
      optsChartData = data[0];
      strXml += "<c:" + chartType + "Chart>";
      strXml += '  <c:varyColors val="1"/>';
      strXml += "<c:ser>";
      strXml += '  <c:idx val="0"/>';
      strXml += '  <c:order val="0"/>';
      strXml += "  <c:tx>";
      strXml += "    <c:strRef>";
      strXml += "      <c:f>Sheet1!$B$1</c:f>";
      strXml += "      <c:strCache>";
      strXml += '        <c:ptCount val="1"/>';
      strXml += '        <c:pt idx="0"><c:v>' + encodeXmlEntities(optsChartData.name) + "</c:v></c:pt>";
      strXml += "      </c:strCache>";
      strXml += "    </c:strRef>";
      strXml += "  </c:tx>";
      strXml += "  <c:spPr>";
      strXml += '    <a:solidFill><a:schemeClr val="accent1"/></a:solidFill>';
      strXml += '    <a:ln w="9525" cap="flat"><a:solidFill><a:srgbClr val="F9F9F9"/></a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>';
      if (opts.dataNoEffects) {
        strXml += "<a:effectLst/>";
      } else {
        strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
      }
      strXml += "  </c:spPr>";
      optsChartData.labels[0].forEach(function(_label, idx) {
        strXml += "<c:dPt>";
        strXml += ' <c:idx val="'.concat(idx, '"/>');
        strXml += ' <c:bubble3D val="0"/>';
        strXml += " <c:spPr>";
        strXml += "<a:solidFill>".concat(createColorElement(opts.chartColors[idx + 1 > opts.chartColors.length ? Math.floor(Math.random() * opts.chartColors.length) : idx]), "</a:solidFill>");
        if (opts.dataBorder) {
          strXml += '<a:ln w="'.concat(valToPts(opts.dataBorder.pt), '" cap="flat"><a:solidFill>').concat(createColorElement(opts.dataBorder.color), '</a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>');
        }
        strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
        strXml += "  </c:spPr>";
        strXml += "</c:dPt>";
      });
      strXml += "<c:dLbls>";
      optsChartData.labels[0].forEach(function(_label, idx) {
        strXml += "<c:dLbl>";
        strXml += ' <c:idx val="'.concat(idx, '"/>');
        strXml += '  <c:numFmt formatCode="'.concat(encodeXmlEntities(opts.dataLabelFormatCode) || "General", '" sourceLinked="0"/>');
        strXml += "  <c:spPr/><c:txPr>";
        strXml += "   <a:bodyPr/><a:lstStyle/>";
        strXml += "   <a:p><a:pPr>";
        strXml += '   <a:defRPr sz="'.concat(Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100), '" b="').concat(opts.dataLabelFontBold ? 1 : 0, '" i="').concat(opts.dataLabelFontItalic ? 1 : 0, '" u="none" strike="noStrike">');
        strXml += "    <a:solidFill>" + createColorElement(opts.dataLabelColor || DEF_FONT_COLOR) + "</a:solidFill>";
        strXml += '    <a:latin typeface="'.concat(opts.dataLabelFontFace || "Arial", '"/>');
        strXml += "   </a:defRPr>";
        strXml += "      </a:pPr></a:p>";
        strXml += "    </c:txPr>";
        if (chartType === CHART_TYPE.PIE && opts.dataLabelPosition)
          strXml += '<c:dLblPos val="'.concat(opts.dataLabelPosition, '"/>');
        strXml += '    <c:showLegendKey val="0"/>';
        strXml += '    <c:showVal val="' + (opts.showValue ? "1" : "0") + '"/>';
        strXml += '    <c:showCatName val="' + (opts.showLabel ? "1" : "0") + '"/>';
        strXml += '    <c:showSerName val="' + (opts.showSerName ? "1" : "0") + '"/>';
        strXml += '    <c:showPercent val="' + (opts.showPercent ? "1" : "0") + '"/>';
        strXml += '    <c:showBubbleSize val="0"/>';
        strXml += "  </c:dLbl>";
      });
      strXml += ' <c:numFmt formatCode="'.concat(encodeXmlEntities(opts.dataLabelFormatCode) || "General", '" sourceLinked="0"/>');
      strXml += "    <c:txPr>";
      strXml += "      <a:bodyPr/>";
      strXml += "      <a:lstStyle/>";
      strXml += "      <a:p>";
      strXml += "        <a:pPr>";
      strXml += '          <a:defRPr sz="1800" b="'.concat(opts.dataLabelFontBold ? "1" : "0", '" i="').concat(opts.dataLabelFontItalic ? "1" : "0", '" u="none" strike="noStrike">');
      strXml += '            <a:solidFill><a:srgbClr val="000000"/></a:solidFill><a:latin typeface="Arial"/>';
      strXml += "          </a:defRPr>";
      strXml += "        </a:pPr>";
      strXml += "      </a:p>";
      strXml += "    </c:txPr>";
      strXml += chartType === CHART_TYPE.PIE ? '<c:dLblPos val="ctr"/>' : "";
      strXml += '    <c:showLegendKey val="0"/>';
      strXml += '    <c:showVal val="0"/>';
      strXml += '    <c:showCatName val="1"/>';
      strXml += '    <c:showSerName val="0"/>';
      strXml += '    <c:showPercent val="1"/>';
      strXml += '    <c:showBubbleSize val="0"/>';
      strXml += ' <c:showLeaderLines val="'.concat(opts.showLeaderLines ? "1" : "0", '"/>');
      strXml += "</c:dLbls>";
      strXml += "<c:cat>";
      strXml += "  <c:strRef>";
      strXml += "    <c:f>Sheet1!$A$2:$A$".concat(optsChartData.labels[0].length + 1, "</c:f>");
      strXml += "    <c:strCache>";
      strXml += '         <c:ptCount val="'.concat(optsChartData.labels[0].length, '"/>');
      optsChartData.labels[0].forEach(function(label, idx) {
        strXml += '<c:pt idx="'.concat(idx, '"><c:v>').concat(encodeXmlEntities(label), "</c:v></c:pt>");
      });
      strXml += "    </c:strCache>";
      strXml += "  </c:strRef>";
      strXml += "</c:cat>";
      strXml += "  <c:val>";
      strXml += "    <c:numRef>";
      strXml += "      <c:f>Sheet1!$B$2:$B$".concat(optsChartData.labels[0].length + 1, "</c:f>");
      strXml += "      <c:numCache>";
      strXml += '           <c:ptCount val="'.concat(optsChartData.labels[0].length, '"/>');
      optsChartData.values.forEach(function(value, idx) {
        strXml += '<c:pt idx="'.concat(idx, '"><c:v>').concat(value || value === 0 ? value : "", "</c:v></c:pt>");
      });
      strXml += "      </c:numCache>";
      strXml += "    </c:numRef>";
      strXml += "  </c:val>";
      strXml += "  </c:ser>";
      strXml += '  <c:firstSliceAng val="'.concat(opts.firstSliceAng ? Math.round(opts.firstSliceAng) : 0, '"/>');
      if (chartType === CHART_TYPE.DOUGHNUT)
        strXml += '<c:holeSize val="'.concat(typeof opts.holeSize === "number" ? opts.holeSize : "50", '"/>');
      strXml += "</c:" + chartType + "Chart>";
      break;
    default:
      strXml += "";
      break;
  }
  return strXml;
}
function makeCatAxis(opts, axisId, valAxisId) {
  var strXml = "";
  if (opts._type === CHART_TYPE.SCATTER || opts._type === CHART_TYPE.BUBBLE || opts._type === CHART_TYPE.BUBBLE3D) {
    strXml += "<c:valAx>";
  } else {
    strXml += "<c:" + (opts.catLabelFormatCode ? "dateAx" : "catAx") + ">";
  }
  strXml += '  <c:axId val="' + axisId + '"/>';
  strXml += "  <c:scaling>";
  strXml += '<c:orientation val="' + (opts.catAxisOrientation || (opts.barDir === "col" ? "minMax" : "minMax")) + '"/>';
  if (opts.catAxisMaxVal || opts.catAxisMaxVal === 0)
    strXml += '<c:max val="'.concat(opts.catAxisMaxVal, '"/>');
  if (opts.catAxisMinVal || opts.catAxisMinVal === 0)
    strXml += '<c:min val="'.concat(opts.catAxisMinVal, '"/>');
  strXml += "</c:scaling>";
  strXml += '  <c:delete val="' + (opts.catAxisHidden ? "1" : "0") + '"/>';
  strXml += '  <c:axPos val="' + (opts.barDir === "col" ? "b" : "l") + '"/>';
  strXml += opts.catGridLine.style !== "none" ? createGridLineElement(opts.catGridLine) : "";
  if (opts.showCatAxisTitle) {
    strXml += genXmlTitle({
      color: opts.catAxisTitleColor,
      fontFace: opts.catAxisTitleFontFace,
      fontSize: opts.catAxisTitleFontSize,
      titleRotate: opts.catAxisTitleRotate,
      title: opts.catAxisTitle || "Axis Title"
    });
  }
  if (opts._type === CHART_TYPE.SCATTER || opts._type === CHART_TYPE.BUBBLE || opts._type === CHART_TYPE.BUBBLE3D) {
    strXml += '  <c:numFmt formatCode="' + (opts.valAxisLabelFormatCode ? encodeXmlEntities(opts.valAxisLabelFormatCode) : "General") + '" sourceLinked="1"/>';
  } else {
    strXml += '  <c:numFmt formatCode="' + (encodeXmlEntities(opts.catLabelFormatCode) || "General") + '" sourceLinked="1"/>';
  }
  if (opts._type === CHART_TYPE.SCATTER) {
    strXml += '  <c:majorTickMark val="none"/>';
    strXml += '  <c:minorTickMark val="none"/>';
    strXml += '  <c:tickLblPos val="nextTo"/>';
  } else {
    strXml += '  <c:majorTickMark val="' + (opts.catAxisMajorTickMark || "out") + '"/>';
    strXml += '  <c:minorTickMark val="' + (opts.catAxisMinorTickMark || "none") + '"/>';
    strXml += '  <c:tickLblPos val="' + (opts.catAxisLabelPos || (opts.barDir === "col" ? "low" : "nextTo")) + '"/>';
  }
  strXml += "  <c:spPr>";
  strXml += '    <a:ln w="'.concat(opts.catAxisLineSize ? valToPts(opts.catAxisLineSize) : ONEPT, '" cap="flat">');
  strXml += !opts.catAxisLineShow ? "<a:noFill/>" : "<a:solidFill>" + createColorElement(opts.catAxisLineColor || DEF_CHART_GRIDLINE.color) + "</a:solidFill>";
  strXml += '      <a:prstDash val="' + (opts.catAxisLineStyle || "solid") + '"/>';
  strXml += "      <a:round/>";
  strXml += "    </a:ln>";
  strXml += "  </c:spPr>";
  strXml += "  <c:txPr>";
  if (opts.catAxisLabelRotate) {
    strXml += '<a:bodyPr rot="'.concat(convertRotationDegrees(opts.catAxisLabelRotate), '"/>');
  } else {
    strXml += "<a:bodyPr/>";
  }
  strXml += "    <a:lstStyle/>";
  strXml += "    <a:p>";
  strXml += "    <a:pPr>";
  strXml += '      <a:defRPr sz="'.concat(Math.round((opts.catAxisLabelFontSize || DEF_FONT_SIZE) * 100), '" b="').concat(opts.catAxisLabelFontBold ? 1 : 0, '" i="').concat(opts.catAxisLabelFontItalic ? 1 : 0, '" u="none" strike="noStrike">');
  strXml += "      <a:solidFill>" + createColorElement(opts.catAxisLabelColor || DEF_FONT_COLOR) + "</a:solidFill>";
  strXml += '      <a:latin typeface="' + (opts.catAxisLabelFontFace || "Arial") + '"/>';
  strXml += "   </a:defRPr>";
  strXml += "  </a:pPr>";
  strXml += '  <a:endParaRPr lang="' + (opts.lang || "en-US") + '"/>';
  strXml += "  </a:p>";
  strXml += " </c:txPr>";
  strXml += ' <c:crossAx val="' + valAxisId + '"/>';
  strXml += " <c:".concat(typeof opts.valAxisCrossesAt === "number" ? "crossesAt" : "crosses", ' val="').concat(opts.valAxisCrossesAt || "autoZero", '"/>');
  strXml += ' <c:auto val="1"/>';
  strXml += ' <c:lblAlgn val="ctr"/>';
  strXml += ' <c:noMultiLvlLbl val="'.concat(opts.catAxisMultiLevelLabels ? 0 : 1, '"/>');
  if (opts.catAxisLabelFrequency)
    strXml += ' <c:tickLblSkip val="' + opts.catAxisLabelFrequency + '"/>';
  if (opts.catLabelFormatCode || opts._type === CHART_TYPE.SCATTER || opts._type === CHART_TYPE.BUBBLE || opts._type === CHART_TYPE.BUBBLE3D) {
    if (opts.catLabelFormatCode) {
      ["catAxisBaseTimeUnit", "catAxisMajorTimeUnit", "catAxisMinorTimeUnit"].forEach(function(opt) {
        if (opts[opt] && (typeof opts[opt] !== "string" || !["days", "months", "years"].includes(opts[opt].toLowerCase()))) {
          console.warn('"'.concat(opt, `" must be one of: 'days','months','years' !`));
          opts[opt] = null;
        }
      });
      if (opts.catAxisBaseTimeUnit)
        strXml += '<c:baseTimeUnit val="' + opts.catAxisBaseTimeUnit.toLowerCase() + '"/>';
      if (opts.catAxisMajorTimeUnit)
        strXml += '<c:majorTimeUnit val="' + opts.catAxisMajorTimeUnit.toLowerCase() + '"/>';
      if (opts.catAxisMinorTimeUnit)
        strXml += '<c:minorTimeUnit val="' + opts.catAxisMinorTimeUnit.toLowerCase() + '"/>';
    }
    if (opts.catAxisMajorUnit)
      strXml += '<c:majorUnit val="'.concat(opts.catAxisMajorUnit, '"/>');
    if (opts.catAxisMinorUnit)
      strXml += '<c:minorUnit val="'.concat(opts.catAxisMinorUnit, '"/>');
  }
  if (opts._type === CHART_TYPE.SCATTER || opts._type === CHART_TYPE.BUBBLE || opts._type === CHART_TYPE.BUBBLE3D) {
    strXml += "</c:valAx>";
  } else {
    strXml += "</c:" + (opts.catLabelFormatCode ? "dateAx" : "catAx") + ">";
  }
  return strXml;
}
function makeValAxis(opts, valAxisId) {
  var axisPos = valAxisId === AXIS_ID_VALUE_PRIMARY ? opts.barDir === "col" ? "l" : "b" : opts.barDir !== "col" ? "r" : "t";
  if (valAxisId === AXIS_ID_VALUE_SECONDARY)
    axisPos = "r";
  var crossAxId = valAxisId === AXIS_ID_VALUE_PRIMARY ? AXIS_ID_CATEGORY_PRIMARY : AXIS_ID_CATEGORY_SECONDARY;
  var strXml = "";
  strXml += "<c:valAx>";
  strXml += '  <c:axId val="' + valAxisId + '"/>';
  strXml += "  <c:scaling>";
  if (opts.valAxisLogScaleBase)
    strXml += '<c:logBase val="'.concat(opts.valAxisLogScaleBase, '"/>');
  strXml += '<c:orientation val="' + (opts.valAxisOrientation || (opts.barDir === "col" ? "minMax" : "minMax")) + '"/>';
  if (opts.valAxisMaxVal || opts.valAxisMaxVal === 0)
    strXml += '<c:max val="'.concat(opts.valAxisMaxVal, '"/>');
  if (opts.valAxisMinVal || opts.valAxisMinVal === 0)
    strXml += '<c:min val="'.concat(opts.valAxisMinVal, '"/>');
  strXml += "  </c:scaling>";
  strXml += '  <c:delete val="'.concat(opts.valAxisHidden ? 1 : 0, '"/>');
  strXml += '  <c:axPos val="' + axisPos + '"/>';
  if (opts.valGridLine.style !== "none")
    strXml += createGridLineElement(opts.valGridLine);
  if (opts.showValAxisTitle) {
    strXml += genXmlTitle({
      color: opts.valAxisTitleColor,
      fontFace: opts.valAxisTitleFontFace,
      fontSize: opts.valAxisTitleFontSize,
      titleRotate: opts.valAxisTitleRotate,
      title: opts.valAxisTitle || "Axis Title"
    });
  }
  strXml += '<c:numFmt formatCode="'.concat(opts.valAxisLabelFormatCode ? encodeXmlEntities(opts.valAxisLabelFormatCode) : "General", '" sourceLinked="0"/>');
  if (opts._type === CHART_TYPE.SCATTER) {
    strXml += '  <c:majorTickMark val="none"/>';
    strXml += '  <c:minorTickMark val="none"/>';
    strXml += '  <c:tickLblPos val="nextTo"/>';
  } else {
    strXml += ' <c:majorTickMark val="' + (opts.valAxisMajorTickMark || "out") + '"/>';
    strXml += ' <c:minorTickMark val="' + (opts.valAxisMinorTickMark || "none") + '"/>';
    strXml += ' <c:tickLblPos val="' + (opts.valAxisLabelPos || (opts.barDir === "col" ? "nextTo" : "low")) + '"/>';
  }
  strXml += " <c:spPr>";
  strXml += '   <a:ln w="'.concat(opts.valAxisLineSize ? valToPts(opts.valAxisLineSize) : ONEPT, '" cap="flat">');
  strXml += !opts.valAxisLineShow ? "<a:noFill/>" : "<a:solidFill>" + createColorElement(opts.valAxisLineColor || DEF_CHART_GRIDLINE.color) + "</a:solidFill>";
  strXml += '     <a:prstDash val="' + (opts.valAxisLineStyle || "solid") + '"/>';
  strXml += "     <a:round/>";
  strXml += "   </a:ln>";
  strXml += " </c:spPr>";
  strXml += " <c:txPr>";
  strXml += "  <a:bodyPr".concat(opts.valAxisLabelRotate ? ' rot="' + convertRotationDegrees(opts.valAxisLabelRotate).toString() + '"' : "", "/>");
  strXml += "  <a:lstStyle/>";
  strXml += "  <a:p>";
  strXml += "    <a:pPr>";
  strXml += '      <a:defRPr sz="'.concat(Math.round((opts.valAxisLabelFontSize || DEF_FONT_SIZE) * 100), '" b="').concat(opts.valAxisLabelFontBold ? 1 : 0, '" i="').concat(opts.valAxisLabelFontItalic ? 1 : 0, '" u="none" strike="noStrike">');
  strXml += "        <a:solidFill>" + createColorElement(opts.valAxisLabelColor || DEF_FONT_COLOR) + "</a:solidFill>";
  strXml += '        <a:latin typeface="' + (opts.valAxisLabelFontFace || "Arial") + '"/>';
  strXml += "      </a:defRPr>";
  strXml += "    </a:pPr>";
  strXml += '  <a:endParaRPr lang="' + (opts.lang || "en-US") + '"/>';
  strXml += "  </a:p>";
  strXml += " </c:txPr>";
  strXml += ' <c:crossAx val="' + crossAxId + '"/>';
  if (typeof opts.catAxisCrossesAt === "number") {
    strXml += ' <c:crossesAt val="'.concat(opts.catAxisCrossesAt, '"/>');
  } else if (typeof opts.catAxisCrossesAt === "string") {
    strXml += ' <c:crosses val="' + opts.catAxisCrossesAt + '"/>';
  } else {
    var isRight = axisPos === "r" || axisPos === "t";
    var crosses = isRight ? "max" : "autoZero";
    strXml += ' <c:crosses val="' + crosses + '"/>';
  }
  strXml += ' <c:crossBetween val="' + (opts._type === CHART_TYPE.SCATTER || !!(Array.isArray(opts._type) && opts._type.filter(function(type) {
    return type.type === CHART_TYPE.AREA;
  }).length > 0) ? "midCat" : "between") + '"/>';
  if (opts.valAxisMajorUnit)
    strXml += ' <c:majorUnit val="'.concat(opts.valAxisMajorUnit, '"/>');
  if (opts.valAxisDisplayUnit) {
    strXml += '<c:dispUnits><c:builtInUnit val="'.concat(opts.valAxisDisplayUnit, '"/>').concat(opts.valAxisDisplayUnitLabel ? "<c:dispUnitsLbl/>" : "", "</c:dispUnits>");
  }
  strXml += "</c:valAx>";
  return strXml;
}
function makeSerAxis(opts, axisId, valAxisId) {
  var strXml = "";
  strXml += "<c:serAx>";
  strXml += '  <c:axId val="' + axisId + '"/>';
  strXml += '  <c:scaling><c:orientation val="' + (opts.serAxisOrientation || (opts.barDir === "col" ? "minMax" : "minMax")) + '"/></c:scaling>';
  strXml += '  <c:delete val="' + (opts.serAxisHidden ? "1" : "0") + '"/>';
  strXml += '  <c:axPos val="' + (opts.barDir === "col" ? "b" : "l") + '"/>';
  strXml += opts.serGridLine.style !== "none" ? createGridLineElement(opts.serGridLine) : "";
  if (opts.showSerAxisTitle) {
    strXml += genXmlTitle({
      color: opts.serAxisTitleColor,
      fontFace: opts.serAxisTitleFontFace,
      fontSize: opts.serAxisTitleFontSize,
      titleRotate: opts.serAxisTitleRotate,
      title: opts.serAxisTitle || "Axis Title"
    });
  }
  strXml += '  <c:numFmt formatCode="'.concat(encodeXmlEntities(opts.serLabelFormatCode) || "General", '" sourceLinked="0"/>');
  strXml += '  <c:majorTickMark val="out"/>';
  strXml += '  <c:minorTickMark val="none"/>';
  strXml += '  <c:tickLblPos val="'.concat(opts.serAxisLabelPos || opts.barDir === "col" ? "low" : "nextTo", '"/>');
  strXml += "  <c:spPr>";
  strXml += '    <a:ln w="12700" cap="flat">';
  strXml += !opts.serAxisLineShow ? "<a:noFill/>" : "<a:solidFill>".concat(createColorElement(opts.serAxisLineColor || DEF_CHART_GRIDLINE.color), "</a:solidFill>");
  strXml += '      <a:prstDash val="solid"/>';
  strXml += "      <a:round/>";
  strXml += "    </a:ln>";
  strXml += "  </c:spPr>";
  strXml += "  <c:txPr>";
  strXml += "    <a:bodyPr/>";
  strXml += "    <a:lstStyle/>";
  strXml += "    <a:p>";
  strXml += "    <a:pPr>";
  strXml += '    <a:defRPr sz="'.concat(Math.round((opts.serAxisLabelFontSize || DEF_FONT_SIZE) * 100), '" b="').concat(opts.serAxisLabelFontBold ? "1" : "0", '" i="').concat(opts.serAxisLabelFontItalic ? "1" : "0", '" u="none" strike="noStrike">');
  strXml += "      <a:solidFill>".concat(createColorElement(opts.serAxisLabelColor || DEF_FONT_COLOR), "</a:solidFill>");
  strXml += '      <a:latin typeface="'.concat(opts.serAxisLabelFontFace || "Arial", '"/>');
  strXml += "   </a:defRPr>";
  strXml += "  </a:pPr>";
  strXml += '  <a:endParaRPr lang="' + (opts.lang || "en-US") + '"/>';
  strXml += "  </a:p>";
  strXml += " </c:txPr>";
  strXml += ' <c:crossAx val="' + valAxisId + '"/>';
  strXml += ' <c:crosses val="autoZero"/>';
  if (opts.serAxisLabelFrequency)
    strXml += ' <c:tickLblSkip val="' + opts.serAxisLabelFrequency + '"/>';
  if (opts.serLabelFormatCode) {
    ["serAxisBaseTimeUnit", "serAxisMajorTimeUnit", "serAxisMinorTimeUnit"].forEach(function(opt) {
      if (opts[opt] && (typeof opts[opt] !== "string" || !["days", "months", "years"].includes(opt.toLowerCase()))) {
        console.warn('"'.concat(opt, `" must be one of: 'days','months','years' !`));
        opts[opt] = null;
      }
    });
    if (opts.serAxisBaseTimeUnit)
      strXml += ' <c:baseTimeUnit  val="'.concat(opts.serAxisBaseTimeUnit.toLowerCase(), '"/>');
    if (opts.serAxisMajorTimeUnit)
      strXml += ' <c:majorTimeUnit val="'.concat(opts.serAxisMajorTimeUnit.toLowerCase(), '"/>');
    if (opts.serAxisMinorTimeUnit)
      strXml += ' <c:minorTimeUnit val="'.concat(opts.serAxisMinorTimeUnit.toLowerCase(), '"/>');
    if (opts.serAxisMajorUnit)
      strXml += ' <c:majorUnit val="'.concat(opts.serAxisMajorUnit, '"/>');
    if (opts.serAxisMinorUnit)
      strXml += ' <c:minorUnit val="'.concat(opts.serAxisMinorUnit, '"/>');
  }
  strXml += "</c:serAx>";
  return strXml;
}
function genXmlTitle(opts, chartX, chartY) {
  var align = opts.titleAlign === "left" || opts.titleAlign === "right" ? '<a:pPr algn="'.concat(opts.titleAlign.substring(0, 1), '">') : "<a:pPr>";
  var rotate = opts.titleRotate ? '<a:bodyPr rot="'.concat(convertRotationDegrees(opts.titleRotate), '"/>') : "<a:bodyPr/>";
  var sizeAttr = opts.fontSize ? 'sz="'.concat(Math.round(opts.fontSize * 100), '"') : "";
  var titleBold = opts.titleBold ? 1 : 0;
  var layout = "<c:layout/>";
  if (opts.titlePos && typeof opts.titlePos.x === "number" && typeof opts.titlePos.y === "number") {
    var totalX = opts.titlePos.x + chartX;
    var totalY = opts.titlePos.y + chartY;
    var valX = totalX === 0 ? 0 : totalX * (totalX / 5) / 10;
    if (valX >= 1)
      valX = valX / 10;
    if (valX >= 0.1)
      valX = valX / 10;
    var valY = totalY === 0 ? 0 : totalY * (totalY / 5) / 10;
    if (valY >= 1)
      valY = valY / 10;
    if (valY >= 0.1)
      valY = valY / 10;
    layout = '<c:layout><c:manualLayout><c:xMode val="edge"/><c:yMode val="edge"/><c:x val="'.concat(valX, '"/><c:y val="').concat(valY, '"/></c:manualLayout></c:layout>');
  }
  return `<c:title>
      <c:tx>
        <c:rich>
          `.concat(rotate, `
          <a:lstStyle/>
          <a:p>
            `).concat(align, `
            <a:defRPr `).concat(sizeAttr, ' b="').concat(titleBold, `" i="0" u="none" strike="noStrike">
              <a:solidFill>`).concat(createColorElement(opts.color || DEF_FONT_COLOR), `</a:solidFill>
              <a:latin typeface="`).concat(opts.fontFace || "Arial", `"/>
            </a:defRPr>
          </a:pPr>
          <a:r>
            <a:rPr `).concat(sizeAttr, ' b="').concat(titleBold, `" i="0" u="none" strike="noStrike">
              <a:solidFill>`).concat(createColorElement(opts.color || DEF_FONT_COLOR), `</a:solidFill>
              <a:latin typeface="`).concat(opts.fontFace || "Arial", `"/>
            </a:rPr>
            <a:t>`).concat(encodeXmlEntities(opts.title) || "", `</a:t>
          </a:r>
        </a:p>
        </c:rich>
      </c:tx>
      `).concat(layout, `
      <c:overlay val="0"/>
    </c:title>`);
}
function getExcelColName(colIndex) {
  var colStr = "";
  var colIdx = colIndex - 1;
  if (colIdx <= 25) {
    colStr = LETTERS[colIdx];
  } else {
    colStr = "".concat(LETTERS[Math.floor(colIdx / LETTERS.length - 1)]).concat(LETTERS[colIdx % LETTERS.length]);
  }
  return colStr;
}
function createShadowElement(options2, defaults) {
  if (!options2) {
    return "<a:effectLst/>";
  } else if (typeof options2 !== "object") {
    console.warn("`shadow` options must be an object. Ex: `{shadow: {type:'none'}}`");
    return "<a:effectLst/>";
  }
  var strXml = "<a:effectLst>";
  var opts = __assign2(__assign2({}, defaults), options2);
  var type = opts.type || "outer";
  var blur = valToPts(opts.blur);
  var offset4 = valToPts(opts.offset);
  var angle = Math.round(opts.angle * 60000);
  var color = opts.color;
  var opacity = Math.round(opts.opacity * 1e5);
  var rotShape = opts.rotateWithShape ? 1 : 0;
  strXml += "<a:".concat(type, 'Shdw sx="100000" sy="100000" kx="0" ky="0"  algn="bl" blurRad="').concat(blur, '" rotWithShape="').concat(rotShape, '" dist="').concat(offset4, '" dir="').concat(angle, '">');
  strXml += '<a:srgbClr val="'.concat(color, '">');
  strXml += '<a:alpha val="'.concat(opacity, '"/></a:srgbClr>');
  strXml += "</a:".concat(type, "Shdw>");
  strXml += "</a:effectLst>";
  return strXml;
}
function createGridLineElement(glOpts) {
  var strXml = "<c:majorGridlines>";
  strXml += " <c:spPr>";
  strXml += '  <a:ln w="'.concat(valToPts(glOpts.size || DEF_CHART_GRIDLINE.size), '" cap="').concat(createLineCap(glOpts.cap || DEF_CHART_GRIDLINE.cap), '">');
  strXml += '  <a:solidFill><a:srgbClr val="' + (glOpts.color || DEF_CHART_GRIDLINE.color) + '"/></a:solidFill>';
  strXml += '   <a:prstDash val="' + (glOpts.style || DEF_CHART_GRIDLINE.style) + '"/><a:round/>';
  strXml += "  </a:ln>";
  strXml += " </c:spPr>";
  strXml += "</c:majorGridlines>";
  return strXml;
}
function createLineCap(lineCap) {
  if (!lineCap || lineCap === "flat") {
    return "flat";
  } else if (lineCap === "square") {
    return "sq";
  } else if (lineCap === "round") {
    return "rnd";
  } else {
    var neverLineCap = lineCap;
    throw new Error("Invalid chart line cap: ".concat(neverLineCap));
  }
}
function encodeSlideMediaRels(layout) {
  var fs = typeof window === "undefined" ? (() => ({})) : null;
  var https2 = typeof window === "undefined" ? (init_https(), __toCommonJS(exports_https)) : null;
  var imageProms = [];
  var candidateRels = layout._relsMedia.filter(function(rel) {
    return rel.type !== "online" && !rel.data && (!rel.path || rel.path && !rel.path.includes("preencoded"));
  });
  var unqPaths = [];
  candidateRels.forEach(function(rel) {
    if (!unqPaths.includes(rel.path)) {
      rel.isDuplicate = false;
      unqPaths.push(rel.path);
    } else {
      rel.isDuplicate = true;
    }
  });
  candidateRels.filter(function(rel) {
    return !rel.isDuplicate;
  }).forEach(function(rel) {
    imageProms.push(new Promise(function(resolve, reject) {
      if (fs && rel.path.indexOf("http") !== 0) {
        try {
          var bitmap = fs.readFileSync(rel.path);
          rel.data = Buffer.from(bitmap).toString("base64");
          candidateRels.filter(function(dupe) {
            return dupe.isDuplicate && dupe.path === rel.path;
          }).forEach(function(dupe) {
            return dupe.data = rel.data;
          });
          resolve("done");
        } catch (ex) {
          rel.data = IMG_BROKEN;
          candidateRels.filter(function(dupe) {
            return dupe.isDuplicate && dupe.path === rel.path;
          }).forEach(function(dupe) {
            return dupe.data = rel.data;
          });
          reject(new Error('ERROR: Unable to read media: "'.concat(rel.path, `"
`).concat(String(ex))));
        }
      } else if (fs && https2 && rel.path.indexOf("http") === 0) {
        https2.get(rel.path, function(res) {
          var rawData = "";
          res.setEncoding("binary");
          res.on("data", function(chunk) {
            return rawData += chunk;
          });
          res.on("end", function() {
            rel.data = Buffer.from(rawData, "binary").toString("base64");
            candidateRels.filter(function(dupe) {
              return dupe.isDuplicate && dupe.path === rel.path;
            }).forEach(function(dupe) {
              return dupe.data = rel.data;
            });
            resolve("done");
          });
          res.on("error", function(_ex) {
            rel.data = IMG_BROKEN;
            candidateRels.filter(function(dupe) {
              return dupe.isDuplicate && dupe.path === rel.path;
            }).forEach(function(dupe) {
              return dupe.data = rel.data;
            });
            reject(new Error("ERROR! Unable to load image (https.get): ".concat(rel.path)));
          });
        });
      } else {
        var xhr_1 = new XMLHttpRequest;
        xhr_1.onload = function() {
          var reader = new FileReader;
          reader.onloadend = function() {
            rel.data = reader.result;
            candidateRels.filter(function(dupe) {
              return dupe.isDuplicate && dupe.path === rel.path;
            }).forEach(function(dupe) {
              return dupe.data = rel.data;
            });
            if (!rel.isSvgPng) {
              resolve("done");
            } else {
              createSvgPngPreview(rel).then(function() {
                resolve("done");
              }).catch(function(ex) {
                reject(ex);
              });
            }
          };
          reader.readAsDataURL(xhr_1.response);
        };
        xhr_1.onerror = function(ex) {
          rel.data = IMG_BROKEN;
          candidateRels.filter(function(dupe) {
            return dupe.isDuplicate && dupe.path === rel.path;
          }).forEach(function(dupe) {
            return dupe.data = rel.data;
          });
          reject(new Error("ERROR! Unable to load image (xhr.onerror): ".concat(rel.path)));
        };
        xhr_1.open("GET", rel.path);
        xhr_1.responseType = "blob";
        xhr_1.send();
      }
    }));
  });
  layout._relsMedia.filter(function(rel) {
    return rel.isSvgPng && rel.data;
  }).forEach(function(rel) {
    if (fs) {
      rel.data = IMG_BROKEN;
      imageProms.push(Promise.resolve().then(function() {
        return "done";
      }));
    } else {
      imageProms.push(createSvgPngPreview(rel));
    }
  });
  return imageProms;
}
function createSvgPngPreview(rel) {
  return __awaiter(this, undefined, undefined, function() {
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          return [4, new Promise(function(resolve, reject) {
            var image = new Image;
            image.onload = function() {
              if (image.width + image.height === 0) {
                image.onerror("h/w=0");
              }
              var canvas = document.createElement("CANVAS");
              var ctx = canvas.getContext("2d");
              canvas.width = image.width;
              canvas.height = image.height;
              ctx.drawImage(image, 0, 0);
              try {
                rel.data = canvas.toDataURL(rel.type);
                resolve("done");
              } catch (ex) {
                image.onerror(ex);
              }
              canvas = null;
            };
            image.onerror = function(ex) {
              rel.data = IMG_BROKEN;
              reject(new Error("ERROR! Unable to load image (image.onerror): ".concat(rel.path)));
            };
            image.src = typeof rel.data === "string" ? rel.data : IMG_BROKEN;
          })];
        case 1:
          return [2, _a.sent()];
      }
    });
  });
}
function slideObjectToXml(slide) {
  var _a;
  var strSlideXml = slide._name ? '<p:cSld name="' + slide._name + '">' : "<p:cSld>";
  var intTableNum = 1;
  if (slide._bkgdImgRid) {
    strSlideXml += '<p:bg><p:bgPr><a:blipFill dpi="0" rotWithShape="1"><a:blip r:embed="rId'.concat(slide._bkgdImgRid, '"><a:lum/></a:blip><a:srcRect/><a:stretch><a:fillRect/></a:stretch></a:blipFill><a:effectLst/></p:bgPr></p:bg>');
  } else if ((_a = slide.background) === null || _a === undefined ? undefined : _a.color) {
    strSlideXml += "<p:bg><p:bgPr>".concat(genXmlColorSelection(slide.background), "</p:bgPr></p:bg>");
  } else if (!slide.bkgd && slide._name && slide._name === DEF_PRES_LAYOUT_NAME) {
    strSlideXml += '<p:bg><p:bgRef idx="1001"><a:schemeClr val="bg1"/></p:bgRef></p:bg>';
  }
  strSlideXml += "<p:spTree>";
  strSlideXml += '<p:nvGrpSpPr><p:cNvPr id="1" name=""/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr>';
  strSlideXml += '<p:grpSpPr><a:xfrm><a:off x="0" y="0"/><a:ext cx="0" cy="0"/>';
  strSlideXml += '<a:chOff x="0" y="0"/><a:chExt cx="0" cy="0"/></a:xfrm></p:grpSpPr>';
  slide._slideObjects.forEach(function(slideItemObj, idx) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    var x3 = 0;
    var y2 = 0;
    var cx2 = getSmartParseNumber("75%", "X", slide._presLayout);
    var cy = 0;
    var placeholderObj;
    var locationAttr = "";
    var arrTabRows = null;
    var objTabOpts = null;
    var intColCnt = 0;
    var intColW = 0;
    var cellOpts = null;
    var strXml = null;
    var sizing = (_a2 = slideItemObj.options) === null || _a2 === undefined ? undefined : _a2.sizing;
    var rounding = (_b = slideItemObj.options) === null || _b === undefined ? undefined : _b.rounding;
    if (slide._slideLayout !== undefined && slide._slideLayout._slideObjects !== undefined && slideItemObj.options && slideItemObj.options.placeholder) {
      placeholderObj = slide._slideLayout._slideObjects.filter(function(object) {
        return object.options.placeholder === slideItemObj.options.placeholder;
      })[0];
    }
    slideItemObj.options = slideItemObj.options || {};
    if (typeof slideItemObj.options.x !== "undefined")
      x3 = getSmartParseNumber(slideItemObj.options.x, "X", slide._presLayout);
    if (typeof slideItemObj.options.y !== "undefined")
      y2 = getSmartParseNumber(slideItemObj.options.y, "Y", slide._presLayout);
    if (typeof slideItemObj.options.w !== "undefined")
      cx2 = getSmartParseNumber(slideItemObj.options.w, "X", slide._presLayout);
    if (typeof slideItemObj.options.h !== "undefined")
      cy = getSmartParseNumber(slideItemObj.options.h, "Y", slide._presLayout);
    var imgWidth = cx2;
    var imgHeight = cy;
    if (placeholderObj) {
      if (placeholderObj.options.x || placeholderObj.options.x === 0)
        x3 = getSmartParseNumber(placeholderObj.options.x, "X", slide._presLayout);
      if (placeholderObj.options.y || placeholderObj.options.y === 0)
        y2 = getSmartParseNumber(placeholderObj.options.y, "Y", slide._presLayout);
      if (placeholderObj.options.w || placeholderObj.options.w === 0)
        cx2 = getSmartParseNumber(placeholderObj.options.w, "X", slide._presLayout);
      if (placeholderObj.options.h || placeholderObj.options.h === 0)
        cy = getSmartParseNumber(placeholderObj.options.h, "Y", slide._presLayout);
    }
    if (slideItemObj.options.flipH)
      locationAttr += ' flipH="1"';
    if (slideItemObj.options.flipV)
      locationAttr += ' flipV="1"';
    if (slideItemObj.options.rotate)
      locationAttr += ' rot="'.concat(convertRotationDegrees(slideItemObj.options.rotate), '"');
    switch (slideItemObj._type) {
      case SLIDE_OBJECT_TYPES.table:
        arrTabRows = slideItemObj.arrTabRows;
        objTabOpts = slideItemObj.options;
        intColCnt = 0;
        intColW = 0;
        arrTabRows[0].forEach(function(cell) {
          cellOpts = cell.options || null;
          intColCnt += (cellOpts === null || cellOpts === undefined ? undefined : cellOpts.colspan) ? Number(cellOpts.colspan) : 1;
        });
        strXml = '<p:graphicFrame><p:nvGraphicFramePr><p:cNvPr id="'.concat(intTableNum * slide._slideNum + 1, '" name="').concat(slideItemObj.options.objectName, '"/>');
        strXml += '<p:cNvGraphicFramePr><a:graphicFrameLocks noGrp="1"/></p:cNvGraphicFramePr>' + '  <p:nvPr><p:extLst><p:ext uri="{D42A27DB-BD31-4B8C-83A1-F6EECF244321}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="1579011935"/></p:ext></p:extLst></p:nvPr>' + "</p:nvGraphicFramePr>";
        strXml += '<p:xfrm><a:off x="'.concat(x3 || (x3 === 0 ? 0 : EMU), '" y="').concat(y2 || (y2 === 0 ? 0 : EMU), '"/><a:ext cx="').concat(cx2 || (cx2 === 0 ? 0 : EMU), '" cy="').concat(cy || EMU, '"/></p:xfrm>');
        strXml += '<a:graphic><a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/table"><a:tbl><a:tblPr/>';
        if (Array.isArray(objTabOpts.colW)) {
          strXml += "<a:tblGrid>";
          for (var col = 0;col < intColCnt; col++) {
            var w2 = inch2Emu(objTabOpts.colW[col]);
            if (w2 == null || isNaN(w2)) {
              w2 = (typeof slideItemObj.options.w === "number" ? slideItemObj.options.w : 1) / intColCnt;
            }
            strXml += '<a:gridCol w="'.concat(Math.round(w2), '"/>');
          }
          strXml += "</a:tblGrid>";
        } else {
          intColW = objTabOpts.colW ? objTabOpts.colW : EMU;
          if (slideItemObj.options.w && !objTabOpts.colW)
            intColW = Math.round((typeof slideItemObj.options.w === "number" ? slideItemObj.options.w : 1) / intColCnt);
          strXml += "<a:tblGrid>";
          for (var colw = 0;colw < intColCnt; colw++) {
            strXml += '<a:gridCol w="'.concat(intColW, '"/>');
          }
          strXml += "</a:tblGrid>";
        }
        arrTabRows.forEach(function(cells) {
          var _a3, _b2;
          var _loop_1 = function(cIdx2) {
            var cell = cells[cIdx2];
            var colspan = (_a3 = cell.options) === null || _a3 === undefined ? undefined : _a3.colspan;
            var rowspan = (_b2 = cell.options) === null || _b2 === undefined ? undefined : _b2.rowspan;
            if (colspan && colspan > 1) {
              var vMergeCells = new Array(colspan - 1).fill(undefined).map(function(_2) {
                return { _type: SLIDE_OBJECT_TYPES.tablecell, options: { rowspan }, _hmerge: true };
              });
              cells.splice.apply(cells, __spreadArray2([cIdx2 + 1, 0], vMergeCells, false));
              cIdx2 += colspan;
            } else {
              cIdx2 += 1;
            }
            out_cIdx_1 = cIdx2;
          };
          var out_cIdx_1;
          for (var cIdx = 0;cIdx < cells.length; ) {
            _loop_1(cIdx);
            cIdx = out_cIdx_1;
          }
        });
        arrTabRows.forEach(function(cells, rIdx) {
          var nextRow = arrTabRows[rIdx + 1];
          if (!nextRow)
            return;
          cells.forEach(function(cell, cIdx) {
            var _a3, _b2;
            var rowspan = cell._rowContinue || ((_a3 = cell.options) === null || _a3 === undefined ? undefined : _a3.rowspan);
            var colspan = (_b2 = cell.options) === null || _b2 === undefined ? undefined : _b2.colspan;
            var _hmerge = cell._hmerge;
            if (rowspan && rowspan > 1) {
              var hMergeCell = { _type: SLIDE_OBJECT_TYPES.tablecell, options: { colspan }, _rowContinue: rowspan - 1, _vmerge: true, _hmerge };
              nextRow.splice(cIdx, 0, hMergeCell);
            }
          });
        });
        arrTabRows.forEach(function(cells, rIdx) {
          var intRowH = 0;
          if (Array.isArray(objTabOpts.rowH) && objTabOpts.rowH[rIdx])
            intRowH = inch2Emu(Number(objTabOpts.rowH[rIdx]));
          else if (objTabOpts.rowH && !isNaN(Number(objTabOpts.rowH)))
            intRowH = inch2Emu(Number(objTabOpts.rowH));
          else if (slideItemObj.options.cy || slideItemObj.options.h) {
            intRowH = Math.round((slideItemObj.options.h ? inch2Emu(slideItemObj.options.h) : typeof slideItemObj.options.cy === "number" ? slideItemObj.options.cy : 1) / arrTabRows.length);
          }
          strXml += '<a:tr h="'.concat(intRowH, '">');
          cells.forEach(function(cellObj) {
            var _a3, _b2, _c2, _d2, _e2;
            var cell = cellObj;
            var cellSpanAttrs = {
              rowSpan: ((_a3 = cell.options) === null || _a3 === undefined ? undefined : _a3.rowspan) > 1 ? cell.options.rowspan : undefined,
              gridSpan: ((_b2 = cell.options) === null || _b2 === undefined ? undefined : _b2.colspan) > 1 ? cell.options.colspan : undefined,
              vMerge: cell._vmerge ? 1 : undefined,
              hMerge: cell._hmerge ? 1 : undefined
            };
            var cellSpanAttrStr = Object.keys(cellSpanAttrs).map(function(k2) {
              return [k2, cellSpanAttrs[k2]];
            }).filter(function(_a4) {
              _a4[0];
              var v2 = _a4[1];
              return !!v2;
            }).map(function(_a4) {
              var k2 = _a4[0], v2 = _a4[1];
              return "".concat(String(k2), '="').concat(String(v2), '"');
            }).join(" ");
            if (cellSpanAttrStr)
              cellSpanAttrStr = " " + cellSpanAttrStr;
            if (cell._hmerge || cell._vmerge) {
              strXml += "<a:tc".concat(cellSpanAttrStr, "><a:tcPr/></a:tc>");
              return;
            }
            var cellOpts2 = cell.options || {};
            cell.options = cellOpts2;
            ["align", "bold", "border", "color", "fill", "fontFace", "fontSize", "margin", "underline", "valign"].forEach(function(name) {
              if (objTabOpts[name] && !cellOpts2[name] && cellOpts2[name] !== 0)
                cellOpts2[name] = objTabOpts[name];
            });
            var cellValign = cellOpts2.valign ? ' anchor="'.concat(cellOpts2.valign.replace(/^c$/i, "ctr").replace(/^m$/i, "ctr").replace("center", "ctr").replace("middle", "ctr").replace("top", "t").replace("btm", "b").replace("bottom", "b"), '"') : "";
            var fillColor = ((_d2 = (_c2 = cell._optImp) === null || _c2 === undefined ? undefined : _c2.fill) === null || _d2 === undefined ? undefined : _d2.color) ? cell._optImp.fill.color : ((_e2 = cell._optImp) === null || _e2 === undefined ? undefined : _e2.fill) && typeof cell._optImp.fill === "string" ? cell._optImp.fill : "";
            fillColor = fillColor || cellOpts2.fill ? cellOpts2.fill : "";
            var cellFill = fillColor ? genXmlColorSelection(fillColor) : "";
            var cellMargin = cellOpts2.margin === 0 || cellOpts2.margin ? cellOpts2.margin : DEF_CELL_MARGIN_IN;
            if (!Array.isArray(cellMargin) && typeof cellMargin === "number")
              cellMargin = [cellMargin, cellMargin, cellMargin, cellMargin];
            var cellMarginXml = "";
            if (cellMargin[0] >= 1) {
              cellMarginXml = ' marL="'.concat(valToPts(cellMargin[3]), '" marR="').concat(valToPts(cellMargin[1]), '" marT="').concat(valToPts(cellMargin[0]), '" marB="').concat(valToPts(cellMargin[2]), '"');
            } else {
              cellMarginXml = ' marL="'.concat(inch2Emu(cellMargin[3]), '" marR="').concat(inch2Emu(cellMargin[1]), '" marT="').concat(inch2Emu(cellMargin[0]), '" marB="').concat(inch2Emu(cellMargin[2]), '"');
            }
            strXml += "<a:tc".concat(cellSpanAttrStr, ">").concat(genXmlTextBody(cell), "<a:tcPr").concat(cellMarginXml).concat(cellValign, ">");
            if (cellOpts2.border && Array.isArray(cellOpts2.border)) {
              [
                { idx: 3, name: "lnL" },
                { idx: 1, name: "lnR" },
                { idx: 0, name: "lnT" },
                { idx: 2, name: "lnB" }
              ].forEach(function(obj) {
                if (cellOpts2.border[obj.idx].type !== "none") {
                  strXml += "<a:".concat(obj.name, ' w="').concat(valToPts(cellOpts2.border[obj.idx].pt), '" cap="flat" cmpd="sng" algn="ctr">');
                  strXml += "<a:solidFill>".concat(createColorElement(cellOpts2.border[obj.idx].color), "</a:solidFill>");
                  strXml += '<a:prstDash val="'.concat(cellOpts2.border[obj.idx].type === "dash" ? "sysDash" : "solid", '"/><a:round/><a:headEnd type="none" w="med" len="med"/><a:tailEnd type="none" w="med" len="med"/>');
                  strXml += "</a:".concat(obj.name, ">");
                } else {
                  strXml += "<a:".concat(obj.name, ' w="0" cap="flat" cmpd="sng" algn="ctr"><a:noFill/></a:').concat(obj.name, ">");
                }
              });
            }
            strXml += cellFill;
            strXml += "  </a:tcPr>";
            strXml += " </a:tc>";
          });
          strXml += "</a:tr>";
        });
        strXml += "      </a:tbl>";
        strXml += "    </a:graphicData>";
        strXml += "  </a:graphic>";
        strXml += "</p:graphicFrame>";
        strSlideXml += strXml;
        intTableNum++;
        break;
      case SLIDE_OBJECT_TYPES.text:
      case SLIDE_OBJECT_TYPES.placeholder:
        if (!slideItemObj.options.line && cy === 0)
          cy = EMU * 0.3;
        if (!slideItemObj.options._bodyProp)
          slideItemObj.options._bodyProp = {};
        if (slideItemObj.options.margin && Array.isArray(slideItemObj.options.margin)) {
          slideItemObj.options._bodyProp.lIns = valToPts(slideItemObj.options.margin[0] || 0);
          slideItemObj.options._bodyProp.rIns = valToPts(slideItemObj.options.margin[1] || 0);
          slideItemObj.options._bodyProp.bIns = valToPts(slideItemObj.options.margin[2] || 0);
          slideItemObj.options._bodyProp.tIns = valToPts(slideItemObj.options.margin[3] || 0);
        } else if (typeof slideItemObj.options.margin === "number") {
          slideItemObj.options._bodyProp.lIns = valToPts(slideItemObj.options.margin);
          slideItemObj.options._bodyProp.rIns = valToPts(slideItemObj.options.margin);
          slideItemObj.options._bodyProp.bIns = valToPts(slideItemObj.options.margin);
          slideItemObj.options._bodyProp.tIns = valToPts(slideItemObj.options.margin);
        }
        strSlideXml += "<p:sp>";
        strSlideXml += '<p:nvSpPr><p:cNvPr id="'.concat(idx + 2, '" name="').concat(slideItemObj.options.objectName, '">');
        if ((_c = slideItemObj.options.hyperlink) === null || _c === undefined ? undefined : _c.url) {
          strSlideXml += '<a:hlinkClick r:id="rId'.concat(slideItemObj.options.hyperlink._rId, '" tooltip="').concat(slideItemObj.options.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.options.hyperlink.tooltip) : "", '"/>');
        }
        if ((_d = slideItemObj.options.hyperlink) === null || _d === undefined ? undefined : _d.slide) {
          strSlideXml += '<a:hlinkClick r:id="rId'.concat(slideItemObj.options.hyperlink._rId, '" tooltip="').concat(slideItemObj.options.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.options.hyperlink.tooltip) : "", '" action="ppaction://hlinksldjump"/>');
        }
        strSlideXml += "</p:cNvPr>";
        strSlideXml += "<p:cNvSpPr" + (((_e = slideItemObj.options) === null || _e === undefined ? undefined : _e.isTextBox) ? ' txBox="1"/>' : "/>");
        strSlideXml += "<p:nvPr>".concat(slideItemObj._type === "placeholder" ? genXmlPlaceholder(slideItemObj) : genXmlPlaceholder(placeholderObj), "</p:nvPr>");
        strSlideXml += "</p:nvSpPr><p:spPr>";
        strSlideXml += "<a:xfrm".concat(locationAttr, ">");
        strSlideXml += '<a:off x="'.concat(x3, '" y="').concat(y2, '"/>');
        strSlideXml += '<a:ext cx="'.concat(cx2, '" cy="').concat(cy, '"/></a:xfrm>');
        if (slideItemObj.shape === "custGeom") {
          strSlideXml += "<a:custGeom><a:avLst />";
          strSlideXml += "<a:gdLst>";
          strSlideXml += "</a:gdLst>";
          strSlideXml += "<a:ahLst />";
          strSlideXml += "<a:cxnLst>";
          strSlideXml += "</a:cxnLst>";
          strSlideXml += '<a:rect l="l" t="t" r="r" b="b" />';
          strSlideXml += "<a:pathLst>";
          strSlideXml += '<a:path w="'.concat(cx2, '" h="').concat(cy, '">');
          (_f = slideItemObj.options.points) === null || _f === undefined || _f.forEach(function(point, i5) {
            if ("curve" in point) {
              switch (point.curve.type) {
                case "arc":
                  strSlideXml += '<a:arcTo hR="'.concat(getSmartParseNumber(point.curve.hR, "Y", slide._presLayout), '" wR="').concat(getSmartParseNumber(point.curve.wR, "X", slide._presLayout), '" stAng="').concat(convertRotationDegrees(point.curve.stAng), '" swAng="').concat(convertRotationDegrees(point.curve.swAng), '" />');
                  break;
                case "cubic":
                  strSlideXml += `<a:cubicBezTo>
									<a:pt x="`.concat(getSmartParseNumber(point.curve.x1, "X", slide._presLayout), '" y="').concat(getSmartParseNumber(point.curve.y1, "Y", slide._presLayout), `" />
									<a:pt x="`).concat(getSmartParseNumber(point.curve.x2, "X", slide._presLayout), '" y="').concat(getSmartParseNumber(point.curve.y2, "Y", slide._presLayout), `" />
									<a:pt x="`).concat(getSmartParseNumber(point.x, "X", slide._presLayout), '" y="').concat(getSmartParseNumber(point.y, "Y", slide._presLayout), `" />
									</a:cubicBezTo>`);
                  break;
                case "quadratic":
                  strSlideXml += `<a:quadBezTo>
									<a:pt x="`.concat(getSmartParseNumber(point.curve.x1, "X", slide._presLayout), '" y="').concat(getSmartParseNumber(point.curve.y1, "Y", slide._presLayout), `" />
									<a:pt x="`).concat(getSmartParseNumber(point.x, "X", slide._presLayout), '" y="').concat(getSmartParseNumber(point.y, "Y", slide._presLayout), `" />
									</a:quadBezTo>`);
                  break;
              }
            } else if ("close" in point) {
              strSlideXml += "<a:close />";
            } else if (point.moveTo || i5 === 0) {
              strSlideXml += '<a:moveTo><a:pt x="'.concat(getSmartParseNumber(point.x, "X", slide._presLayout), '" y="').concat(getSmartParseNumber(point.y, "Y", slide._presLayout), '" /></a:moveTo>');
            } else {
              strSlideXml += '<a:lnTo><a:pt x="'.concat(getSmartParseNumber(point.x, "X", slide._presLayout), '" y="').concat(getSmartParseNumber(point.y, "Y", slide._presLayout), '" /></a:lnTo>');
            }
          });
          strSlideXml += "</a:path>";
          strSlideXml += "</a:pathLst>";
          strSlideXml += "</a:custGeom>";
        } else {
          strSlideXml += '<a:prstGeom prst="' + slideItemObj.shape + '"><a:avLst>';
          if (slideItemObj.options.rectRadius) {
            strSlideXml += '<a:gd name="adj" fmla="val '.concat(Math.round(slideItemObj.options.rectRadius * EMU * 1e5 / Math.min(cx2, cy)), '"/>');
          } else if (slideItemObj.options.angleRange) {
            for (var i4 = 0;i4 < 2; i4++) {
              var angle = slideItemObj.options.angleRange[i4];
              strSlideXml += '<a:gd name="adj'.concat(i4 + 1, '" fmla="val ').concat(convertRotationDegrees(angle), '" />');
            }
            if (slideItemObj.options.arcThicknessRatio) {
              strSlideXml += '<a:gd name="adj3" fmla="val '.concat(Math.round(slideItemObj.options.arcThicknessRatio * 50000), '" />');
            }
          }
          strSlideXml += "</a:avLst></a:prstGeom>";
        }
        strSlideXml += slideItemObj.options.fill ? genXmlColorSelection(slideItemObj.options.fill) : "<a:noFill/>";
        if (slideItemObj.options.line) {
          strSlideXml += slideItemObj.options.line.width ? '<a:ln w="'.concat(valToPts(slideItemObj.options.line.width), '">') : "<a:ln>";
          if (slideItemObj.options.line.color)
            strSlideXml += genXmlColorSelection(slideItemObj.options.line);
          if (slideItemObj.options.line.dashType)
            strSlideXml += '<a:prstDash val="'.concat(slideItemObj.options.line.dashType, '"/>');
          if (slideItemObj.options.line.beginArrowType)
            strSlideXml += '<a:headEnd type="'.concat(slideItemObj.options.line.beginArrowType, '"/>');
          if (slideItemObj.options.line.endArrowType)
            strSlideXml += '<a:tailEnd type="'.concat(slideItemObj.options.line.endArrowType, '"/>');
          strSlideXml += "</a:ln>";
        }
        if (slideItemObj.options.shadow && slideItemObj.options.shadow.type !== "none") {
          slideItemObj.options.shadow.type = slideItemObj.options.shadow.type || "outer";
          slideItemObj.options.shadow.blur = valToPts(slideItemObj.options.shadow.blur || 8);
          slideItemObj.options.shadow.offset = valToPts(slideItemObj.options.shadow.offset || 4);
          slideItemObj.options.shadow.angle = Math.round((slideItemObj.options.shadow.angle || 270) * 60000);
          slideItemObj.options.shadow.opacity = Math.round((slideItemObj.options.shadow.opacity || 0.75) * 1e5);
          slideItemObj.options.shadow.color = slideItemObj.options.shadow.color || DEF_TEXT_SHADOW.color;
          strSlideXml += "<a:effectLst>";
          strSlideXml += " <a:".concat(slideItemObj.options.shadow.type, "Shdw ").concat(slideItemObj.options.shadow.type === "outer" ? 'sx="100000" sy="100000" kx="0" ky="0" algn="bl" rotWithShape="0"' : "", ' blurRad="').concat(slideItemObj.options.shadow.blur, '" dist="').concat(slideItemObj.options.shadow.offset, '" dir="').concat(slideItemObj.options.shadow.angle, '">');
          strSlideXml += ' <a:srgbClr val="'.concat(slideItemObj.options.shadow.color, '">');
          strSlideXml += ' <a:alpha val="'.concat(slideItemObj.options.shadow.opacity, '"/></a:srgbClr>');
          strSlideXml += " </a:outerShdw>";
          strSlideXml += "</a:effectLst>";
        }
        strSlideXml += "</p:spPr>";
        strSlideXml += genXmlTextBody(slideItemObj);
        strSlideXml += "</p:sp>";
        break;
      case SLIDE_OBJECT_TYPES.image:
        strSlideXml += "<p:pic>";
        strSlideXml += "  <p:nvPicPr>";
        strSlideXml += '<p:cNvPr id="'.concat(idx + 2, '" name="').concat(slideItemObj.options.objectName, '" descr="').concat(encodeXmlEntities(slideItemObj.options.altText || slideItemObj.image), '">');
        if ((_g = slideItemObj.hyperlink) === null || _g === undefined ? undefined : _g.url) {
          strSlideXml += '<a:hlinkClick r:id="rId'.concat(slideItemObj.hyperlink._rId, '" tooltip="').concat(slideItemObj.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.hyperlink.tooltip) : "", '"/>');
        }
        if ((_h = slideItemObj.hyperlink) === null || _h === undefined ? undefined : _h.slide) {
          strSlideXml += '<a:hlinkClick r:id="rId'.concat(slideItemObj.hyperlink._rId, '" tooltip="').concat(slideItemObj.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.hyperlink.tooltip) : "", '" action="ppaction://hlinksldjump"/>');
        }
        strSlideXml += "    </p:cNvPr>";
        strSlideXml += '    <p:cNvPicPr><a:picLocks noChangeAspect="1"/></p:cNvPicPr>';
        strSlideXml += "    <p:nvPr>" + genXmlPlaceholder(placeholderObj) + "</p:nvPr>";
        strSlideXml += "  </p:nvPicPr>";
        strSlideXml += "<p:blipFill>";
        if ((slide._relsMedia || []).filter(function(rel) {
          return rel.rId === slideItemObj.imageRid;
        })[0] && (slide._relsMedia || []).filter(function(rel) {
          return rel.rId === slideItemObj.imageRid;
        })[0].extn === "svg") {
          strSlideXml += '<a:blip r:embed="rId'.concat(slideItemObj.imageRid - 1, '">');
          strSlideXml += slideItemObj.options.transparency ? ' <a:alphaModFix amt="'.concat(Math.round((100 - slideItemObj.options.transparency) * 1000), '"/>') : "";
          strSlideXml += " <a:extLst>";
          strSlideXml += '  <a:ext uri="{96DAC541-7B7A-43D3-8B79-37D633B846F1}">';
          strSlideXml += '   <asvg:svgBlip xmlns:asvg="http://schemas.microsoft.com/office/drawing/2016/SVG/main" r:embed="rId'.concat(slideItemObj.imageRid, '"/>');
          strSlideXml += "  </a:ext>";
          strSlideXml += " </a:extLst>";
          strSlideXml += "</a:blip>";
        } else {
          strSlideXml += '<a:blip r:embed="rId'.concat(slideItemObj.imageRid, '">');
          strSlideXml += slideItemObj.options.transparency ? '<a:alphaModFix amt="'.concat(Math.round((100 - slideItemObj.options.transparency) * 1000), '"/>') : "";
          strSlideXml += "</a:blip>";
        }
        if (sizing === null || sizing === undefined ? undefined : sizing.type) {
          var boxW = sizing.w ? getSmartParseNumber(sizing.w, "X", slide._presLayout) : cx2;
          var boxH = sizing.h ? getSmartParseNumber(sizing.h, "Y", slide._presLayout) : cy;
          var boxX = getSmartParseNumber(sizing.x || 0, "X", slide._presLayout);
          var boxY = getSmartParseNumber(sizing.y || 0, "Y", slide._presLayout);
          strSlideXml += ImageSizingXml[sizing.type]({ w: imgWidth, h: imgHeight }, { w: boxW, h: boxH, x: boxX, y: boxY });
          imgWidth = boxW;
          imgHeight = boxH;
        } else {
          strSlideXml += "  <a:stretch><a:fillRect/></a:stretch>";
        }
        strSlideXml += "</p:blipFill>";
        strSlideXml += "<p:spPr>";
        strSlideXml += " <a:xfrm" + locationAttr + ">";
        strSlideXml += '  <a:off x="'.concat(x3, '" y="').concat(y2, '"/>');
        strSlideXml += '  <a:ext cx="'.concat(imgWidth, '" cy="').concat(imgHeight, '"/>');
        strSlideXml += " </a:xfrm>";
        strSlideXml += ' <a:prstGeom prst="'.concat(rounding ? "ellipse" : "rect", '"><a:avLst/></a:prstGeom>');
        if (slideItemObj.options.shadow && slideItemObj.options.shadow.type !== "none") {
          slideItemObj.options.shadow.type = slideItemObj.options.shadow.type || "outer";
          slideItemObj.options.shadow.blur = valToPts(slideItemObj.options.shadow.blur || 8);
          slideItemObj.options.shadow.offset = valToPts(slideItemObj.options.shadow.offset || 4);
          slideItemObj.options.shadow.angle = Math.round((slideItemObj.options.shadow.angle || 270) * 60000);
          slideItemObj.options.shadow.opacity = Math.round((slideItemObj.options.shadow.opacity || 0.75) * 1e5);
          slideItemObj.options.shadow.color = slideItemObj.options.shadow.color || DEF_TEXT_SHADOW.color;
          strSlideXml += "<a:effectLst>";
          strSlideXml += "<a:".concat(slideItemObj.options.shadow.type, "Shdw ").concat(slideItemObj.options.shadow.type === "outer" ? 'sx="100000" sy="100000" kx="0" ky="0" algn="bl" rotWithShape="0"' : "", ' blurRad="').concat(slideItemObj.options.shadow.blur, '" dist="').concat(slideItemObj.options.shadow.offset, '" dir="').concat(slideItemObj.options.shadow.angle, '">');
          strSlideXml += '<a:srgbClr val="'.concat(slideItemObj.options.shadow.color, '">');
          strSlideXml += '<a:alpha val="'.concat(slideItemObj.options.shadow.opacity, '"/></a:srgbClr>');
          strSlideXml += "</a:".concat(slideItemObj.options.shadow.type, "Shdw>");
          strSlideXml += "</a:effectLst>";
        }
        strSlideXml += "</p:spPr>";
        strSlideXml += "</p:pic>";
        break;
      case SLIDE_OBJECT_TYPES.media:
        if (slideItemObj.mtype === "online") {
          strSlideXml += "<p:pic>";
          strSlideXml += " <p:nvPicPr>";
          strSlideXml += '<p:cNvPr id="'.concat(slideItemObj.mediaRid + 2, '" name="').concat(slideItemObj.options.objectName, '"/>');
          strSlideXml += " <p:cNvPicPr/>";
          strSlideXml += " <p:nvPr>";
          strSlideXml += '  <a:videoFile r:link="rId'.concat(slideItemObj.mediaRid, '"/>');
          strSlideXml += " </p:nvPr>";
          strSlideXml += " </p:nvPicPr>";
          strSlideXml += ' <p:blipFill><a:blip r:embed="rId'.concat(slideItemObj.mediaRid + 1, '"/><a:stretch><a:fillRect/></a:stretch></p:blipFill>');
          strSlideXml += " <p:spPr>";
          strSlideXml += "  <a:xfrm".concat(locationAttr, '><a:off x="').concat(x3, '" y="').concat(y2, '"/><a:ext cx="').concat(cx2, '" cy="').concat(cy, '"/></a:xfrm>');
          strSlideXml += '  <a:prstGeom prst="rect"><a:avLst/></a:prstGeom>';
          strSlideXml += " </p:spPr>";
          strSlideXml += "</p:pic>";
        } else {
          strSlideXml += "<p:pic>";
          strSlideXml += " <p:nvPicPr>";
          strSlideXml += '<p:cNvPr id="'.concat(slideItemObj.mediaRid + 2, '" name="').concat(slideItemObj.options.objectName, '"><a:hlinkClick r:id="" action="ppaction://media"/></p:cNvPr>');
          strSlideXml += ' <p:cNvPicPr><a:picLocks noChangeAspect="1"/></p:cNvPicPr>';
          strSlideXml += " <p:nvPr>";
          strSlideXml += '  <a:videoFile r:link="rId'.concat(slideItemObj.mediaRid, '"/>');
          strSlideXml += "  <p:extLst>";
          strSlideXml += '   <p:ext uri="{DAA4B4D4-6D71-4841-9C94-3DE7FCFB9230}">';
          strSlideXml += '    <p14:media xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" r:embed="rId'.concat(slideItemObj.mediaRid + 1, '"/>');
          strSlideXml += "   </p:ext>";
          strSlideXml += "  </p:extLst>";
          strSlideXml += " </p:nvPr>";
          strSlideXml += " </p:nvPicPr>";
          strSlideXml += ' <p:blipFill><a:blip r:embed="rId'.concat(slideItemObj.mediaRid + 2, '"/><a:stretch><a:fillRect/></a:stretch></p:blipFill>');
          strSlideXml += " <p:spPr>";
          strSlideXml += "  <a:xfrm".concat(locationAttr, '><a:off x="').concat(x3, '" y="').concat(y2, '"/><a:ext cx="').concat(cx2, '" cy="').concat(cy, '"/></a:xfrm>');
          strSlideXml += '  <a:prstGeom prst="rect"><a:avLst/></a:prstGeom>';
          strSlideXml += " </p:spPr>";
          strSlideXml += "</p:pic>";
        }
        break;
      case SLIDE_OBJECT_TYPES.chart:
        strSlideXml += "<p:graphicFrame>";
        strSlideXml += " <p:nvGraphicFramePr>";
        strSlideXml += '   <p:cNvPr id="'.concat(idx + 2, '" name="').concat(slideItemObj.options.objectName, '" descr="').concat(encodeXmlEntities(slideItemObj.options.altText || ""), '"/>');
        strSlideXml += "   <p:cNvGraphicFramePr/>";
        strSlideXml += "   <p:nvPr>".concat(genXmlPlaceholder(placeholderObj), "</p:nvPr>");
        strSlideXml += " </p:nvGraphicFramePr>";
        strSlideXml += ' <p:xfrm><a:off x="'.concat(x3, '" y="').concat(y2, '"/><a:ext cx="').concat(cx2, '" cy="').concat(cy, '"/></p:xfrm>');
        strSlideXml += ' <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">';
        strSlideXml += '  <a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/chart">';
        strSlideXml += '   <c:chart r:id="rId'.concat(slideItemObj.chartRid, '" xmlns:c="http://schemas.openxmlformats.org/drawingml/2006/chart"/>');
        strSlideXml += "  </a:graphicData>";
        strSlideXml += " </a:graphic>";
        strSlideXml += "</p:graphicFrame>";
        break;
      default:
        strSlideXml += "";
        break;
    }
  });
  if (slide._slideNumberProps) {
    if (!slide._slideNumberProps.align)
      slide._slideNumberProps.align = "left";
    strSlideXml += "<p:sp>";
    strSlideXml += " <p:nvSpPr>";
    strSlideXml += '  <p:cNvPr id="25" name="Slide Number Placeholder 0"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr>';
    strSlideXml += '  <p:nvPr><p:ph type="sldNum" sz="quarter" idx="4294967295"/></p:nvPr>';
    strSlideXml += " </p:nvSpPr>";
    strSlideXml += " <p:spPr>";
    strSlideXml += "<a:xfrm>" + '<a:off x="'.concat(getSmartParseNumber(slide._slideNumberProps.x, "X", slide._presLayout), '" y="').concat(getSmartParseNumber(slide._slideNumberProps.y, "Y", slide._presLayout), '"/>') + '<a:ext cx="'.concat(slide._slideNumberProps.w ? getSmartParseNumber(slide._slideNumberProps.w, "X", slide._presLayout) : "800000", '" cy="').concat(slide._slideNumberProps.h ? getSmartParseNumber(slide._slideNumberProps.h, "Y", slide._presLayout) : "300000", '"/>') + "</a:xfrm>" + ' <a:prstGeom prst="rect"><a:avLst/></a:prstGeom>' + ' <a:extLst><a:ext uri="{C572A759-6A51-4108-AA02-DFA0A04FC94B}"><ma14:wrappingTextBoxFlag val="0" xmlns:ma14="http://schemas.microsoft.com/office/mac/drawingml/2011/main"/></a:ext></a:extLst>' + "</p:spPr>";
    strSlideXml += "<p:txBody>";
    strSlideXml += "<a:bodyPr";
    if (slide._slideNumberProps.margin && Array.isArray(slide._slideNumberProps.margin)) {
      strSlideXml += ' lIns="'.concat(valToPts(slide._slideNumberProps.margin[3] || 0), '"');
      strSlideXml += ' tIns="'.concat(valToPts(slide._slideNumberProps.margin[0] || 0), '"');
      strSlideXml += ' rIns="'.concat(valToPts(slide._slideNumberProps.margin[1] || 0), '"');
      strSlideXml += ' bIns="'.concat(valToPts(slide._slideNumberProps.margin[2] || 0), '"');
    } else if (typeof slide._slideNumberProps.margin === "number") {
      strSlideXml += ' lIns="'.concat(valToPts(slide._slideNumberProps.margin || 0), '"');
      strSlideXml += ' tIns="'.concat(valToPts(slide._slideNumberProps.margin || 0), '"');
      strSlideXml += ' rIns="'.concat(valToPts(slide._slideNumberProps.margin || 0), '"');
      strSlideXml += ' bIns="'.concat(valToPts(slide._slideNumberProps.margin || 0), '"');
    }
    if (slide._slideNumberProps.valign) {
      strSlideXml += ' anchor="'.concat(slide._slideNumberProps.valign.replace("top", "t").replace("middle", "ctr").replace("bottom", "b"), '"');
    }
    strSlideXml += "/>";
    strSlideXml += "  <a:lstStyle><a:lvl1pPr>";
    if (slide._slideNumberProps.fontFace || slide._slideNumberProps.fontSize || slide._slideNumberProps.color) {
      strSlideXml += '<a:defRPr sz="'.concat(Math.round((slide._slideNumberProps.fontSize || 12) * 100), '">');
      if (slide._slideNumberProps.color)
        strSlideXml += genXmlColorSelection(slide._slideNumberProps.color);
      if (slide._slideNumberProps.fontFace) {
        strSlideXml += '<a:latin typeface="'.concat(slide._slideNumberProps.fontFace, '"/><a:ea typeface="').concat(slide._slideNumberProps.fontFace, '"/><a:cs typeface="').concat(slide._slideNumberProps.fontFace, '"/>');
      }
      strSlideXml += "</a:defRPr>";
    }
    strSlideXml += "</a:lvl1pPr></a:lstStyle>";
    strSlideXml += "<a:p>";
    if (slide._slideNumberProps.align.startsWith("l"))
      strSlideXml += '<a:pPr algn="l"/>';
    else if (slide._slideNumberProps.align.startsWith("c"))
      strSlideXml += '<a:pPr algn="ctr"/>';
    else if (slide._slideNumberProps.align.startsWith("r"))
      strSlideXml += '<a:pPr algn="r"/>';
    else
      strSlideXml += '<a:pPr algn="l"/>';
    strSlideXml += '<a:fld id="'.concat(SLDNUMFLDID, '" type="slidenum"><a:rPr b="').concat(slide._slideNumberProps.bold ? 1 : 0, '" lang="en-US"/>');
    strSlideXml += "<a:t>".concat(slide._slideNum, '</a:t></a:fld><a:endParaRPr lang="en-US"/></a:p>');
    strSlideXml += "</p:txBody></p:sp>";
  }
  strSlideXml += "</p:spTree>";
  strSlideXml += "</p:cSld>";
  return strSlideXml;
}
function slideObjectRelationsToXml(slide, defaultRels) {
  var lastRid = 0;
  var strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + CRLF + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">';
  slide._rels.forEach(function(rel) {
    lastRid = Math.max(lastRid, rel.rId);
    if (rel.type.toLowerCase().includes("hyperlink")) {
      if (rel.data === "slide") {
        strXml += '<Relationship Id="rId'.concat(rel.rId, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide" Target="slide').concat(rel.Target, '.xml"/>');
      } else {
        strXml += '<Relationship Id="rId'.concat(rel.rId, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink" Target="').concat(rel.Target, '" TargetMode="External"/>');
      }
    } else if (rel.type.toLowerCase().includes("notesSlide")) {
      strXml += '<Relationship Id="rId'.concat(rel.rId, '" Target="').concat(rel.Target, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide"/>');
    }
  });
  (slide._relsChart || []).forEach(function(rel) {
    lastRid = Math.max(lastRid, rel.rId);
    strXml += '<Relationship Id="rId'.concat(rel.rId, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart" Target="').concat(rel.Target, '"/>');
  });
  (slide._relsMedia || []).forEach(function(rel) {
    var relRid = rel.rId.toString();
    lastRid = Math.max(lastRid, rel.rId);
    if (rel.type.toLowerCase().includes("image")) {
      strXml += '<Relationship Id="rId' + relRid + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="' + rel.Target + '"/>';
    } else if (rel.type.toLowerCase().includes("audio")) {
      if (strXml.includes(' Target="' + rel.Target + '"')) {
        strXml += '<Relationship Id="rId' + relRid + '" Type="http://schemas.microsoft.com/office/2007/relationships/media" Target="' + rel.Target + '"/>';
      } else {
        strXml += '<Relationship Id="rId' + relRid + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/audio" Target="' + rel.Target + '"/>';
      }
    } else if (rel.type.toLowerCase().includes("video")) {
      if (strXml.includes(' Target="' + rel.Target + '"')) {
        strXml += '<Relationship Id="rId' + relRid + '" Type="http://schemas.microsoft.com/office/2007/relationships/media" Target="' + rel.Target + '"/>';
      } else {
        strXml += '<Relationship Id="rId' + relRid + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/video" Target="' + rel.Target + '"/>';
      }
    } else if (rel.type.toLowerCase().includes("online")) {
      if (strXml.includes(' Target="' + rel.Target + '"')) {
        strXml += '<Relationship Id="rId' + relRid + '" Type="http://schemas.microsoft.com/office/2007/relationships/image" Target="' + rel.Target + '"/>';
      } else {
        strXml += '<Relationship Id="rId' + relRid + '" Target="' + rel.Target + '" TargetMode="External" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/video"/>';
      }
    }
  });
  defaultRels.forEach(function(rel, idx) {
    strXml += '<Relationship Id="rId'.concat(lastRid + idx + 1, '" Type="').concat(rel.type, '" Target="').concat(rel.target, '"/>');
  });
  strXml += "</Relationships>";
  return strXml;
}
function genXmlParagraphProperties(textObj, isDefault) {
  var _a, _b;
  var strXmlBullet = "";
  var strXmlLnSpc = "";
  var strXmlParaSpc = "";
  var strXmlTabStops = "";
  var tag = isDefault ? "a:lvl1pPr" : "a:pPr";
  var bulletMarL = valToPts(DEF_BULLET_MARGIN);
  var paragraphPropXml = "<".concat(tag).concat(textObj.options.rtlMode ? ' rtl="1" ' : "");
  {
    if (textObj.options.align) {
      switch (textObj.options.align) {
        case "left":
          paragraphPropXml += ' algn="l"';
          break;
        case "right":
          paragraphPropXml += ' algn="r"';
          break;
        case "center":
          paragraphPropXml += ' algn="ctr"';
          break;
        case "justify":
          paragraphPropXml += ' algn="just"';
          break;
        default:
          paragraphPropXml += "";
          break;
      }
    }
    if (textObj.options.lineSpacing) {
      strXmlLnSpc = '<a:lnSpc><a:spcPts val="'.concat(Math.round(textObj.options.lineSpacing * 100), '"/></a:lnSpc>');
    } else if (textObj.options.lineSpacingMultiple) {
      strXmlLnSpc = '<a:lnSpc><a:spcPct val="'.concat(Math.round(textObj.options.lineSpacingMultiple * 1e5), '"/></a:lnSpc>');
    }
    if (textObj.options.indentLevel && !isNaN(Number(textObj.options.indentLevel)) && textObj.options.indentLevel > 0) {
      paragraphPropXml += ' lvl="'.concat(textObj.options.indentLevel, '"');
    }
    if (textObj.options.paraSpaceBefore && !isNaN(Number(textObj.options.paraSpaceBefore)) && textObj.options.paraSpaceBefore > 0) {
      strXmlParaSpc += '<a:spcBef><a:spcPts val="'.concat(Math.round(textObj.options.paraSpaceBefore * 100), '"/></a:spcBef>');
    }
    if (textObj.options.paraSpaceAfter && !isNaN(Number(textObj.options.paraSpaceAfter)) && textObj.options.paraSpaceAfter > 0) {
      strXmlParaSpc += '<a:spcAft><a:spcPts val="'.concat(Math.round(textObj.options.paraSpaceAfter * 100), '"/></a:spcAft>');
    }
    if (typeof textObj.options.bullet === "object") {
      if ((_b = (_a = textObj === null || textObj === undefined ? undefined : textObj.options) === null || _a === undefined ? undefined : _a.bullet) === null || _b === undefined ? undefined : _b.indent)
        bulletMarL = valToPts(textObj.options.bullet.indent);
      if (textObj.options.bullet.type) {
        if (textObj.options.bullet.type.toString().toLowerCase() === "number") {
          paragraphPropXml += ' marL="'.concat(textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL, '" indent="-').concat(bulletMarL, '"');
          strXmlBullet = '<a:buSzPct val="100000"/><a:buFont typeface="+mj-lt"/><a:buAutoNum type="'.concat(textObj.options.bullet.style || "arabicPeriod", '" startAt="').concat(textObj.options.bullet.numberStartAt || textObj.options.bullet.startAt || "1", '"/>');
        }
      } else if (textObj.options.bullet.characterCode) {
        var bulletCode = "&#x".concat(textObj.options.bullet.characterCode, ";");
        if (!/^[0-9A-Fa-f]{4}$/.test(textObj.options.bullet.characterCode)) {
          console.warn("Warning: `bullet.characterCode should be a 4-digit unicode charatcer (ex: 22AB)`!");
          bulletCode = BULLET_TYPES.DEFAULT;
        }
        paragraphPropXml += ' marL="'.concat(textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL, '" indent="-').concat(bulletMarL, '"');
        strXmlBullet = '<a:buSzPct val="100000"/><a:buChar char="' + bulletCode + '"/>';
      } else if (textObj.options.bullet.code) {
        var bulletCode = "&#x".concat(textObj.options.bullet.code, ";");
        if (!/^[0-9A-Fa-f]{4}$/.test(textObj.options.bullet.code)) {
          console.warn("Warning: `bullet.code should be a 4-digit hex code (ex: 22AB)`!");
          bulletCode = BULLET_TYPES.DEFAULT;
        }
        paragraphPropXml += ' marL="'.concat(textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL, '" indent="-').concat(bulletMarL, '"');
        strXmlBullet = '<a:buSzPct val="100000"/><a:buChar char="' + bulletCode + '"/>';
      } else {
        paragraphPropXml += ' marL="'.concat(textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL, '" indent="-').concat(bulletMarL, '"');
        strXmlBullet = '<a:buSzPct val="100000"/><a:buChar char="'.concat(BULLET_TYPES.DEFAULT, '"/>');
      }
    } else if (textObj.options.bullet) {
      paragraphPropXml += ' marL="'.concat(textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL, '" indent="-').concat(bulletMarL, '"');
      strXmlBullet = '<a:buSzPct val="100000"/><a:buChar char="'.concat(BULLET_TYPES.DEFAULT, '"/>');
    } else if (!textObj.options.bullet) {
      paragraphPropXml += ' indent="0" marL="0"';
      strXmlBullet = "<a:buNone/>";
    }
    if (textObj.options.tabStops && Array.isArray(textObj.options.tabStops)) {
      var tabStopsXml = textObj.options.tabStops.map(function(stop) {
        return '<a:tab pos="'.concat(inch2Emu(stop.position || 1), '" algn="').concat(stop.alignment || "l", '"/>');
      }).join("");
      strXmlTabStops = "<a:tabLst>".concat(tabStopsXml, "</a:tabLst>");
    }
    paragraphPropXml += ">" + strXmlLnSpc + strXmlParaSpc + strXmlBullet + strXmlTabStops;
    if (isDefault)
      paragraphPropXml += genXmlTextRunProperties(textObj.options, true);
    paragraphPropXml += "</" + tag + ">";
  }
  return paragraphPropXml;
}
function genXmlTextRunProperties(opts, isDefault) {
  var _a;
  var runProps = "";
  var runPropsTag = isDefault ? "a:defRPr" : "a:rPr";
  runProps += "<" + runPropsTag + ' lang="' + (opts.lang ? opts.lang : "en-US") + '"' + (opts.lang ? ' altLang="en-US"' : "");
  runProps += opts.fontSize ? ' sz="'.concat(Math.round(opts.fontSize * 100), '"') : "";
  runProps += (opts === null || opts === undefined ? undefined : opts.bold) ? ' b="'.concat(opts.bold ? "1" : "0", '"') : "";
  runProps += (opts === null || opts === undefined ? undefined : opts.italic) ? ' i="'.concat(opts.italic ? "1" : "0", '"') : "";
  runProps += (opts === null || opts === undefined ? undefined : opts.strike) ? ' strike="'.concat(typeof opts.strike === "string" ? opts.strike : "sngStrike", '"') : "";
  if (typeof opts.underline === "object" && ((_a = opts.underline) === null || _a === undefined ? undefined : _a.style)) {
    runProps += ' u="'.concat(opts.underline.style, '"');
  } else if (typeof opts.underline === "string") {
    runProps += ' u="'.concat(String(opts.underline), '"');
  } else if (opts.hyperlink) {
    runProps += ' u="sng"';
  }
  if (opts.baseline) {
    runProps += ' baseline="'.concat(Math.round(opts.baseline * 50), '"');
  } else if (opts.subscript) {
    runProps += ' baseline="-40000"';
  } else if (opts.superscript) {
    runProps += ' baseline="30000"';
  }
  runProps += opts.charSpacing ? ' spc="'.concat(Math.round(opts.charSpacing * 100), '" kern="0"') : "";
  runProps += ' dirty="0">';
  if (opts.color || opts.fontFace || opts.outline || typeof opts.underline === "object" && opts.underline.color) {
    if (opts.outline && typeof opts.outline === "object") {
      runProps += '<a:ln w="'.concat(valToPts(opts.outline.size || 0.75), '">').concat(genXmlColorSelection(opts.outline.color || "FFFFFF"), "</a:ln>");
    }
    if (opts.color)
      runProps += genXmlColorSelection({ color: opts.color, transparency: opts.transparency });
    if (opts.highlight)
      runProps += "<a:highlight>".concat(createColorElement(opts.highlight), "</a:highlight>");
    if (typeof opts.underline === "object" && opts.underline.color)
      runProps += "<a:uFill>".concat(genXmlColorSelection(opts.underline.color), "</a:uFill>");
    if (opts.glow)
      runProps += "<a:effectLst>".concat(createGlowElement(opts.glow, DEF_TEXT_GLOW), "</a:effectLst>");
    if (opts.fontFace) {
      runProps += '<a:latin typeface="'.concat(opts.fontFace, '" pitchFamily="34" charset="0"/><a:ea typeface="').concat(opts.fontFace, '" pitchFamily="34" charset="-122"/><a:cs typeface="').concat(opts.fontFace, '" pitchFamily="34" charset="-120"/>');
    }
  }
  if (opts.hyperlink) {
    if (typeof opts.hyperlink !== "object")
      throw new Error("ERROR: text `hyperlink` option should be an object. Ex: `hyperlink:{url:'https://github.com'}` ");
    else if (!opts.hyperlink.url && !opts.hyperlink.slide)
      throw new Error("ERROR: 'hyperlink requires either `url` or `slide`'");
    else if (opts.hyperlink.url) {
      runProps += '<a:hlinkClick r:id="rId'.concat(opts.hyperlink._rId, '" invalidUrl="" action="" tgtFrame="" tooltip="').concat(opts.hyperlink.tooltip ? encodeXmlEntities(opts.hyperlink.tooltip) : "", '" history="1" highlightClick="0" endSnd="0"').concat(opts.color ? ">" : "/>");
    } else if (opts.hyperlink.slide) {
      runProps += '<a:hlinkClick r:id="rId'.concat(opts.hyperlink._rId, '" action="ppaction://hlinksldjump" tooltip="').concat(opts.hyperlink.tooltip ? encodeXmlEntities(opts.hyperlink.tooltip) : "", '"').concat(opts.color ? ">" : "/>");
    }
    if (opts.color) {
      runProps += " <a:extLst>";
      runProps += '  <a:ext uri="{A12FA001-AC4F-418D-AE19-62706E023703}">';
      runProps += '   <ahyp:hlinkClr xmlns:ahyp="http://schemas.microsoft.com/office/drawing/2018/hyperlinkcolor" val="tx"/>';
      runProps += "  </a:ext>";
      runProps += " </a:extLst>";
      runProps += "</a:hlinkClick>";
    }
  }
  runProps += "</".concat(runPropsTag, ">");
  return runProps;
}
function genXmlTextRun(textObj) {
  return textObj.text ? "<a:r>".concat(genXmlTextRunProperties(textObj.options, false), "<a:t>").concat(encodeXmlEntities(textObj.text), "</a:t></a:r>") : "";
}
function genXmlBodyProperties(slideObject) {
  var bodyProperties = "<a:bodyPr";
  if (slideObject && slideObject._type === SLIDE_OBJECT_TYPES.text && slideObject.options._bodyProp) {
    bodyProperties += slideObject.options._bodyProp.wrap ? ' wrap="square"' : ' wrap="none"';
    if (slideObject.options._bodyProp.lIns || slideObject.options._bodyProp.lIns === 0)
      bodyProperties += ' lIns="'.concat(slideObject.options._bodyProp.lIns, '"');
    if (slideObject.options._bodyProp.tIns || slideObject.options._bodyProp.tIns === 0)
      bodyProperties += ' tIns="'.concat(slideObject.options._bodyProp.tIns, '"');
    if (slideObject.options._bodyProp.rIns || slideObject.options._bodyProp.rIns === 0)
      bodyProperties += ' rIns="'.concat(slideObject.options._bodyProp.rIns, '"');
    if (slideObject.options._bodyProp.bIns || slideObject.options._bodyProp.bIns === 0)
      bodyProperties += ' bIns="'.concat(slideObject.options._bodyProp.bIns, '"');
    bodyProperties += ' rtlCol="0"';
    if (slideObject.options._bodyProp.anchor)
      bodyProperties += ' anchor="' + slideObject.options._bodyProp.anchor + '"';
    if (slideObject.options._bodyProp.vert)
      bodyProperties += ' vert="' + slideObject.options._bodyProp.vert + '"';
    bodyProperties += ">";
    if (slideObject.options.fit) {
      if (slideObject.options.fit === "none")
        bodyProperties += "";
      else if (slideObject.options.fit === "shrink")
        bodyProperties += "<a:normAutofit/>";
      else if (slideObject.options.fit === "resize")
        bodyProperties += "<a:spAutoFit/>";
    }
    if (slideObject.options.shrinkText)
      bodyProperties += "<a:normAutofit/>";
    bodyProperties += slideObject.options._bodyProp.autoFit ? "<a:spAutoFit/>" : "";
    bodyProperties += "</a:bodyPr>";
  } else {
    bodyProperties += ' wrap="square" rtlCol="0">';
    bodyProperties += "</a:bodyPr>";
  }
  return slideObject._type === SLIDE_OBJECT_TYPES.tablecell ? "<a:bodyPr/>" : bodyProperties;
}
function genXmlTextBody(slideObj) {
  var opts = slideObj.options || {};
  var tmpTextObjects = [];
  var arrTextObjects = [];
  if (opts && slideObj._type !== SLIDE_OBJECT_TYPES.tablecell && (typeof slideObj.text === "undefined" || slideObj.text === null))
    return "";
  var strSlideXml = slideObj._type === SLIDE_OBJECT_TYPES.tablecell ? "<a:txBody>" : "<p:txBody>";
  {
    strSlideXml += genXmlBodyProperties(slideObj);
    if (opts.h === 0 && opts.line && opts.align)
      strSlideXml += '<a:lstStyle><a:lvl1pPr algn="l"/></a:lstStyle>';
    else if (slideObj._type === "placeholder")
      strSlideXml += "<a:lstStyle>".concat(genXmlParagraphProperties(slideObj, true), "</a:lstStyle>");
    else
      strSlideXml += "<a:lstStyle/>";
  }
  if (typeof slideObj.text === "string" || typeof slideObj.text === "number") {
    tmpTextObjects.push({ text: slideObj.text.toString(), options: opts || {} });
  } else if (slideObj.text && !Array.isArray(slideObj.text) && typeof slideObj.text === "object" && Object.keys(slideObj.text).includes("text")) {
    tmpTextObjects.push({ text: slideObj.text || "", options: slideObj.options || {} });
  } else if (Array.isArray(slideObj.text)) {
    tmpTextObjects = slideObj.text.map(function(item) {
      return { text: item.text, options: item.options };
    });
  }
  tmpTextObjects.forEach(function(itext, idx) {
    if (!itext.text)
      itext.text = "";
    itext.options = itext.options || opts || {};
    if (idx === 0 && itext.options && !itext.options.bullet && opts.bullet)
      itext.options.bullet = opts.bullet;
    if (typeof itext.text === "string" || typeof itext.text === "number") {
      itext.text = itext.text.toString().replace(/\r*\n/g, CRLF);
    }
    if (itext.text.includes(CRLF) && itext.text.match(/\n$/g) === null) {
      itext.text.split(CRLF).forEach(function(line) {
        itext.options.breakLine = true;
        arrTextObjects.push({ text: line, options: itext.options });
      });
    } else {
      arrTextObjects.push(itext);
    }
  });
  var arrLines = [];
  var arrTexts = [];
  arrTextObjects.forEach(function(textObj, idx) {
    if (arrTexts.length > 0 && (textObj.options.align || opts.align)) {
      if (textObj.options.align !== arrTextObjects[idx - 1].options.align) {
        arrLines.push(arrTexts);
        arrTexts = [];
      }
    } else if (arrTexts.length > 0 && textObj.options.bullet && arrTexts.length > 0) {
      arrLines.push(arrTexts);
      arrTexts = [];
      textObj.options.breakLine = false;
    }
    arrTexts.push(textObj);
    if (arrTexts.length > 0 && textObj.options.breakLine) {
      if (idx + 1 < arrTextObjects.length) {
        arrLines.push(arrTexts);
        arrTexts = [];
      }
    }
    if (idx + 1 === arrTextObjects.length)
      arrLines.push(arrTexts);
  });
  arrLines.forEach(function(line) {
    var _a;
    var reqsClosingFontSize = false;
    strSlideXml += "<a:p>";
    var paragraphPropXml = "<a:pPr ".concat(((_a = line[0].options) === null || _a === undefined ? undefined : _a.rtlMode) ? ' rtl="1" ' : "");
    line.forEach(function(textObj, idx) {
      textObj.options._lineIdx = idx;
      if (idx > 0 && textObj.options.softBreakBefore) {
        strSlideXml += "<a:br/>";
      }
      textObj.options.align = textObj.options.align || opts.align;
      textObj.options.lineSpacing = textObj.options.lineSpacing || opts.lineSpacing;
      textObj.options.lineSpacingMultiple = textObj.options.lineSpacingMultiple || opts.lineSpacingMultiple;
      textObj.options.indentLevel = textObj.options.indentLevel || opts.indentLevel;
      textObj.options.paraSpaceBefore = textObj.options.paraSpaceBefore || opts.paraSpaceBefore;
      textObj.options.paraSpaceAfter = textObj.options.paraSpaceAfter || opts.paraSpaceAfter;
      paragraphPropXml = genXmlParagraphProperties(textObj, false);
      strSlideXml += paragraphPropXml.replace("<a:pPr></a:pPr>", "");
      Object.entries(opts).filter(function(_a2) {
        var key = _a2[0];
        _a2[1];
        return !(textObj.options.hyperlink && key === "color");
      }).forEach(function(_a2) {
        var key = _a2[0], val = _a2[1];
        if (key !== "bullet" && !textObj.options[key])
          textObj.options[key] = val;
      });
      strSlideXml += genXmlTextRun(textObj);
      if (!textObj.text && opts.fontSize || textObj.options.fontSize) {
        reqsClosingFontSize = true;
        opts.fontSize = opts.fontSize || textObj.options.fontSize;
      }
    });
    if (slideObj._type === SLIDE_OBJECT_TYPES.tablecell && (opts.fontSize || opts.fontFace)) {
      if (opts.fontFace) {
        strSlideXml += '<a:endParaRPr lang="'.concat(opts.lang || "en-US", '"') + (opts.fontSize ? ' sz="'.concat(Math.round(opts.fontSize * 100), '"') : "") + ' dirty="0">';
        strSlideXml += '<a:latin typeface="'.concat(opts.fontFace, '" charset="0"/>');
        strSlideXml += '<a:ea typeface="'.concat(opts.fontFace, '" charset="0"/>');
        strSlideXml += '<a:cs typeface="'.concat(opts.fontFace, '" charset="0"/>');
        strSlideXml += "</a:endParaRPr>";
      } else {
        strSlideXml += '<a:endParaRPr lang="'.concat(opts.lang || "en-US", '"') + (opts.fontSize ? ' sz="'.concat(Math.round(opts.fontSize * 100), '"') : "") + ' dirty="0"/>';
      }
    } else if (reqsClosingFontSize) {
      strSlideXml += '<a:endParaRPr lang="'.concat(opts.lang || "en-US", '"') + (opts.fontSize ? ' sz="'.concat(Math.round(opts.fontSize * 100), '"') : "") + ' dirty="0"/>';
    } else {
      strSlideXml += '<a:endParaRPr lang="'.concat(opts.lang || "en-US", '" dirty="0"/>');
    }
    strSlideXml += "</a:p>";
  });
  strSlideXml += slideObj._type === SLIDE_OBJECT_TYPES.tablecell ? "</a:txBody>" : "</p:txBody>";
  return strSlideXml;
}
function genXmlPlaceholder(placeholderObj) {
  var _a, _b;
  if (!placeholderObj)
    return "";
  var placeholderIdx = ((_a = placeholderObj.options) === null || _a === undefined ? undefined : _a._placeholderIdx) ? placeholderObj.options._placeholderIdx : "";
  var placeholderTyp = ((_b = placeholderObj.options) === null || _b === undefined ? undefined : _b._placeholderType) ? placeholderObj.options._placeholderType : "";
  var placeholderType = placeholderTyp && PLACEHOLDER_TYPES[placeholderTyp] ? PLACEHOLDER_TYPES[placeholderTyp].toString() : "";
  return `<p:ph
		`.concat(placeholderIdx ? ' idx="' + placeholderIdx.toString() + '"' : "", `
		`).concat(placeholderType && PLACEHOLDER_TYPES[placeholderType] ? ' type="'.concat(placeholderType, '"') : "", `
		`).concat(placeholderObj.text && placeholderObj.text.length > 0 ? ' hasCustomPrompt="1"' : "", `
		/>`);
}
function makeXmlContTypes(slides, slideLayouts, masterSlide) {
  var strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + CRLF;
  strXml += '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">';
  strXml += '<Default Extension="xml" ContentType="application/xml"/>';
  strXml += '<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>';
  strXml += '<Default Extension="jpeg" ContentType="image/jpeg"/>';
  strXml += '<Default Extension="jpg" ContentType="image/jpg"/>';
  strXml += '<Default Extension="svg" ContentType="image/svg+xml"/>';
  strXml += '<Default Extension="png" ContentType="image/png"/>';
  strXml += '<Default Extension="gif" ContentType="image/gif"/>';
  strXml += '<Default Extension="m4v" ContentType="video/mp4"/>';
  strXml += '<Default Extension="mp4" ContentType="video/mp4"/>';
  slides.forEach(function(slide) {
    (slide._relsMedia || []).forEach(function(rel) {
      if (rel.type !== "image" && rel.type !== "online" && rel.type !== "chart" && rel.extn !== "m4v" && !strXml.includes(rel.type)) {
        strXml += '<Default Extension="' + rel.extn + '" ContentType="' + rel.type + '"/>';
      }
    });
  });
  strXml += '<Default Extension="vml" ContentType="application/vnd.openxmlformats-officedocument.vmlDrawing"/>';
  strXml += '<Default Extension="xlsx" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"/>';
  strXml += '<Override PartName="/ppt/presentation.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml"/>';
  strXml += '<Override PartName="/ppt/notesMasters/notesMaster1.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.notesMaster+xml"/>';
  slides.forEach(function(slide, idx) {
    strXml += '<Override PartName="/ppt/slideMasters/slideMaster'.concat(idx + 1, '.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml"/>');
    strXml += '<Override PartName="/ppt/slides/slide'.concat(idx + 1, '.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.slide+xml"/>');
    slide._relsChart.forEach(function(rel) {
      strXml += '<Override PartName="'.concat(rel.Target, '" ContentType="application/vnd.openxmlformats-officedocument.drawingml.chart+xml"/>');
    });
  });
  strXml += '<Override PartName="/ppt/presProps.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.presProps+xml"/>';
  strXml += '<Override PartName="/ppt/viewProps.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.viewProps+xml"/>';
  strXml += '<Override PartName="/ppt/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/>';
  strXml += '<Override PartName="/ppt/tableStyles.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.tableStyles+xml"/>';
  slideLayouts.forEach(function(layout, idx) {
    strXml += '<Override PartName="/ppt/slideLayouts/slideLayout'.concat(idx + 1, '.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml"/>');
    (layout._relsChart || []).forEach(function(rel) {
      strXml += ' <Override PartName="' + rel.Target + '" ContentType="application/vnd.openxmlformats-officedocument.drawingml.chart+xml"/>';
    });
  });
  slides.forEach(function(_slide, idx) {
    strXml += '<Override PartName="/ppt/notesSlides/notesSlide'.concat(idx + 1, '.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.notesSlide+xml"/>');
  });
  masterSlide._relsChart.forEach(function(rel) {
    strXml += ' <Override PartName="' + rel.Target + '" ContentType="application/vnd.openxmlformats-officedocument.drawingml.chart+xml"/>';
  });
  masterSlide._relsMedia.forEach(function(rel) {
    if (rel.type !== "image" && rel.type !== "online" && rel.type !== "chart" && rel.extn !== "m4v" && !strXml.includes(rel.type)) {
      strXml += ' <Default Extension="' + rel.extn + '" ContentType="' + rel.type + '"/>';
    }
  });
  strXml += ' <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>';
  strXml += ' <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>';
  strXml += "</Types>";
  return strXml;
}
function makeXmlRootRels() {
  return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF, `<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
		<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>
		<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>
		<Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="ppt/presentation.xml"/>
		</Relationships>`);
}
function makeXmlApp(slides, company) {
  return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF, `<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">
	<TotalTime>0</TotalTime>
	<Words>0</Words>
	<Application>Microsoft Office PowerPoint</Application>
	<PresentationFormat>On-screen Show (16:9)</PresentationFormat>
	<Paragraphs>0</Paragraphs>
	<Slides>`).concat(slides.length, `</Slides>
	<Notes>`).concat(slides.length, `</Notes>
	<HiddenSlides>0</HiddenSlides>
	<MMClips>0</MMClips>
	<ScaleCrop>false</ScaleCrop>
	<HeadingPairs>
		<vt:vector size="6" baseType="variant">
			<vt:variant><vt:lpstr>Fonts Used</vt:lpstr></vt:variant>
			<vt:variant><vt:i4>2</vt:i4></vt:variant>
			<vt:variant><vt:lpstr>Theme</vt:lpstr></vt:variant>
			<vt:variant><vt:i4>1</vt:i4></vt:variant>
			<vt:variant><vt:lpstr>Slide Titles</vt:lpstr></vt:variant>
			<vt:variant><vt:i4>`).concat(slides.length, `</vt:i4></vt:variant>
		</vt:vector>
	</HeadingPairs>
	<TitlesOfParts>
		<vt:vector size="`).concat(slides.length + 1 + 2, `" baseType="lpstr">
			<vt:lpstr>Arial</vt:lpstr>
			<vt:lpstr>Calibri</vt:lpstr>
			<vt:lpstr>Office Theme</vt:lpstr>
			`).concat(slides.map(function(_slideObj, idx) {
    return "<vt:lpstr>Slide ".concat(idx + 1, "</vt:lpstr>");
  }).join(""), `
		</vt:vector>
	</TitlesOfParts>
	<Company>`).concat(company, `</Company>
	<LinksUpToDate>false</LinksUpToDate>
	<SharedDoc>false</SharedDoc>
	<HyperlinksChanged>false</HyperlinksChanged>
	<AppVersion>16.0000</AppVersion>
	</Properties>`);
}
function makeXmlCore(title, subject, author, revision) {
  return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
	<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
		<dc:title>`.concat(encodeXmlEntities(title), `</dc:title>
		<dc:subject>`).concat(encodeXmlEntities(subject), `</dc:subject>
		<dc:creator>`).concat(encodeXmlEntities(author), `</dc:creator>
		<cp:lastModifiedBy>`).concat(encodeXmlEntities(author), `</cp:lastModifiedBy>
		<cp:revision>`).concat(revision, `</cp:revision>
		<dcterms:created xsi:type="dcterms:W3CDTF">`).concat(new Date().toISOString().replace(/\.\d\d\dZ/, "Z"), `</dcterms:created>
		<dcterms:modified xsi:type="dcterms:W3CDTF">`).concat(new Date().toISOString().replace(/\.\d\d\dZ/, "Z"), `</dcterms:modified>
	</cp:coreProperties>`);
}
function makeXmlPresentationRels(slides) {
  var intRelNum = 1;
  var strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + CRLF;
  strXml += '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">';
  strXml += '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster" Target="slideMasters/slideMaster1.xml"/>';
  for (var idx = 1;idx <= slides.length; idx++) {
    strXml += '<Relationship Id="rId'.concat(++intRelNum, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide" Target="slides/slide').concat(idx, '.xml"/>');
  }
  intRelNum++;
  strXml += '<Relationship Id="rId'.concat(intRelNum + 0, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesMaster" Target="notesMasters/notesMaster1.xml"/>') + '<Relationship Id="rId'.concat(intRelNum + 1, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/presProps" Target="presProps.xml"/>') + '<Relationship Id="rId'.concat(intRelNum + 2, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/viewProps" Target="viewProps.xml"/>') + '<Relationship Id="rId'.concat(intRelNum + 3, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/>') + '<Relationship Id="rId'.concat(intRelNum + 4, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/tableStyles" Target="tableStyles.xml"/>') + "</Relationships>";
  return strXml;
}
function makeXmlSlide(slide) {
  return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF) + '<p:sld xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" ' + 'xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"' + "".concat((slide === null || slide === undefined ? undefined : slide.hidden) ? ' show="0"' : "", ">") + "".concat(slideObjectToXml(slide)) + "<p:clrMapOvr><a:masterClrMapping/></p:clrMapOvr></p:sld>";
}
function getNotesFromSlide(slide) {
  var notesText = "";
  slide._slideObjects.forEach(function(data) {
    if (data._type === SLIDE_OBJECT_TYPES.notes)
      notesText += (data === null || data === undefined ? undefined : data.text) && data.text[0] ? data.text[0].text : "";
  });
  return notesText.replace(/\r*\n/g, CRLF);
}
function makeXmlNotesMaster() {
  return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF, '<p:notesMaster xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"><p:cSld><p:bg><p:bgRef idx="1001"><a:schemeClr val="bg1"/></p:bgRef></p:bg><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name=""/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x="0" y="0"/><a:ext cx="0" cy="0"/><a:chOff x="0" y="0"/><a:chExt cx="0" cy="0"/></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id="2" name="Header Placeholder 1"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="hdr" sz="quarter"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="0" y="0"/><a:ext cx="2971800" cy="458788"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0"/><a:lstStyle><a:lvl1pPr algn="l"><a:defRPr sz="1200"/></a:lvl1pPr></a:lstStyle><a:p><a:endParaRPr lang="en-US"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="3" name="Date Placeholder 2"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="dt" idx="1"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="3884613" y="0"/><a:ext cx="2971800" cy="458788"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0"/><a:lstStyle><a:lvl1pPr algn="r"><a:defRPr sz="1200"/></a:lvl1pPr></a:lstStyle><a:p><a:fld id="{5282F153-3F37-0F45-9E97-73ACFA13230C}" type="datetimeFigureOut"><a:rPr lang="en-US"/><a:t>7/23/19</a:t></a:fld><a:endParaRPr lang="en-US"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="4" name="Slide Image Placeholder 3"/><p:cNvSpPr><a:spLocks noGrp="1" noRot="1" noChangeAspect="1"/></p:cNvSpPr><p:nvPr><p:ph type="sldImg" idx="2"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="685800" y="1143000"/><a:ext cx="5486400" cy="3086100"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom><a:noFill/><a:ln w="12700"><a:solidFill><a:prstClr val="black"/></a:solidFill></a:ln></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0" anchor="ctr"/><a:lstStyle/><a:p><a:endParaRPr lang="en-US"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="5" name="Notes Placeholder 4"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="body" sz="quarter" idx="3"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="685800" y="4400550"/><a:ext cx="5486400" cy="3600450"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0"/><a:lstStyle/><a:p><a:pPr lvl="0"/><a:r><a:rPr lang="en-US"/><a:t>Click to edit Master text styles</a:t></a:r></a:p><a:p><a:pPr lvl="1"/><a:r><a:rPr lang="en-US"/><a:t>Second level</a:t></a:r></a:p><a:p><a:pPr lvl="2"/><a:r><a:rPr lang="en-US"/><a:t>Third level</a:t></a:r></a:p><a:p><a:pPr lvl="3"/><a:r><a:rPr lang="en-US"/><a:t>Fourth level</a:t></a:r></a:p><a:p><a:pPr lvl="4"/><a:r><a:rPr lang="en-US"/><a:t>Fifth level</a:t></a:r></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="6" name="Footer Placeholder 5"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="ftr" sz="quarter" idx="4"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="0" y="8685213"/><a:ext cx="2971800" cy="458787"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0" anchor="b"/><a:lstStyle><a:lvl1pPr algn="l"><a:defRPr sz="1200"/></a:lvl1pPr></a:lstStyle><a:p><a:endParaRPr lang="en-US"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="7" name="Slide Number Placeholder 6"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="sldNum" sz="quarter" idx="5"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="3884613" y="8685213"/><a:ext cx="2971800" cy="458787"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0" anchor="b"/><a:lstStyle><a:lvl1pPr algn="r"><a:defRPr sz="1200"/></a:lvl1pPr></a:lstStyle><a:p><a:fld id="{CE5E9CC1-C706-0F49-92D6-E571CC5EEA8F}" type="slidenum"><a:rPr lang="en-US"/><a:t>#</a:t></a:fld><a:endParaRPr lang="en-US"/></a:p></p:txBody></p:sp></p:spTree><p:extLst><p:ext uri="{BB962C8B-B14F-4D97-AF65-F5344CB8AC3E}"><p14:creationId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="1024086991"/></p:ext></p:extLst></p:cSld><p:clrMap bg1="lt1" tx1="dk1" bg2="lt2" tx2="dk2" accent1="accent1" accent2="accent2" accent3="accent3" accent4="accent4" accent5="accent5" accent6="accent6" hlink="hlink" folHlink="folHlink"/><p:notesStyle><a:lvl1pPr marL="0" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl1pPr><a:lvl2pPr marL="457200" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl2pPr><a:lvl3pPr marL="914400" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl3pPr><a:lvl4pPr marL="1371600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl4pPr><a:lvl5pPr marL="1828800" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl5pPr><a:lvl6pPr marL="2286000" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl6pPr><a:lvl7pPr marL="2743200" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl7pPr><a:lvl8pPr marL="3200400" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl8pPr><a:lvl9pPr marL="3657600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl9pPr></p:notesStyle></p:notesMaster>');
}
function makeXmlNotesSlide(slide) {
  return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF, '<p:notes xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"><p:cSld><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name=""/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x="0" y="0"/><a:ext cx="0" cy="0"/><a:chOff x="0" y="0"/><a:chExt cx="0" cy="0"/></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id="2" name="Slide Image Placeholder 1"/><p:cNvSpPr><a:spLocks noGrp="1" noRot="1" noChangeAspect="1"/></p:cNvSpPr><p:nvPr><p:ph type="sldImg"/></p:nvPr></p:nvSpPr><p:spPr/></p:sp><p:sp><p:nvSpPr><p:cNvPr id="3" name="Notes Placeholder 2"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="body" idx="1"/></p:nvPr></p:nvSpPr><p:spPr/><p:txBody><a:bodyPr/><a:lstStyle/><a:p><a:r><a:rPr lang="en-US" dirty="0"/><a:t>').concat(encodeXmlEntities(getNotesFromSlide(slide)), '</a:t></a:r><a:endParaRPr lang="en-US" dirty="0"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="4" name="Slide Number Placeholder 3"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="sldNum" sz="quarter" idx="10"/></p:nvPr></p:nvSpPr><p:spPr/><p:txBody><a:bodyPr/><a:lstStyle/><a:p><a:fld id="').concat(SLDNUMFLDID, '" type="slidenum"><a:rPr lang="en-US"/><a:t>').concat(slide._slideNum, '</a:t></a:fld><a:endParaRPr lang="en-US"/></a:p></p:txBody></p:sp></p:spTree><p:extLst><p:ext uri="{BB962C8B-B14F-4D97-AF65-F5344CB8AC3E}"><p14:creationId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="1024086991"/></p:ext></p:extLst></p:cSld><p:clrMapOvr><a:masterClrMapping/></p:clrMapOvr></p:notes>');
}
function makeXmlLayout(layout) {
  return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		<p:sldLayout xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" preserve="1">
		`.concat(slideObjectToXml(layout), `
		<p:clrMapOvr><a:masterClrMapping/></p:clrMapOvr></p:sldLayout>`);
}
function makeXmlMaster(slide, layouts) {
  var layoutDefs = layouts.map(function(_layoutDef, idx) {
    return '<p:sldLayoutId id="'.concat(LAYOUT_IDX_SERIES_BASE + idx, '" r:id="rId').concat(slide._rels.length + idx + 1, '"/>');
  });
  var strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + CRLF;
  strXml += '<p:sldMaster xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main">';
  strXml += slideObjectToXml(slide);
  strXml += '<p:clrMap bg1="lt1" tx1="dk1" bg2="lt2" tx2="dk2" accent1="accent1" accent2="accent2" accent3="accent3" accent4="accent4" accent5="accent5" accent6="accent6" hlink="hlink" folHlink="folHlink"/>';
  strXml += "<p:sldLayoutIdLst>" + layoutDefs.join("") + "</p:sldLayoutIdLst>";
  strXml += '<p:hf sldNum="0" hdr="0" ftr="0" dt="0"/>';
  strXml += "<p:txStyles>" + " <p:titleStyle>" + '  <a:lvl1pPr algn="ctr" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="0"/></a:spcBef><a:buNone/><a:defRPr sz="4400" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mj-lt"/><a:ea typeface="+mj-ea"/><a:cs typeface="+mj-cs"/></a:defRPr></a:lvl1pPr>' + " </p:titleStyle>" + " <p:bodyStyle>" + '  <a:lvl1pPr marL="342900" indent="-342900" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char=""/><a:defRPr sz="3200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl1pPr>' + '  <a:lvl2pPr marL="742950" indent="-285750" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char=""/><a:defRPr sz="2800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl2pPr>' + '  <a:lvl3pPr marL="1143000" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char=""/><a:defRPr sz="2400" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl3pPr>' + '  <a:lvl4pPr marL="1600200" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char=""/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl4pPr>' + '  <a:lvl5pPr marL="2057400" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char=""/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl5pPr>' + '  <a:lvl6pPr marL="2514600" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char=""/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl6pPr>' + '  <a:lvl7pPr marL="2971800" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char=""/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl7pPr>' + '  <a:lvl8pPr marL="3429000" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char=""/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl8pPr>' + '  <a:lvl9pPr marL="3886200" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char=""/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl9pPr>' + " </p:bodyStyle>" + " <p:otherStyle>" + '  <a:defPPr><a:defRPr lang="en-US"/></a:defPPr>' + '  <a:lvl1pPr marL="0" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl1pPr>' + '  <a:lvl2pPr marL="457200" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl2pPr>' + '  <a:lvl3pPr marL="914400" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl3pPr>' + '  <a:lvl4pPr marL="1371600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl4pPr>' + '  <a:lvl5pPr marL="1828800" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl5pPr>' + '  <a:lvl6pPr marL="2286000" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl6pPr>' + '  <a:lvl7pPr marL="2743200" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl7pPr>' + '  <a:lvl8pPr marL="3200400" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl8pPr>' + '  <a:lvl9pPr marL="3657600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl9pPr>' + " </p:otherStyle>" + "</p:txStyles>";
  strXml += "</p:sldMaster>";
  return strXml;
}
function makeXmlSlideLayoutRel(layoutNumber, slideLayouts) {
  return slideObjectRelationsToXml(slideLayouts[layoutNumber - 1], [
    {
      target: "../slideMasters/slideMaster1.xml",
      type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster"
    }
  ]);
}
function makeXmlSlideRel(slides, slideLayouts, slideNumber) {
  return slideObjectRelationsToXml(slides[slideNumber - 1], [
    {
      target: "../slideLayouts/slideLayout".concat(getLayoutIdxForSlide(slides, slideLayouts, slideNumber), ".xml"),
      type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout"
    },
    {
      target: "../notesSlides/notesSlide".concat(slideNumber, ".xml"),
      type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide"
    }
  ]);
}
function makeXmlNotesSlideRel(slideNumber) {
  return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
			<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesMaster" Target="../notesMasters/notesMaster1.xml"/>
			<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide" Target="../slides/slide`.concat(slideNumber, `.xml"/>
		</Relationships>`);
}
function makeXmlMasterRel(masterSlide, slideLayouts) {
  var defaultRels = slideLayouts.map(function(_layoutDef, idx) {
    return {
      target: "../slideLayouts/slideLayout".concat(idx + 1, ".xml"),
      type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout"
    };
  });
  defaultRels.push({ target: "../theme/theme1.xml", type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" });
  return slideObjectRelationsToXml(masterSlide, defaultRels);
}
function makeXmlNotesMasterRel() {
  return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF, `<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
		<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="../theme/theme1.xml"/>
		</Relationships>`);
}
function getLayoutIdxForSlide(slides, slideLayouts, slideNumber) {
  for (var i4 = 0;i4 < slideLayouts.length; i4++) {
    if (slideLayouts[i4]._name === slides[slideNumber - 1]._slideLayout._name) {
      return i4 + 1;
    }
  }
  return 1;
}
function makeXmlTheme(pres) {
  var _a, _b, _c, _d;
  var majorFont = ((_a = pres.theme) === null || _a === undefined ? undefined : _a.headFontFace) ? '<a:latin typeface="'.concat((_b = pres.theme) === null || _b === undefined ? undefined : _b.headFontFace, '"/>') : '<a:latin typeface="Calibri Light" panose="020F0302020204030204"/>';
  var minorFont = ((_c = pres.theme) === null || _c === undefined ? undefined : _c.bodyFontFace) ? '<a:latin typeface="'.concat((_d = pres.theme) === null || _d === undefined ? undefined : _d.bodyFontFace, '"/>') : '<a:latin typeface="Calibri" panose="020F0502020204030204"/>';
  return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="4472C4"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="5B9BD5"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont>'.concat(majorFont, '<a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface=" Light"/><a:font script="Hang" typeface=" "/><a:font script="Hans" typeface=" Light"/><a:font script="Hant" typeface=""/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Angsana New"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:majorFont><a:minorFont>').concat(minorFont, '<a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface=""/><a:font script="Hang" typeface=" "/><a:font script="Hans" typeface=""/><a:font script="Hant" typeface=""/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Cordia New"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>');
}
function makeXmlPresentation(pres) {
  var strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF) + '<p:presentation xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" ' + 'xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" '.concat(pres.rtlMode ? 'rtl="1"' : "", ' saveSubsetFonts="1" autoCompressPictures="0">');
  strXml += '<p:sldMasterIdLst><p:sldMasterId id="2147483648" r:id="rId1"/></p:sldMasterIdLst>';
  strXml += "<p:sldIdLst>";
  pres.slides.forEach(function(slide) {
    return strXml += '<p:sldId id="'.concat(slide._slideId, '" r:id="rId').concat(slide._rId, '"/>');
  });
  strXml += "</p:sldIdLst>";
  strXml += '<p:notesMasterIdLst><p:notesMasterId r:id="rId'.concat(pres.slides.length + 2, '"/></p:notesMasterIdLst>');
  strXml += '<p:sldSz cx="'.concat(pres.presLayout.width, '" cy="').concat(pres.presLayout.height, '"/>');
  strXml += '<p:notesSz cx="'.concat(pres.presLayout.height, '" cy="').concat(pres.presLayout.width, '"/>');
  strXml += "<p:defaultTextStyle>";
  for (var idy = 1;idy < 10; idy++) {
    strXml += "<a:lvl".concat(idy, 'pPr marL="').concat((idy - 1) * 457200, '" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1">') + '<a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/>' + "</a:defRPr></a:lvl".concat(idy, "pPr>");
  }
  strXml += "</p:defaultTextStyle>";
  if (pres.sections && pres.sections.length > 0) {
    strXml += '<p:extLst><p:ext uri="{521415D9-36F7-43E2-AB2F-B90AF26B5E84}">';
    strXml += '<p14:sectionLst xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main">';
    pres.sections.forEach(function(sect) {
      strXml += '<p14:section name="'.concat(encodeXmlEntities(sect.title), '" id="{').concat(getUuid("xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"), '}"><p14:sldIdLst>');
      sect._slides.forEach(function(slide) {
        return strXml += '<p14:sldId id="'.concat(slide._slideId, '"/>');
      });
      strXml += "</p14:sldIdLst></p14:section>";
    });
    strXml += "</p14:sectionLst></p:ext>";
    strXml += '<p:ext uri="{EFAFB233-063F-42B5-8137-9DF3F51BA10A}"><p15:sldGuideLst xmlns:p15="http://schemas.microsoft.com/office/powerpoint/2012/main"/></p:ext>';
    strXml += "</p:extLst>";
  }
  strXml += "</p:presentation>";
  return strXml;
}
function makeXmlPresProps() {
  return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF, '<p:presentationPr xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"/>');
}
function makeXmlTableStyles() {
  return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF, '<a:tblStyleLst xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" def="{5C22544A-7EE6-4342-B048-85BDC9FD1C3A}"/>');
}
function makeXmlViewProps() {
  return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF, '<p:viewPr xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"><p:normalViewPr horzBarState="maximized"><p:restoredLeft sz="15611"/><p:restoredTop sz="94610"/></p:normalViewPr><p:slideViewPr><p:cSldViewPr snapToGrid="0" snapToObjects="1"><p:cViewPr varScale="1"><p:scale><a:sx n="136" d="100"/><a:sy n="136" d="100"/></p:scale><p:origin x="216" y="312"/></p:cViewPr><p:guideLst/></p:cSldViewPr></p:slideViewPr><p:notesTextViewPr><p:cViewPr><p:scale><a:sx n="1" d="1"/><a:sy n="1" d="1"/></p:scale><p:origin x="0" y="0"/></p:cViewPr></p:notesTextViewPr><p:gridSpacing cx="76200" cy="76200"/></p:viewPr>');
}
var import_jszip, __assign2 = function() {
  __assign2 = Object.assign || function __assign(t2) {
    for (var s2, i4 = 1, n2 = arguments.length;i4 < n2; i4++) {
      s2 = arguments[i4];
      for (var p3 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p3))
          t2[p3] = s2[p3];
    }
    return t2;
  };
  return __assign2.apply(this, arguments);
}, EMU = 914400, ONEPT = 12700, CRLF = `\r
`, LAYOUT_IDX_SERIES_BASE = 2147483649, REGEX_HEX_COLOR, LINEH_MODIFIER = 1.67, DEF_BULLET_MARGIN = 27, DEF_CELL_BORDER, DEF_CELL_MARGIN_IN, DEF_CHART_BORDER, DEF_CHART_GRIDLINE, DEF_FONT_COLOR = "000000", DEF_FONT_SIZE = 12, DEF_FONT_TITLE_SIZE = 18, DEF_PRES_LAYOUT = "LAYOUT_16x9", DEF_PRES_LAYOUT_NAME = "DEFAULT", DEF_SHAPE_LINE_COLOR = "333333", DEF_SHAPE_SHADOW, DEF_SLIDE_MARGIN_IN, DEF_TEXT_SHADOW, DEF_TEXT_GLOW, AXIS_ID_VALUE_PRIMARY = "2094734552", AXIS_ID_VALUE_SECONDARY = "2094734553", AXIS_ID_CATEGORY_PRIMARY = "2094734554", AXIS_ID_CATEGORY_SECONDARY = "2094734555", AXIS_ID_SERIES_PRIMARY = "2094734556", LETTERS, BARCHART_COLORS, PIECHART_COLORS, TEXT_HALIGN, TEXT_VALIGN, SLDNUMFLDID = "{F7021451-1387-4CA6-816F-3879F97B5CBC}", OutputType, ChartType, ShapeType, SchemeColor, AlignH, AlignV, SHAPE_TYPE, CHART_TYPE, SCHEME_COLOR_NAMES, MASTER_OBJECTS, SLIDE_OBJECT_TYPES, PLACEHOLDER_TYPES, BULLET_TYPES, IMG_BROKEN = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAB3CAYAAAD1oOVhAAAGAUlEQVR4Xu2dT0xcRRzHf7tAYSsc0EBSIq2xEg8mtTGebVzEqOVIolz0siRE4gGTStqKwdpWsXoyGhMuyAVJOHBgqyvLNgonDkabeCBYW/8kTUr0wsJC+Wfm0bfuvn37Znbem9mR9303mJnf/Pb7ed95M7PDI5JIJPYJV5EC7e3t1N/fT62trdqViQCIu+bVgpIHEo/Hqbe3V/sdYVKHyWSSZmZm8ilVA0oeyNjYmEnaVC2Xvr6+qg5fAOJAz4DU1dURGzFSqZRVqtMpAFIGyMjICC0vL9PExIRWKADiAYTNshYWFrRCARAOEFZcCKWtrY0GBgaUTYkBRACIE4rKZwqACALR5RQAqQCIDqcASIVAVDsFQCSAqHQKgEgCUeUUAPEBRIVTAMQnEBvK5OQkbW9vk991CoAEAMQJxc86BUACAhKUUwAkQCBBOAVAAgbi1ykAogCIH6cAiCIgsk4BEIVAZJwCIIqBVLqiBxANQFgXS0tLND4+zl08AogmIG5OSSQS1gGKwgtANAIRcQqAaAbCe6YASBWA2E6xDyeyDUl7+AKQMkDYYevm5mZHabA/Li4uUiaTsYLau8QA4gLE/hU7wajyYtv1hReDAiAOxQcHBymbzark4BkbQKom/X8dp9Npmpqasn4BIAYAYSnYp+4BBEAMUcCwNOCQsAKZnp62NtQOw8WmwT09PUo+ijaHsOMx7GppaaH6+nolH0Z10K2tLVpdXbW6UfV3mNqBdHd3U1NTk2rtlMRfW1uj2dlZAFGirkRQAJEQTWUTAFGprkRsAJEQTWUTAFGprkRsAJEQTWUTAFGprkRsAJEQTWUTAFGprkRsAJEQTWUTAFGprkRsAJEQTWUTAGHqrm8caPzQ0WC1logbeiC7X3xJm0PvUmRzh45cuki1588FAmVn9BO6P3yF9utrqGH0MtW82S8UN9RA9v/4k7InjhcJFTs/TLVXLwmJV67S7vD7tHF5pKi46fYdosdOcOOGG8j1OcqefbFEJD9Q3GCwDhqT31HklS4A8VRgfYM2Op6k3bt/BQJl58J7lPvwg5JYNccepaMry0LPqFA7hCm39+NNyp2J0172b19QysGINj5CsRtpij57musOViH0QPJQXn6J9u7dlYJSFkbrMYolrwvDAJAC+WWdEpQz7FTgECeUCpzi6YxvvqXoM6eEhqnCSgDikEzUKUE7Aw7xuHctKB5OYU3dZlNR9syQdAaAcAYTC0pXF+39c09o2Ik+3EqxVKqiB7hbYAxZkk4pbBaEM+AQofv+wTrFwylBOQNABIGwavdfe4O2pg5elO+86l99nY58/VUF0byrYsjiSFluNlXYrOHcBar7+EogUADEQ0YRGHbzoKAASBkg2+9cpM1rV0tK2QOcXW7bLEFAARAXIF4w2DrDWoeUWaf4hQIgDiA8GPZ2iNfi0Q8UACkAIgrDbrJ385eDxaPLLrEsFAB5oG6lMPJQPLZZZKAACBGVhcG2Q+bmuLu2nk55e4jqPv1IeEoceiBeX7s2zCa5MAqdstl91vfXwaEGsv/rb5TtOFk6tWXOuJGh6KmnhO9sayrMninPx103JBtXblHkice58cINZP4Hyr5wpkgkdiChEmc4FWazLzenNKa/p0jncwDiqcD6BuWePk07t1asatZGoYQzSqA4nFJ7soNiP/+EUyfc25GI2GG53dHPrKo1g/1Cw4pIXLrzO+1c+/wg7tBbFDle/EbQcjFCPWQJCau5EoBoFpzXHYDwFNJcDiCaBed1ByA8hTSXA4hmwXndAQhPIc3lAKJZcF53AMJTSHM5gGgWnNcdgPAU0lwOIJoF53UHIDyFNJcfSiCdnZ0Ui8U0SxlMd7lcjubn561gh+Y1scFIU/0o/3sgeLO12E2k7UXKYumgFoAYdg8ACIAYpoBh6cAhAGKYAoalA4cAiGEKGJYOHAIghilgWDpwCIAYpoBh6cAhAGKYAoalA4cAiGEKGJYOHAIghilgWDpwCIAYpoBh6ZQ4JB6PKzviYthnNy4d9h+1M5mMlVckkUjsG5dhiBMCEMPg/wuOfrZZ/RSywQAAAABJRU5ErkJggg==", IMG_PLAYBTN = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB4AAAAVnCAYAAACzfHDVAAAAYHpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjaVcjJDYAwDEXBu6ughBfH+YnLQSwSHVA+Yrkwx7HtPHabHuEWrQ+lBBAZ6TMweBWoCwUH8quZH6VWFXVT696zxp12ARkVFEqn8wB8AAAACXBIWXMAAC4jAAAuIwF4pT92AADZLklEQVR42uzdd5hV9Z0/8M+dmcsUZmDovYOhKCiKYhR7JJuoSTCWGFI0WUxijBoTTXazVlyza4maYm9rTRSJigVsqCDNQhHBAogKCEgRMjMMU+7vj93sL8kqClLmnPt6PY+PeXZM9vP9vO8jZ+Y955xMfJLjorBrRMuSgmiViyjN1Ee2oSCyucbIBAAAAAAAAADbXaYgcoWNUZcrirpMbdRsysa69wbF+rggGrf439vSF7seF12aFUTnxvoosGIAAAAAAACAXacgoqEgF++/VRgr4r5o+Kh/pvD//F8uiII+LaPrum/EXzqui2b1ddHGKgEAAAAAAAB2rVxEQWMmWrQtjHZlA6N2w2tR84//zP8pgHu3ib6NBdG+zdqorK6KVUXZaB85j3sGAAAAAAAAaAoaG6OwIBdtyneP2PBabPzbr/1dAdx3VHRtyESHiIhcYzQrLo7WmVzkcjmPgAYAAAAAAABoSgpy0eIfS+D/LYD7fy3abC6Inn/7X2hsjELlLwAAAAAAAEDT9D8lcM1fHwddFBFxyAVR9M686PVp/gfqayKiJiLqLBMAAAAAAABgh8hGRGlEUekn/6PFEb3ikNgQk6O+KCJi6dzoksv83/cB/1X9xoiaJdmoWxlRV1dk2QAAAAAAAAA7QTZbH9muERX96v7n9t7/q6Exinq3i86LI94pjOOisHUu+uYykfmof7h+Y8Sa6aVRt74gGhs9DRoAAAAAAABgZ2lsLIi69QWxeUUmSjs0/vedwR8hk4uydSfE+wVd6qOyMfMx7/mtj9jwUtbjngEAAAAAAAB2obrqolg7IxtR/9Ffb4wo7P5GtCwobRaVH/c/UvNmNuqqPfIZAAAAAAAAYFerqy6KmjezH/v1ktpoVZBr/PgCeMN7yl8AAAAAAACApmJLHW5jUVQWNDSP+Q3ZeLco4i9/+8X6teHRzwAAAAAAAABNSd3/dLn/oLAoqqIuVhXFxhhSGB/xqGjlLwAAAAAAAECTU1eTjaK/KXSLIv7SWB+bc5ko9YxnAAAAAAAAgATJFv393bz1EeV//c8F1gMAAAAAAACQDgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKREkRUAAACwrUpLSwuGDRvWfMCAAS26du3avKysrLiioqKkZcuWzZs1a1bcvHnz0tLS0rJsNtusuLi4ebNmzUoLCgo+8/eijY2N9Zs3b66pra2tqqur21xTU1NdVVVVs2nTptqNGzdWbdiwoeYvf/nL5hUrVlQtWLBgw6xZs6pqamoaJQYAAEDaKYABAACIiIghQ4aUHnTQQW379u3bql27dq3at2/fpkWLFq2bN29eWVpa2qpZs2bNCwsLm2ez2fLCwsLyoqKi8sLCwtKknK+hoaG6vr6+qqGh4S91dXV/aWhoqNq8eXNVTU3NuqqqqvUbNmxYu2rVqjWrV69e99Zbb6177rnnPpgzZ06NTwYAAABJogAGAADIA8OGDWt+xBFHdBwwYECnLl26dGjdunXHFi1adCgtLe1YUlLSvlmzZq0KCgqK07yDwsLCssLCwrKIaPdp/zuNjY21mzdvXrdp06ZVNTU172/YsGHl2rVr31+2bNnKBQsWrHjyySffnzVrVpVPGAAAAE1Fpuexsd9HfaF+ZcSal0ptCAAAIAE6deqUPf744zvtueeeXbp3796lbdu2XSorKzuXlpZ2KS0t7VBYWFhhSztGQ0PDxpqampU1NTXL169fv+yDDz5Y9s477yybPXv2sj/96U8rVqxYUWdLAAAAbE9t9q6Jog4f/TUFMAAAQEJks9nMt7/97Y4jRozo1bdv397t2rXrXl5e3rWsrKxzcXFx+4gosKUmp7G2tnZVTU3Nso0bNy5btWrV0tdff/2tJ598cvG999672noAAADYFgpgAACAhPne977X6a9Fb/v27Xu1bNmyV1lZWa8kvXOXLauvr9/wl7/8ZdG6desWL1u2bNHChQsX/fGPf1w8derUjbYDAADAliiAAQAAmqhsNps59dRTuxx66KH9+/Tp87n27dv3Ly8v719UVOSRzXlq06ZNKzZu3Pj6+++//8abb775xqOPPvrG3XffvcpmAAAA+CsFMAAAQBNx6qmndvniF784qHfv3v3btWv3uYqKis8VFhaW2wxbUl9fv37Dhg1vfPDBB68vXrz4jccee2z+jTfeuNxmAAAA8pMCGAAAYBc45phjWn/rW9/aq3///kPatGnTv6Kiop9HOLO9NDQ0VG/cuPGtNWvWLFy4cOGcO+6445WHHnporc0AAACknwIYAABgJzjjjDO6f+lLX9qrV69eg1u3bj2orKysR0RkbIadJFddXb103bp18xcvXjz30UcffeXqq69+x1oAAADSRwEMAACwnZWWlhb86le/2u3QQw8d1r17931btmw5qLCwsMxmaEoaGhqqP/zww/nvvPPOzGeeeWbW2LFj36ipqWm0GQAAgGRTAAMAAGwHP/7xj7t+9atf3bdXr15D27Ztu1c2m21jKyRJXV3dmg8++OCVRYsWvfznP/95xh/+8IdltgIAAJA8CmAAAIBtcOKJJ7Y75ZRTDujXr9+w1q1bD81ms61shTSpq6tbt3bt2pfffPPNWbfccsvUe++9d7WtAAAANH0KYAAAgE+hoqKi4IILLhg0YsSI/bp27bpfy5YtB2YymUKbIR/kcrmGDz/8cP6777474/nnn59x4YUXvrZx40aPiwYAAGiCFMAAAAAf4/jjj2/7/e9//8D+/fsf2Lp1630KCgpKbAUiGhsbN61fv37eW2+9NeWGG2545u67715lKwAAAE2DAhgAAOB/ZLPZzAUXXPC5I4888sDu3bsfWFFRsVtEFNgMbFl1dfWSd999d8qsWbNmnnvuuS+vW7euwVYAAAB2DQUwAACQ10pLSwsuvfTSQYcccsjBXbt2HVFWVtbDVmDb1dbWrnr//fdfmDp16uRf/vKXL65evbreVgAAAHYeBTAAAJB3Bg0aVHrBBRd8fs899zywQ4cOBxQVFbWwFdj+Ghsba9euXTtrzpw5T59//vmTX3755WpbAQAA2LEUwAAAQF4YNmxY8/POO+/gIUOGHOZ9vrDz/W0ZfNFFFz07a9asKlsBAADY/hTAAABAarVq1arwyiuv3HfEiBEjO3TocFBhYWGZrcCu19DQUP3+++8/O2XKlIk/+clPZm7cuLHRVgAAALYPBTAAAJAqrVq1Kvztb3+7/3777Xd4x44dRxQWFpbbCjRdDQ0NG99///0pM2bMeOqHP/zhC8pgAACAz0YBDAAApMJZZ53V45vf/OaRvXr1GllaWtrVRiB5ampq3l28ePHEO++8c9LVV1/9jo0AAABsPQUwAACQWMOHDy+/6KKLvjB48OCjW7RoMdBGID0+/PDDV+fNmzfhvPPOe3L69Ol/sREAAIBPRwEMAAAkSqtWrQpvuOGGQ/bbb79/atOmzX6ZTCZrK5BeuVyubs2aNTNmzJjx2JgxYyavW7euwVYAAAA+ngIYAABIhB//+Mddv/e9732lZ8+e/1RcXNzWRiD/1NbWfvD2228/dssttzz029/+9l0bAQAA+L8UwAAAQJNVUVFRcO21137+4IMPPrZ169b7ZTKZAlsBIqJxzZo1M59//vnxp5122hR3BQMAAPx/CmAAAKDJOeWUUzqefvrpx/bu3ftL2Wy2jY0AH6e+vn7j0qVLH/vd7373x+uvv36ZjQAAAPlOAQwAADQJ2Ww2c+uttx5wyCGHnNC6deu9I8LdvsDWaFy7du1L06ZN+/OPfvSjZ1evXl1vJQAAQD5SAAMAALtU//79S6655pp/2nPPPY8tLy/vayPAZ1VTU7NswYIF488999wHp06dutFGAACAfKIABgAAdomf//znPU855ZQTu3btemRhYWGZjQDbW2NjY92KFSuevOWWW+689NJLF9kIAACQDxTAAADATuMxz8Cusn79+rlPP/30f5188slT6+rqcjYCAACklQIYAADY4fr27Vv8hz/84a+Pee5nI8CuUlNT8+68efPu/8EPfvDgwoULN9kIAACQNgpgAABghxkyZEjpNddc89XBgwefWFxc3MFGgKaitrZ21dy5c+/5yU9+8uc5c+bU2AgAAJAWWyqAPYoNAADYJqNHj+4wb968n06ZMuXRYcOGnaH8BZqa4uLi9sOGDTtjypQpj86bN++nJ510UntbAQAA0s4dwAAAwFY599xze33/+9//dufOnY/IZDJZGwGSIpfL1S1fvvzJG2644fbLLrvsbRsBAACSyiOgAQCAz+y8887r+53vfOfbHTt2PDyTyRTaCJBUuVyuYcWKFU/cdNNN//XrX/96sY0AAABJowAGAAC22WWXXTboG9/4xg9at249zDaAtFm7du2su++++9pzzjnnNdsAAACSQgEMAABsNcUvkE8UwQAAQJIogAEAgE9N8Qvks7Vr18665557rvv5z38+3zYAAICmaksFcGHlwOj6UV9orIqoWZG1PQAAyBO/+MUvet9xxx3nHHrooT8pLS3tYiNAPiotLe2y7777HvP973+/X1lZ2ZIpU6assxUAAKCpKetcHwXlH/01BTAAAOS5M844o/u99957zpe//OWflZeX94qIjK0AeS5TXl7e8+CDDx71/e9/v3dEvDVjxowPrQUAAGgqFMAAAMD/ceKJJ7a77777fjJq1Kh/KS8v7xOKX4B/lCkvL+99+OGHj/rWt77VfvXq1Qvnz59fbS0AAMCutqUC2DuAAQAgzwwdOrTs+uuvP6l///4nFRYWltkI20NjY2Ns2rQpqquro6amJurr62PTpk2xefPmqK+vj+rq6qivr4/NmzfHpk2boqGhYZv/fxUWFkZJSUk0a9YsioqKoqysLIqKiqJZs2ZRUlISRUVFUVpa+r9/FRQUCIjtoqGhoeq11167a8yYMffMmTOnxkYAAIBdZUvvAFYAAwBAnujUqVP2nnvuGbXXXnudnM1mK22Ej9PQ0BAbN26MDRs2/J+/Nm7cGBs3boyamprYtGlTbNq0KWpqaqK2trbJnqe4uDhKSkqitLT0f/9eUVERFRUV0aJFi//zV0VFRRQWFvog8LHq6urWvvjii7eceOKJf169enW9jQAAADubAhgAAPLcXXfdddAXv/jF00tLS7vZRn7L5XKxYcOGWLt2baxbty7Wrl37d3+tW7cuNmzYkPd7atGiRbRu3TpatWoVrVu3jjZt2vzvf27dunW0aNHCh4morq5e+sgjj1zzne98Z6ptAAAAO5MCGAAA8tTVV189+MQTTzyzoqJioG3kj8bGxli5cmUsX748Pvjgg1i9evX//n3t2rXR2NhoSZ9RYWFhtGrVKtq1axdt27b937937tw5OnTo4LHTeWbDhg3z77333qvOPPPMebYBAADsDApgAADIM1/72tfaXHrppad27979qIjQRKVUQ0NDrFq1KlasWBHvv//+//595cqVTfqRzGlXXFwcHTp0iI4dO0bnzp2jY8eO0alTp2jXrp1HS6dYLpdrfOeddx76+c9/fv2ECRPW2QgAALAjKYABACBP9OrVq9ldd931jT322OM7hYWFZTaSHh9++GG88847sXTp0njvvfdixYoVsXr16mhoaLCchCgsLIz27dtHp06dolu3btG9e/fo3r27x0mnTENDQ9W8efNu++Y3v/nHJUuWbLYRAABgR1AAAwBAHrjrrrtG/NM//dOZJSUlXWwj2davXx9Lly6Nd955539L3w8//NBiUqqysvJ/y+C//tWqVSuLSbiamppljz322G9Gjx49xTYAAIDtTQEMAAAp9qtf/arPD3/4w5+1atVqL9tIno0bN8aSJUvirbfeikWLFsV7770XmzZtspg8V1JSEl27do0+ffpE3759o3fv3lFeXm4xCbRu3bqXr7322ivGjh27yDYAAIDtRQEMAAApNGjQoNI77rjju7vttttJBQUFWRtJhtWrV8ebb74ZixcvjiVLlsTy5cujsbHRYtiigoKC6Ny5c/Tu3Tt69+4d/fr1i7Zt21pMQjQ2Nta98cYbd33rW9+6ff78+TU2AgAAfFYKYAAASJHS0tKCBx988Jj99tvvn7PZbBsbaboaGhri7bffjrfeeisWLFgQS5YscXcv201FRUX06tUr+vbtG3379o2ePXtGYWGhxTRhdXV1a2bMmHHjV77ylYdqamr85gcAALDNFMAAAJASp59+erdf/vKX51ZWVu5jG03T6tWr47XXXouFCxfGm2++GRs3brQUdooWLVpE3759Y8CAATFw4EB3CDdh69evf/E//uM//vPqq69+xzYAAIBtoQAGAICEGzRoUOm99977w969ex+byWTc4teErF+/PubNmxcLFiyIN954Q+FLk9GiRYvo169fDBgwIPbYY4+orKy0lCYkl8s1LF68eNyJJ554rcdCAwAAW0sBDAAACXbNNdcMOemkk35RVlbWyzZ2vVwuF++++27MnTs3XnvttViyZIl3+NLkFRQURK9evWLQoEExePDg6Natm6U0EdXV1UvuvvvuX//kJz+ZYxsAAMCnpQAGAIAEOuqoo1r99re//VmHDh0Ot41da9OmTTF79uyYO3duLFy4MKqqqiyFRGvevHn0798/Bg8eHHvuuWeUlJRYyi62cuXKp04//fTLJ0yYsM42AACAT6IABgCAhBk3btwRRxxxxFnZbLaNbewaVVVVMXfu3Jg7d27Mnz8/amtrLYVUKi4ujoEDB8bgwYNj8ODBUV5ebim7SF1d3ZqnnnrqqlGjRj1hGwAAwJYogAEAICFOOeWUjhdddNEvW7duvZ9t7HwrV66MWbNmxdy5c+Odd96JXC5nKeSdzp07x9577x3Dhg2LDh06WMgusHbt2hnnnXfepbfccsv7tgEAAHwUBTAAADRxpaWlBU899dQ3Bw8e/L2CggLPYt2JVqxYES+99FK89NJLsXz5cguBv/HXMnjvvfeOTp06WchO1NjYuGnu3Lk3H3744XfV1NR40TgAAPB3FMAAANCEjR49usOll176yzZt2gy3jZ1j/fr18eKLL8bMmTNj6dKlFgKfQs+ePWPfffeNYcOGRYsWLSxkJ1mzZs0L55577q/vvvvuVbYBAAD8lQIYAACaoIqKioKJEyd+c/Dgwd8vKCgotpEda8OGDfHiiy/G9OnTlb7wGfXo0SOGDx8ew4YNi4qKCgvZwdwNDAAA/CMFMAAANDGnnHJKx7Fjx/5rZWXlMNvYcerr6+PVV1+NGTNmxLx586Kurs5SYDvKZrMxZMiQ2HfffWP33XePwsJCS9mB1q5dO+MXv/jFv995550rbQMAAPKbAhgAAJqIbDabeeKJJ47fZ599fuSu3x0jl8vFwoULY/r06TF79uzYtGmTpcBOUFpaGkOGDInhw4fHgAEDLGQHaWhoqJ42bdo1Rx555J9tAwAA8pcCGAAAmoDjjz++7ZVXXvmr1q1be9fvDrBmzZqYNm1azJw5M1audHMc7EodO3aMz3/+87H//vt7X/CO+3fetDPPPPOScePGfWAbAACQfxTAAACwi9100037HXvssf9WXFzc1ja2n1wuF6+99lo8//zzMW/evKivr7cUaEKKiopizz33jBEjRsTnPve5yGQylrId1dbWrvrjH/948Q9+8INZtgEAAPlFAQwAALvIkCFDSu+///5zunTp8k+2sf2sXbs2Jk+eHNOnT48PP/zQQiABKisrY8SIEXHIIYdEeXm5hWxHy5Yte+zrX//6f86ZM6fGNgAAID9sqQAurBwYXT/qC41VETUrsrYHAADb6IILLtjt97///VVt2rQZZhvbx+LFi2P8+PFx9913xxtvvBG1tbWWAgmxadOmeOONN+LZZ5+NtWvXRps2bTweejtp0aJFv5NOOumg0tLSuc8+++xaGwEAgPQr61wfBR/zu7XuAAYAgO0sm81mJk2a9PVhw4b9pKCgwG9VfkZ1dXUxY8aMeOaZZ+K9996zEEiRfv36xSGHHBJDhw6NgoICC/mMGhsbN8+YMeOaL37xi+Pq6upyNgIAAOnlEdAAALCTHH/88W2vuuqqCyorK/exjc9mzZo18dRTT8XUqVNj06ZNFgIpVlFREZ///OfjsMMOi8rKSgv5jNavXz/r9NNPv3DcuHEf2AYAAKSTAhgAAHaC22677fNf+9rXzstms5W2se0WLVoUjz/+eMybNy9yOTewQT4pKiqKIUOGxBFHHBG9e/e2kM+grq5u3QMPPHDRySefPM02AAAgfRTAAACwA1VUVBQ8/fTTpwwcOPCUTCbjGabbIJfLxauvvhpPPvlkLFy40EIgz2UymRgwYEAcccQRMWjQIAvZ9n+3Ns6fP/+Www8//JaNGzc22ggAAKTHlgrgwsqB0fWjvtBYFVGzwuvKAABgS0488cR2EyZMuLx79+5fzmQyGRvZOo2NjTFr1qy49dZb48knn4wPPvC0UuC/rV69OmbMmBFz5syJ0tLS6NSpU/jX7NbJZDKZ9u3bD/3+978/dPny5TNfffXValsBAIB0KOtcHwXlH/O9gDuAAQBg29x66637H3vssRcWFRW1sI2tU1NTE0899VQ8++yzsWHDBgsBPlGLFi3i4IMPjsMPPzxKS/28YmvV19d/OG7cuPNPPvnk6bYBAADJ5xHQAACwHWWz2cyzzz77rSFDhvzAI5+3zqZNm2Ly5Mnx1FNPKX6BbdKiRYs47LDD4pBDDlEEb6VcLtfwyiuvXHfooYfeWVdX5yXrAACQYApgAADYTo455pjW11133cWVlZV728ant2HDhnj88cdjypQpUVtbayHAZ1ZcXBwHHnhgfPGLX4wWLTyIYWusWbNm2re//e3zn3nmGb+JAwAACeUdwAAAsB1cfvnlu1900UW/LS8v72cbn05VVVVMmDAhbrnllnjzzTejoaHBUoDtoqGhIZYsWRLPPfdc1NTURI8ePSKb9XOMT6OsrKzb17/+9SPbtm0774knnlhtIwAAkMDreu8ABgCAz+bhhx/+8qGHHnpOQUFBsW18sk2bNsUzzzwTTzzxRFRVVVkIsMOVl5fHkUceGYccckgUF/tX9afR2Ni46emnn/71Mccc87htAABAsngENAAAbKN27doVTZ48+YxevXodZxufrK6uLp5++umYOHGi4hfYJSoqKuKLX/xiHHzwwe4I/pQWLVr0x4MOOuiadevWeUwDAAAkhEdAAwDANjj22GPbPvzww7/p2LHjobaxZXV1dfHkk0/GddddF3Pnzo26ujpLAXaJzZs3x2uvvRbPPfdcRET06NEjCgsLLWYLWrduvfv3vve9fd9+++1pCxYsqLYRAABo+rb0CGgFMAAAfITLL7989wsuuOB3zZs372UbH6+xsTGmTJkS119/fbzyyiuKX6DJ2Lx5cyxYsCCmT58excXF0a1bt8hkMhbzMUpKSjp8+ctfPrJt27ZzvBcYAACaPu8ABgCArTB+/Pgjv/CFL/xLQUFBiW18vAULFsT48eNj6dKllgE0eT169IivfOUrMWjQIMvYgsbGxpqJEydecuyxxz5pGwAA0HR5BzAAAHwK7dq1K3ruued+1qNHj6/axsdbtGhR3H///bF48WLLABKnV69ecdxxx0WfPn0sYwuWLl3654MOOujy1atX19sGAAA0Pd4BDAAAn2DYsGHNn3766V936tTpC7bx0TZs2BD33Xdf/PGPf4y1a9daCJBI69evj2nTpsW6deuiZ8+eUVLiYQ8fpbKysv+3v/3t/lOmTJmyfPlyz/cHAIAmxjuAAQBgC372s5/1uP76669t0aKF54J+hJqamhg/fnzcfPPN8fbbb0cul7MUINFyuVy888478cwzz0RVVVX07t07slk/A/lHZWVl3U488cTD6+rqZkyfPv1DGwEAgCZ0va4ABgCAj3bFFVfscdZZZ11dXFzcwTb+Xi6XixkzZsR1110XCxYsiMbGRksBUqWxsTGWLFkSM2bMiPLy8ujSpUtkMhmL+RvZbLbFQQcddHibNm1mP/HEE6ttBAAAmoYtFcDeAQwAQN6aNGnSqAMOOODsTCZTaBt/b9GiRXHPPffEu+++axlA3ujWrVucdNJJ0bt3b8v4B7lcrm7y5Mm//vKXv/yIbQAAwK63pXcAK4ABAMg7paWlBTNnzjyzT58+x9vG39uwYUOMGzcuZsyY4VHPQF7KZDKx3377xde//vWoqKiwkH+waNGiP+27775X1dTUeCwEAADsQgpgAAD4H926dctOnjz5V506dRppG/9fLpeLqVOnxp///OfYuHGjhQB5r6KiIkaNGhX777+/x0L/g+XLlz9+6KGHXvLuu+/W2QYAAOwaWyqAvQMYAIC8MXz48PInnnjiynbt2o2wjf/vnXfeiWuvvTaee+652Lx5s4UARMTmzZtjzpw58dprr0XPnj2jRYsWlvI/Kioq+n7rW98aMnXq1Ofee+89f3AAAMAusKV3ACuAAQDIC9/+9rc73n777X9o0aLFANv4b1VVVXHXXXfFvffeG+vXr7cQgI+wbt26eP7552P9+vWx2267RVFRkaVERElJSefjjjvuoA8++GDKK6+88hcbAQCAnUsBDABAXjv//PP7XXzxxX8oKSnpbBv/bfr06XHttdfGokWLLAPgU3jnnXdi2rRp0bp16+jc2R8nERHZbLbyC1/4whElJSUvTp48eY2NAADAzqMABgAgb/3ud7/b60c/+tFVRUVFrWwjYs2aNXHzzTfHpEmTora21kIAtkJtbW289NJL8c4770Tfvn2jtLQ073dSWFhYNnz48C/26dNn4UMPPbTMpwQAAHYOBTAAAHnp1ltv3f+b3/zmfxYWFjbP913kcrl4/vnn4/rrr4/ly5f7cAB8BitXroxp06ZFRUVFdOvWLTKZTF7vo6CgIDto0KBDBw0atOiBBx54xycEAAB2vC0VwJmex8Z+H/WF+pURa17ym6wAACTTww8//KXDDjvsXzKZTN6/rPGDDz6I22+/Pd544w0fDIDtbMCAAfGtb30r2rRpk/e7yOVyjVOmTPn1yJEjH/LJAACAHavN3jVR1OGjv6YABgAgdV555ZXTPve5z30r3/fQ0NAQjz32WDz++ONRV1fngwGwg2Sz2Tj66KPjC1/4QhQUFOT9Pl5//fU79tprr9/7ZAAAwI6jAAYAIC9ks9nMyy+/fFafPn2Oz/ddvPvuu3HbbbfFe++954MBsJN069YtvvOd70S3bt3yfhdLliy5f5999rmypqam0ScDAAC2PwUwAACpV1paWjBr1qyzevfufVw+7yGXy8WTTz4ZDz74oLt+AXaBbDYbxxxzTBxxxBF5fzfw0qVLHxg6dOjlSmAAANj+FMAAAKRar169mk2ePHlsu3btDsrnPaxcuTJuueWWePvtt30oAHaxnj17ximnnBIdOnTI6z2sXr16yiGHHPIvS5Ys2exTAQAA28+WCuDCyoHR9aO+0FgVUbMia3sAADRpQ4cOLXvqqacub9Omzf75uoNcLhfPPPNMXH/99bF27VofCoAmYP369TFlypQoKSmJnj17RiaTycs9NG/evPtJJ500ZPLkyc+sWLHCoykAAGA7KetcHwXlH/01BTAAAIk1ZMiQ0kceeeSKVq1a7Z2vO6iuro7bb789nnjiiWhs9IRNgKaksbEx5s+fH++//34MGDAgstn8/DlLaWlpp6997WuDn3rqqadXrlxZ75MBAACfnQIYAIDUOfTQQ1s8+OCDv2/ZsuUe+bqDOXPmxNVXX+2RzwBN3PLly+OFF16Ijh075u0joUtLSzudcMIJ+7/00ktPv/3227U+FQAA8NkogAEASJVhw4Y1v++++37TsmXLQfl4/vr6+hg/fnz88Y9/jNpaP0MHSILNmzfHiy++GJs3b47ddtstCgoK8m4HxcXFbY866qg9n3vuuaeXL1/ucdAAAPAZKIABAEiNI488snLcuHG/b9GixcB8PP97770XV111VcyZM8eHASCBFi1aFC+//HL069cvWrRokXfnLykp6XDcccftP2fOnGcWLVq0yScCAAC2jQIYAIBUOPLIIyvvvPPO35aXl++Wj+d/+umn48Ybb4wPP/zQhwEgwf7yl7/ECy+8ECUlJdGrV6+8O3+zZs3aHHXUUfspgQEAYNspgAEASLxjjz227W233faH5s2b98m3s1dVVcXNN98cTz31VDQ2NvowAKRAY2NjzJ8/P5YtWxYDBgyIZs2a5dX5mzVr1uaYY4458M0333xm4cKFNT4RAACwdRTAAAAk2qGHHtritttuuzofy9+33347rrnmmli8eLEPAkAKvf/++/HKK69Enz59orKyMq/Ons1mK4888sh9Zs6c+dTSpUs3+zQAAMCnpwAGACCxjjjiiJb33nvvteXl5f3y6dy5XC4mTZoUN998c1RVVfkgAKRYVVVVTJ06NbLZbPTp0ycymUzenL24uLjtV7/61c+/8sorTy1evLjWpwEAAD4dBTAAAIl06KGHtrj33nt/l2/lb3V1ddx0000xefLkyOVyPggAeSCXy8WCBQvi3Xffjd133z2y2fz5mUyzZs1aH3300fvNmDHjSXcCAwDAp6MABgAgcYYOHVo2fvz4qysqKgbk07mXLVsWV111lUc+A+SplStXxiuvvBKf+9znoqKiIm/O3axZszZHH3300GeeeebJFStW1PkkAADAlimAAQBIlCFDhpQ++uij17Rs2XL3fDr31KlT49prr42NGzf6EADksaqqqpg+fXq0bds2unTpkjfnLikpaT9q1KihTz755JMrV66s90kAAICPt6UCuMB6AABoSjp16pSdMGHCv1dWVu6RL2dubGyMcePGxR133BF1dW56AiCitrY2br755hg/fnw0NjbmzbkrKyv3mDBhwr9369bNXQkAALCNFMAAADQZrVq1Kpw+ffolbdq02T9fzlxdXR2/+93vYtKkSd73C8DfyeVy8fjjj8fvf//7qK6uzptzt2nTZv8pU6Zc0qpVq0KfAgAA2HoKYAAAmoSKioqC2bNnX9KuXbuD8uXMS5cujYsuuijmz5/vAwDAx3r11VfjoosuiqVLl+bNmdu1a3fQ7Nmz/72iosLPrgAAYCu5iAYAoEmYOXPmz9q1a3dIvpz35ZdfjiuuuCLWrVsnfAA+0bp16+KKK66Il19+OW/O3K5du4Nnzpz5M+kDAMDWUQADALDLvfjii2N69OgxKh/Omsvl4oEHHogbbrghamtrhQ/Ap1ZbWxs33HBDPPDAA3nz2oAePXqMevHFF8dIHwAAPj0FMAAAu9SkSZO+NnDgwFPy4ax1dXVx8803x8SJE73vF4BtksvlYuLEiXHLLbdEXV1dXpx54MCBJ0+aNOlr0gcAgE9HAQwAwC7z6KOPHnXggQeekw9nXbduXfz617+OWbNmCR6Az2zmzJnx61//Ol9eJZA58MADz3n00UePkjwAAHyywsqB0fWjvtBYFVGzImtDAADsEDfeeOO+Rx999EWZTKYw7Wddvnx5XHXVVbFy5UrBA7DdbNiwIWbPnh0DBw6MioqKtB8307179/179uz56sMPP7xc+gAA5LuyzvVRUP7RX1MAAwCw011xxRV7fPe7372qoKCgWdrPOmfOnPjtb38bGzduFDwA2111dXVMmzYtOnfuHB07dkz1WTOZTOHuu+9+eJs2bV6aNGnSKukDAJDPFMAAADQZZ5xxRvef/exnvy0sLCxP+1knTJgQd999d9TX1wsegB2moaEhXnrppchms9G3b99UnzWTyRTttddeB/3lL395dubMmRukDwBAvlIAAwDQJBx00EEVf/jDH64pLi7ulOZz5nK5eOCBB+Kxxx4TOgA77c+eBQsWRF1dXfTv3z8ymUxqz1pQUFBywAEHDJs+ffqkpUuXbpY+AAD5aEsFcIH1AACwMwwaNKj0vvvuu7qsrKxXms9ZV1cX1113XUyaNEnoAOx0EydOjOuvvz7q6upSfc6ysrJef/rTn67u379/idQBAODvKYABANjhKioqCh577LGLKyoqBqb5nNXV1XHNNdfE7NmzhQ7ALvPKK6/ElVdeGVVVVak+Z4sWLQZOnDhxbEVFhZ9vAQDA33CBDADADjdz5syftW3b9sA0n3HdunVx2WWXxRtvvCFwAHa5xYsXx2WXXRZr165N9TnbtWt34MyZM38mcQAA+P8UwAAA7FBPPvnkqB49eoxK8xlXrVoVV1xxRSxfvlzgADQZK1asiCuuuCJWrlyZ6nP26NFj1KRJk0ZJHAAA/lth5cDo+lFfaKyKqFmRtSEAALbZjTfeuO+XvvSlCzOZTGp/8fDdd9+NK6+8MtatWydwAJqc6urqmDVrVvTv3z8qKytTe85u3boN79mz57yHH37Yb2MBAJAXyjrXR0H5R39NAQwAwA5x3nnn9T311FOvLigoKE7rGV977bW45pprorq6WuAANFmbN2+OGTNmRI8ePaJ9+/apPGMmkykYNGjQIYWFhVOee+45v5UFAEDqKYABANipjjrqqFb/8R//8YdmzZq1SusZX3755bj++uujrq5O4AA0eQ0NDfHSSy9Fp06dolOnTqk8Y0FBQXbYsGGfnz9//qQ33nhjk9QBAEizLRXA3gEMAMB21a1bt+wNN9zwnyUlJR3TesYpU6bEjTfeGPX19QIHIDHq6+vjxhtvjKlTp6b2jCUlJZ1uuOGG/+jWrZu7GgAAyFsKYAAAtqunn376XyorK/dI6/kmTZoUd955ZzQ2NgobgMRpbGyMO+64I5588snUnrGysnLw008//UtpAwCQrxTAAABsN88///w3unTp8k9pPd/EiRNj3LhxkcvlhA1AYuVyubj//vtTXQJ36dLlS88+++yJ0gYAIB95BzAAANvFTTfdNPzII488L5PJZNJ4vsceeyzGjx8vaABS47XXXotmzZpF3759U3m+zp0779urV695Dz/88DJpAwCQNlt6B7ACGACAz+wXv/hF7x/+8IdXFxQUNEvj+R544IF45JFHBA1A6ixYsCDq6upiwIABqTtbJpPJDBo06ODGxsbnpk6dul7aAACkiQIYAIAd5oADDqj43e9+99tmzZq1TeP5xo0bF5MmTRI0AKm1aNGi2Lx5cwwcODB1ZysoKMjut99+w5577rnH33vvvc3SBgAgLbZUAHsHMAAA2yybzWbuvPPOfyktLe2exvNNmDBB+QtAXpg0aVI89NBDqTxbaWlpj3vuuedfstlsRtIAAOQDBTAAANvs+eef/06HDh0OTePZHn744Xj44YeFDEDeeOSRR+LPf/5zKs/WoUOHw5599tlvSxkAgHygAAYAYJvcd999hw8ePPjUNJ7t/vvvjwkTJggZgLzz2GOPxX333ZfKs+25554/+NOf/nSYlAEASDvvAAYAYKudccYZ3ceMGXN5QUFBcdrONnHixHjkkUeEDEDeWrx4cWSz2ejbt2/ajpbp06fPvn/5y18mz5w5c4OkAQBIsi29A1gBDADAVhk2bFjzG2+88Q/NmjVrl7azPfroo6l99CUAbI2FCxdGUVFR9OvXL1XnKigoKD7wwAP3e/LJJx9dsWJFnaQBAEiqLRXAHgENAMBWuffee39ZWlraPW3nevzxx+PBBx8UMAD8jz//+c8xceLE1J2rtLS0x3333fdLCQMAkFYKYAAAPrVJkyaN6tSp0xEpPFeMHz9ewADwD8aPHx+TJ09O3bk6der0hUmTJn1VwgAApJFHQAMA8Kmcd955fU888cR/z2QyRWk618yZM+Puu+8WMAB8jNdeey06duwYnTt3TtW5unbtuk9BQcHzzz333DopAwCQNN4BDADAZ3LEEUe0vOKKK67NZrOVaTrXyy+/HDfffHPkcjkhA8DHyOVyMXv27OjSpUt06tQpNefKZDJF++yzz/CpU6c+9u67726WNAAASeIdwAAAbLNsNpu55ZZb/q2kpKRjms61YMGCuPnmm6OxsVHIAPAJGhsb4+abb44333wzVecqLS3tcvfdd5+fzWYzUgYAIC0UwAAAbNGkSZO+3rZt2wPTdKZly5bFDTfcEPX19QIGgE+prq4urr322li+fHmqztWuXbsDH3/88VESBgAgLTwCGgCAj3XZZZcN+upXvzo2k8mk5hcH33///bjyyiujqqpKwACwlerq6uLll1+OIUOGRHl5eWrO1aVLl31LS0unPvPMM2ukDABAEngENAAAW61///4lJ5988q8ymUxRWs60YcOG+P3vfx8bN24UMABso40bN8bvfve7VP15WlBQkP3hD394ft++fYslDABA4q9vrQAAgI/y4IMPnl1WVtYrLeeprq6O3/zmN7Fq1SrhAsBntGrVqrjyyiujuro6NWcqKyvr8/DDD58lXQAAkk4BDADA/zF+/Pgju3XrdnRazlNfX5/KdxYCwK60fPnyuO6666K+vj41Z+rRo8dXx40bd4R0AQBIMgUwAAB/53vf+16nI4444py0nCeXy8Vtt90Wb7zxhnABYDt7/fXX47bbbotcLpeaMx155JHnfvvb3+4oXQAAkkoBDADA/6qoqCi4+OKLLywsLCxPy5nGjx8fs2bNEi4A7CCzZs2Khx56KDXnKSwsrPj1r399QUVFhZ+bAQCQSC5kAQD4XxMnThxdWVk5OC3nef7552PixImCBYAd7LHHHosXXnghNeeprKzc89FHHz1RsgAAJFFh5cDo+lFfaKyKqFmRtSEAgDxxwQUX7DZq1KgLM5lMYRrO8+qrr8Ytt9ySqkdSAkBT/7O3d+/e0a5du1Scp2PHjkNzudxzU6ZMWSddAACamrLO9VHwMc/wcwcwAADRt2/f4h//+McXZzKZVPwG4HvvvRc33HBDNDY2ChcAdpKGhoa47rrrYtmyZak4T0FBQfbss88e27dv32LpAgCQqGtZKwAAYPz48T8qKyvrkYazbNiwIX7/+99HbW2tYAFgJ9u0aVP8/ve/j40bN6biPGVlZb3GjRs3RrIAACSJAhgAIM/ddNNNw/v06XN8Gs5SX18f1157baxdu1awALCLrFmzJq699tqor69PxXn69ev3jd///vdDJQsAQFIogAEA8thBBx1Uceyxx/5rRGTScJ477rgjFi9eLFgA2MUWLVoUd955Z1qOU/CNb3zj34YNG9ZcsgAAJOIC1goAAPLXzTfffFZxcXG7NJxl4sSJMX36dKECQBMxbdq0mDRpUirOUlJS0unOO+88Q6oAACSBAhgAIE/913/914FdunT5UhrO8tprr8Wf//xnoQJAEzN+/PhYsGBBKs7SrVu3o2+66abhUgUAoKlTAAMA5KEvfelLlV/5yld+lYazrFixIq6//vpobGwULAA0MY2NjXHdddfFihUr0nCczHHHHfergw46qEKyAAA0ZQpgAIA8dPXVV5+ezWYrk36OmpqauPbaa2PTpk1CBYAmatOmTXHttddGTU1N4s+SzWbb3njjjT+RKgAATZkCGAAgz9x6663Du3Tp8uWknyOXy8Utt9wSK1euFCoANHErV66MW2+9NXK5XOLP4lHQAAA0dQpgAIA8MnTo0LKvfvWrv0jDWSZMmBBz584VKgAkxJw5c+Kxxx5LxVlGjRr1i6FDh5ZJFQCApkgBDACQR+64444fFRcXd0z6OV5++eV45JFHBAoACfPQQw+l4he4SkpKOt5xxx0/lCgAAE2RAhgAIE9cfvnlu/fs2XNU0s/xwQcfxB133JGKR0gCQL7J5XJx2223xZo1axJ/lp49ex57+eWX7y5VAACaGgUwAEAe6NatW/a73/3uv2YymURf/9XX18cNN9wQ1dXVQgWAhKqqqoobb7wx6uvrE32OTCZT8N3vfvdX3bp1y0oVAICmRAEMAJAHxo8ff0pZWVmvpJ/jnnvuiaVLlwoUABJuyZIlcd999yX+HGVlZT3Hjx9/ikQBAGhKFMAAACn385//vOeAAQNGJ/0c06dPjylTpggUAFJi8uTJMWPGjMSfY8CAAaN//vOf95QoAABNhQIYACDFstls5qyzzjo3k8kk+tGEK1asiLvvvlugAJAyd911V6xYsSLRZ8hkMtmzzjrr3Gw2m5EoAABNgQIYACDFxo0b98XKysq9knyG2trauOGGG6K2tlagAJAyf/1zfvPmzYk+R2Vl5V7jxo0bKVEAAJoCBTAAQEoNHz68/OCDDz4t6ee4//77Y/ny5QIFgJRavnx5jBs3LvHnGDFixI+HDRvWXKIAAOxqCmAAgJS69dZbT8tms22TfIYZM2bEc889J0wASLnJkyfHzJkzE32G4uLitrfffvtp0gQAYFdTAAMApNBVV121R48ePb6S5DOsXLky7rrrLmECQJ64++6744MPPkj0GXr27PnVK664Yg9pAgCwKymAAQBSprS0tOAb3/jGT5N8rdfY2Bi333679/4CQB6pqamJ2267LRobG5N8jIJvfvObZ5aWlvqZGwAAu+6i1AoAANJlwoQJX6uoqBiQ5DOMHz8+Fi1aJEwAyDNvvvlmPPjgg4k+Q4sWLQY9+OCDx0gTAIBdRQEMAJAiRx55ZOWwYcN+kOQzzJ07N5544glhAkCemjhxYixYsCDRZxg+fPiPjjjiiJbSBABgV1AAAwCkyBVXXHFyUVFRRVLnr6qqijvvvDNyuZwwASBP5XK5uP3226O6ujqxZygqKmrxm9/85mRpAgCwKyiAAQBS4vzzz+/Xu3fv45J8httvvz0+/PBDYQJAnlu3bl3cfvvtiT5D7969jz///PP7SRMAgJ1NAQwAkALZbDZz6qmn/jyTyST2+m769OkxZ84cYQIAERExe/bsmDFjRmLnz2QyBaeeeurPs9lsRpoAAOxMCmAAgBT44x//eERlZeXgpM6/du3auPfeewUJAPyde+65J9atW5fY+SsrKwf/6U9/+oIkAQDYmRTAAAAJ17dv3+JDDjnkR0k+w9133x01NTXCBAD+Tk1NTdx9992JPsPBBx/8o759+xZLEwCAnUUBDACQcHfdddc3S0pKOiV1/smTJ8e8efMECQB8pLlz58azzz6b2PlLSko63nPPPd+SJAAAO4sCGAAgwb70pS9VDhw48KSkzr9mzZoYP368IAGALXrggQdizZo1iZ2/f//+Jx111FGtJAkAwM6gAAYASLArrrji1MLCwvIkzp7L5eK2226LTZs2CRIA2KJNmzbFbbfdFrlcLpHzFxYWll1++eU/kCQAADuDAhgAIKF+8Ytf9O7evftXkjr/s88+G2+88YYgAYBP5Y033ojnn38+sfN369bt6F/96ld9JAkAwI6mAAYASKgf/vCHP8pkMom8nvvggw/igQceECIAsFXGjRsX69atS+TsmUym4NRTT/2xFAEA2NEUwAAACXTdddcNa9eu3YFJnD2Xy8Udd9wRtbW1ggQAtsqmTZvizjvvTOz8bdq02f+mm27aT5IAAOxICmAAgIQpLS0t+NrXvnZ6Uud/4YUXYuHChYIEALbJq6++GjNmzEjs/Mccc8zpFRUVfiYHAMAO42ITACBhbr/99oMrKip2S+LsGzZsiHHjxgkRAPhM7r///qiqqkrk7OXl5X3/67/+6wgpAgCwoyiAAQASpKKiouCwww47Nanz33vvvYn9YS0A0HRs2LAh7r///sTOf9BBB/1zq1atCiUJAMCOoAAGAEiQ+++//+iysrKeSZx9zpw58dJLLwkRANguXnjhhViwYEEiZy8tLe32xz/+8StSBABgR1AAAwAkRN++fYv33Xfff07i7LW1tXHvvfcKEQDYru6+++6oq6tL5Oz77bffKf379y+RIgAA25sCGAAgIW6++eZRxcXFbZM4+yOPPBJr164VIgCwXa1atSoee+yxRM6ezWbb3njjjV+TIgAA25sCGAAgAYYOHVq21157fSeJs7/33nvxxBNPCBEA2CEmTpwYK1asSOTsQ4YM+c7QoUPLpAgAwPakAAYASIBrr732xKKiosqkzZ3L5eKee+6JxsZGIQIAO0R9fX3cddddkcvlEjd7UVFR5bXXXnuCFAEA2J4UwAAATdwBBxxQMWDAgG8kcfYZM2bEW2+9JUQAYId6880348UXX0zk7AMGDPjG8OHDy6UIAMD2ogAGAGjirrrqqhOKiooqkjb3pk2b4oEHHhAgALBT3H///VFbW5u4uYuKilpcffXV7gIGAGC7UQADADRhBx10UEX//v0Teffvww8/HB9++KEQAYCdYv369TFhwoREzj5w4MBvHHDAARVSBABge1AAAwA0Yf/5n/95bGFhYfOkzb1q1aqYPHmyAAGAnerpp5+O1atXJ27uwsLC8ssuu2yUBAEA2B4UwAAATdQBBxxQMWjQoNFJnP3uu++O+vp6IQIAO1V9fX3cddddiZx99913/+bQoUPLpAgAwGelAAYAaKIuv/zyYwsLC8uTNvfcuXNjwYIFAgQAdokFCxbE3LlzEzd3UVFRi9/97ndflyAAAJ+VAhgAoAkaOnRo2aBBgxL37t+6urr405/+JEAAYJf605/+FHV1dYmbe/fdd//mkCFDSiUIAMBnoQAGAGiCfvOb33ylqKioZdLmfu655xL53j0AIF1Wr14dzz33XOLmLioqann11VcfLUEAAD4LBTAAQBPTq1evZoMHD/5m0uaurq6ORx55RIAAQJPwyCOPRHV1deLmHjJkyLe6deuWlSAAANtKAQwA0MTcdNNNxxQXF7dN2twTJkyIqqoqAQIATUJVVVUifzmtuLi43a233uouYAAAtpkCGACgCWnVqlXhXnvtdVLS5l61alU8++yzAgQAmpTJkyfHqlWrEjf30KFDR7dq1apQggAAbAsFMABAE3LLLbccXlJS0jlpcz/44INRX18vQACgSamvr48HH3wwcXOXlJR0vummmw6VIAAA20IBDADQRGSz2cwBBxzw7aTNvWjRonjppZcECAA0SS+99FIsXrw4cXOPGDHiO9lsNiNBAAC2lgIYAKCJuOaaa/YuLy/vm7S5H3roocjlcgIEAJqkXC6XyLuAy8vL+1111VV7SRAAgK2lAAYAaCK+8pWvfDdpM8+bNy8WLlwoPACgSVu4cGG8+uqrrg8BAMgLCmAAgCbgsssuG1RZWblPkmbO5XIxfvx44QEAifDAAw8k7qklrVu33veSSy7pLz0AALaGAhgAoAkYNWrUCUmbefbs2bFs2TLhAQCJsGzZsnjllVcSN/cJJ5xwovQAANgaCmAAgF3sn//5nzt37NjxiCTN3NjYGA888IDwAIBEGT9+fDQ0NCRq5k6dOn1h9OjRHaQHAMCnpQAGANjFfvSjH30tk8kk6rps2rRpsWrVKuEBAImyatWqeOGFFxI1cyaTKfzpT386SnoAAHxaCmAAgF1o0KBBpX369Plqkmaur6+PCRMmCA8ASKQJEyZEXV1dombu27fvV/r27VssPQAAPg0FMADALnTZZZcdXlRUVJGkmadOnRpr164VHgCQSOvXr48pU6YkauaioqLK3/zmN0dIDwCAT0MBDACwi2Sz2cy+++57UpJmrqurc/cvAJB4jz76aOLuAt5///1PymazGekBAPBJFMAAALvI1VdfPbSsrKx3kmaeMmVKbNiwQXgAQKJt2LAhnn/++UTNXFZW1ueqq67aS3oAAHwSBTAAwC7y5S9/+bgkzVtfXx8TJ04UHACQCo8//nji7gL+0pe+dLzkAAD4JApgAIBdYPTo0R3atm07IkkzT5s2LdatWyc8ACAVPvzww5g+fXqiZm7fvv2I0aNHd5AeAABbogAGANgFfvrTn47KZDKFSZm3vr4+HnnkEcEBAKnyyCOPRH19fWLmzWQyhT/96U+/JjkAALZEAQwAsJN16tQp26dPn6OTNLO7fwGANFq3bl1MmzYtUTP36dPnmE6dOmWlBwDAx1EAAwDsZFddddUB2Wy2dVLmbWxsjEmTJgmOVOvYsWN06OCJmgD5aNKkSdHY2JiYebPZbOurrrrqAMkBAPBxFMAAADvZiBEjvp6keV988cVYtWqV4Ei1Ll26xIUXXhinnXZadO3a1UIA8siqVavipZdecj0JAEBqKIABAHaiM844o3tlZeXeSZk3l8vFxIkTBUdeyGQyMXjw4PjVr34VY8aMcUcwQB55/PHHI5fLJWbeysrKvc8444zukgMA4KMogAEAdqJTTjnlqxGRScq8CxYsiPfee09w5JVMJhN77713XHjhhTFmzJho3769pQCk3HvvvRcLFy5M1B9X/3NdCQAA/4cCGABgJ+nVq1ezXr16fTlJM3v3L/nsr0XwBRdcECeffHK0bdvWUgBSLGnXPb169fpyr169mkkOAIB/pAAGANhJrrjiioOLiopaJmXeBN4JAztEYWFhDB8+PC688MIYPXp0VFZWWgpACi1YsCCWLVuWmHmLiopaXnnllYdIDgCAf6QABgDYSYYPH/6VJM2btHfhwY5WVFQUI0aMiEsuuSRGjx4dLVu2tBSAFMnlcvH4448naub99tvvK5IDAOAfKYABAHaC0aNHd6isrByalHnXrl0bL7/8suDgI/y1CL744ovjhBNOiBYtWlgKQEq89NJLsW7dusTMW1lZudfo0aM7SA4AgL+lAAYA2AlOP/30o5J07fXMM89EQ0OD4GALiouL47DDDouxY8fGqFGjoqyszFIAEq6hoSGeeeaZJI1c8D/XmQAA8P8vEq0AAGDHymazmX79+n05KfPW1tbGlClTBAefUnFxcYwcOTIuvfTSGDVqVJSWlloKQII9//zzUVtbm5h5+/Xr9+VsNpuRHAAAf6UABgDYwX7zm9/sWVJS0jkp886YMSOqq6sFB1uppKQkRo4cGZdcckkcffTRUVJSYikACVRdXR0zZ85M0p8/na+44orBkgMA4K8UwAAAO9gXvvCFLyVl1lwuF08//bTQ4DNo3rx5HHXUUXHJJZfEyJEjI5vNWgpAwjz11FORy+USM++RRx75ZakBAPBXCmAAgB1oyJAhpZ07dz4iKfO+/vrrsWLFCsHBdlBeXh6jRo2KSy+9VBEMkDArVqyI119/PTHzdunS5fD+/ft79AQAABGhAAYA2KHGjh17aGFhYWJeCOruX9j+KioqYtSoUXHxxRfH4YcfHkVFRZYC4LpouyosLGz+H//xHwdLDQCACAUwAMAOteeeex6ZlFnXrl0b8+bNExrsIK1atYrjjz8+LrroohgxYkQUFPh2DKApmzdvXqxZsyYx8+61115HSg0AgAgFMADADnPMMce0bt269b5Jmfe5556LxsZGwcEO1qZNmxg9enRcfPHFimCAJqyxsTGee+65JP35MvyYY45pLTkAAPykAQBgBznzzDMPz2Qyibjeqq+vj6lTpwoNdqK2bdvG6NGj47zzzovhw4crggGaoBdeeCHq6+sTMWsmkyk844wzDpUaAAB+wgAAsIP079//C0mZdc6cObFhwwahwS7QqVOnOPnkk+Pf/u3fYu+9945MJmMpAE3Ehg0bYvbs2YmZd8CAAR4DDQCAAhgAYEf43ve+16mysnKPpMybpMcbQlp17tw5xowZE7/61a8UwQBNyPPPP5+YWSsrKwd/73vf6yQ1AID8pgAGANgBTj755CMiIhHtzcqVK+P1118XGjQRXbt2jTFjxsQ555wTgwcPthCAXez111+PlStXJmXczMknn3y41AAA8psCGABgB+jXr19iHv88ZcqUyOVyQoMmpnfv3nHaaafFOeecE/3797cQgF0kl8vFlClTknQd6jHQAAB5TgEMALCdnX766d0qKip2S8Ks9fX1MW3aNKFBE9anT58466yz4pxzzonddtvNQgB2gWnTpkV9fX0iZq2oqNjt9NNP7yY1AID8pQAGANjORo8efURSZp03b15s3LhRaJAAffr0ibPPPjvOPPPM6Nmzp4UA7EQbN26MefPmuR4FACARFMAAANtZr169EvPetSQ9zhD4bwMGDIhf/vKXceaZZ0b37t0tBGAnmTp1apKuRw+TGABA/lIAAwBsR2eccUb38vLyvkmYdf369fHaa68JDRJqwIAB8S//8i9x2mmnRbdunvQJsKPNnz8/Pvzww0TMWl5e3u9HP/pRF6kBAOQnBTAAwHZ03HHHHZSUWWfMmBGNjY1CgwTLZDIxePDg+Nd//dcYM2ZMdOjQwVIAdpDGxsaYMWNGYub9xje+cYjUAADykwIYAGA76tOnz8FJmDOXyyXqMYbAlmUymdh7773jwgsvjDFjxkT79u0tBWAHeOGFF5J0XXqIxAAA8pMCGABgOznppJPat2zZcvckzLpkyZJYuXKl0CBl/loEX3DBBXHyySdH27ZtLQVgO1qxYkW8/fbbiZi1srJy0PHHH+8PAgCAPKQABgDYTr773e8eGBGZJMyapMcXAluvsLAwhg8fHhdeeGGMHj06KisrLQVgO5k+fXpSRi34/ve/f6DEAADyjwIYAGA72X333Q9Nwpz19fUxc+ZMgUEeKCoqihEjRsQll1wSo0ePjpYtW1oKwGc0c+bMqK+vT8SsAwcOPFRiAAD5RwEMALAdHHTQQRUtW7bcKwmzLly4MKqrq4UGeeSvRfDFF18cJ5xwQrRo0cJSALZRVVVVvP7664mYtVWrVkOHDx9eLjUAgPyiAAYA2A7OPvvsz2cymaIkzOrxz5C/iouL47DDDouxY8fGqFGjoqyszFIAtkFSnqaSyWSy55577uclBgCQXxTAAADbwe67735AEuasra2NOXPmCAzyXHFxcYwcOTIuvfRSRTDANpg9e3bU1dUlYtY99tjjAIkBAOQXBTAAwGfUqlWrwnbt2u2fhFnnzZsXtbW1QgMiIqKkpCRGjhwZY8eOjaOPPjpKSkosBeBT2LRpU8ybNy8Rs7Zv337/iooKPwMEAMgjLv4AAD6jCy+8cPeioqKKJMz64osvCgz4P5o3bx5HHXVUXHLJJTFy5MjIZrOWAvAJZs2alYg5i4qKWlx88cWDJAYAkD8UwAAAn9GBBx6YiMfqVVdXJ+ZOFWDXKC8vj1GjRsWll16qCAb4BPPmzYuamppEzHrQQQd5DDQAQB5RAAMAfEZdu3YdnoQ5582bF/X19QIDPlFFRUWMGjUqLr744jj88MOjqKjIUgD+QV1dXbz66quJmLVLly77SwwAIH8ogAEAPoNTTjmlY3l5+W5JmPXll18WGLBVWrVqFccff3xcdNFFMWLEiCgo8C0kwN966aWXEjFnRUXFbieddFJ7iQEA5AffvQMAfAYnnnji55MwZ21tbcyfP19gwDZp06ZNjB49OsaOHasIBvgb8+fPj9ra2iSMmvnud7/7eYkBAOQH37UDAHwGn/vc5/ZLwpwLFy6Muro6gQGfyV+L4PPOOy+GDx+uCAby3ubNm2PhwoWJmLVfv37DJQYAkB98tw4AsI1atWpV2Lp1672TMKvHPwPbU6dOneLkk0+Oc889NwYNGmQhQF6bPXt2IuZs06bN3hUVFX4WCACQB1z0AQBso/PPP39gYWFheVOfs76+PubMmSMwYLvr2bNn/OQnP4nzzjsv9t5778hkMpYC5J3Zs2dHfX19k5+zqKio4vzzzx8oMQCA9FMAAwBso/3333/fJMz5+uuvR01NjcCAHaZLly4xZsyYOOecc2Lw4MEWAuSV6urqeOONNxIx64EHHriPxAAA0k8BDACwjbp27ZqIxz/PnTtXWMBO0bt37zjttNPinHPOif79+1sIkDeScr3VvXv3vaUFAJB+CmAAgG0wZMiQ0srKyj2a+py5XM7jn4Gdrk+fPnHWWWfFOeecE7vttpuFAKk3e/bsyOVyTX7Oli1b7jlo0KBSiQEApJsCGABgG5x55pl7ZjKZbFOfc9myZbFu3TqBAbtEnz594uyzz44zzzwzevbsaSFAaq1bty6WL1/e5OfMZDLZs846a4jEAADSrcgKAAC23tChQ4clYc558+YJC9jlBgwYEAMGDIgFCxbE+PHjY+nSpZYCpM68efOiS5cuTX7OffbZZ5+ImC4xAID0cgcwAMA26Nix4z5JmHP+/PnCApqMAQMGxC9/+cs47bTTolu3bhYCpEpSrrs6deq0j7QAANJNAQwAsJWOOOKIlhUVFf2a+pxVVVWxaNEigQFNSiaTicGDB8e//uu/xpgxY6JDhw6WAqTCW2+9FVVVVU1+zoqKis8deuihLSQGAJBeCmAAgK108sknD46ITFOfc/78+dHY2CgwoEnKZDKx9957x4UXXhhjxoyJ9u3bWwqQaI2NjbFgwYJE/Cv4u9/97h4SAwBILwUwAMBW2n333fdMwpze/wskwV+L4AsuuCBOPvnkaNu2raUAiZWU66/BgwfvKS0AgPQqsgIAgK3Trl27wU19xlwul5Q7UAAiIqKwsDCGDx8e++yzT0ybNi0mTJgQ69evtxggURYsWBC5XC4ymab9sJgOHToMlhYAQHq5AxgAYCsMGjSotGXLlgOa+pzvvfdebNy4UWBA4hQVFcWIESPikksuidGjR0fLli0tBUiMDz/8MJYtW9bk52zZsuXA/v37l0gMACCdFMAAAFvhxz/+8aBMJtPkn6Li7l8g6f5aBI8dOzZOOOGEaNGihaUAibBw4cImP2Mmk8n+5Cc/GSAtAIB0UgADAGyFvffee88kzJmEHzwCfBrNmjWLww47LMaOHRujRo2KsrIySwGatKT8Il5SrmsBANh63gEMALAVunbtOqSpz1hfXx9vvvmmsIBUKS4ujpEjR8bBBx8czz77bDz++ONRXV1tMUCT8+abb0Z9fX0UFTXtH7t16dJlT2kBAKSTO4ABAD6lioqKgoqKikFNfc4lS5bE5s2bBQakUklJSYwcOTLGjh0bRx99dJSUeIUl0LTU1tbG0qVLm/ycLVu2HFRaWupngwAAKeQiDwDgUzr77LP7FhYWNvlnj7722mvCAlKvefPmcdRRR8Ull1wSI0eOjGbNmlkK4HpsKxQWFpafffbZvaQFAJA+CmAAgE9p//3375+EOV9//XVhAXmjvLw8Ro0aFf/+7/8eI0eOjGw2aymA67FP6fOf//xAaQEApI8CGADgU+rRo8fuTX3G2traePvtt4UF5J2KiooYNWpUXHzxxXH44Yc3+XdvAum2ePHiRLySo1evXoOkBQCQPgpgAIBPqXXr1k3+DoklS5ZEQ0ODsIC81apVqzj++OPj4osvjhEjRkRBgW97gZ2voaEhlixZ0uTnbNOmjQIYACCFfCcMAPApDBkypLR58+a9m/qcb775prAAIqJ169YxevToGDt2rCIYcF32MZo3b95n0KBBpdICAEgX3wEDAHwKp556av9MJtPkr53eeustYQH8jTZt2sTo0aPjvPPOi+HDhyuCAddlfyOTyRT84Ac/+Jy0AADSxXe+AACfwuDBg5v84/Hq6+tj0aJFwgL4CJ06dYqTTz45/u3f/i323nvvyGQylgLsUIsXL07Eqzn23HPPgdICAEgXBTAAwKfQpUuXAU19xnfeeSfq6uqEBbAFnTt3jjFjxiiCgR2utrY23n333SRc53oPMABAyiiAAQA+hZYtW/Zv6jN6/DPAp9elS5cYM2ZMnHvuuTF48GALAfL2+iwJ17kAAGwdBTAAwCcYPnx4eUlJSeemPqfHPwNsvV69esVpp50W55xzTvTvrwMB8u/6rLS0tPPw4cPLpQUAkB4KYACAT/Ctb31rt4ho8s8IXbx4sbAAtlGfPn3irLPOinPOOSd22203CwG2i4T8gl7m29/+dj9pAQCkhwIYAOAT7L777k2+CVi7dm1s2LBBWACfUZ8+feLss8+OM888M3r27GkhwGfy4Ycfxrp165r8nAMHDlQAAwCkSJEVAABsWadOnZr8D8TefvttQQFsRwMGDIgBAwbEggULYvz48bF06VJLAbb5Oq1Vq1audwEA2GkUwAAAn6CyslIBDJCnBgwYEP3794958+bFQw89FO+++66lAFtlyZIlsddeezX1613PvgcASBEFMADAFnTq1CnbvHnzXk19ziVLlggLYAfJZDIxePDg2GOPPeLll1+OBx98MFauXGkxQGqu05o3b967Xbt2RatXr66XGABA8nkHMADAFowZM6ZnJpPJNuUZGxsbPZoUYCfIZDKx9957x4UXXhhjxoyJ9u3bWwrwiZYuXRqNjY1NesaCgoLsqaee2kNaAADp4A5gAIAt2Hvvvfs29RlXrlwZtbW1wgLYSf5aBO+5554xa9asmDBhQqxevdpigI9UW1sb77//fnTu3LlJzzls2LC+EbFIYgAAyecOYACALejRo0eTL4DfeecdQQHsAoWFhTF8+PC48MILY/To0VFZWWkpQGKv15Jw3QsAwKejAAYA2ILWrVs3+ff/vvvuu4IC2IUKCwtjxIgRcckll8To0aOjZcuWlgIk7notCde9AAB8Oh4BDQCwBc2bN+/Z1GdUAAM0kW+wi4pixIgRsd9++8WUKVPiscceiw0bNlgMEO+9914SrnsVwAAAKeEOYACAj9G/f/+SkpKSjk19TgUwQNPSrFmzOOyww2Ls2LExatSoKCsrsxTIc0m4XistLe3Ut2/fYmkBACSfAhgA4GOccMIJ3Zr69dK6deuiqqpKWABNUHFxcYwcOTJ+/etfK4Ihz1VVVcX69eub+pgF3/zmN7tLCwAg+RTAAAAfY8iQIT2b+oxJeJwgQL77axE8duzYOProo6OkpMRSIA8l4botCde/AAB8MgUwAMDH6N69e8+mPqPHPwMkR/PmzeOoo46KSy65JEaOHBnNmjWzFMgjSbhuS8L1LwAAn0wBDADwMVq1atWjqc+4bNkyQQEkTHl5eYwaNSr+/d//PUaOHBnZbNZSIA8k4botCde/AAB8MgUwAMDHqKio6NXUZ1y+fLmgAJL750yMGjUqLr744jj88MOjqKjIUiDFknDd1rJly16SAgBIPgUwAMBHyGazmbKysq5NecbGxsZYtWqVsAASrlWrVnH88cfHxRdfHCNGjIiCAt+qQxqtWrUqGhsbm/SMJSUlXbPZbEZaAADJ5rtKAICPcNxxx7UrKCgobsozrl69Ourr64UFkBKtW7eO0aNHx9ixYxXBkEJ1dXXxwQcfNOkZCwoKio877rh20gIASDbfTQIAfITPf/7zXZr6jO+//76gAFKoTZs2MXr06Dj//PNj+PDhimBIkRUrVrgOBgBgh/NdJP+PvTuPr7I888d/nSwEkhD2HUQEUVRAoIiouCtq64Jabd1arVorbqO2tlXbaavTOu38Rqffdmpbu9rWpYogsqgFRXCttAIKArJDgAAJBLKQ5JzfH8WO4+DOcp6T9/v18jWvTv657ut6hNvnk/t+AICd2G+//bL+xVcSXiAC8PF17do1Lr300rj99ttj2LBhkUq5lRWSLgn7tyTsgwEAeH8FWgAA8H917txZAAxAVujevXtceeWVsXr16njiiSdi9uzZkclkNAYSKAn7tyTsgwEAeH8CYACAnWjXrp0roAHIKj169Igrr7wyli5dGpMmTYo5c+ZoCiRMEvZvSdgHAwDw/gTAAAA7UVxc3D3baxQAAzRPffr0ibFjx8aSJUti/PjxsWDBAk2BhEjC/i0J+2AAAN6fbwADAOxESUlJz2yur7q6Ourq6gwKoBnbb7/94l/+5V/ia1/7WhxwwAEaAglQV1cX1dXV9sEAAOxWAmAAgHc5/PDDSwsKCtpmc40VFRUGBUBERPTt2zduvPHGuOGGG2LffffVEMhy2b6PKygoaDt8+PASkwIASC4BMADAu5x44oldsr3GDRs2GBQA/8uAAQPiG9/4Rtxwww3Ru3dvDQH7uE+yH+5qUgAAyeUbwAAA79KvX7+sD4DXr19vUADs1IABA+LAAw+MuXPnxoQJE2LlypWaAlkkCTe5HHDAAV0i4i3TAgBIJgEwAMC7dO/evXO21+gEMADvJ5VKxaBBg2LgwIExe/bsGD9+fKxbt05jwD4uZ/bDAAC8NwEwAMC7tG/fvlO21ygABuDDSKVSMWzYsBg6dGjMnj07HnvsMbdIwF6WhBPASdgPAwDw3gTAAADv0rp166w/8ZCEF4cAZI+3g+BDDz00XnnllZg4caK/S8A+LtH7YQAA3psAGADgXUpKSrL6xENjY2Ns3rzZoAD4yPLz8+Pwww+P4cOHx/PPPx8TJ06MqqoqjYE9aPPmzdHY2BgFBdn7Wi7b98MAALw/ATAAwLu0bNmySzbXV1lZGZlMxqAA+Njy8/Nj1KhRMXLkyHjhhRcEwbAHZTKZqKqqio4dO9oPAwCwWwiAAQDepaioKKuvvKusrDQkAHaJgoKCGDVqVIwYMSJmzpwZkydPji1btmgM7IH9XDYHwNm+HwYA4P3laQEAwP8YPnx4SX5+fkk21ygABmBXa9GiRRx//PFxxx13xNlnnx0lJSWaAs14P5efn18yfPhwfxAAACSUABgA4B2OOOKIDtleo+//ArC7FBUVxejRo+P73/9+nH322VFcXKwpsBsk4cr1JOyLAQDYOQEwAMA79O3bt1221+gEMAC729tB8B133BGnn356tGrVSlOgme3n9ttvv7YmBQCQTAJgAIB36NSpkwAYAHYoKSmJz3zmM3HnnXfG6NGjo0WLFpoCzWQ/l4R9MQAAOycABgB4hw4dOrTN9hqTcGUgALmlpKQkzj777PjOd74To0aNivz8fE2BHN/PJWFfDADAzgmAAQDeoaysrG221ygABmBvad++fVx00UVx5513xgknnBCFhYWaAjm6nysrK3MCGAAgoQTAAADvUFJS0j6b68tkMlFdXW1QAOxV7dq1i/POOy+++93vxqhRoyIvz+sF+CiSsJ8rLS0VAAMAJJT/QgMAeIfi4uK22VxfXV1dNDY2GhQAWeHtE8F33HGHIBg+gsbGxqirq7MvBgBgt/BfZgAA79CqVausPung9C8A2ahDhw5x0UUXxbe//e04/PDDBcGQA/u6oqIiJ4ABABLKf5EBALxDQUGBABgAPqauXbvGpZdeGt/61rdi2LBhkUqlNAUSuq9r0aJFW1MCAEimAi0AAPgfhYWFZdlc39atWw0JgKzXrVu3uPLKK2P16tXxxBNPxOzZsyOTyWgMJGhfl+37YgAA3psAGADgnZujgoLW2VyfE8AAJEmPHj3iyiuvjKVLl8akSZNizpw5mgIJ2ddl+74YAID35gpoAIAdWrdunZefn98ym2sUAAOQRH369ImxY8fGLbfcEgMGDNAQSMC+Lj8/v1WrVq28OwQASCCbOACAHQYNGlQSEVn9scJt27YZFACJtd9++8UNN9wQX/va1+KAAw7QEJq1BOzr8gYPHlxsUgAAySMABgDY4YADDijJ9hpramoMCoDE69u3b9x4441xww03xL777qshNEu1tbVZX2P//v1LTQoAIHl8AxgAYIeePXtm/QuuJLwoBIAPa8CAATFgwICYP39+jBs3LpYvX64pNBtJ2Nf16NGjxKQAAJJHAAwAsEOnTp0EwACwFwwYMCAOPPDAmDt3bkyYMCFWrlypKeS8JOzrunbtKgAGAEggATAAwA5lZWVZ/4Krrq7OoADISalUKgYNGhQDBw6M2bNnx4QJE2Lt2rUaQ85KQgDcpk0bV0ADACSQABgAYIeysjIngAFgL0ulUjFs2LAYOnRozJ49O8aPHx/r1q3TGHKOABgAgN1FAAwAsENJSUlxttfoBDAAzcXbQfCQIUPi5ZdfjokTJ0ZFRYXGkDOSEAAnYX8MAMD/JQAGANihqKioKNtrrKmpMSgAmpW8vLw4/PDDY/jw4fH888/HE088EZWVlRpD4iUhAG7RokWRSQEAJI8AGABgh8LCwhbZXF86nY7t27cbFADNUn5+fowaNSpGjhwZL7zwQkycODGqqqo0hsTavn17ZDKZSKVSWVtjixYtWpgUAEDyCIABAHbI9gC4oaHBkABo9goKCmLUqFExYsSImDlzZkyePDm2bNmiMSROJpOJhoaGyOaMtbCw0AlgAIAk/neTFgAA7NgYFRRk9QuuxsZGQwKAHVq0aBHHH398HHnkkfHMM8/E1KlTY9u2bRpDomR7AJzt+2MAAN5jH6cFAAA7NkZZ/oLL9c8A8H8VFRXF6NGj49hjj41nnnkmpkyZEjU1NRpDImT7DS8FBQWugAYASCABMADA2xujLH/B5QpoAHhvbwfBRx11VEyfPj2efvrpqK2t1RiymgAYAIDdIU8LAAD+QQAMAMlXUlISn/nMZ+LOO++M0aNHZ/X1uiAABgBgdxAAAwDskO1XQAuAAeDDKykpibPPPjv+7d/+LUaPHh2FhYWagv3dR5Sfn9/SlAAAkkcADADw9sYoL88JYADIMa1bt46zzz47vve978UJJ5wgCMb+7iPIz8/3LwwAQAIJgAEAdkilUlm9N2psbDQkAPiY2rVrF+edd15897vfjRNOOCEKCgo0Bfu7D94f55sSAEDyCIABAHbI9gA4nU4bEgB8Qu3bt/9nEDxq1KjIy/NqBPu799kfp0wJACB5/FcOAMAOXnABQPPRoUOHuOiii+J73/ueIJi9JpPJZHuJ/sUAAEggmzgAgP+R1QFwAl4QAkDidOzYMS666KL41re+FYcffnj4fTDs796xOc7yG3IAANg5mzgAgITsjQTAALD7dOvWLS699NL41re+FcOGDRMEs0dk+xXQeXl5/kUAAEigAi0AAPiHbH/BJQAGgN2ve/fuceWVV8ayZcviiSeeiDlz5mgKzXl/5/AIAEACCYABAHbIZDJOAAMAERGx7777xtixY2PJkiUxYcKEmD9/vqZgfwwAQCIIgAEA/ocr7gCA/2W//faLG264Id56660YP358vPnmm5rCLpPtV0Cn3IUOAJBIAmAAgB2y/QVXtr8gBIBc1rdv37jxxhvjrbfeinHjxsWiRYs0hU/MFdAAANjEAQDsXln9Bs4BDADY+/r27Rs333xz3HDDDdG7d28NIdf3d75BAgCQQE4AAwDskO0nMATAAJA9BgwYEAMGDIj58+fHI488EitXrtQUcnF/5woaAIAEcgIYAGCHVCqVzvL6DAkAssyAAQPi1ltvjbFjx0bPnj01hJza32UScEc1AAD/lxPAAAD/QwAMAHysv6MHDRoUBx98cDz//PMxadKk2LRpk8aQ+P1dtv+CJAAAO+cEMADADul0dr/fEgADQHarr6+PioqK2LZtm2aQE/u7dDrtBDAAQAI5AQwA8D+cAAYAPrK6urp4+umnY9q0acJfcm1/5wQwAEACCYABAP6HEw4AwIfW0NAQ06ZNiyeffDK2bt2qIXxkCfgGsAAYACCBBMAAADtkMpmsDoDz8ny9AwCywdvB71NPPRXV1dUaQs7u7wTAAADJJAAGANgh219wCYABYO9qbGyMGTNmxJNPPhmVlZUawieWn5+f9VtkUwIASB4BMADADplMpiGb6yssLDQkANgL0ul0zJo1KyZPnhwbN27UEHaZgoLsfjXX1NTUaEoAAAncZ2oBAMA/NDY2bs/m+gTAALBnpdPpePnll2Py5Mmxdu1aDWGXa9GiRbb/O1BvSgAAySMABgDYoampSQAMAEQmk4nZs2fH448/HuXl5RpCs93fNTY2CoABABJIAAwAsENDQ0NWv+ASAAPA7vV28PvEE0/E6tWrNYTdLtuvgM72G3IAAHiPfaYWAAD8gyugAaD5mjNnTkyaNCmWLl2qGewx2X4FtAAYACCZBMAAADs0NTU5AQwAzcyCBQtiwoQJ8dZbb2kG9nfv0tDQIAAGAEggATAAwA7Z/oJLAAwAu87ChQtj/PjxsXjxYs1gr8n2K6Cz/RckAQB4j32mFgAA/EO2B8AFBQWRl5cX6XTasADgY1q+fHmMGzcu5s+frxnsVXl5eVkfAG/fvt0JYACABBIAAwDs0NDQkPUnHFq1ahXbtm0zLAD4iFauXBmPPPKI4Jes2tclYH8sAAYASCABMADADrW1tXXZXqMAGAA+mnXr1sX48eNj9uzZkclkNISs2tdlu7q6ulqTAgBIHgEwAMAOW7du3ZrtNSbhRSEAZIP169fHY489JvjFvu4TqK6u3mpSAADJIwAGANihqqpKAAwACbdhw4Z4/PHH45VXXommpiYNwb7uE6isrHT1DABAAgmAAQB22LRpU9a/4GrZsqVBAcBOVFVVxcSJE+OFF16IxsZGDSHrJSEA3rRpkxPAAAAJJAAGANhh3bp1WR8AOwEMAP/bli1bYsKECYJfEicJ+7ry8nIBMABAAgmAAQB2WLZsmSugASAhqqurY/LkyTFz5syor6/XEBInCfu6pUuXCoABABJIAAwAsMP8+fOz/gRwcXGxQQHQrNXU1MSUKVPimWeeEfySaEnY173++uu+AQwAkEACYACAHRYsWFCXyWQaUqlUYbbW2Lp1a4MCoFmqq6uLp59+OqZNmxbbtsmkSL5s39el0+mGpUuXbjcpAIDkEQADALxDU1PTtoKCgrbZWp8AGIDmZvv27TF9+vR48sknY+tWt9GSO7J9X9fU1ORfOACAhBIAAwC8Q0NDw9ZsDoBLS0sNCYDm8ndyTJs2LZ566qmorq7WEHJOtu/rGhsb/YsHAJBQAmAAgHeor6+vbNWqVc9src8JYAByXWNjY8yYMSOefPLJqKys1BByVrbv6+rr66tMCQAgmQTAAADv0NDQkNVvmgXAAOSqdDods2bNismTJ8fGjRs1hJyX7fu6bN8XAwDw3gTAAADvUFdXV5XN9ZWWlkYqlYpMJmNYAOSETCYTr732Wjz++OOxatUqDaFZSKVSUVJSktU11tbWVpkUAEAyCYABAN5h27Ztm7K5vvz8/GjVqlXU1NQYFgCJlslkYvbs2fH4449HeXm5htCstGrVKvLz87O6xq1btzoBDACQUAJgAIB3qK6u3pztNZaVlQmAAUist4PfiRMnxpo1azSEZqmsrCzra9y2bVuVSQEAJJMAGADgHaqqqjZle43t2rWLtWvXGhYAiTNnzpyYNGlSLF26VDNo1tq1a5f1NW7atMkJYACALNbQWBgFjQ0REZFKRSavMJre/pkAGADgHSoqKqqyvcYkvDAEgHdasGBBTJgwId566y3NgITs5zZs2CAABgDIYoUFDf9MejMRqab0/+S+AmAAgHdYtWpV1r/oatu2rUEBkAgLFy6M8ePHx+LFizUD3iEJAfDq1aurTAoAIJkEwAAA77BgwYKsD4CdAAYg2y1fvjzGjRsX8+fP1wzYiST8Ql8S9sUAAOycABgA4B2eeOKJjZlMpimVSuVna41OAAOQrVauXBmPPPKI4Bc+QLb/Ql8mk2l64oknNpoUAEAyCYABAN6huro6vX379g1FRUVdsrVGJ4AByDZr166NCRMmxOzZsyOTyWgIJHw/t3379g3V1dVpkwIASCYBMADAu9TV1a0XAAPAB1u/fn089thjgl/Isf1cXV3delMCAEguATAAwLvU1dVVtGnTJmvrKykpiRYtWsT27dsNC4C9oqKiIiZOnBivvPJKNDU1aQh8BEVFRVFcXJz1+2GTAgBILgEwAMC7bN26dV2XLll7ADhSqVR07Ngx1qxZY1gA7FFVVVUxceLEeP755wW/8DF17NgxUqlU1u+HTQoAILkEwAAA71JVVZX1Jx46deokAAZgj9m8eXM8/vjj8cILL0RjY6OGwCfcx9kPAwCwOwmAAQDeZf369Vn/zbMkvDgEIPm2bNkSU6ZMiZkzZ0Z9fb2GwC7QsWNH+2EAAHYrATAAwLusXr066088JOHFIQDJVVNTE1OmTIlnnnlG8Au7WBJ+kW/VqlUCYACABBMAAwC8y9///ves/+aZABiA3aG2tjYmT54czz77bNTV1WkINNN93KuvvioABgBIMAEwAMC7PPzww+t//OMfN6RSqcJsrbFz584GBcAus3379pg+fXpMnTo1tm3bpiGwG2X7CeB0Ot3w8MMPC4ABABJMAAwA8C7V1dXpurq68latWu2TrTV26NAh8vLyIp1OGxgAH1tDQ0NMmzYtnnrqqaiurtYQ2M3y8vKiQ4cOWV1jfX39mtraWptMAIAEEwADAOxEbW3tmmwOgAsKCqJdu3axceNGwwLgI2tsbIwZM2bEk08+GZWVlRoCe0j79u2joCC7X8fV1NSUmxQAQLIJgAEAdmLz5s2r2rdvn9U1duvWTQAMwEeSTqdj1qxZMXnyZH+HwF7av2W7LVu2rDQpAIBkEwADAOzEpk2bVvfp0yera+zWrVvMmzfPsAD4QG8Hv1OmTIkNGzZoCOzF/Vu227BhwxqTAgBINgEwAMBOrFixYvWwYcOyusYkvEAEYO/KZDLx0ksvxZQpU6K83K2usLd17do162tctWrVKpMCAEg2ATAAwE7Mnz9/9ZgxY7K6xiS8QARg78hkMjF79uyYOHFirFnjMB9kiyT8At+8efP8oQEAkHACYACAnRg3btyab37zm5mISGVrjU4AA7Azc+bMiSeeeCKWLVumGZBlEvALfJlx48atNikAgGQTAAMA7MTrr79e29DQsKmwsLBDttZYXFwcZWVlsWXLFgMDIBYsWBDjx4+PJUuWaAZkobKysiguLs7qGhsaGjYuWLCgzrQAAJJNAAwA8B62bt26vF27dh2yucauXbsKgAGauYULF8b48eNj8eLFmgFZLAm3t2zbtm25SQEAJJ8AGADgPVRVVS1t167d0GyusWfPnrFw4ULDAmiGli1bFo899ljMnz9fMyABevbsmfU1VlZWLjUpAIDkEwADALyHdevWLevTp09W15iEF4kA7ForVqyIRx99VPALCZOEfdvatWuXmRQAQPIJgAEA3sPChQuXHX744VldY69evQwKoJlYtWpVjB8/PubOnRuZTEZDIGGSsG9buHDhMpMCAEg+ATAAwHuYNm3a0ksuuSSra+zevXvk5+dHU1OTgQHkqHXr1sX48eNj9uzZgl9IqIKCgkR8A/jpp59eZloAADmw/9QCAICde+ihhzbcd999W/Pz80uzdjNXUBBdunSJNWvWGBhAjqmoqIiJEyfGyy+/HOl0WkMgwbp27RoFBdn9Gq6xsbH6kUce2WBaAADJJwAGAHgf27ZtW15WVnZwNtfYq1cvATBADqmqqoqJEyfG888/74YHyBFJ+P7vtm3blpsUAEBuEAADALyPLVu2LMv2ALhnz57x0ksvGRZAwm3evDkef/zxeOGFF6KxsVFDIIck4fu/W7ZsWWpSAAC5QQAMAPA+1q9fvyzbT2z06NHDoAASbMuWLTFlypSYOXNm1NfXawjkoCTs19avX7/MpAAAcoMAGADgfSxYsGDh0KFDs7rGfffdN1KpVGQyGQMDSJCampqYMmVKPPPMM4JfyGGpVCr23XffrK9z/vz5C00LACA3CIABAN7Ho48++uYFF1yQ1TWWlJRE586dY926dQYGkAC1tbUxefLkePbZZ6Ourk5DIMd17do1WrVqlfV1/vnPf15kWgAAuUEADADwPiZNmlRVX1+/oaioqGM217nvvvsKgAGy3Pbt22P69OkxderU2LZtm4ZAM9GnT5+sr7G+vr7iySefrDItAIDcIAAGAPgAW7duXZTtAXCfPn3ipZdeMiyALNTQ0BDTpk2Lp556KqqrqzUEmpkkXP+8detWp38BAHKIABgA4ANUVFQs7NChw8hsrjEJLxYBmpvGxsaYMWNGPPnkk1FZWakh0EwlYZ9WUVHh+78AADlEAAwA8AGWLl266MADD8zqGnv16hUFBQXR2NhoYAB7WTqdjlmzZsWkSZNi06ZNGgLNWGFhYfTs2TMR+13TAgDIHQJgAIAPMHPmzEWnnnpqdm/qCgqiZ8+esWzZMgMD2EveDn4nT54cGzdu1BAg9tlnn8jPz0/CfnexaQEA5I48LQAAeH+//OUvV6bT6bpsr7NPnz6GBbAXZDKZePHFF+O73/1u3H///cJf4J+ScP1zOp2u++Uvf7nStAAAcocTwAAAH6C6ujpdXV29uE2bNodkc539+vWL6dOnGxjAHpLJZGL27NkxceLEWLNmjYYAO92fJWCvu7i6ujptWgAAuUMADADwIWzYsGFetgfA/fv3NyiAPeTVV1+NSZMmxapVqzQD2KlUKpWI/dmGDRvmmhYAQG4RAAMAfAiLFy9+o2/fvlldY1lZWXTu3DnWr19vYAC7yYIFC2L8+PGxZMkSzQDeV5cuXaK0tDQJ+9z5pgUAkFsEwAAAH8JTTz31+ujRo7O+zv33318ADLAbLFy4MMaPHx+LFy/WDOBD78uSYMqUKa+bFgBAbsnTAgCAD/aLX/xiTWNjY1W215mUF40ASbFs2bK4++674z/+4z+Ev8BHkoTv/zY0NFTee++9q00LACC3OAEMAPAhNDQ0ZDZv3jy/Q4cOI7O5TgEwwK6xYsWKePTRR2P+fDejArm7L9uyZYs/5AAAcpAAGADgQ1q3bl3WB8AdO3aMNm3axObNmw0M4GNYtWpVjB8/PubOnRuZTEZDgI+lbdu20aFDh0Tsb00LACD3CIABAD6kefPmzTvooIOyvs4DDzwwXnrpJQMD+AjWrVsX48ePj9mzZwt+gV2yH0uCuXPnzjMtAIDcIwAGAPiQ/vznP88/77zzsr7OAw44QAAM8CFVVFTEuHHjBL/ALt+PJcHDDz/sBDAAQA4SAAMAfEgTJ06srK2tXdGqVat9srnOgw8+2LAAPkBVVVVMnDgxnn/++WhqatIQYJdKwq0xNTU1yydNmlRlWgAAuUcADADwEWzYsOHvvXr1yuoAuG3bttG1a9dYu3atgQG8y+bNm+Pxxx+PF154IRobGzUE2OW6desWbdu2TcS+1rQAAHKTABgA4CNYuHDha7169Toj2+scMGCAABjgHbZs2RJTpkyJ5557LrZv364hwG6TlO//Lly48O+mBQCQmwTAAAAfwcSJE/9+wgknZH2dBx54YEyfPt3AgGavpqYmpkyZEs8880zU19drCLDbDRgwIBF1jh8//u+mBQCQmwTAAAAfwb333rv6Bz/4wfqioqLO2VznAQccEHl5eZFOpw0NaJZqa2tj8uTJ8eyzz0ZdXZ2GAHtEXl5e9O/fP+vrrK+vX3ffffeVmxgAQG4SAAMAfESVlZVzu3btmtXHgFu1ahX77LNPLFu2zMCAZqWuri6efvrpmDZtWmzbtk1DgD1qn332iVatWmV9nZs2bZpjWgAAuUsADADwES1dunR2tgfAERGDBg0SAAPNRkNDQ0ybNi2eeuqpqK6u1hBgr+2/kuCtt976m2kBAOQuATAAwEc0ffr0v48cOTLr6xw4cGBMmDDBwICc1tDQEM8991w8+eSTUVlZqSHAXt9/JcG0adP+bloAALlLAAwA8BH9x3/8x9JbbrmlOj8/v3U219mrV68oKyuLLVu2GBqQc9LpdMyaNSsmTZoUmzZt0hBgrysrK4tevXplfZ2NjY1b7rnnnmUmBgCQuwTAAAAfUW1tbXrDhg1/7dKly3HZXGcqlYqBAwfGrFmzDA3IGW8Hv5MnT46NGzdqCJA1Bg4cGKlUKuvr3Lhx4yu1tbVpEwMAyF0CYACAj+Gtt956JdsD4IgQAAM5I51Ox8svvxxTpkyJ8vJyDQGyct+VBIsWLXrFtAAAcpsAGADgYxg/fvwrRxxxRNbXedBBB0VBQUE0NjYaGpBImUwmZs+eHRMnTow1a9ZoCJCVCgoK4qCDDkpErY888ogAGAAgx+VpAQDAR/fjH/94ZX19/fpsr7OoqCj69etnYEAivfrqq3HHHXfEz3/+c+EvkNX69esXRUVFWV9nXV1d+b333rvaxAAAcpsTwAAAH9OGDRte6dGjx6ezvc5BgwbFggULDAxIjCVLlsSECRNi/vz5mgEkwuDBgxNR5/r1653+BQBoBgTAAAAf07x5815OQgA8bNiwePjhhyOTyRgakNXefPPNmDBhQixevFgzgMRIpVIxdOjQRNQ6d+7cl0wMACD3CYABAD6m++677+XRo0dnIiKVzXW2bds2evfuHcuWLTM0ICstW7YsHnvsMSd+gUTq06dPtG3bNgmlpu+9996/mhgAQO4TAAMAfEwTJ06s3Lp165LS0tK+2V7rkCFDBMBA1lmxYkU8+uijgl8g0YYMGZKIOqurqxc+/fTTm00MACD3CYABAD6B8vLyl/fff/+sD4AHDx4c48aNMzAgK6xcuTImTJgQc+fOdT09kHhJ+f7vmjVrfP8XAKCZEAADAHwCM2fOfG7//ff/fLbX2a1bt+jWrVuUl5cbGrDXrFu3LsaPHx+zZ88W/AI5oWfPntGlS5dE1DpjxoznTAwAoHkQAAMAfAK33Xbba5dcckl1fn5+62yvdciQIQJgYK9Yv359PPbYY4JfIOck5frnxsbGzbfddts8EwMAaB4EwAAAn0BlZWXThg0b/tqlS5fjsr3WQw89NCZNmmRowJ78MzKeeOKJeP7556OpqUlDgJxz6KGHJqLOioqKV6qrq9MmBgDQPAiAAQA+oXnz5s1MQgDcu3dv10ADe0RVVVVMnDgxXnjhhWhsbNQQICd17949evbsmZT9quufAQCakTwtAAD4ZP77v/97VkQk4kTFpz71KQMDdpstW7bEQw89FLfffns899xzwl8gpw0fPjwRdWYymfTdd9/9gokBADQfTgADAHxCkyZNqtqyZcuCsrKyg7K91uHDh8fjjz9uaMAuVVNTE1OmTIlnnnkm6uvrNQTIealUKg477LBE1Lply5bXp0+fvsXUAACaDwEwAMAusHz58lkDBw7M+gC4S5cu0atXr1i5cqWhAZ9YbW1tTJ48OZ599tmoq6vTEKDZ6N27d3Ts2DEx+1QTAwBoXgTAAAC7wLPPPvvCwIEDr0hCrcOGDRMAA59IXV1dPP300zFt2rTYtm2bhgDNzrBhwxJT61/+8pcXTQwAoHnxDWAAgF3g1ltvnV9fX782CbUefvjhkUqlDA34yBoaGmLq1Klx6623xuOPPy78BZqlJF3/XFdXt/rWW29dYGoAAM2LE8AAALtAQ0NDZs2aNc/16dPns9lea7t27aJPnz6xZMkSgwM+7J9xMW3atHjqqaeiurpaQ4Bmbb/99ou2bdsmotbVq1fPNDEAgOZHAAwAsIs8++yz05IQAEdEHHHEEQJg4AOl0+mYNWtWTJo0KTZt2qQhABFx5JFHJqbW6dOnTzMxAIDmxxXQAAC7yC233PJaQ0NDZRJqHT58eLRo0cLQgJ1Kp9Px3HPPxW233Rb333+/8Bdgh6KiovjUpz6ViFobGho23HLLLXNNDQCg+XECGABgF6murk6Xl5c/t88++5yR7bW2bNkyDj300Hj55ZcNDvindDodL7/8ckyZMiXKy8s1BOBdhgwZEkVFRYmodc2aNc/V1tamTQ0AoPkRAAMA7EIvvvjiM0kIgCMiRo4cKQAGIiIik8nE7NmzY+LEibFmzRoNAXif/VNSzJo161kTAwBongTAAAC70O233/7KOeecszU/P78022sdMGBAtG/f3tWu0My9+uqrMWnSpFi1apVmALyPjh07xgEHHJCIWhsbG6u/8Y1v/NXUAACaJwEwAMAutHLlyob169fP6tat2+hsrzWVSsXhhx8ekyZNMjhohubMmROTJ0+OJUuWaAbAh3D44YdHKpVKRK3r16+fVVFR0WhqAADNU54WAADsWq+++mpirts77LDDDAyamTfffDP+/d//PX7yk58IfwE+pFQqFSNGjEhMva+88sozpgYA0Hw5AQwAsIvddNNNz5166qnV+fn5rbO91m7dukX//v1j4cKFBgc5btmyZfHYY4/F/PnzNQPgIzrggAOic+fOiai1sbFxy4033jjL1AAAmi8BMADALrZy5cqG8vLyGT179vx0Euo9+uijBcCQw5YvXx7jxo0T/AJ8wv1SUpSXlz9TXl7eYGoAAM2XABgAYDeYMWPGUxdccEEiAuAhQ4ZE69ato7q62uAgh6xcuTImTJgQc+fOjUwmoyEAH1ObNm3i0EMPTUy9zz777FOmBgDQvPkGMADAbvDVr371lYaGhk1JqLWgoCCOOOIIQ4McsW7duvj5z38ed955Z8yZM0f4C/AJjRw5MvLz8xNRa0NDw8abbrrpVVMDAGjenAAGANgNKisrm1atWjW9T58+5ySh3qOPPjqefPJJQREk2Pr16+Oxxx6L2bNn+3cZYBdJpVIxatSoxNS7cuXKadXV1WmTAwBo3pwABgDYTaZNm5aY6/c6duwYAwYMMDRIoA0bNsSvf/3r+Nd//dd49dVXhb8Au9CAAQOiY8eOian36aefftLUAAAQAAMA7CZf+9rX5tTX11ckpd6jjjrK0CBBqqqq4v77749vf/vb8eKLL0ZTU5OmAOxiRx55ZGJqra+vX/eNb3zjdVMDAMAV0AAAu0ltbW16xYoVT++///6fT0K9hx56aLRt2zaqqqoMD7LYli1bYsqUKfHcc8/F9u3bNQRgN2nbtm0MGTIkMfUuX778qdraWtc/AwDgBDAAwO70xz/+cUJSas3Pz4/jjjvO0CBL1dTUxKOPPhq33XZb/OUvfxH+Auxmxx57bOTn5yel3Myvf/3rCaYGAECEABgAYLe66667llZXV89PSr1HH310tGjRwuAgi7wd/H7jG9+IqVOnRn19vaYA7GYtWrSIo48+OjH1btmy5Y177rlnhckBABDhCmgAgN3u9ddfn3T44YcPSEKtxcXFcdhhh8XMmTMNDvayurq6ePrpp2PatGmxbds2DQHYgw477LAoKSlJTL3z5s17wtQAAHibE8AAALvZ9773vanpdLohKfWecMIJkUqlDA72koaGhpg6dWrceuut8fjjjwt/AfawVCoVJ5xwQmLqTafT27/73e8+ZXIAALzNCWAAgN1s+vTpWyoqKmZ26dIlER/Y7d69e/Tv3z/efPNNw4M9qKGhIaZNmxZPPfVUVFdXawjAXnLAAQdE9+7dE1NvRUXFczNmzPAXBwAA/+QEMADAHjBr1qxEXcuXpFMvkHTpdDqee+65uP322+PRRx8V/gLsZccff3yi6p0xY8YkUwMA4J2cAAYA2AO++tWvvnT66adXFRYWtk1CvQMHDoyOHTvGhg0bDA92k3Q6HbNmzYrJkyfHxo0bNQQgC3Ts2DEGDhyYmHobGhoqb7755pdMDgCAd3ICGABgDygvL29YsWLF1MRsEvPy4sQTTzQ42A3S6XS8+OKL8Z3vfCfuv/9+4S9AFjnppJMiLy85r8tWrFgxpaKiotHkAAB4JwEwAMAe8qtf/erRiMgkpd6jjjoqysrKDA52kUwmE6+++mp873vfi1//+texdu1aTQHIImVlZXHUUUcl6q+W//7v//6zyQEA8G4CYACAPeQ///M/l1dWVv4tKfUWFhbGMcccY3CwC7wd/P785z+PNWvWaAhAFjruuOOioCA5X0urqqqa/dOf/nS1yQEA8G4CYACAPeill14al6R6jzvuuCgqKjI4+JjmzJkTd911V/z85z+P1au9owfIVkVFRYn7xbcXXnhhnMkBALAzBVoAALDnjB079pkFCxZUFhYWtktCvSUlJXHEEUfE9OnTDQ8+gjfffDPGjx8fb731lmYAJMCRRx4ZJSUliam3oaFh0zXXXPOsyQEAsDMCYACAPai8vLxh6dKlE/v3739xUmo+8cQT49lnn410Om2A8AEWLVoUjz32WCxevFgzABIiLy8vTjzxxETVvGTJkifKy8sbTA8AgJ3ucbUAAGDP+u1vfzsxIjJJqbdjx44xdOhQg4P3sXz58rj77rvjRz/6kfAXIGGGDRsWHTp0SFLJmd/85jePmxwAAO9FAAwAsIf953/+5/JNmza9kqSaTz/99EilUoYH77Jy5cr4yU9+Et///vdj/vz5GgKQMHl5eXHGGWckquZNmza9fM8996wwPQAA3osroAEA9oKXXnpp/KmnnnpYUurt2rVrDBkyJGbPnm14EBHr1q2L8ePHx+zZsyOTyWgIQEINHTo0OnfunKiaX3jhhQkmBwDA+xEAAwDsBZdffvkzS5YsWVdUVNQlKTWfccYZ8be//U3YRbO2fv36eOyxxwS/ADkglUrF6aefnqia6+rq1lx22WXTTQ8AgPcjAAYA2AsqKyub5s+f/8ihhx56dVJq7tatm1PANFsbNmyIxx9/PF555ZVoamrSEIAc8KlPfSq6du2aqJrfeOONcdXV1WnTAwDg/fgGMADAXvL1r399XDqdrktSzb4FTHNTVVUV999/f3z729+OF198UfgLkCNSqVR8+tOfTlTN6XS69pvf/OZjpgcAwAdxAhgAYC+ZMWNG9Zo1a/7Ss2fPxLx97N69ewwcODDmzJljgOS0LVu2xIQJE+KFF16IxsZGDQHIMYceemh069YtUTWvXr36qRkzZlSbHgAAH8QJYACAvejXv/71HyMiUR8SPeuss5wCJmdt27YtHn300bjtttviueeeE/4C5KC8vLwYM2ZM0srO/OpXv/qT6QEA8KH2vFoAALD3fP/733+rqqoqUR/V7dGjR3zqU58yPHJKfX19TJ06Nb71rW/F1KlTo76+XlMActSIESOiS5cuiap506ZNf73rrruWmh4AAB+GABgAYC975plnHkpazWeccUbk5dlKkjvmzZsXjz76aGzdulUzAHJYQUFBnH766Ymre9q0aQ+aHgAAH5a3dgAAe9nYsWNn1tfXr01SzZ07d47DDjvM8ACARBk5cmR06NAhUTXX1dWtHjt27POmBwDAhyUABgDYyyorK5tee+21Pyat7jPPPDMKCgoMEABIhBYtWiTy9O/s2bP/UF1dnTZBAAA+LAEwAEAWuOqqqyY0NjZWJanm9u3bx9FHH214AEAiHHfccdGmTZtE1dzQ0LDxiiuumGh6AAB8FAJgAIAssGDBgrqFCxc+lrS6R48eHYWFhQYIAGS1li1bxsknn5y4uhcuXDhu6dKl200QAICPQgAMAJAlvv71r/8pnU7XJqnmtm3bximnnGJ4AEBWO+2006K0tDRRNTc1NdV+7Wtfe8j0AAD4qATAAABZ4umnn968fPnyxF3xN3r06GjXrp0BAgBZqUOHDnH88ccnru5ly5ZNmD59+hYTBADgoxIAAwBkkbvvvvtPmUymKUk1FxYWxumnn254AEBWOvPMMxP3yYpMJtN41113/dH0AAD4OATAAABZ5Be/+MWatWvXTkta3UcccUT06tXLAAGArNK7d+847LDDEld3eXn5X+6///51JggAwMchAAYAyDIPP/zwn5JWcyqVijPPPNPwAICsMmbMmEilUomr+8EHH/yT6QEA8HEJgAEAsszXv/71NzZs2DAraXUPHDgwDj74YAMEALLCoEGDYsCAAYmru6KiYuatt966wAQBAPi4BMAAAFlo3Lhxv01i3WPGjIm8PFtMAGDvysvLizFjxiSy9j//+c+/NUEAAD7RflgLAACyz/XXXz+nqqrqr0mru1evXnHUUUcZIACwVx1zzDHRvXv3xNW9adOmV2666aa5JggAwCchAAYAyFJ/+tOf7k1i3WPGjInS0lIDBAD2ijZt2sRZZ52VyNofeOCBe00QAIBPSgAMAJClbrrpprlJPAVcXFwcZ555pgECAHvFWWedFS1btkxc3Zs2bXrl5ptvnmeCAAB8UgJgAIAsNm7cuF8lse5Ro0ZF7969DRAA2KP69OkTI0eOTGTtjz322K9MEACAXUEADACQxcaOHTu7qqrqb0mrO5VKxfnnnx+pVMoQAYA9tv/4/Oc/n8j9R2Vl5d+uueaav5kiAAC7ggAYACDLTZ069bdJrLtv374xZMgQAwQA9ojDDjsssTeQTJ48+TcmCADAriIABgDIcpdeeumLVVVVryax9s9//vNRXFxsiADAblVaWhrnn39+Imuvqqr66+WXX/6SKQIAsKsIgAEAEuChhx76WRLrLisri9NPP90AAYDd6qyzzoqSkpIklp753e9+91MTBABgVxIAAwAkwA033DB3w4YNs5JY+3HHHRd9+vQxRABgt+jbt28cddRRiay9oqJi1te//vU3TBEAgF1JAAwAkBA///nPfxoR6aTVnUql4vOf/3zk5dl6AgC7Vn5+flx00UWRSqWSWH76F7/4xX+bIgAAu5q3cAAACXHHHXe8tW7duulJrL13795xzDHHGCIAsEudcMIJ0b1790TWXl5e/pc77rjjLVMEAGBXEwADACTI3XfffW8mk2lKYu1nnXVWtG3b1hABgF2iQ4cOcfrppyey9kwm03T33Xf/3BQBANgdBMAAAAlyzz33rCgvL386ibW3bNkyzj33XEMEAHaJc889N1q0aJHI2tesWTP1xz/+8UpTBABgdxAAAwAkzA9/+MOfZzKZhiTWPnz48Bg0aJAhAgCfyKGHHhpDhw5NZO3pdLrhBz/4wS9MEQCA3UUADACQMPfee+/qRYsWPZDU+i+++OIoKSkxSADgY2ndunVcfPHFia1/4cKFf7jvvvvKTRIAgN1FAAwAkECXXXbZrxsaGjYlsfaysjJXQQMAH9u5554bpaWliay9oaFh4+WXX/47UwQAYHcSAAMAJNDs2bNrXn311V8ntf4jjjgiDj74YIMEAD6SwYMHx+GHH57Y+l955ZX7Zs+eXWOSAADsTgJgAICEOueccx6tqalZmtT6L7roomjZsqVBAgAfSsuWLeNzn/tcYuuvqalZMmbMmMdMEgCA3U0ADACQUJWVlU3Tpk37RVLrb9++fZx++ukGCQB8KGeccUa0b98+sfU/+eST91ZXV6dNEgCA3U0ADACQYOedd960qqqqV5Ja/wknnOAqaADgAx188MFx/PHHJ7b+TZs2vXzBBRc8a5IAAOwJAmAAgIT74x//eG9EZJJYeyqVigsuuMBV0ADAe2rZsmVccMEFkUqlkrqEzP333/8zkwQAYE8RAAMAJNzNN988b9WqVU8ktf6OHTsm+nt+AMDudcEFF0THjh0TW/+KFSse//rXv/6GSQIAsKcIgAEAcsCNN974k6ampq1JrX/kyJExdOhQgwQA/pdPfepTMWLEiMTW39TUVH3zzTf/t0kCALAnCYABAHLAxIkTK//+97//KslruPDCC6OsrMwwAYCIiGjTpk18/vOfT/QaZs+efd/EiRMrTRMAgD1JAAwAkCPOPvvsh2pqapYntf7S0tK46KKLDBIAiFQqFV/84hejtLQ0sWuoqal566yzznrYNAEA2NMEwAAAOaKioqJx0qRJP07yGgYPHhwjR440TABo5o444og46KCDEr2GJ5544qeVlZVNpgkAwJ4mAAYAyCGXXHLJzIqKihlJXsMFF1wQ3bp1M0wAaKZ69uyZ+KufKyoqZnzhC1+YZZoAAOwNAmAAgBzzb//2b/ek0+ntSa2/RYsWceWVV0ZhYaFhAkAzU1hYGF/60pcSvQ9Ip9Pb/+3f/u0e0wQAYG8RAAMA5Jh777139aJFix5M8hq6d+8eZ555pmECQDNzxhlnRPfu3RO9hsWLFz947733rjZNAAD2FgEwAEAO+uxnP/vL2traRL94PPHEE2Pw4MGGCQDNxKBBg+Kkk05K9Bpqa2tXn3vuub80TQAA9iYBMABADlq8eHH9uHHj/j3Ja0ilUnHJJZdE27ZtDRQAclybNm3ikksuiVQqleh1jBs37t8XL15cb6IAAOxNAmAAgBx1+eWXv1RRUTEjyWsoLS2NL3zhC4l/GQwAvLe3f+mrdevWiV5HRUXFM5dffvlLJgoAwN4mAAYAyGE33HDDXU1NTVuTvIaDDjrI94ABIId95jOfiUMOOSTRa2hqaqq+4YYbfmiaAABkAwEwAEAOGzdu3MbZs2cn/jt0p5xyiu8BA0AOOuSQQ+LTn/504tfx17/+9efjxo3baKIAAGQDATAAQI77zGc+81B1dfXCJK8hlUrFF7/4xejQoYOBAkCO6NixY3zpS19K/KceNm/ePO+00057xEQBAMgWAmAAgBxXXV2dfuCBB34UEekkr6O4uDguvfTSyMuzhQWApMvPz4/LLrssiouLk76U9P333/+ftbW1aVMFACBbeHsGANAMXH/99XMWLVr0YNLXsf/++8e5555roACQcOedd1707ds38etYuHDhH7/61a++bqIAAGQTATAAQDNxySWX/Lyurq486es4/vjjfQ8YABJs2LBhccwxxyR+HXV1dWsuvPDC+0wUAIBsIwAGAGgmXnvttdoHHnjguxGRSfI6UqlUfOlLX4oePXoYKgAkTO/evePSSy9N/Hd/IyLzwAMPfO/111+vNVUAALKNABgAoBm5+uqr/7Z06dJHk76OoqKiGDt2bJSWlhoqACRE69at46qrrorCwsLEr2X58uXjrr766r+ZKgAA2UgADADQzJx33nn/r66ubnXS19GhQ4e4/PLLIy/PlhYAsl1eXl5cfvnl0b59+8Svpb6+ft0ll1zyE1MFACBr999aAADQvLz++uu1Dz744Pcj4VdBR0QMGDAgzjrrLEMFgCw3ZsyYOPDAA3NiLY899tgPXnnllW2mCgBAthIAAwA0Q1/5ylf+umbNmqm5sJaTTz45Dj30UEMFgCw1ZMiQOOmkk3JiLWvXrv3LpZde+oKpAgCQzQTAAADN1GWXXfYf9fX1FUlfRyqViksvvTS6d+9uqACQZXr06BFf/OIXI5VKJX4tDQ0Nm6655pofmioAANlOAAwA0EzNmDGj+oEHHvhO5MBV0C1btozrr78+2rZta7AAkCXatWsX1113XbRs2TIXlpN56KGH/nXSpElVJgsAQLYTAAMANGNf+cpX/rpkyZI/58Ja2rZtG1dffXW0aNHCYAFgL2vRokVcffXVOfPLWUuXLn30iiuueNlkAQBIAgEwAEAzd+655/6ktrZ2eS6spXfv3jlzzSQAJNXbn2fYZ599cmI9tbW1y88555wfmywAAEkhAAYAaOYWLFhQ97Of/ezbmUymMRfWM2zYsDjllFMMFgD2kk9/+tMxdOjQnFhLJpNp/NnPfvbtBQsW1JksAABJIQAGACBuvfXWBfPnz78/V9Zz5plnxuDBgw0WAPaw4cOHx2c+85mcWc/8+fN/d+utty4wWQAAkkQADABARESMGTPmvpqamrdyYS2pVCouu+yy6Nmzp8ECwB7Su3fvuPjii3PmUwxbt25ddPrpp//aZAEASBoBMAAAERGxcuXKhh/+8Ie3pdPpnLjisGXLlvEv//Iv0aVLF8MFgN2sS5cucf3110dRUVFOrKepqanmu9/97jfKy8sbTBcAgKQRAAMA8E933XXX0ueff/6eXFlPaWlpXHvttVFWVma4ALCblJWVxXXXXRclJSU5s6aZM2fe/f/+3/9bZboAACSRABgAgP/l5JNPHldeXv50rqynU6dOMXbs2Jw5kQQA2aSoqCiuueaa6NixY86sqby8/MlTTz11gukCAJBUAmAAAP6PSy655K66urq1ubKefffdN6644orIy7P9BYBdJS8vL6688sro3bt3zqyprq6u/JJLLvmh6QIAkOi9uhYAAPBus2bNqn7ooYfujIh0rqxp4MCBcd555xkuAOwi559/fhxyyCG5tKT0gw8+eOesWbOqTRcAgCTLb3tQ9NzpjndbRG15oQ4BADRTEydOXDNmzJi8Tp06Dc2VNfXp0yfy8/PjzTffNGAA+ATOOuusOOmkk3JqTa+//vp9Z5555kTTBQAgCYq7N0Ze6c5/5gQwAADv6dRTT/31li1bXs+lNZ122mlx9NFHGy4AfEzHHntsnHrqqTm1pi1btrxx2mmn/cZ0AQDIBQJgAADeU0VFReONN974jcbGxqpcWtcFF1wQRx55pAEDwEd05JFHxuc+97mcWlNjY2PVzTff/I2KiopGEwYAIBcIgAEAeF9//OMf1z/yyCPfiRz6HnAqlYqLLroohgwZYsAA8CENHTo0LrrookilUrm0rPQjjzzynfvvv3+dCQMAkCsEwAAAfKBLL730hQULFvwupzbCeXnxpS99Kfbff38DBoAPcNBBB8WXvvSlyMvLrVdJCxYs+N2ll176ggkDAJBLBMAAAHwoo0eP/mVVVdXcXFpTYWFhfOUrX4kePXoYMAC8h169esUVV1wRBQUFObWuqqqqOaNHj/6lCQMAkGsEwAAAfCgVFRWNV1111S0NDQ0bcmldJSUlcfPNN8c+++xjyADwLr17946bbropiouLc2pdDQ0NG6666qqv++4vAAC5SAAMAMCHNmHChE3333//tzKZTDqX1lVcXBzXXXdddO/e3ZABYIfu3bvHtddeG61atcqpdWUymfT999//rQkTJmwyZQAAcpEAGACAj2Ts2LGz58+f/9tcW1fr1q3juuuuiw4dOhgyAM1ehw4d4rrrrovWrVvn3Nrmz5//m7Fjx842ZQAAcpUAGACAj+y44477xaZNm17MtXW1a9cubrzxxmjXrp0hA9BstW3bNmf/Pty4ceOLxx13nO/+AgCQ0wTAAAB8ZNXV1emLL774W3V1datzbW0dO3aMG2+8Mdq0aWPQADQ7ZWVlceONN0bHjh1zbm21tbWrL7zwwturq6vTJg0AQC7Lb3tQ9NzZD9LbImrLC3UIAICdWrZsWf327dtfOvbYY0/Ny8trkUtrKykpiaFDh8Zrr70WNTU1hg1As9ChQ4f42te+Fp06dcq5tTU1NW39zne+M/bBBx9cb9IAAOSC4u6NkVe6858JgAEA+NhefPHFzYcccsiyAQMGnBgRqZzaRBcXx5AhQ4TAADQLHTt2jJtuuik6dOiQi8tLjx8//ravfvWrc0waAIBc8X4BsCugAQD4RC688MIZb7zxxm9ycW3t27ePm266KSdPQgHA2zp16pTL4W+88cYbv77wwgufM2kAAJoLATAAAJ/YqFGjfrFhw4aZubi2t0Pgzp07GzQAOadz585x0003Rfv27XNyfRs2bJg5atSo+0waAIDmRAAMAMAnVltbm77sssu+V1dXtzoX19euXbu44YYbomPHjoYNQM7o0KFDXH/99dGuXbtc3Z+s/sIXvvDd2tratGkDANCc+AYwAAC7xJIlS+oj4pVRo0admpeX1yLX1ldcXBxDhw6NuXPnxrZt2wwcgETr0qVL3HjjjTl77XNTU1P1nXfeec0f/vCHdaYNAEAuer9vAAuAAQDYZWbNmlXVo0ePuYceeujoVCqVn2vra9WqVYwYMSIWLVoUlZWVBg5AIu23335x0003RVlZWU6uL51ON/z617++4fbbb3/TtAEAyFUCYAAA9phJkyatPeqoozbsu+++R+fi+goLC2P48OGxbNmy2LBhg4EDkCgDBgyIa6+9Nlq1apWza5w2bdq/XXLJJc+ZNgAAuez9AmDfAAYAYJc77bTTHn/rrbcezNX1FRUVxTXXXBNDhgwxbAASY8iQIXHNNddEUVFRzq5xwYIFvzv99NOfMG0AAJozATAAALvFEUcccc+GDRtm5ur6CgoK4sorr4wjjjjCsAFIwt/LceWVV0ZBQUHOrrG8vPypESNG/LdpAwDQ3AmAAQDYLaqrq9MXXXTRd2pra1fk7GY6Ly8uvvjiOPLIIw0cgKw1atSouPjiiyMvL3dfA23dunXxZz/72e83NDRkTBwAgObON4ABANhtli9fvr2mpuaFY4899uT8/PyWubjGVCoVgwYNikwmE4sWLTJ0ALLK6aefHueee26kUqmcXWN9fX3FDTfccM3UqVOrTBwAgObi/b4BLAAGAGC3evnll7cUFBS8cMQRR4zOy8trkYtrTKVSccABB0SnTp1i7ty5kck4fATA3lVYWBhXXHFFHHPMMTm9zsbGxuo777zzKz/72c9WmzoAAM2JABgAgL1qxowZlb169Xp98ODBJ6dSqfxcXWfPnj2jb9++8fe//z0aGxsNHoC9olWrVnH11VfHwIEDc3qd6XS64be//e2Nt9122wJTBwCguREAAwCw1z3xxBPlw4cPX9OvX79jIyJn76Hs2LFjDBw4MObMmRN1dXUGD8Ae1a5du7jxxhujT58+ub7U9JQpU779xS9+8XlTBwCgOXq/ADhPewAA2FPGjBkz9Y033vh1rq+zZ8+eceONN0bHjh0NHYA9pkuXLnHTTTdF9+7dc36tc+fO/eU555zzF1MHAID/SwAMAMAe9alPfernS5cufTjX19mlS5e49dZb48ADDzR0AHa7gQMHxje/+c3o1KlTzq/1rbfeemjEiBG/MnUAANg5ATAAAHvcsccee8/GjRtfyPV1FhcXx7XXXhsjRowwdAB2m8MPPzyuuuqqaNmyZc6vdePGjc8fffTR95g6AAC8NwEwAAB7XEVFReNxxx339crKyr/l+loLCgrisssui/PPPz9SqZThA7DLpFKpOP/88+PSSy+NgoKCnF/vpk2bXj7ssMNuqaysbDJ9AAB4bwJgAAD2isWLF9efddZZN1dXV7/ZHNZ7/PHHx5e//OUoKioyfAA+sRYtWsSXv/zlOP7445vFequrq98cM2bMN8rLyxtMHwAA3l9+24Oi585+kN4WUVteqEMAAOw2a9asaVi1atWs0aNHH1dQUNA619fbrVu3OOCAA2LevHlRX1/vAQDgYykrK4trrrkmDjrooGax3rq6uvKxY8de89RTT202fQAA+Ifi7o2RV7rznwmAAQDYq+bNm1ezevXqZ04++eTjCwoKSnN9ve3atYuRI0fG8uXLY+PGjR4AAD6S/v37x0033RRdu3ZtFuutr69fd9111335T3/6U4XpAwDA/xAAAwCQ1ebMmbMtlUq9fOSRR56Ul5eX83ckt2jRIkaMGBG1tbWxdOlSDwAAH8rxxx8fX/rSl5rN5wQaGxu33HXXXdf99Kc/XWn6AADwvwmAAQDIejNnzqzs2bPn64MHDz4plUrl5/p6U6lUHHLIIdGqVatYsGBBZDIZDwEAO5WXlxef/exn4/TTT49UKtUs1pxOp7f//ve//+o3vvGN1z0BAADwfwmAAQBIhEmTJpXvs88+8wYOHHhCKpUqaA5r3m+//WLAgAExd+5c3wUG4P8oKyuL6667LoYNG9Zs1pxOp7f/8Y9/vOmqq676qycAAAB2TgAMAEBiTJw4cc3BBx+85MADDzwulUrlNYc1t2/fPoYOHRqLFi2KLVu2eAgAiIiIffbZJ66//vro2bNns1lzJpNpnDBhwm1f/OIXn/cEAADAexMAAwCQKI8++ujy/fff/42DDjrohOZwHXRERHFxcRx11FHR2NgYb731locAoJkbPXp0XHHFFVFSUtJs1pxOpxsefvjhr15yySWzPAEAAPD+BMAAACTO+PHjVw0cOHDpAQcccGxzOQmcSqViwIAB0aVLl3jjjTeiqanJgwDQzBQVFcWll14aJ554YrP53m/EP07+Pv7447dffPHFMz0FAADwwQTAAAAk0iOPPLLs0EMPXbb//vs3mxA4IqJHjx4xZMiQePPNN2Pr1q0eBIBmonv37vEv//IvccABBzSrdWcymaYnnnji9s997nPPeAoAAODDEQADAJBYDz/88NJjjjlmY+/evY+KiGZzFKq0tDSGDx8eq1evjvXr13sQAHLcwIED45prrol27do1t6VnZsyY8YOzzjprqqcAAAA+PAEwAACJdv/99795zDHHVO6zzz5HRDMKgVu0aBGHHXZYtGzZMhYuXBjpdNrDAJBjCgoK4pxzzonzzz8/WrRo0dyWn37uuefuOuWUUyZ4EgAA4KMRAAMAkHi///3v5w8bNmxF3759j2lO10GnUqno27dvDB06NBYvXhxbtmzxMADkiJ49e8YNN9wQgwcPblbf+434x7XPU6ZM+fbpp58+2ZMAAAAfnQAYAICc8OCDDy4ZNmzYin79+jWrEDgionXr1nHEEUdEfX19LF261MMAkGCpVCpOOOGEuOKKK6JNmzbNbv07wt9vnXPOOX/xNAAAwMcjAAYAIGc89NBDS4YNG7a8X79+xza3EDg/Pz8OPvjg6NWrV8yfPz8aGho8EAAJU1JSEpdffnmccMIJkZ+f3+zWn8lkGp944olvffazn53maQAAgI9PAAwAQE556KGHlo4cOXJdnz59RqWa252ZEdG1a9cYNmxYLFu2LCorKz0QAAnRt2/fuO6662K//fZrluvPZDLpp59++rvnnHPO054GAAD4ZATAAADknD/96U+LDj300KX7779/s7sOOiKiuLg4jjzyyCgpKYk333wz0um0hwIgSxUUFMRnP/vZuPDCC6OkpKRZ9iCdTjc88sgjt5x//vnTPREAAPDJCYABAMhJDz/88NId3wQelUqlmt09mqlUKvr06RMHH3xwLFy4MLZt2+ahAMgynTt3jrFjx8bQoUOjGV5aERH/CH+feOKJ2y+88MLnPBEAALBrCIABAMhZDz300JIePXq8NmjQoGPz8vJaNMcetG3bNkaNGhVNTU2xZMkSDwVAFkilUjF69Oi48soro0OHDs22D01NTdt++9vf/stll132oqcCAAB2HQEwAAA5bdKkSeXdu3efM3jw4GYbAufn58eAAQOiV69esWDBgti+fbsHA2Avad26dVx66aVx/PHHR35+frPtQ2NjY/WvfvWrf7nuuute81QAAMCuJQAGACDnTZ48eW1jY+OMI4444uiCgoKS5tqHrl27xqhRo2Lbtm2xcuVKDwbAHpRKpWLUqFExduzY6NWrV7PuRX19/fo77rjjK9/61rcWejIAAGDXEwADANAsPP/881UbNmx45rjjjjuqsLCwrLn2obCwMAYNGhT77bdfLF68OGpraz0cALtZ+/bt44orrogTTzwxCgub9/uU2tralTfffPPVP/nJT1Z7MgAAYPcQAAMA0Gz87W9/27p27doZJ5xwwsjCwsK2zbkXnTp1ipEjR0Z1dbXTwAC70ciRI+Pqq6+OHj16NPte1NTULL/hhhuu/e1vf7vOkwEAALuPABgAgGbltdde2zpv3rynTznllKFFRUWdmnMvCgsL49BDD4399tsvFi1a5DQwwC709qnfk08+udmf+o2I2Lx587yLL774unHjxm30dAAAwO71fgFwat9zYsTOftC4LmLjq610DwCAxOrVq1fhs88++69du3Y9QTciGhoaYurUqTF58uRobGzUEICPqaCgIE499dQYPXq04HeH8vLyp4499tjvrly5skE3AABg9+swrDYKuuz8ZwJgAAByWuvWrfNeeumlm/fdd9+zdeMfVq9eHffff38sWbJEMwA+ov322y8uuugi1z2/w8KFC38/fPjwnzY0NGR0AwAA9gwBMAAAzd7zzz9/8aGHHnp1RKR0IyKTycTMmTPjz3/+c9TV1WkIwAcoKSmJ8847L0aMGBGplL9Kdki//PLL9xx77LEPagUAAOxZ7xcA+wYwAADNwn333Tfn+OOP39yrV6/DQwgcqVQqevfuHcOHD49169ZFRUWFhwTgPRxyyCExduzY6N+/v/B3h0wm0/jMM8/828knnzxONwAAYM97v28AC4ABAGg2fve7370xePDgJf369Ts6lUrl60hEcXFxjBgxInr06BFLly6N2tpaTQHYoUOHDvGFL3whzjzzzCguLtaQHZqammoeeOCBWz73uc9N1w0AANg7BMAAALDDww8/vKygoOC54cOHH1FQUFCqI//QrVu3OO6446K0tDQWL14cTU1NmgI0Wy1btoxzzjknLr300ujevbuGvENtbe2K22677arbbrvtDd0AAIC9RwAMAADv8Oyzz25avHjx0yeddNKQoqKiTjryD3l5edGnT58YOXJkbN26NVatWqUpQLNz+OGHx1e+8pUYMGBA5OXlacg7VFVV/e3CCy+8/oEHHvDdAAAA2MsEwAAA8C7z58+vefbZZ58+44wz+hcXF/fSkf/RsmXLGDJkSOyzzz6xdOnSqKmp0RQg53Xs2DG++MUvximnnBItW7bUkHdZt27dMyeffPI3Xn755W26AQAAe9/7BcCpfc+JETv7QeO6iI2vttI9AAByWmFhYer555//0sEHH3y5bvxfTU1N8fzzz8f48eOjurpaQ4Cc07p16zjzzDPjyCOPdOJ35zJ///vff3rMMcfc39DQkNEOAADIDh2G1UZBl53/TAAMAAARMWnSpM8cc8wxt6RSKdfg7ERNTU1MmTIlpk2bFg0NDRoCJF5hYWGccsopcdJJJ0VRUZGG7EQ6na6fOnXqd88555y/6AYAAGSX9wuAXQENAAAR8Yc//GHhfvvt98aAAQOOysvLkwS8S2FhYQwYMCCGDh0amzZtinXr1mkKkFiDBw+Oq666KoYOHRoFBQUashONjY1Vv//972/5whe+MEs3AAAg+/gGMAAAfAgTJkxYXV1dPf3II4/8VGFhYTsd+b9KS0vjsMMOi/79+8eaNWti8+bNmgIkRu/evePyyy+PU045JUpLSzXkPWzdunXxLbfccs33vve9hboBAADZyTeAAQDgI+jTp0+LJ5988us9evQ4TTfe3/z58+ORRx6JlStXagaQtXr16hXnnHNODBgwQDM+wKpVq5444YQTfrBy5Ur3/QMAQBbzDWAAAPgYnnnmmfOHDx9+fSqVytON95bJZGL27Nkxbty4qKio0BAga3Tu3DnOOuusGDp0aKRSKQ15/z/Lm2bNmvXDk08++THdAACA7OcbwAAA8DH85je/eX3//fd//cADDzzSd4HfWyqViu7du8cxxxwT7dq1i2XLlkV9fb3GAHtN27Zt49xzz42LL744evToIfz9AI2NjdUPPvjgLZ/97Gf/ohsAAJAMvgEMAAAf0/jx41dFxPOHHXbYiMLCwjIdeW95eXnRu3fvOOqoo6KgoCBWrlwZjY2NGgPsMcXFxXHKKafEl770pejbt2/k5bnA4YPU1tau+MEPfnD9LbfcMk83AAAgQf/94xvAAADwyQwePLjVo48++s1u3bqdpBsfTn19fTzzzDMxderU2LZtm4YAu01ZWVmceuqpceSRR0ZRkQsbPqyVK1c+/ulPf/pHixcvdm0DAAAkjG8AAwDALvLkk0+edeSRR96USqVcl/MhCYKB3eXtE7/HHnus4PcjyGQyDbNmzfoP3/sFAIDk8g1gAADYRX7/+98v6NGjx2uHHHLIyPz8fL8x+SEUFBREv3794qijjoq8vLxYtWqVq6GBT6Rly5ZxwgknxBVXXBEHHXRQFBQUaMqH1NDQsOG3v/3t1z7/+c8/oxsAAJBcroAGAIBd7Lzzzut4991339m2bdvBuvHR1NTUxLPPPhvTpk2LLVu2aAjwoZWVlcXxxx8fxxxzTBQXF2vIR1RVVfW3a6+99vZHHnlkg24AAECyuQIaAAB2g06dOhVMmzZtbN++fT8XESkd+WgaGhri+eefjyeffDI2bJBFAO/7522cdNJJccQRR0RhodvKPobMokWL/nTsscf+pLKyskk7AAAg+QTAAACwG/3hD38Ydfrpp99WUFDQRjc+unQ6Ha+++mpMnTo1Vq5cqSHAP/Xq1StOOeWUGDp0aOTl5WnIx9DY2Fg1YcKEOy666KKZugEAALlDAAwAALvZaaed1vbee+/9docOHUbqxse3fPnymDZtWrz88suRTqc1BJqhvLy8OOyww+L444+P3r17a8gnsHHjxue//OUvf3fSpElVugEAALlFAAwAAHtAYWFh6qmnnjpv+PDh16RSKXeUfgIbNmyIGTNmxHPPPRc1NTUaAs1AcXFxjBo1Ko4++ujo2LGjhnwCmUym4ZVXXvl/J5100kMNDQ0ZHQEAgNzzfgFwftuDoufOfpDeFlFb7p0VAAB8WOl0On7zm9+8Xlpa+uLgwYM/VVhYWKYrH09xcXEMGDAgjj322GjTpk2sXbs2amtrNQZyUIcOHeKMM86ISy+9NAYOHBjFxcWa8gnU1tau+slPfnLjxRdf/IybFAAAIHcVd2+MvNKd/8wJYAAA2A1OPPHENvfdd9+tnTp1Olo3PrnGxsb429/+Fs8++2wsWrRIQyAH9OvXL44++ugYNmxYFBQUaMguUFFR8cwXv/jFf5s+ffoW3QAAgNzmCmgAANhLHn744RNGjx799YKCgta6sWusX78+Zs6cGc8//3xUV1drCCRIaWlpHHnkkXHUUUdF586dNWQXaWxs3DJ16tS7PvvZz/5FNwAAoHkQAAMAwF50ySWXdP3+97//rXbt2g3VjV2nsbExXnvttXjuuedi/vz5GgJZbMCAATFq1KgYPHiw0767WFVV1atf//rXv/e73/1urW4AAEDzIQAGAIC9rF27dvlTp0699OCDD740lUrl68iutXz58nj++efj5ZdfjpqaGg2BLFBSUhLDhw+PI444Inr37q0hu1gmk2mcN2/efSeeeOJvq6urfewXAACaGQEwAABkia9//ev73Xjjjf9aWlraXzd2vXQ6HW+++WY899xz8dprr0VjY6OmwB5UUFAQgwcPjlGjRsUBBxwQeXl5mrIbVFdXL/zP//zPf/3BD36wRDcAAKB5EgADAEAWOfjgg1v9+c9/vrZ3795jIiKlI7tHZWVlvPjii/HCCy/EunXrNAR2o65du8bIkSPj8MMPj7Zt22rI7pNZunTpn88888z/t3jx4nrtAACA5ksADAAAWejuu+8eePHFF9/WqlUrd6PuZuXl5fHqq6/GSy+9FOvXr9cQ2AU6d+4cI0aMiGHDhkW3bt00ZDerqalZ9tvf/vbOm266aa5uAAAAAmAAAMhS/fr1K3r44Ycv79+//4WpVMpdqXvA8uXL46WXXoqXX345qqurNQQ+grKyshg+fHiMGDHCd333kEwmk164cOEfzj777F8sXbp0u44AAAARAmAAAMh6P/3pT4d97nOf+2bLli176Mae0dDQEHPnzo2//vWvMXfu3Ni+Xa4CO9OyZcsYNGhQDBs2LA455JAoKCjQlD2ktrZ21R//+Mc7rr322r/rBgAA8E4CYAAASIA+ffq0ePTRR69wGnjPS6fTsXTp0nj11VedDIaIaNu2bQwbNiyGDRsWffr0ibw8fyTtSZlMpuG11177+ZlnnvmnioqKRh0BAADeTQAMAAAJ8uMf//jQCy644JutWrXaRzf2vLdPBs+ePTvmzp0bdXV1mkKzUFZWFoMHD45hw4ZF//79Iz8/X1P2gpqammX333//nTfccINv/QIAAO9JAAwAAAnTrl27/HHjxp37qU996qq8vDwb870kk8nEihUrYu7cuTFnzpxYsWJFZDIZjSEnpFKp6Nu3bwwbNiwGDRoUHTt21JS9qKmpqfbVV1/92ZgxY/5cWVnZpCMAAMD7EQADAEBCffnLX+5x++23f7V9+/aH68bet2XLlnjjjTdizpw5MW/evKivr9cUEqVly5Zx8MEHx6BBg+KQQw6J0tJSTckCGzdufPG73/3uv//iF79YoxsAAMCHIQAGAIAEKywsTE2cOPGMkSNHXlNQUNBaR7JDXV1dvPnmm/HGG2/EG2+8EevXr9cUslKXLl3ioIMOioMOOigOOOCAKCoq0pQs0djYuGXmzJk/PvPMMyc2NDS4XgAAAPjQBMAAAJADjjzyyNY/+9nPrujbt++5EZGnI9mluro6Fi5cGPPnz4958+ZFZWWlprBXtGvXLg455JAYMGBA9O/fP1q39nsjWSj91ltv/fmqq676xaxZs6q1AwAA+KgEwAAAkEN++ctfjhgzZsyNrVq16q0b2SmdTsfKlStj0aJFsXDhwli8eHFs27ZNY9gtSkpKol+/ftG/f//Yf//9o1evXpGX53dEslVNTc3yRx999EdXXnnlK7oBAAB8XAJgAADIMd26dSt8+OGHPzd48ODL8vPzbdyzXCaTiTVr1sTChQtj0aJFsWjRotiyZYvG8LGUlZVF//79/xn6du/ePVKplMZkuaampprXXnvtV2PGjHmgoqKiUUcAAIBPQgAMAAA56rjjjiv7r//6r8tdC508mzdvjuXLl8eKFSti+fLlsXjx4qipqdEY/pfi4uLo169f9O7dO/bZZ5/Yd999o6ysTGMSJJPJpJcsWfLn66677pfTp0/3mx8AAMAuIQAGAIAc99Of/nTIueeee3NpaWlf3UimxsbGWLlyZSxdujSWLVsWy5cvj3Xr1kUmk9GcZiKVSkWXLl1in332iT59+kSfPn2iV69eUVBQoDkJtXXr1sUPPvjgj6699tq/6wYAALArCYABAKAZaNeuXf64cePOGTp06BUFBQWtdST56uvrY+XKlf88KbxixYpYu3ZtpNNpzUm4vLy86Nq1a+yzzz7//KdXr17RsmVLzckBjY2NW/7617/+4pxzznm0srKySUcAAIBdTQAMAADNyIknntjmnnvuuXzfffcdk0qlHB3MMdu3b481a9bEmjVrYu3atbF27dooLy+PDRs2CIazUF5eXnTs2DG6desWXbt2jW7dukW3bt2iR48eUVhYqEE5JpPJNC5ZsuRR1z0DAAC7mwAYAACaoa9+9av7Xnfdddd16NDhCN3IfY2Njf8MhNetWxfr1q2LioqKWLduXWzbtk2DdrPS0tLo3LnzP//p0qVLdO3aNbp27eoK52Ziw4YNM//rv/7rxz/60Y+W6wYAALC7CYABAKAZ++UvfznirLPOuq64uNj3gZupmpqaWL9+/T//qaioiMrKyqisrIxNmzZFY2OjJn2AgoKCaN++fbRr1y7at28fHTt2jC5dukSnTp2ic+fOUVxcrEnN1NatW98aP378PVdcccXLugEAAOwpAmAAAGjm2rVrl//ggw+eOWLEiCsLCwvb6gjvtHnz5n+GwZs2bYrKysqorq6OLVu2xJYtW6K6ujqqq6sjk8nk3NpTqVS0bt06WrduHWVlZdGmTZsoLS39X2Fvu3btok2bNh4U/peGhobKl1566efnnHPO+OrqavevAwAAe5QAGAAAiIiIoUOHFt97770XHHjggRfk5+c7ssiHlk6n/xkEV1dXR01Nzfv+k8lkora2NtLpdNTX10dTU1PU1dXt0u8U5+XlRcuWLSM/Pz+KiooiLy8vWrVqFalUKoqLi3f6T0lJSbRq1eqfgW9paWnk5eUZMB9aU1NTzYIFC/745S9/+Y+zZ8+u0REAAGBvEAADAAD/y2mnndb2rrvuurRPnz5n5+XlFeoIe9LbgfDbtm/f/r7XUBcUFESLFi3++b/fDnxhT8pkMg1LliwZd8stt/xq0qRJVToCAADsTQJgAABgp0477bS2d95554X777//5wTBAP9XJpNpWLhw4QO33nrrHwS/AABAtni/ADi/7UHRc2c/SG+LqC33/gcAAHLZokWL6u69995X0un0swcddFCnkpKS3roC8A8VFRUz/7//7/+77aKLLpq6aNGiOh0BAACyRXH3xsgr3fnPBMAAAEDMnDmz8u67736qqalpWr9+/Ypbt27dN5VKpXQGaG4ymUx6zZo1U+65555/Peeccx6cOXNmpa4AAADZRgAMAAB8KDNnzqz88Y9//Gw6nZ4uCAaak7eD37vvvvtfzz///McEvwAAQDYTAAMAAB+JIBhoLgS/AABAEgmAAQCAj+XtILisrOyFvn37diwuLu4VEYJgIBdkKioqnrv33nu/PWbMmEcEvwAAQJK8XwCc2vecGLGzHzSui9j4aivdAwAA/unqq6/u8ZWvfOX8Pn36nJWXl9dCR4CkSafT9UuXLh3/X//1Xw/84he/WKMjAABAEnUYVhsFXXb+MwEwAADwkZ1xxhntb7/99rMPPPDA8/Pz81vrCJDtmpqaqhcsWPDgd77znUcmTpzotC8AAJBoAmAAAGC3GD58eMkPf/jDzwwePPjioqKijjoCZJv6+voNr7322u9vvPHGx2fPnl2jIwAAQC4QAAMAALvV0KFDi++5556zDjnkkPOKioq66giwt9XV1a19/fXXH7z++uvHC34BAIBcIwAGAAD2iFatWuXdc889w0455ZTzO3bseJSOAHtYZsOGDbOmTJny4PXXX/9qbW1tWksAAIBcJAAGAAD2uH/913/tf/7555/dq1ev0/Ly8lroCLC7pNPp+pUrV05+4IEHHvnOd76zSEcAAIBcJwAGAAD2mjPOOKP97bfffvYBBxzw2YKCgjY6AuwqjY2NVW+++eafv/e97z06YcKETToCAAA0FwJgAABgrxs+fHjJ97///dGDBg0aU1paur+OAB9XdXX1wtdee+3Rr371q1Nfe+21Wh0BAACaGwEwAACQVb761a/ue8EFF3y6b9++ZxUUFLTWEeCDNDY2bnnrrbfG/+EPf5j4ox/9aLmOAAAAzZkAGAAAyEpDhw4t/sEPfnDy4MGDz27dunV/HQHerbq6+s2XX375weuuu+7ppUuXbtcRAAAAATAAAJDlCgsLU3ffffeQ0aNHn9G1a9fj8vLyinQFmq90Ol1XXl4+bcqUKROuvfbav+sIAADA/yYABgAAEqNPnz4t/v3f/33UyJEjz2rfvv2nIiKlK9AsZDZt2vTXF1544bGvfe1rzzntCwAA8N4EwAAAQCJddNFFXa6++uqTDzzwwLNbtmzZTUcg99TV1a1ZsGDBuJ/+9KdP3n///et0BAAA4IMJgAEAgETr1q1b4d13333k4YcffmqHDh2OyMvLK9QVSK50Ot2wcePGWbNmzZp8/fXXz6qoqGjUFQAAgA9PAAwAAOSMo48+uvWtt956/CGHHHJKu3btBkdEnq5AIqQrKytfmzdv3uQ777xz+owZM6q1BAAA4OMRAAMAADnpuOOOK/vGN75x/CGHHHJa27ZtB4bvBUO2yVRVVc2dN2/epO9///vTpk+fvkVLAAAAPjkBMAAAkPNuu+22vmedddZJffr0Oa5Vq1a9dQT2ntra2uXLly+f/uijjz51xx13vKUjAAAAu5YAGAAAaFa+9KUvdbv44ouP7t+//wlOBsMekamqqpq7cOHCv/z+97+fcd9995VrCQAAwO4jAAYAAJqtSy65pOtll112jDAYdrl0VVXVvIULF/7lV7/61bO/+93v1moJAADAniEABgAAiIirr766x/nnnz9q//33P7JNmzZDUqlUga7Ah5fJZBoqKyv/vnjx4uf+9Kc/zbr33ntX6woAAMCeJwAGAAB4l379+hV97WtfGzRy5MhRPXv2PLaoqKizrsD/VV9fv37VqlXPvPDCC8/9+7//+5zFixfX6woAAMDeJQAGAAB4H61bt8678847Bx599NFHde/efURpaen+4apomq/M1q1bF69Zs+bF5557btY3v/nNOdXV1WltAQAAyB4CYAAAgI9g8ODBrcaOHXvI8OHDD+vevfvw1q1bHxACYXJXprq6+s01a9a88sorr7z8k5/8ZN5rr71Wqy0AAADZSwAMAADwCVx//fX7nHHGGYf169dvePv27Yfm5+e31hWSrLGxsXrjxo2vvvXWWy+PHz/+lR//+McrdQUAACA5BMAAAAC70Je//OUe55xzzvA+ffoM7tix45CioqKuukI2q6+vX7t27doXFy9ePGfixImv3Xvvvat1BQAAILkEwAAAALvRl7/85R6f+cxnBvfr129Qly5dDm/ZsqVAmL2qrq5u7bp16wS+AAAAOUoADAAAsIe0atUq75prrtnn2GOPPXi//fY7uH379oeUlpb2TaVS+brDbpKuqalZtnHjxnlvvfXW3GeffXbef/3Xfy2vra1Naw0AAEBuEgADAADsRQceeGDLq6+++oAhQ4Yc3LNnz4Pbtm17sGuj+biampqqq6qqXi8vL583Z86ceb/85S/nvfjii1t1BgAAoPkQAAMAAGSZoUOHFn/xi1/cf9CgQQf26NHjwHbt2h3YqlWr3qlUKk932CFdU1OzvLKycsHq1asXzJkzZ8Gf//znJTNmzKjWGgAAgOZNAAwAAJAAxx13XNkFF1xw4MEHH3xA165dDywtLd23pKRkn1QqVag7uS2TyTRs27ZtRXV19dJ169YtfOONNxZOmDBh4YQJEzbpDgAAAO8mAAYAAEiw8847r+OJJ57Yp3///vt16dKlT5s2bfZr3bp1v/z8/GLdSZampqaa6urqxZs3b16ybt26pQsXLlzy9NNPL33ooYc26A4AAAAflgAYAAAgx7Rr1y7/kksu6TFkyJCe++67b89OnTr1Kisr61VcXNyzZcuW3VKpVL4u7R2ZTKaprq6uvKamZtWWLVtWVlRUrFy6dOnK2bNnr7r//vvXVFZWNukSAAAAn4QAGAAAoBnp1KlTwec+97luQ4cO7bnPPvv0aNeuXafWrVt3Li4u7tqyZcvORUVFnfLy8lro1MeTTqe319fXr6+rq6uoqalZW11dvb6ysnL9ihUrVr/66qurHnzwwbUVFRWNOgUAAMDuIgAGAADgfznjjDPaH3bYYZ369OnTuUuXLp3Kysral5SUtC0uLu5YVFTUrqioqG2LFi065OfnlzaXnjQ1NW3dvn37xvr6+qr6+vrKmpqaDdu2bavasmXLpnXr1lUsXbp0/Ysvvrh+4sSJlZ4gAAAA9iYBMAAAAB9Lr169CkeNGtXuoIMOatexY8ey9u3bl7Zp06Z1SUlJWXFxcetWrVq1btGiRVlRUVHrwsLC1hGRX1hYWBoR+QUFBSV5eXkFeXl5u/0/LtPpdG06nW5sbGzcFhFNDQ0NW3f83+r6+vrq7du3b6mtra2uqamp3rZtW/XmzZurN23aVL1hw4YtCxYsqJo1a1bl0qVLt5s4AAAASSAABgAAYK/q169fUffu3Vvss88+xSUlJQVv//8LCwtT3bp1+8BTxuXl5VsbGhoyb//vbdu2Na5YsaJmzZo12xcvXlyvwwAAADQn7xcAF2gPAAAAu9vixYvrdwS11boBAAAAu0+eFgAAAAAAAADkBgEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4o0AIAAAAAAACA5GhoLIyCxoaIiEilIpNXGE1v/0wADAAAAAAAAJAghQUN/0x6MxGppvT/5L6ugAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAIb/v5272ZHiusM4/FZ1NUkz9sQwOF4EyZJtpJCwysa5jSy4n1xPEqRIuQFvvfGSgIwBOzGRQAQERnx0d1UW0cgWGvKxsMGvnmfVdc7/1OJsf+oCAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoMY3JP//9K8My551lzpAk293a7QAAAAAAAAD8iIw3r+SL7TpPxuSt4/ibJJuz20QDBgAAAAAAAHhzrJPp6NvHYcyyjLl7dJTPbl/Jp6sPLufSsM+5ec7q5YOrF0OeP/SVaAAAAAAAAIA3weH7u6zfm79dWDIMSw6225w785vsx3XyzasOby5ssz69c4sAAAAAAAAAr9n69C6bC9sT93a7rKdnORin5Otxynzi1JQcfiwCAwAAAAAAALxO69O7HH68TaaT98cp85R8vbp3Nfszv8q0LHn7xMF1sjk/ZzUPmZ/MmWefhAYAAAAAAAD4oayPdjn7223Gn7x6ZrXPnetX8mBKkpv3cufDd/Pufn5FL56SzcVtNheT3dNt8tQlAwAAAAAAAHyv1sm0ySv/9XtsNWZ3I/lHkgzHi7/4XY7WYz5yiwAAAAAAAAA/Ivtcv/3nPEyS1fHa42t5+vNLyX7JoRsCAAAAAAAAePPt1/nbV3/KvePn1Xc371/NYxEYAAAAAAAA4M0yTHk2rvNo2WdzvHZqzN9v/SF3vju3evng/at5fPDLPDu1yuGyZHSVAAAAAAAAAK/XOGe4ueSvZ4e8M8xZbVe5ceuPufvy3Oqkw4+v5emDX+fuuTlLhhwsEYIBAAAAAAAAXpclGR8OuXP0TR4cPM/9z/+SRyfNDf/1TZezOp/87KdjzizJZkhO7edMy/w/nAUAAAAAAADg/zaMWcZkP8/ZLsmLacr2/MV8+cnvs/tP5/4FmLjAq1ifcioAAAAASUVORK5CYII=", _chartCounter = 0, Slide, ImageSizingXml, VERSION = "3.12.0", PptxGenJS;
var init_pptxgen_es = __esm(() => {
  import_jszip = __toESM(require_lib(), 1);
  REGEX_HEX_COLOR = /^[0-9a-fA-F]{6}$/;
  DEF_CELL_BORDER = { type: "solid", color: "666666", pt: 1 };
  DEF_CELL_MARGIN_IN = [0.05, 0.1, 0.05, 0.1];
  DEF_CHART_BORDER = { type: "solid", color: "363636", pt: 1 };
  DEF_CHART_GRIDLINE = { color: "888888", style: "solid", size: 1, cap: "flat" };
  DEF_SHAPE_SHADOW = { type: "outer", blur: 3, offset: 23000 / 12700, angle: 90, color: "000000", opacity: 0.35, rotateWithShape: true };
  DEF_SLIDE_MARGIN_IN = [0.5, 0.5, 0.5, 0.5];
  DEF_TEXT_SHADOW = { type: "outer", blur: 8, offset: 4, angle: 270, color: "000000", opacity: 0.75 };
  DEF_TEXT_GLOW = { size: 8, color: "FFFFFF", opacity: 0.75 };
  LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
  BARCHART_COLORS = [
    "C0504D",
    "4F81BD",
    "9BBB59",
    "8064A2",
    "4BACC6",
    "F79646",
    "628FC6",
    "C86360",
    "C0504D",
    "4F81BD",
    "9BBB59",
    "8064A2",
    "4BACC6",
    "F79646",
    "628FC6",
    "C86360"
  ];
  PIECHART_COLORS = [
    "5DA5DA",
    "FAA43A",
    "60BD68",
    "F17CB0",
    "B2912F",
    "B276B2",
    "DECF3F",
    "F15854",
    "A7A7A7",
    "5DA5DA",
    "FAA43A",
    "60BD68",
    "F17CB0",
    "B2912F",
    "B276B2",
    "DECF3F",
    "F15854",
    "A7A7A7"
  ];
  (function(TEXT_HALIGN2) {
    TEXT_HALIGN2["left"] = "left";
    TEXT_HALIGN2["center"] = "center";
    TEXT_HALIGN2["right"] = "right";
    TEXT_HALIGN2["justify"] = "justify";
  })(TEXT_HALIGN || (TEXT_HALIGN = {}));
  (function(TEXT_VALIGN2) {
    TEXT_VALIGN2["b"] = "b";
    TEXT_VALIGN2["ctr"] = "ctr";
    TEXT_VALIGN2["t"] = "t";
  })(TEXT_VALIGN || (TEXT_VALIGN = {}));
  (function(OutputType2) {
    OutputType2["arraybuffer"] = "arraybuffer";
    OutputType2["base64"] = "base64";
    OutputType2["binarystring"] = "binarystring";
    OutputType2["blob"] = "blob";
    OutputType2["nodebuffer"] = "nodebuffer";
    OutputType2["uint8array"] = "uint8array";
  })(OutputType || (OutputType = {}));
  (function(ChartType2) {
    ChartType2["area"] = "area";
    ChartType2["bar"] = "bar";
    ChartType2["bar3d"] = "bar3D";
    ChartType2["bubble"] = "bubble";
    ChartType2["bubble3d"] = "bubble3D";
    ChartType2["doughnut"] = "doughnut";
    ChartType2["line"] = "line";
    ChartType2["pie"] = "pie";
    ChartType2["radar"] = "radar";
    ChartType2["scatter"] = "scatter";
  })(ChartType || (ChartType = {}));
  (function(ShapeType2) {
    ShapeType2["accentBorderCallout1"] = "accentBorderCallout1";
    ShapeType2["accentBorderCallout2"] = "accentBorderCallout2";
    ShapeType2["accentBorderCallout3"] = "accentBorderCallout3";
    ShapeType2["accentCallout1"] = "accentCallout1";
    ShapeType2["accentCallout2"] = "accentCallout2";
    ShapeType2["accentCallout3"] = "accentCallout3";
    ShapeType2["actionButtonBackPrevious"] = "actionButtonBackPrevious";
    ShapeType2["actionButtonBeginning"] = "actionButtonBeginning";
    ShapeType2["actionButtonBlank"] = "actionButtonBlank";
    ShapeType2["actionButtonDocument"] = "actionButtonDocument";
    ShapeType2["actionButtonEnd"] = "actionButtonEnd";
    ShapeType2["actionButtonForwardNext"] = "actionButtonForwardNext";
    ShapeType2["actionButtonHelp"] = "actionButtonHelp";
    ShapeType2["actionButtonHome"] = "actionButtonHome";
    ShapeType2["actionButtonInformation"] = "actionButtonInformation";
    ShapeType2["actionButtonMovie"] = "actionButtonMovie";
    ShapeType2["actionButtonReturn"] = "actionButtonReturn";
    ShapeType2["actionButtonSound"] = "actionButtonSound";
    ShapeType2["arc"] = "arc";
    ShapeType2["bentArrow"] = "bentArrow";
    ShapeType2["bentUpArrow"] = "bentUpArrow";
    ShapeType2["bevel"] = "bevel";
    ShapeType2["blockArc"] = "blockArc";
    ShapeType2["borderCallout1"] = "borderCallout1";
    ShapeType2["borderCallout2"] = "borderCallout2";
    ShapeType2["borderCallout3"] = "borderCallout3";
    ShapeType2["bracePair"] = "bracePair";
    ShapeType2["bracketPair"] = "bracketPair";
    ShapeType2["callout1"] = "callout1";
    ShapeType2["callout2"] = "callout2";
    ShapeType2["callout3"] = "callout3";
    ShapeType2["can"] = "can";
    ShapeType2["chartPlus"] = "chartPlus";
    ShapeType2["chartStar"] = "chartStar";
    ShapeType2["chartX"] = "chartX";
    ShapeType2["chevron"] = "chevron";
    ShapeType2["chord"] = "chord";
    ShapeType2["circularArrow"] = "circularArrow";
    ShapeType2["cloud"] = "cloud";
    ShapeType2["cloudCallout"] = "cloudCallout";
    ShapeType2["corner"] = "corner";
    ShapeType2["cornerTabs"] = "cornerTabs";
    ShapeType2["cube"] = "cube";
    ShapeType2["curvedDownArrow"] = "curvedDownArrow";
    ShapeType2["curvedLeftArrow"] = "curvedLeftArrow";
    ShapeType2["curvedRightArrow"] = "curvedRightArrow";
    ShapeType2["curvedUpArrow"] = "curvedUpArrow";
    ShapeType2["custGeom"] = "custGeom";
    ShapeType2["decagon"] = "decagon";
    ShapeType2["diagStripe"] = "diagStripe";
    ShapeType2["diamond"] = "diamond";
    ShapeType2["dodecagon"] = "dodecagon";
    ShapeType2["donut"] = "donut";
    ShapeType2["doubleWave"] = "doubleWave";
    ShapeType2["downArrow"] = "downArrow";
    ShapeType2["downArrowCallout"] = "downArrowCallout";
    ShapeType2["ellipse"] = "ellipse";
    ShapeType2["ellipseRibbon"] = "ellipseRibbon";
    ShapeType2["ellipseRibbon2"] = "ellipseRibbon2";
    ShapeType2["flowChartAlternateProcess"] = "flowChartAlternateProcess";
    ShapeType2["flowChartCollate"] = "flowChartCollate";
    ShapeType2["flowChartConnector"] = "flowChartConnector";
    ShapeType2["flowChartDecision"] = "flowChartDecision";
    ShapeType2["flowChartDelay"] = "flowChartDelay";
    ShapeType2["flowChartDisplay"] = "flowChartDisplay";
    ShapeType2["flowChartDocument"] = "flowChartDocument";
    ShapeType2["flowChartExtract"] = "flowChartExtract";
    ShapeType2["flowChartInputOutput"] = "flowChartInputOutput";
    ShapeType2["flowChartInternalStorage"] = "flowChartInternalStorage";
    ShapeType2["flowChartMagneticDisk"] = "flowChartMagneticDisk";
    ShapeType2["flowChartMagneticDrum"] = "flowChartMagneticDrum";
    ShapeType2["flowChartMagneticTape"] = "flowChartMagneticTape";
    ShapeType2["flowChartManualInput"] = "flowChartManualInput";
    ShapeType2["flowChartManualOperation"] = "flowChartManualOperation";
    ShapeType2["flowChartMerge"] = "flowChartMerge";
    ShapeType2["flowChartMultidocument"] = "flowChartMultidocument";
    ShapeType2["flowChartOfflineStorage"] = "flowChartOfflineStorage";
    ShapeType2["flowChartOffpageConnector"] = "flowChartOffpageConnector";
    ShapeType2["flowChartOnlineStorage"] = "flowChartOnlineStorage";
    ShapeType2["flowChartOr"] = "flowChartOr";
    ShapeType2["flowChartPredefinedProcess"] = "flowChartPredefinedProcess";
    ShapeType2["flowChartPreparation"] = "flowChartPreparation";
    ShapeType2["flowChartProcess"] = "flowChartProcess";
    ShapeType2["flowChartPunchedCard"] = "flowChartPunchedCard";
    ShapeType2["flowChartPunchedTape"] = "flowChartPunchedTape";
    ShapeType2["flowChartSort"] = "flowChartSort";
    ShapeType2["flowChartSummingJunction"] = "flowChartSummingJunction";
    ShapeType2["flowChartTerminator"] = "flowChartTerminator";
    ShapeType2["folderCorner"] = "folderCorner";
    ShapeType2["frame"] = "frame";
    ShapeType2["funnel"] = "funnel";
    ShapeType2["gear6"] = "gear6";
    ShapeType2["gear9"] = "gear9";
    ShapeType2["halfFrame"] = "halfFrame";
    ShapeType2["heart"] = "heart";
    ShapeType2["heptagon"] = "heptagon";
    ShapeType2["hexagon"] = "hexagon";
    ShapeType2["homePlate"] = "homePlate";
    ShapeType2["horizontalScroll"] = "horizontalScroll";
    ShapeType2["irregularSeal1"] = "irregularSeal1";
    ShapeType2["irregularSeal2"] = "irregularSeal2";
    ShapeType2["leftArrow"] = "leftArrow";
    ShapeType2["leftArrowCallout"] = "leftArrowCallout";
    ShapeType2["leftBrace"] = "leftBrace";
    ShapeType2["leftBracket"] = "leftBracket";
    ShapeType2["leftCircularArrow"] = "leftCircularArrow";
    ShapeType2["leftRightArrow"] = "leftRightArrow";
    ShapeType2["leftRightArrowCallout"] = "leftRightArrowCallout";
    ShapeType2["leftRightCircularArrow"] = "leftRightCircularArrow";
    ShapeType2["leftRightRibbon"] = "leftRightRibbon";
    ShapeType2["leftRightUpArrow"] = "leftRightUpArrow";
    ShapeType2["leftUpArrow"] = "leftUpArrow";
    ShapeType2["lightningBolt"] = "lightningBolt";
    ShapeType2["line"] = "line";
    ShapeType2["lineInv"] = "lineInv";
    ShapeType2["mathDivide"] = "mathDivide";
    ShapeType2["mathEqual"] = "mathEqual";
    ShapeType2["mathMinus"] = "mathMinus";
    ShapeType2["mathMultiply"] = "mathMultiply";
    ShapeType2["mathNotEqual"] = "mathNotEqual";
    ShapeType2["mathPlus"] = "mathPlus";
    ShapeType2["moon"] = "moon";
    ShapeType2["noSmoking"] = "noSmoking";
    ShapeType2["nonIsoscelesTrapezoid"] = "nonIsoscelesTrapezoid";
    ShapeType2["notchedRightArrow"] = "notchedRightArrow";
    ShapeType2["octagon"] = "octagon";
    ShapeType2["parallelogram"] = "parallelogram";
    ShapeType2["pentagon"] = "pentagon";
    ShapeType2["pie"] = "pie";
    ShapeType2["pieWedge"] = "pieWedge";
    ShapeType2["plaque"] = "plaque";
    ShapeType2["plaqueTabs"] = "plaqueTabs";
    ShapeType2["plus"] = "plus";
    ShapeType2["quadArrow"] = "quadArrow";
    ShapeType2["quadArrowCallout"] = "quadArrowCallout";
    ShapeType2["rect"] = "rect";
    ShapeType2["ribbon"] = "ribbon";
    ShapeType2["ribbon2"] = "ribbon2";
    ShapeType2["rightArrow"] = "rightArrow";
    ShapeType2["rightArrowCallout"] = "rightArrowCallout";
    ShapeType2["rightBrace"] = "rightBrace";
    ShapeType2["rightBracket"] = "rightBracket";
    ShapeType2["round1Rect"] = "round1Rect";
    ShapeType2["round2DiagRect"] = "round2DiagRect";
    ShapeType2["round2SameRect"] = "round2SameRect";
    ShapeType2["roundRect"] = "roundRect";
    ShapeType2["rtTriangle"] = "rtTriangle";
    ShapeType2["smileyFace"] = "smileyFace";
    ShapeType2["snip1Rect"] = "snip1Rect";
    ShapeType2["snip2DiagRect"] = "snip2DiagRect";
    ShapeType2["snip2SameRect"] = "snip2SameRect";
    ShapeType2["snipRoundRect"] = "snipRoundRect";
    ShapeType2["squareTabs"] = "squareTabs";
    ShapeType2["star10"] = "star10";
    ShapeType2["star12"] = "star12";
    ShapeType2["star16"] = "star16";
    ShapeType2["star24"] = "star24";
    ShapeType2["star32"] = "star32";
    ShapeType2["star4"] = "star4";
    ShapeType2["star5"] = "star5";
    ShapeType2["star6"] = "star6";
    ShapeType2["star7"] = "star7";
    ShapeType2["star8"] = "star8";
    ShapeType2["stripedRightArrow"] = "stripedRightArrow";
    ShapeType2["sun"] = "sun";
    ShapeType2["swooshArrow"] = "swooshArrow";
    ShapeType2["teardrop"] = "teardrop";
    ShapeType2["trapezoid"] = "trapezoid";
    ShapeType2["triangle"] = "triangle";
    ShapeType2["upArrow"] = "upArrow";
    ShapeType2["upArrowCallout"] = "upArrowCallout";
    ShapeType2["upDownArrow"] = "upDownArrow";
    ShapeType2["upDownArrowCallout"] = "upDownArrowCallout";
    ShapeType2["uturnArrow"] = "uturnArrow";
    ShapeType2["verticalScroll"] = "verticalScroll";
    ShapeType2["wave"] = "wave";
    ShapeType2["wedgeEllipseCallout"] = "wedgeEllipseCallout";
    ShapeType2["wedgeRectCallout"] = "wedgeRectCallout";
    ShapeType2["wedgeRoundRectCallout"] = "wedgeRoundRectCallout";
  })(ShapeType || (ShapeType = {}));
  (function(SchemeColor2) {
    SchemeColor2["text1"] = "tx1";
    SchemeColor2["text2"] = "tx2";
    SchemeColor2["background1"] = "bg1";
    SchemeColor2["background2"] = "bg2";
    SchemeColor2["accent1"] = "accent1";
    SchemeColor2["accent2"] = "accent2";
    SchemeColor2["accent3"] = "accent3";
    SchemeColor2["accent4"] = "accent4";
    SchemeColor2["accent5"] = "accent5";
    SchemeColor2["accent6"] = "accent6";
  })(SchemeColor || (SchemeColor = {}));
  (function(AlignH2) {
    AlignH2["left"] = "left";
    AlignH2["center"] = "center";
    AlignH2["right"] = "right";
    AlignH2["justify"] = "justify";
  })(AlignH || (AlignH = {}));
  (function(AlignV2) {
    AlignV2["top"] = "top";
    AlignV2["middle"] = "middle";
    AlignV2["bottom"] = "bottom";
  })(AlignV || (AlignV = {}));
  (function(SHAPE_TYPE2) {
    SHAPE_TYPE2["ACTION_BUTTON_BACK_OR_PREVIOUS"] = "actionButtonBackPrevious";
    SHAPE_TYPE2["ACTION_BUTTON_BEGINNING"] = "actionButtonBeginning";
    SHAPE_TYPE2["ACTION_BUTTON_CUSTOM"] = "actionButtonBlank";
    SHAPE_TYPE2["ACTION_BUTTON_DOCUMENT"] = "actionButtonDocument";
    SHAPE_TYPE2["ACTION_BUTTON_END"] = "actionButtonEnd";
    SHAPE_TYPE2["ACTION_BUTTON_FORWARD_OR_NEXT"] = "actionButtonForwardNext";
    SHAPE_TYPE2["ACTION_BUTTON_HELP"] = "actionButtonHelp";
    SHAPE_TYPE2["ACTION_BUTTON_HOME"] = "actionButtonHome";
    SHAPE_TYPE2["ACTION_BUTTON_INFORMATION"] = "actionButtonInformation";
    SHAPE_TYPE2["ACTION_BUTTON_MOVIE"] = "actionButtonMovie";
    SHAPE_TYPE2["ACTION_BUTTON_RETURN"] = "actionButtonReturn";
    SHAPE_TYPE2["ACTION_BUTTON_SOUND"] = "actionButtonSound";
    SHAPE_TYPE2["ARC"] = "arc";
    SHAPE_TYPE2["BALLOON"] = "wedgeRoundRectCallout";
    SHAPE_TYPE2["BENT_ARROW"] = "bentArrow";
    SHAPE_TYPE2["BENT_UP_ARROW"] = "bentUpArrow";
    SHAPE_TYPE2["BEVEL"] = "bevel";
    SHAPE_TYPE2["BLOCK_ARC"] = "blockArc";
    SHAPE_TYPE2["CAN"] = "can";
    SHAPE_TYPE2["CHART_PLUS"] = "chartPlus";
    SHAPE_TYPE2["CHART_STAR"] = "chartStar";
    SHAPE_TYPE2["CHART_X"] = "chartX";
    SHAPE_TYPE2["CHEVRON"] = "chevron";
    SHAPE_TYPE2["CHORD"] = "chord";
    SHAPE_TYPE2["CIRCULAR_ARROW"] = "circularArrow";
    SHAPE_TYPE2["CLOUD"] = "cloud";
    SHAPE_TYPE2["CLOUD_CALLOUT"] = "cloudCallout";
    SHAPE_TYPE2["CORNER"] = "corner";
    SHAPE_TYPE2["CORNER_TABS"] = "cornerTabs";
    SHAPE_TYPE2["CROSS"] = "plus";
    SHAPE_TYPE2["CUBE"] = "cube";
    SHAPE_TYPE2["CURVED_DOWN_ARROW"] = "curvedDownArrow";
    SHAPE_TYPE2["CURVED_DOWN_RIBBON"] = "ellipseRibbon";
    SHAPE_TYPE2["CURVED_LEFT_ARROW"] = "curvedLeftArrow";
    SHAPE_TYPE2["CURVED_RIGHT_ARROW"] = "curvedRightArrow";
    SHAPE_TYPE2["CURVED_UP_ARROW"] = "curvedUpArrow";
    SHAPE_TYPE2["CURVED_UP_RIBBON"] = "ellipseRibbon2";
    SHAPE_TYPE2["CUSTOM_GEOMETRY"] = "custGeom";
    SHAPE_TYPE2["DECAGON"] = "decagon";
    SHAPE_TYPE2["DIAGONAL_STRIPE"] = "diagStripe";
    SHAPE_TYPE2["DIAMOND"] = "diamond";
    SHAPE_TYPE2["DODECAGON"] = "dodecagon";
    SHAPE_TYPE2["DONUT"] = "donut";
    SHAPE_TYPE2["DOUBLE_BRACE"] = "bracePair";
    SHAPE_TYPE2["DOUBLE_BRACKET"] = "bracketPair";
    SHAPE_TYPE2["DOUBLE_WAVE"] = "doubleWave";
    SHAPE_TYPE2["DOWN_ARROW"] = "downArrow";
    SHAPE_TYPE2["DOWN_ARROW_CALLOUT"] = "downArrowCallout";
    SHAPE_TYPE2["DOWN_RIBBON"] = "ribbon";
    SHAPE_TYPE2["EXPLOSION1"] = "irregularSeal1";
    SHAPE_TYPE2["EXPLOSION2"] = "irregularSeal2";
    SHAPE_TYPE2["FLOWCHART_ALTERNATE_PROCESS"] = "flowChartAlternateProcess";
    SHAPE_TYPE2["FLOWCHART_CARD"] = "flowChartPunchedCard";
    SHAPE_TYPE2["FLOWCHART_COLLATE"] = "flowChartCollate";
    SHAPE_TYPE2["FLOWCHART_CONNECTOR"] = "flowChartConnector";
    SHAPE_TYPE2["FLOWCHART_DATA"] = "flowChartInputOutput";
    SHAPE_TYPE2["FLOWCHART_DECISION"] = "flowChartDecision";
    SHAPE_TYPE2["FLOWCHART_DELAY"] = "flowChartDelay";
    SHAPE_TYPE2["FLOWCHART_DIRECT_ACCESS_STORAGE"] = "flowChartMagneticDrum";
    SHAPE_TYPE2["FLOWCHART_DISPLAY"] = "flowChartDisplay";
    SHAPE_TYPE2["FLOWCHART_DOCUMENT"] = "flowChartDocument";
    SHAPE_TYPE2["FLOWCHART_EXTRACT"] = "flowChartExtract";
    SHAPE_TYPE2["FLOWCHART_INTERNAL_STORAGE"] = "flowChartInternalStorage";
    SHAPE_TYPE2["FLOWCHART_MAGNETIC_DISK"] = "flowChartMagneticDisk";
    SHAPE_TYPE2["FLOWCHART_MANUAL_INPUT"] = "flowChartManualInput";
    SHAPE_TYPE2["FLOWCHART_MANUAL_OPERATION"] = "flowChartManualOperation";
    SHAPE_TYPE2["FLOWCHART_MERGE"] = "flowChartMerge";
    SHAPE_TYPE2["FLOWCHART_MULTIDOCUMENT"] = "flowChartMultidocument";
    SHAPE_TYPE2["FLOWCHART_OFFLINE_STORAGE"] = "flowChartOfflineStorage";
    SHAPE_TYPE2["FLOWCHART_OFFPAGE_CONNECTOR"] = "flowChartOffpageConnector";
    SHAPE_TYPE2["FLOWCHART_OR"] = "flowChartOr";
    SHAPE_TYPE2["FLOWCHART_PREDEFINED_PROCESS"] = "flowChartPredefinedProcess";
    SHAPE_TYPE2["FLOWCHART_PREPARATION"] = "flowChartPreparation";
    SHAPE_TYPE2["FLOWCHART_PROCESS"] = "flowChartProcess";
    SHAPE_TYPE2["FLOWCHART_PUNCHED_TAPE"] = "flowChartPunchedTape";
    SHAPE_TYPE2["FLOWCHART_SEQUENTIAL_ACCESS_STORAGE"] = "flowChartMagneticTape";
    SHAPE_TYPE2["FLOWCHART_SORT"] = "flowChartSort";
    SHAPE_TYPE2["FLOWCHART_STORED_DATA"] = "flowChartOnlineStorage";
    SHAPE_TYPE2["FLOWCHART_SUMMING_JUNCTION"] = "flowChartSummingJunction";
    SHAPE_TYPE2["FLOWCHART_TERMINATOR"] = "flowChartTerminator";
    SHAPE_TYPE2["FOLDED_CORNER"] = "folderCorner";
    SHAPE_TYPE2["FRAME"] = "frame";
    SHAPE_TYPE2["FUNNEL"] = "funnel";
    SHAPE_TYPE2["GEAR_6"] = "gear6";
    SHAPE_TYPE2["GEAR_9"] = "gear9";
    SHAPE_TYPE2["HALF_FRAME"] = "halfFrame";
    SHAPE_TYPE2["HEART"] = "heart";
    SHAPE_TYPE2["HEPTAGON"] = "heptagon";
    SHAPE_TYPE2["HEXAGON"] = "hexagon";
    SHAPE_TYPE2["HORIZONTAL_SCROLL"] = "horizontalScroll";
    SHAPE_TYPE2["ISOSCELES_TRIANGLE"] = "triangle";
    SHAPE_TYPE2["LEFT_ARROW"] = "leftArrow";
    SHAPE_TYPE2["LEFT_ARROW_CALLOUT"] = "leftArrowCallout";
    SHAPE_TYPE2["LEFT_BRACE"] = "leftBrace";
    SHAPE_TYPE2["LEFT_BRACKET"] = "leftBracket";
    SHAPE_TYPE2["LEFT_CIRCULAR_ARROW"] = "leftCircularArrow";
    SHAPE_TYPE2["LEFT_RIGHT_ARROW"] = "leftRightArrow";
    SHAPE_TYPE2["LEFT_RIGHT_ARROW_CALLOUT"] = "leftRightArrowCallout";
    SHAPE_TYPE2["LEFT_RIGHT_CIRCULAR_ARROW"] = "leftRightCircularArrow";
    SHAPE_TYPE2["LEFT_RIGHT_RIBBON"] = "leftRightRibbon";
    SHAPE_TYPE2["LEFT_RIGHT_UP_ARROW"] = "leftRightUpArrow";
    SHAPE_TYPE2["LEFT_UP_ARROW"] = "leftUpArrow";
    SHAPE_TYPE2["LIGHTNING_BOLT"] = "lightningBolt";
    SHAPE_TYPE2["LINE_CALLOUT_1"] = "borderCallout1";
    SHAPE_TYPE2["LINE_CALLOUT_1_ACCENT_BAR"] = "accentCallout1";
    SHAPE_TYPE2["LINE_CALLOUT_1_BORDER_AND_ACCENT_BAR"] = "accentBorderCallout1";
    SHAPE_TYPE2["LINE_CALLOUT_1_NO_BORDER"] = "callout1";
    SHAPE_TYPE2["LINE_CALLOUT_2"] = "borderCallout2";
    SHAPE_TYPE2["LINE_CALLOUT_2_ACCENT_BAR"] = "accentCallout2";
    SHAPE_TYPE2["LINE_CALLOUT_2_BORDER_AND_ACCENT_BAR"] = "accentBorderCallout2";
    SHAPE_TYPE2["LINE_CALLOUT_2_NO_BORDER"] = "callout2";
    SHAPE_TYPE2["LINE_CALLOUT_3"] = "borderCallout3";
    SHAPE_TYPE2["LINE_CALLOUT_3_ACCENT_BAR"] = "accentCallout3";
    SHAPE_TYPE2["LINE_CALLOUT_3_BORDER_AND_ACCENT_BAR"] = "accentBorderCallout3";
    SHAPE_TYPE2["LINE_CALLOUT_3_NO_BORDER"] = "callout3";
    SHAPE_TYPE2["LINE_CALLOUT_4"] = "borderCallout3";
    SHAPE_TYPE2["LINE_CALLOUT_4_ACCENT_BAR"] = "accentCallout3";
    SHAPE_TYPE2["LINE_CALLOUT_4_BORDER_AND_ACCENT_BAR"] = "accentBorderCallout3";
    SHAPE_TYPE2["LINE_CALLOUT_4_NO_BORDER"] = "callout3";
    SHAPE_TYPE2["LINE"] = "line";
    SHAPE_TYPE2["LINE_INVERSE"] = "lineInv";
    SHAPE_TYPE2["MATH_DIVIDE"] = "mathDivide";
    SHAPE_TYPE2["MATH_EQUAL"] = "mathEqual";
    SHAPE_TYPE2["MATH_MINUS"] = "mathMinus";
    SHAPE_TYPE2["MATH_MULTIPLY"] = "mathMultiply";
    SHAPE_TYPE2["MATH_NOT_EQUAL"] = "mathNotEqual";
    SHAPE_TYPE2["MATH_PLUS"] = "mathPlus";
    SHAPE_TYPE2["MOON"] = "moon";
    SHAPE_TYPE2["NON_ISOSCELES_TRAPEZOID"] = "nonIsoscelesTrapezoid";
    SHAPE_TYPE2["NOTCHED_RIGHT_ARROW"] = "notchedRightArrow";
    SHAPE_TYPE2["NO_SYMBOL"] = "noSmoking";
    SHAPE_TYPE2["OCTAGON"] = "octagon";
    SHAPE_TYPE2["OVAL"] = "ellipse";
    SHAPE_TYPE2["OVAL_CALLOUT"] = "wedgeEllipseCallout";
    SHAPE_TYPE2["PARALLELOGRAM"] = "parallelogram";
    SHAPE_TYPE2["PENTAGON"] = "homePlate";
    SHAPE_TYPE2["PIE"] = "pie";
    SHAPE_TYPE2["PIE_WEDGE"] = "pieWedge";
    SHAPE_TYPE2["PLAQUE"] = "plaque";
    SHAPE_TYPE2["PLAQUE_TABS"] = "plaqueTabs";
    SHAPE_TYPE2["QUAD_ARROW"] = "quadArrow";
    SHAPE_TYPE2["QUAD_ARROW_CALLOUT"] = "quadArrowCallout";
    SHAPE_TYPE2["RECTANGLE"] = "rect";
    SHAPE_TYPE2["RECTANGULAR_CALLOUT"] = "wedgeRectCallout";
    SHAPE_TYPE2["REGULAR_PENTAGON"] = "pentagon";
    SHAPE_TYPE2["RIGHT_ARROW"] = "rightArrow";
    SHAPE_TYPE2["RIGHT_ARROW_CALLOUT"] = "rightArrowCallout";
    SHAPE_TYPE2["RIGHT_BRACE"] = "rightBrace";
    SHAPE_TYPE2["RIGHT_BRACKET"] = "rightBracket";
    SHAPE_TYPE2["RIGHT_TRIANGLE"] = "rtTriangle";
    SHAPE_TYPE2["ROUNDED_RECTANGLE"] = "roundRect";
    SHAPE_TYPE2["ROUNDED_RECTANGULAR_CALLOUT"] = "wedgeRoundRectCallout";
    SHAPE_TYPE2["ROUND_1_RECTANGLE"] = "round1Rect";
    SHAPE_TYPE2["ROUND_2_DIAG_RECTANGLE"] = "round2DiagRect";
    SHAPE_TYPE2["ROUND_2_SAME_RECTANGLE"] = "round2SameRect";
    SHAPE_TYPE2["SMILEY_FACE"] = "smileyFace";
    SHAPE_TYPE2["SNIP_1_RECTANGLE"] = "snip1Rect";
    SHAPE_TYPE2["SNIP_2_DIAG_RECTANGLE"] = "snip2DiagRect";
    SHAPE_TYPE2["SNIP_2_SAME_RECTANGLE"] = "snip2SameRect";
    SHAPE_TYPE2["SNIP_ROUND_RECTANGLE"] = "snipRoundRect";
    SHAPE_TYPE2["SQUARE_TABS"] = "squareTabs";
    SHAPE_TYPE2["STAR_10_POINT"] = "star10";
    SHAPE_TYPE2["STAR_12_POINT"] = "star12";
    SHAPE_TYPE2["STAR_16_POINT"] = "star16";
    SHAPE_TYPE2["STAR_24_POINT"] = "star24";
    SHAPE_TYPE2["STAR_32_POINT"] = "star32";
    SHAPE_TYPE2["STAR_4_POINT"] = "star4";
    SHAPE_TYPE2["STAR_5_POINT"] = "star5";
    SHAPE_TYPE2["STAR_6_POINT"] = "star6";
    SHAPE_TYPE2["STAR_7_POINT"] = "star7";
    SHAPE_TYPE2["STAR_8_POINT"] = "star8";
    SHAPE_TYPE2["STRIPED_RIGHT_ARROW"] = "stripedRightArrow";
    SHAPE_TYPE2["SUN"] = "sun";
    SHAPE_TYPE2["SWOOSH_ARROW"] = "swooshArrow";
    SHAPE_TYPE2["TEAR"] = "teardrop";
    SHAPE_TYPE2["TRAPEZOID"] = "trapezoid";
    SHAPE_TYPE2["UP_ARROW"] = "upArrow";
    SHAPE_TYPE2["UP_ARROW_CALLOUT"] = "upArrowCallout";
    SHAPE_TYPE2["UP_DOWN_ARROW"] = "upDownArrow";
    SHAPE_TYPE2["UP_DOWN_ARROW_CALLOUT"] = "upDownArrowCallout";
    SHAPE_TYPE2["UP_RIBBON"] = "ribbon2";
    SHAPE_TYPE2["U_TURN_ARROW"] = "uturnArrow";
    SHAPE_TYPE2["VERTICAL_SCROLL"] = "verticalScroll";
    SHAPE_TYPE2["WAVE"] = "wave";
  })(SHAPE_TYPE || (SHAPE_TYPE = {}));
  (function(CHART_TYPE2) {
    CHART_TYPE2["AREA"] = "area";
    CHART_TYPE2["BAR"] = "bar";
    CHART_TYPE2["BAR3D"] = "bar3D";
    CHART_TYPE2["BUBBLE"] = "bubble";
    CHART_TYPE2["BUBBLE3D"] = "bubble3D";
    CHART_TYPE2["DOUGHNUT"] = "doughnut";
    CHART_TYPE2["LINE"] = "line";
    CHART_TYPE2["PIE"] = "pie";
    CHART_TYPE2["RADAR"] = "radar";
    CHART_TYPE2["SCATTER"] = "scatter";
  })(CHART_TYPE || (CHART_TYPE = {}));
  (function(SCHEME_COLOR_NAMES2) {
    SCHEME_COLOR_NAMES2["TEXT1"] = "tx1";
    SCHEME_COLOR_NAMES2["TEXT2"] = "tx2";
    SCHEME_COLOR_NAMES2["BACKGROUND1"] = "bg1";
    SCHEME_COLOR_NAMES2["BACKGROUND2"] = "bg2";
    SCHEME_COLOR_NAMES2["ACCENT1"] = "accent1";
    SCHEME_COLOR_NAMES2["ACCENT2"] = "accent2";
    SCHEME_COLOR_NAMES2["ACCENT3"] = "accent3";
    SCHEME_COLOR_NAMES2["ACCENT4"] = "accent4";
    SCHEME_COLOR_NAMES2["ACCENT5"] = "accent5";
    SCHEME_COLOR_NAMES2["ACCENT6"] = "accent6";
  })(SCHEME_COLOR_NAMES || (SCHEME_COLOR_NAMES = {}));
  (function(MASTER_OBJECTS2) {
    MASTER_OBJECTS2["chart"] = "chart";
    MASTER_OBJECTS2["image"] = "image";
    MASTER_OBJECTS2["line"] = "line";
    MASTER_OBJECTS2["rect"] = "rect";
    MASTER_OBJECTS2["text"] = "text";
    MASTER_OBJECTS2["placeholder"] = "placeholder";
  })(MASTER_OBJECTS || (MASTER_OBJECTS = {}));
  (function(SLIDE_OBJECT_TYPES2) {
    SLIDE_OBJECT_TYPES2["chart"] = "chart";
    SLIDE_OBJECT_TYPES2["hyperlink"] = "hyperlink";
    SLIDE_OBJECT_TYPES2["image"] = "image";
    SLIDE_OBJECT_TYPES2["media"] = "media";
    SLIDE_OBJECT_TYPES2["online"] = "online";
    SLIDE_OBJECT_TYPES2["placeholder"] = "placeholder";
    SLIDE_OBJECT_TYPES2["table"] = "table";
    SLIDE_OBJECT_TYPES2["tablecell"] = "tablecell";
    SLIDE_OBJECT_TYPES2["text"] = "text";
    SLIDE_OBJECT_TYPES2["notes"] = "notes";
  })(SLIDE_OBJECT_TYPES || (SLIDE_OBJECT_TYPES = {}));
  (function(PLACEHOLDER_TYPES2) {
    PLACEHOLDER_TYPES2["title"] = "title";
    PLACEHOLDER_TYPES2["body"] = "body";
    PLACEHOLDER_TYPES2["image"] = "pic";
    PLACEHOLDER_TYPES2["chart"] = "chart";
    PLACEHOLDER_TYPES2["table"] = "tbl";
    PLACEHOLDER_TYPES2["media"] = "media";
  })(PLACEHOLDER_TYPES || (PLACEHOLDER_TYPES = {}));
  (function(BULLET_TYPES2) {
    BULLET_TYPES2["DEFAULT"] = "&#x2022;";
    BULLET_TYPES2["CHECK"] = "&#x2713;";
    BULLET_TYPES2["STAR"] = "&#x2605;";
    BULLET_TYPES2["TRIANGLE"] = "&#x25B6;";
  })(BULLET_TYPES || (BULLET_TYPES = {}));
  Slide = function() {
    function Slide2(params) {
      var _a;
      this.addSlide = params.addSlide;
      this.getSlide = params.getSlide;
      this._name = "Slide ".concat(params.slideNumber);
      this._presLayout = params.presLayout;
      this._rId = params.slideRId;
      this._rels = [];
      this._relsChart = [];
      this._relsMedia = [];
      this._setSlideNum = params.setSlideNum;
      this._slideId = params.slideId;
      this._slideLayout = params.slideLayout || null;
      this._slideNum = params.slideNumber;
      this._slideObjects = [];
      this._slideNumberProps = ((_a = this._slideLayout) === null || _a === undefined ? undefined : _a._slideNumberProps) ? this._slideLayout._slideNumberProps : null;
    }
    Object.defineProperty(Slide2.prototype, "bkgd", {
      get: function() {
        return this._bkgd;
      },
      set: function(value) {
        this._bkgd = value;
        if (!this._background || !this._background.color) {
          if (!this._background)
            this._background = {};
          if (typeof value === "string")
            this._background.color = value;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slide2.prototype, "background", {
      get: function() {
        return this._background;
      },
      set: function(props) {
        this._background = props;
        if (props)
          addBackgroundDefinition(props, this);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slide2.prototype, "color", {
      get: function() {
        return this._color;
      },
      set: function(value) {
        this._color = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slide2.prototype, "hidden", {
      get: function() {
        return this._hidden;
      },
      set: function(value) {
        this._hidden = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slide2.prototype, "slideNumber", {
      get: function() {
        return this._slideNumberProps;
      },
      set: function(value) {
        this._slideNumberProps = value;
        this._setSlideNum(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slide2.prototype, "newAutoPagedSlides", {
      get: function() {
        return this._newAutoPagedSlides;
      },
      enumerable: false,
      configurable: true
    });
    Slide2.prototype.addChart = function(type, data, options2) {
      var optionsWithType = options2 || {};
      optionsWithType._type = type;
      addChartDefinition(this, type, data, options2);
      return this;
    };
    Slide2.prototype.addImage = function(options2) {
      addImageDefinition(this, options2);
      return this;
    };
    Slide2.prototype.addMedia = function(options2) {
      addMediaDefinition(this, options2);
      return this;
    };
    Slide2.prototype.addNotes = function(notes) {
      addNotesDefinition(this, notes);
      return this;
    };
    Slide2.prototype.addShape = function(shapeName, options2) {
      addShapeDefinition(this, shapeName, options2);
      return this;
    };
    Slide2.prototype.addTable = function(tableRows, options2) {
      this._newAutoPagedSlides = addTableDefinition(this, tableRows, options2, this._slideLayout, this._presLayout, this.addSlide, this.getSlide);
      return this;
    };
    Slide2.prototype.addText = function(text2, options2) {
      var textParam = typeof text2 === "string" || typeof text2 === "number" ? [{ text: text2, options: options2 }] : text2;
      addTextDefinition(this, textParam, options2, false);
      return this;
    };
    return Slide2;
  }();
  ImageSizingXml = {
    cover: function(imgSize, boxDim) {
      var imgRatio = imgSize.h / imgSize.w;
      var boxRatio = boxDim.h / boxDim.w;
      var isBoxBased = boxRatio > imgRatio;
      var width = isBoxBased ? boxDim.h / imgRatio : boxDim.w;
      var height = isBoxBased ? boxDim.h : boxDim.w * imgRatio;
      var hzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.w / width));
      var vzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.h / height));
      return '<a:srcRect l="'.concat(hzPerc, '" r="').concat(hzPerc, '" t="').concat(vzPerc, '" b="').concat(vzPerc, '"/><a:stretch/>');
    },
    contain: function(imgSize, boxDim) {
      var imgRatio = imgSize.h / imgSize.w;
      var boxRatio = boxDim.h / boxDim.w;
      var widthBased = boxRatio > imgRatio;
      var width = widthBased ? boxDim.w : boxDim.h / imgRatio;
      var height = widthBased ? boxDim.w * imgRatio : boxDim.h;
      var hzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.w / width));
      var vzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.h / height));
      return '<a:srcRect l="'.concat(hzPerc, '" r="').concat(hzPerc, '" t="').concat(vzPerc, '" b="').concat(vzPerc, '"/><a:stretch/>');
    },
    crop: function(imgSize, boxDim) {
      var l4 = boxDim.x;
      var r3 = imgSize.w - (boxDim.x + boxDim.w);
      var t2 = boxDim.y;
      var b4 = imgSize.h - (boxDim.y + boxDim.h);
      var lPerc = Math.round(1e5 * (l4 / imgSize.w));
      var rPerc = Math.round(1e5 * (r3 / imgSize.w));
      var tPerc = Math.round(1e5 * (t2 / imgSize.h));
      var bPerc = Math.round(1e5 * (b4 / imgSize.h));
      return '<a:srcRect l="'.concat(lPerc, '" r="').concat(rPerc, '" t="').concat(tPerc, '" b="').concat(bPerc, '"/><a:stretch/>');
    }
  };
  PptxGenJS = function() {
    function PptxGenJS2() {
      var _this = this;
      this._version = VERSION;
      this._alignH = AlignH;
      this._alignV = AlignV;
      this._chartType = ChartType;
      this._outputType = OutputType;
      this._schemeColor = SchemeColor;
      this._shapeType = ShapeType;
      this._charts = CHART_TYPE;
      this._colors = SCHEME_COLOR_NAMES;
      this._shapes = SHAPE_TYPE;
      this.addNewSlide = function(options2) {
        var sectAlreadyInUse = _this.sections.length > 0 && _this.sections[_this.sections.length - 1]._slides.filter(function(slide) {
          return slide._slideNum === _this.slides[_this.slides.length - 1]._slideNum;
        }).length > 0;
        options2.sectionTitle = sectAlreadyInUse ? _this.sections[_this.sections.length - 1].title : null;
        return _this.addSlide(options2);
      };
      this.getSlide = function(slideNum) {
        return _this.slides.filter(function(slide) {
          return slide._slideNum === slideNum;
        })[0];
      };
      this.setSlideNumber = function(slideNum) {
        _this.masterSlide._slideNumberProps = slideNum;
        _this.slideLayouts.filter(function(layout) {
          return layout._name === DEF_PRES_LAYOUT_NAME;
        })[0]._slideNumberProps = slideNum;
      };
      this.createChartMediaRels = function(slide, zip, chartPromises) {
        slide._relsChart.forEach(function(rel) {
          return chartPromises.push(createExcelWorksheet(rel, zip));
        });
        slide._relsMedia.forEach(function(rel) {
          if (rel.type !== "online" && rel.type !== "hyperlink") {
            var data = rel.data && typeof rel.data === "string" ? rel.data : "";
            if (!data.includes(",") && !data.includes(";"))
              data = "image/png;base64," + data;
            else if (!data.includes(","))
              data = "image/png;base64," + data;
            else if (!data.includes(";"))
              data = "image/png;" + data;
            zip.file(rel.Target.replace("..", "ppt"), data.split(",").pop(), { base64: true });
          }
        });
      };
      this.writeFileToBrowser = function(exportName, blobContent) {
        return __awaiter(_this, undefined, undefined, function() {
          var eleLink, url_1;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                eleLink = document.createElement("a");
                eleLink.setAttribute("style", "display:none;");
                eleLink.dataset.interception = "off";
                document.body.appendChild(eleLink);
                if (!window.URL.createObjectURL)
                  return [3, 2];
                url_1 = window.URL.createObjectURL(new Blob([blobContent], { type: "application/vnd.openxmlformats-officedocument.presentationml.presentation" }));
                eleLink.href = url_1;
                eleLink.download = exportName;
                eleLink.click();
                setTimeout(function() {
                  window.URL.revokeObjectURL(url_1);
                  document.body.removeChild(eleLink);
                }, 100);
                return [4, Promise.resolve(exportName)];
              case 1:
                return [2, _a.sent()];
              case 2:
                return [2];
            }
          });
        });
      };
      this.exportPresentation = function(props) {
        return __awaiter(_this, undefined, undefined, function() {
          var arrChartPromises, arrMediaPromises, zip;
          var _this2 = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                arrChartPromises = [];
                arrMediaPromises = [];
                zip = new import_jszip.default;
                this.slides.forEach(function(slide) {
                  arrMediaPromises = arrMediaPromises.concat(encodeSlideMediaRels(slide));
                });
                this.slideLayouts.forEach(function(layout) {
                  arrMediaPromises = arrMediaPromises.concat(encodeSlideMediaRels(layout));
                });
                arrMediaPromises = arrMediaPromises.concat(encodeSlideMediaRels(this.masterSlide));
                return [4, Promise.all(arrMediaPromises).then(function() {
                  return __awaiter(_this2, undefined, undefined, function() {
                    var _this3 = this;
                    return __generator(this, function(_a2) {
                      switch (_a2.label) {
                        case 0:
                          this.slides.forEach(function(slide) {
                            if (slide._slideLayout)
                              addPlaceholdersToSlideLayouts(slide);
                          });
                          zip.folder("_rels");
                          zip.folder("docProps");
                          zip.folder("ppt").folder("_rels");
                          zip.folder("ppt/charts").folder("_rels");
                          zip.folder("ppt/embeddings");
                          zip.folder("ppt/media");
                          zip.folder("ppt/slideLayouts").folder("_rels");
                          zip.folder("ppt/slideMasters").folder("_rels");
                          zip.folder("ppt/slides").folder("_rels");
                          zip.folder("ppt/theme");
                          zip.folder("ppt/notesMasters").folder("_rels");
                          zip.folder("ppt/notesSlides").folder("_rels");
                          zip.file("[Content_Types].xml", makeXmlContTypes(this.slides, this.slideLayouts, this.masterSlide));
                          zip.file("_rels/.rels", makeXmlRootRels());
                          zip.file("docProps/app.xml", makeXmlApp(this.slides, this.company));
                          zip.file("docProps/core.xml", makeXmlCore(this.title, this.subject, this.author, this.revision));
                          zip.file("ppt/_rels/presentation.xml.rels", makeXmlPresentationRels(this.slides));
                          zip.file("ppt/theme/theme1.xml", makeXmlTheme(this));
                          zip.file("ppt/presentation.xml", makeXmlPresentation(this));
                          zip.file("ppt/presProps.xml", makeXmlPresProps());
                          zip.file("ppt/tableStyles.xml", makeXmlTableStyles());
                          zip.file("ppt/viewProps.xml", makeXmlViewProps());
                          this.slideLayouts.forEach(function(layout, idx) {
                            zip.file("ppt/slideLayouts/slideLayout".concat(idx + 1, ".xml"), makeXmlLayout(layout));
                            zip.file("ppt/slideLayouts/_rels/slideLayout".concat(idx + 1, ".xml.rels"), makeXmlSlideLayoutRel(idx + 1, _this3.slideLayouts));
                          });
                          this.slides.forEach(function(slide, idx) {
                            zip.file("ppt/slides/slide".concat(idx + 1, ".xml"), makeXmlSlide(slide));
                            zip.file("ppt/slides/_rels/slide".concat(idx + 1, ".xml.rels"), makeXmlSlideRel(_this3.slides, _this3.slideLayouts, idx + 1));
                            zip.file("ppt/notesSlides/notesSlide".concat(idx + 1, ".xml"), makeXmlNotesSlide(slide));
                            zip.file("ppt/notesSlides/_rels/notesSlide".concat(idx + 1, ".xml.rels"), makeXmlNotesSlideRel(idx + 1));
                          });
                          zip.file("ppt/slideMasters/slideMaster1.xml", makeXmlMaster(this.masterSlide, this.slideLayouts));
                          zip.file("ppt/slideMasters/_rels/slideMaster1.xml.rels", makeXmlMasterRel(this.masterSlide, this.slideLayouts));
                          zip.file("ppt/notesMasters/notesMaster1.xml", makeXmlNotesMaster());
                          zip.file("ppt/notesMasters/_rels/notesMaster1.xml.rels", makeXmlNotesMasterRel());
                          this.slideLayouts.forEach(function(layout) {
                            _this3.createChartMediaRels(layout, zip, arrChartPromises);
                          });
                          this.slides.forEach(function(slide) {
                            _this3.createChartMediaRels(slide, zip, arrChartPromises);
                          });
                          this.createChartMediaRels(this.masterSlide, zip, arrChartPromises);
                          return [4, Promise.all(arrChartPromises).then(function() {
                            return __awaiter(_this3, undefined, undefined, function() {
                              return __generator(this, function(_a3) {
                                switch (_a3.label) {
                                  case 0:
                                    if (!(props.outputType === "STREAM"))
                                      return [3, 2];
                                    return [4, zip.generateAsync({ type: "nodebuffer", compression: props.compression ? "DEFLATE" : "STORE" })];
                                  case 1:
                                    return [2, _a3.sent()];
                                  case 2:
                                    if (!props.outputType)
                                      return [3, 4];
                                    return [4, zip.generateAsync({ type: props.outputType })];
                                  case 3:
                                    return [2, _a3.sent()];
                                  case 4:
                                    return [4, zip.generateAsync({ type: "blob", compression: props.compression ? "DEFLATE" : "STORE" })];
                                  case 5:
                                    return [2, _a3.sent()];
                                }
                              });
                            });
                          })];
                        case 1:
                          return [2, _a2.sent()];
                      }
                    });
                  });
                })];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      };
      var layout4x3 = { name: "screen4x3", width: 9144000, height: 6858000 };
      var layout16x9 = { name: "screen16x9", width: 9144000, height: 5143500 };
      var layout16x10 = { name: "screen16x10", width: 9144000, height: 5715000 };
      var layoutWide = { name: "custom", width: 12192000, height: 6858000 };
      this.LAYOUTS = {
        LAYOUT_4x3: layout4x3,
        LAYOUT_16x9: layout16x9,
        LAYOUT_16x10: layout16x10,
        LAYOUT_WIDE: layoutWide
      };
      this._author = "PptxGenJS";
      this._company = "PptxGenJS";
      this._revision = "1";
      this._subject = "PptxGenJS Presentation";
      this._title = "PptxGenJS Presentation";
      this._presLayout = {
        name: this.LAYOUTS[DEF_PRES_LAYOUT].name,
        _sizeW: this.LAYOUTS[DEF_PRES_LAYOUT].width,
        _sizeH: this.LAYOUTS[DEF_PRES_LAYOUT].height,
        width: this.LAYOUTS[DEF_PRES_LAYOUT].width,
        height: this.LAYOUTS[DEF_PRES_LAYOUT].height
      };
      this._rtlMode = false;
      this._slideLayouts = [
        {
          _margin: DEF_SLIDE_MARGIN_IN,
          _name: DEF_PRES_LAYOUT_NAME,
          _presLayout: this._presLayout,
          _rels: [],
          _relsChart: [],
          _relsMedia: [],
          _slide: null,
          _slideNum: 1000,
          _slideNumberProps: null,
          _slideObjects: []
        }
      ];
      this._slides = [];
      this._sections = [];
      this._masterSlide = {
        addChart: null,
        addImage: null,
        addMedia: null,
        addNotes: null,
        addShape: null,
        addTable: null,
        addText: null,
        _name: null,
        _presLayout: this._presLayout,
        _rId: null,
        _rels: [],
        _relsChart: [],
        _relsMedia: [],
        _slideId: null,
        _slideLayout: null,
        _slideNum: null,
        _slideNumberProps: null,
        _slideObjects: []
      };
    }
    Object.defineProperty(PptxGenJS2.prototype, "layout", {
      get: function() {
        return this._layout;
      },
      set: function(value) {
        var newLayout = this.LAYOUTS[value];
        if (newLayout) {
          this._layout = value;
          this._presLayout = newLayout;
        } else {
          throw new Error("UNKNOWN-LAYOUT");
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "version", {
      get: function() {
        return this._version;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "author", {
      get: function() {
        return this._author;
      },
      set: function(value) {
        this._author = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "company", {
      get: function() {
        return this._company;
      },
      set: function(value) {
        this._company = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "revision", {
      get: function() {
        return this._revision;
      },
      set: function(value) {
        this._revision = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "subject", {
      get: function() {
        return this._subject;
      },
      set: function(value) {
        this._subject = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "theme", {
      get: function() {
        return this._theme;
      },
      set: function(value) {
        this._theme = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "title", {
      get: function() {
        return this._title;
      },
      set: function(value) {
        this._title = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "rtlMode", {
      get: function() {
        return this._rtlMode;
      },
      set: function(value) {
        this._rtlMode = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "masterSlide", {
      get: function() {
        return this._masterSlide;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "slides", {
      get: function() {
        return this._slides;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "sections", {
      get: function() {
        return this._sections;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "slideLayouts", {
      get: function() {
        return this._slideLayouts;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "AlignH", {
      get: function() {
        return this._alignH;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "AlignV", {
      get: function() {
        return this._alignV;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "ChartType", {
      get: function() {
        return this._chartType;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "OutputType", {
      get: function() {
        return this._outputType;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "presLayout", {
      get: function() {
        return this._presLayout;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "SchemeColor", {
      get: function() {
        return this._schemeColor;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "ShapeType", {
      get: function() {
        return this._shapeType;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "charts", {
      get: function() {
        return this._charts;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "colors", {
      get: function() {
        return this._colors;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PptxGenJS2.prototype, "shapes", {
      get: function() {
        return this._shapes;
      },
      enumerable: false,
      configurable: true
    });
    PptxGenJS2.prototype.stream = function(props) {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, this.exportPresentation({
                compression: props === null || props === undefined ? undefined : props.compression,
                outputType: "STREAM"
              })];
            case 1:
              return [2, _a.sent()];
          }
        });
      });
    };
    PptxGenJS2.prototype.write = function(props) {
      return __awaiter(this, undefined, undefined, function() {
        var propsOutpType, propsCompress;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              propsOutpType = typeof props === "object" && (props === null || props === undefined ? undefined : props.outputType) ? props.outputType : props ? props : null;
              propsCompress = typeof props === "object" && (props === null || props === undefined ? undefined : props.compression) ? props.compression : false;
              return [4, this.exportPresentation({
                compression: propsCompress,
                outputType: propsOutpType
              })];
            case 1:
              return [2, _a.sent()];
          }
        });
      });
    };
    PptxGenJS2.prototype.writeFile = function(props) {
      return __awaiter(this, undefined, undefined, function() {
        var fs, propsExpName, propsCompress, fileName;
        var _this = this;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              fs = typeof window === "undefined" ? (() => ({})) : null;
              if (typeof props === "string")
                console.log("Warning: `writeFile(filename)` is deprecated - please use `WriteFileProps` argument (v3.5.0)");
              propsExpName = typeof props === "object" && (props === null || props === undefined ? undefined : props.fileName) ? props.fileName : typeof props === "string" ? props : "";
              propsCompress = typeof props === "object" && (props === null || props === undefined ? undefined : props.compression) ? props.compression : false;
              fileName = propsExpName ? propsExpName.toString().toLowerCase().endsWith(".pptx") ? propsExpName : propsExpName + ".pptx" : "Presentation.pptx";
              return [4, this.exportPresentation({
                compression: propsCompress,
                outputType: fs ? "nodebuffer" : null
              }).then(function(content) {
                return __awaiter(_this, undefined, undefined, function() {
                  return __generator(this, function(_a2) {
                    switch (_a2.label) {
                      case 0:
                        if (!fs)
                          return [3, 2];
                        return [4, new Promise(function(resolve, reject) {
                          fs.writeFile(fileName, content, function(err) {
                            if (err) {
                              reject(err);
                            } else {
                              resolve(fileName);
                            }
                          });
                        })];
                      case 1:
                        return [2, _a2.sent()];
                      case 2:
                        return [4, this.writeFileToBrowser(fileName, content)];
                      case 3:
                        return [2, _a2.sent()];
                    }
                  });
                });
              })];
            case 1:
              return [2, _a.sent()];
          }
        });
      });
    };
    PptxGenJS2.prototype.addSection = function(section) {
      if (!section)
        console.warn("addSection requires an argument");
      else if (!section.title)
        console.warn("addSection requires a title");
      var newSection = {
        _type: "user",
        _slides: [],
        title: section.title
      };
      if (section.order)
        this.sections.splice(section.order, 0, newSection);
      else
        this._sections.push(newSection);
    };
    PptxGenJS2.prototype.addSlide = function(options2) {
      var masterSlideName = typeof options2 === "string" ? options2 : (options2 === null || options2 === undefined ? undefined : options2.masterName) ? options2.masterName : "";
      var slideLayout = {
        _name: this.LAYOUTS[DEF_PRES_LAYOUT].name,
        _presLayout: this.presLayout,
        _rels: [],
        _relsChart: [],
        _relsMedia: [],
        _slideNum: this.slides.length + 1
      };
      if (masterSlideName) {
        var tmpLayout = this.slideLayouts.filter(function(layout) {
          return layout._name === masterSlideName;
        })[0];
        if (tmpLayout)
          slideLayout = tmpLayout;
      }
      var newSlide = new Slide({
        addSlide: this.addNewSlide,
        getSlide: this.getSlide,
        presLayout: this.presLayout,
        setSlideNum: this.setSlideNumber,
        slideId: this.slides.length + 256,
        slideRId: this.slides.length + 2,
        slideNumber: this.slides.length + 1,
        slideLayout
      });
      this._slides.push(newSlide);
      if (options2 === null || options2 === undefined ? undefined : options2.sectionTitle) {
        var sect = this.sections.filter(function(section) {
          return section.title === options2.sectionTitle;
        })[0];
        if (!sect)
          console.warn('addSlide: unable to find section with title: "'.concat(options2.sectionTitle, '"'));
        else
          sect._slides.push(newSlide);
      } else if (this.sections && this.sections.length > 0 && !(options2 === null || options2 === undefined ? undefined : options2.sectionTitle)) {
        var lastSect = this._sections[this.sections.length - 1];
        if (lastSect._type === "default")
          lastSect._slides.push(newSlide);
        else {
          this._sections.push({
            title: "Default-".concat(this.sections.filter(function(sect2) {
              return sect2._type === "default";
            }).length + 1),
            _type: "default",
            _slides: [newSlide]
          });
        }
      }
      return newSlide;
    };
    PptxGenJS2.prototype.defineLayout = function(layout) {
      if (!layout)
        console.warn("defineLayout requires `{name, width, height}`");
      else if (!layout.name)
        console.warn("defineLayout requires `name`");
      else if (!layout.width)
        console.warn("defineLayout requires `width`");
      else if (!layout.height)
        console.warn("defineLayout requires `height`");
      else if (typeof layout.height !== "number")
        console.warn("defineLayout `height` should be a number (inches)");
      else if (typeof layout.width !== "number")
        console.warn("defineLayout `width` should be a number (inches)");
      this.LAYOUTS[layout.name] = {
        name: layout.name,
        _sizeW: Math.round(Number(layout.width) * EMU),
        _sizeH: Math.round(Number(layout.height) * EMU),
        width: Math.round(Number(layout.width) * EMU),
        height: Math.round(Number(layout.height) * EMU)
      };
    };
    PptxGenJS2.prototype.defineSlideMaster = function(props) {
      if (!props.title)
        throw new Error("defineSlideMaster() object argument requires a `title` value. (https://gitbrent.github.io/PptxGenJS/docs/masters.html)");
      var newLayout = {
        _margin: props.margin || DEF_SLIDE_MARGIN_IN,
        _name: props.title,
        _presLayout: this.presLayout,
        _rels: [],
        _relsChart: [],
        _relsMedia: [],
        _slide: null,
        _slideNum: 1000 + this.slideLayouts.length + 1,
        _slideNumberProps: props.slideNumber || null,
        _slideObjects: [],
        background: props.background || null,
        bkgd: props.bkgd || null
      };
      createSlideMaster(props, newLayout);
      this.slideLayouts.push(newLayout);
      if (props.background || props.bkgd)
        addBackgroundDefinition(props.background, newLayout);
      if (newLayout._slideNumberProps && !this.masterSlide._slideNumberProps)
        this.masterSlide._slideNumberProps = newLayout._slideNumberProps;
    };
    PptxGenJS2.prototype.tableToSlides = function(eleId, options2) {
      if (options2 === undefined) {
        options2 = {};
      }
      genTableToSlides(this, eleId, options2, (options2 === null || options2 === undefined ? undefined : options2.masterSlideName) ? this.slideLayouts.filter(function(layout) {
        return layout._name === options2.masterSlideName;
      })[0] : null);
    };
    return PptxGenJS2;
  }();
});

// ../../src/components/canvas/KonvaViewer.tsx
var import_react16 = __toESM(require_react(), 1);

// ../../src/components/canvas/KonvaCanvasEditor.tsx
var import_react15 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/Global.js
var PI_OVER_180 = Math.PI / 180;
function detectBrowser() {
  return typeof window !== "undefined" && ({}.toString.call(window) === "[object Window]" || {}.toString.call(window) === "[object global]");
}
var glob = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" ? self : {};
var Konva = {
  _global: glob,
  version: "10.0.12",
  isBrowser: detectBrowser(),
  isUnminified: /param/.test(function(param) {}.toString()),
  dblClickWindow: 400,
  getAngle(angle) {
    return Konva.angleDeg ? angle * PI_OVER_180 : angle;
  },
  enableTrace: false,
  pointerEventsEnabled: true,
  autoDrawEnabled: true,
  hitOnDragEnabled: false,
  capturePointerEventsEnabled: false,
  _mouseListenClick: false,
  _touchListenClick: false,
  _pointerListenClick: false,
  _mouseInDblClickWindow: false,
  _touchInDblClickWindow: false,
  _pointerInDblClickWindow: false,
  _mouseDblClickPointerId: null,
  _touchDblClickPointerId: null,
  _pointerDblClickPointerId: null,
  _renderBackend: "web",
  legacyTextRendering: false,
  pixelRatio: typeof window !== "undefined" && window.devicePixelRatio || 1,
  dragDistance: 3,
  angleDeg: true,
  showWarnings: true,
  dragButtons: [0, 1],
  isDragging() {
    return Konva["DD"].isDragging;
  },
  isTransforming() {
    var _a, _b;
    return (_b = (_a = Konva["Transformer"]) === null || _a === undefined ? undefined : _a.isTransforming()) !== null && _b !== undefined ? _b : false;
  },
  isDragReady() {
    return !!Konva["DD"].node;
  },
  releaseCanvasOnDestroy: true,
  document: glob.document,
  _injectGlobal(Konva2) {
    if (typeof glob.Konva !== "undefined") {
      console.error("Several Konva instances detected. It is not recommended to use multiple Konva instances in the same environment.");
    }
    glob.Konva = Konva2;
  }
};
var _registerNode = (NodeClass) => {
  Konva[NodeClass.prototype.getClassName()] = NodeClass;
};
Konva._injectGlobal(Konva);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/Util.js
var NODE_ERROR = `Konva.js unsupported environment.

Looks like you are trying to use Konva.js in Node.js environment. because "document" object is undefined.

To use Konva.js in Node.js environment, you need to use the "canvas-backend" or "skia-backend" module.

bash: npm install canvas
js: import "konva/canvas-backend";

or

bash: npm install skia-canvas
js: import "konva/skia-backend";
`;
var ensureBrowser = () => {
  if (typeof document === "undefined") {
    throw new Error(NODE_ERROR);
  }
};

class Transform {
  constructor(m = [1, 0, 0, 1, 0, 0]) {
    this.dirty = false;
    this.m = m && m.slice() || [1, 0, 0, 1, 0, 0];
  }
  reset() {
    this.m[0] = 1;
    this.m[1] = 0;
    this.m[2] = 0;
    this.m[3] = 1;
    this.m[4] = 0;
    this.m[5] = 0;
  }
  copy() {
    return new Transform(this.m);
  }
  copyInto(tr) {
    tr.m[0] = this.m[0];
    tr.m[1] = this.m[1];
    tr.m[2] = this.m[2];
    tr.m[3] = this.m[3];
    tr.m[4] = this.m[4];
    tr.m[5] = this.m[5];
  }
  point(point) {
    const m = this.m;
    return {
      x: m[0] * point.x + m[2] * point.y + m[4],
      y: m[1] * point.x + m[3] * point.y + m[5]
    };
  }
  translate(x, y) {
    this.m[4] += this.m[0] * x + this.m[2] * y;
    this.m[5] += this.m[1] * x + this.m[3] * y;
    return this;
  }
  scale(sx, sy) {
    this.m[0] *= sx;
    this.m[1] *= sx;
    this.m[2] *= sy;
    this.m[3] *= sy;
    return this;
  }
  rotate(rad) {
    const c = Math.cos(rad);
    const s = Math.sin(rad);
    const m11 = this.m[0] * c + this.m[2] * s;
    const m12 = this.m[1] * c + this.m[3] * s;
    const m21 = this.m[0] * -s + this.m[2] * c;
    const m22 = this.m[1] * -s + this.m[3] * c;
    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
    return this;
  }
  getTranslation() {
    return {
      x: this.m[4],
      y: this.m[5]
    };
  }
  skew(sx, sy) {
    const m11 = this.m[0] + this.m[2] * sy;
    const m12 = this.m[1] + this.m[3] * sy;
    const m21 = this.m[2] + this.m[0] * sx;
    const m22 = this.m[3] + this.m[1] * sx;
    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
    return this;
  }
  multiply(matrix) {
    const m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
    const m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];
    const m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
    const m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];
    const dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
    const dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];
    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
    this.m[4] = dx;
    this.m[5] = dy;
    return this;
  }
  invert() {
    const d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
    const m0 = this.m[3] * d;
    const m1 = -this.m[1] * d;
    const m2 = -this.m[2] * d;
    const m3 = this.m[0] * d;
    const m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
    const m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
    this.m[0] = m0;
    this.m[1] = m1;
    this.m[2] = m2;
    this.m[3] = m3;
    this.m[4] = m4;
    this.m[5] = m5;
    return this;
  }
  getMatrix() {
    return this.m;
  }
  decompose() {
    const a = this.m[0];
    const b = this.m[1];
    const c = this.m[2];
    const d = this.m[3];
    const e = this.m[4];
    const f = this.m[5];
    const delta = a * d - b * c;
    const result = {
      x: e,
      y: f,
      rotation: 0,
      scaleX: 0,
      scaleY: 0,
      skewX: 0,
      skewY: 0
    };
    if (a != 0 || b != 0) {
      const r = Math.sqrt(a * a + b * b);
      result.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);
      result.scaleX = r;
      result.scaleY = delta / r;
      result.skewX = (a * c + b * d) / delta;
      result.skewY = 0;
    } else if (c != 0 || d != 0) {
      const s = Math.sqrt(c * c + d * d);
      result.rotation = Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));
      result.scaleX = delta / s;
      result.scaleY = s;
      result.skewX = 0;
      result.skewY = (a * c + b * d) / delta;
    } else {}
    result.rotation = Util._getRotation(result.rotation);
    return result;
  }
}
var OBJECT_ARRAY = "[object Array]";
var OBJECT_NUMBER = "[object Number]";
var OBJECT_STRING = "[object String]";
var OBJECT_BOOLEAN = "[object Boolean]";
var PI_OVER_DEG180 = Math.PI / 180;
var DEG180_OVER_PI = 180 / Math.PI;
var HASH = "#";
var EMPTY_STRING = "";
var ZERO = "0";
var KONVA_WARNING = "Konva warning: ";
var KONVA_ERROR = "Konva error: ";
var RGB_PAREN = "rgb(";
var COLORS = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 132, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 255, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 203],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [119, 128, 144],
  slategrey: [119, 128, 144],
  snow: [255, 255, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  transparent: [255, 255, 255, 0],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 5]
};
var RGB_REGEX = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/;
var animQueue = [];
var _isCanvasFarblingActive = null;
var req = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame || function(f) {
  setTimeout(f, 60);
};
var Util = {
  _isElement(obj) {
    return !!(obj && obj.nodeType == 1);
  },
  _isFunction(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  },
  _isPlainObject(obj) {
    return !!obj && obj.constructor === Object;
  },
  _isArray(obj) {
    return Object.prototype.toString.call(obj) === OBJECT_ARRAY;
  },
  _isNumber(obj) {
    return Object.prototype.toString.call(obj) === OBJECT_NUMBER && !isNaN(obj) && isFinite(obj);
  },
  _isString(obj) {
    return Object.prototype.toString.call(obj) === OBJECT_STRING;
  },
  _isBoolean(obj) {
    return Object.prototype.toString.call(obj) === OBJECT_BOOLEAN;
  },
  isObject(val) {
    return val instanceof Object;
  },
  isValidSelector(selector) {
    if (typeof selector !== "string") {
      return false;
    }
    const firstChar = selector[0];
    return firstChar === "#" || firstChar === "." || firstChar === firstChar.toUpperCase();
  },
  _sign(number) {
    if (number === 0) {
      return 1;
    }
    if (number > 0) {
      return 1;
    } else {
      return -1;
    }
  },
  requestAnimFrame(callback) {
    animQueue.push(callback);
    if (animQueue.length === 1) {
      req(function() {
        const queue = animQueue;
        animQueue = [];
        queue.forEach(function(cb) {
          cb();
        });
      });
    }
  },
  createCanvasElement() {
    ensureBrowser();
    const canvas = document.createElement("canvas");
    try {
      canvas.style = canvas.style || {};
    } catch (e) {}
    return canvas;
  },
  createImageElement() {
    ensureBrowser();
    return document.createElement("img");
  },
  _isInDocument(el) {
    while (el = el.parentNode) {
      if (el == document) {
        return true;
      }
    }
    return false;
  },
  _urlToImage(url, callback) {
    const imageObj = Util.createImageElement();
    imageObj.onload = function() {
      callback(imageObj);
    };
    imageObj.src = url;
  },
  _rgbToHex(r, g, b) {
    return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  },
  _hexToRgb(hex) {
    hex = hex.replace(HASH, EMPTY_STRING);
    const bigint = parseInt(hex, 16);
    return {
      r: bigint >> 16 & 255,
      g: bigint >> 8 & 255,
      b: bigint & 255
    };
  },
  getRandomColor() {
    let randColor = (Math.random() * 16777215 << 0).toString(16);
    while (randColor.length < 6) {
      randColor = ZERO + randColor;
    }
    return HASH + randColor;
  },
  isCanvasFarblingActive() {
    if (_isCanvasFarblingActive !== null) {
      return _isCanvasFarblingActive;
    }
    if (typeof document === "undefined") {
      _isCanvasFarblingActive = false;
      return false;
    }
    const c = this.createCanvasElement();
    c.width = 10;
    c.height = 10;
    const ctx = c.getContext("2d", {
      willReadFrequently: true
    });
    ctx.clearRect(0, 0, 10, 10);
    ctx.fillStyle = "#282828";
    ctx.fillRect(0, 0, 10, 10);
    const d = ctx.getImageData(0, 0, 10, 10).data;
    let isFarbling = false;
    for (let i = 0;i < 100; i++) {
      if (d[i * 4] !== 40 || d[i * 4 + 1] !== 40 || d[i * 4 + 2] !== 40 || d[i * 4 + 3] !== 255) {
        isFarbling = true;
        break;
      }
    }
    _isCanvasFarblingActive = isFarbling;
    this.releaseCanvas(c);
    return _isCanvasFarblingActive;
  },
  getHitColor() {
    const color = this.getRandomColor();
    return this.isCanvasFarblingActive() ? this.getSnappedHexColor(color) : color;
  },
  getHitColorKey(r, g, b) {
    if (this.isCanvasFarblingActive()) {
      r = Math.round(r / 5) * 5;
      g = Math.round(g / 5) * 5;
      b = Math.round(b / 5) * 5;
    }
    return HASH + this._rgbToHex(r, g, b);
  },
  getSnappedHexColor(hex) {
    const rgb = this._hexToRgb(hex);
    return HASH + this._rgbToHex(Math.round(rgb.r / 5) * 5, Math.round(rgb.g / 5) * 5, Math.round(rgb.b / 5) * 5);
  },
  getRGB(color) {
    let rgb;
    if (color in COLORS) {
      rgb = COLORS[color];
      return {
        r: rgb[0],
        g: rgb[1],
        b: rgb[2]
      };
    } else if (color[0] === HASH) {
      return this._hexToRgb(color.substring(1));
    } else if (color.substr(0, 4) === RGB_PAREN) {
      rgb = RGB_REGEX.exec(color.replace(/ /g, ""));
      return {
        r: parseInt(rgb[1], 10),
        g: parseInt(rgb[2], 10),
        b: parseInt(rgb[3], 10)
      };
    } else {
      return {
        r: 0,
        g: 0,
        b: 0
      };
    }
  },
  colorToRGBA(str) {
    str = str || "black";
    return Util._namedColorToRBA(str) || Util._hex3ColorToRGBA(str) || Util._hex4ColorToRGBA(str) || Util._hex6ColorToRGBA(str) || Util._hex8ColorToRGBA(str) || Util._rgbColorToRGBA(str) || Util._rgbaColorToRGBA(str) || Util._hslColorToRGBA(str);
  },
  _namedColorToRBA(str) {
    const c = COLORS[str.toLowerCase()];
    if (!c) {
      return null;
    }
    return {
      r: c[0],
      g: c[1],
      b: c[2],
      a: 1
    };
  },
  _rgbColorToRGBA(str) {
    if (str.indexOf("rgb(") === 0) {
      str = str.match(/rgb\(([^)]+)\)/)[1];
      const parts = str.split(/ *, */).map(Number);
      return {
        r: parts[0],
        g: parts[1],
        b: parts[2],
        a: 1
      };
    }
  },
  _rgbaColorToRGBA(str) {
    if (str.indexOf("rgba(") === 0) {
      str = str.match(/rgba\(([^)]+)\)/)[1];
      const parts = str.split(/ *, */).map((n, index) => {
        if (n.slice(-1) === "%") {
          return index === 3 ? parseInt(n) / 100 : parseInt(n) / 100 * 255;
        }
        return Number(n);
      });
      return {
        r: parts[0],
        g: parts[1],
        b: parts[2],
        a: parts[3]
      };
    }
  },
  _hex8ColorToRGBA(str) {
    if (str[0] === "#" && str.length === 9) {
      return {
        r: parseInt(str.slice(1, 3), 16),
        g: parseInt(str.slice(3, 5), 16),
        b: parseInt(str.slice(5, 7), 16),
        a: parseInt(str.slice(7, 9), 16) / 255
      };
    }
  },
  _hex6ColorToRGBA(str) {
    if (str[0] === "#" && str.length === 7) {
      return {
        r: parseInt(str.slice(1, 3), 16),
        g: parseInt(str.slice(3, 5), 16),
        b: parseInt(str.slice(5, 7), 16),
        a: 1
      };
    }
  },
  _hex4ColorToRGBA(str) {
    if (str[0] === "#" && str.length === 5) {
      return {
        r: parseInt(str[1] + str[1], 16),
        g: parseInt(str[2] + str[2], 16),
        b: parseInt(str[3] + str[3], 16),
        a: parseInt(str[4] + str[4], 16) / 255
      };
    }
  },
  _hex3ColorToRGBA(str) {
    if (str[0] === "#" && str.length === 4) {
      return {
        r: parseInt(str[1] + str[1], 16),
        g: parseInt(str[2] + str[2], 16),
        b: parseInt(str[3] + str[3], 16),
        a: 1
      };
    }
  },
  _hslColorToRGBA(str) {
    if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(str)) {
      const [_, ...hsl] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(str);
      const h = Number(hsl[0]) / 360;
      const s = Number(hsl[1]) / 100;
      const l = Number(hsl[2]) / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return {
          r: Math.round(val),
          g: Math.round(val),
          b: Math.round(val),
          a: 1
        };
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0;i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return {
        r: Math.round(rgb[0]),
        g: Math.round(rgb[1]),
        b: Math.round(rgb[2]),
        a: 1
      };
    }
  },
  haveIntersection(r1, r2) {
    return !(r2.x > r1.x + r1.width || r2.x + r2.width < r1.x || r2.y > r1.y + r1.height || r2.y + r2.height < r1.y);
  },
  cloneObject(obj) {
    const retObj = {};
    for (const key in obj) {
      if (this._isPlainObject(obj[key])) {
        retObj[key] = this.cloneObject(obj[key]);
      } else if (this._isArray(obj[key])) {
        retObj[key] = this.cloneArray(obj[key]);
      } else {
        retObj[key] = obj[key];
      }
    }
    return retObj;
  },
  cloneArray(arr) {
    return arr.slice(0);
  },
  degToRad(deg) {
    return deg * PI_OVER_DEG180;
  },
  radToDeg(rad) {
    return rad * DEG180_OVER_PI;
  },
  _degToRad(deg) {
    Util.warn("Util._degToRad is removed. Please use public Util.degToRad instead.");
    return Util.degToRad(deg);
  },
  _radToDeg(rad) {
    Util.warn("Util._radToDeg is removed. Please use public Util.radToDeg instead.");
    return Util.radToDeg(rad);
  },
  _getRotation(radians) {
    return Konva.angleDeg ? Util.radToDeg(radians) : radians;
  },
  _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  },
  throw(str) {
    throw new Error(KONVA_ERROR + str);
  },
  error(str) {
    console.error(KONVA_ERROR + str);
  },
  warn(str) {
    if (!Konva.showWarnings) {
      return;
    }
    console.warn(KONVA_WARNING + str);
  },
  each(obj, func) {
    for (const key in obj) {
      func(key, obj[key]);
    }
  },
  _inRange(val, left, right) {
    return left <= val && val < right;
  },
  _getProjectionToSegment(x1, y1, x2, y2, x3, y3) {
    let x, y, dist;
    const pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
    if (pd2 == 0) {
      x = x1;
      y = y1;
      dist = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);
    } else {
      const u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / pd2;
      if (u < 0) {
        x = x1;
        y = y1;
        dist = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);
      } else if (u > 1) {
        x = x2;
        y = y2;
        dist = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);
      } else {
        x = x1 + u * (x2 - x1);
        y = y1 + u * (y2 - y1);
        dist = (x - x3) * (x - x3) + (y - y3) * (y - y3);
      }
    }
    return [x, y, dist];
  },
  _getProjectionToLine(pt, line, isClosed) {
    const pc = Util.cloneObject(pt);
    let dist = Number.MAX_VALUE;
    line.forEach(function(p1, i) {
      if (!isClosed && i === line.length - 1) {
        return;
      }
      const p2 = line[(i + 1) % line.length];
      const proj = Util._getProjectionToSegment(p1.x, p1.y, p2.x, p2.y, pt.x, pt.y);
      const px = proj[0], py = proj[1], pdist = proj[2];
      if (pdist < dist) {
        pc.x = px;
        pc.y = py;
        dist = pdist;
      }
    });
    return pc;
  },
  _prepareArrayForTween(startArray, endArray, isClosed) {
    const start = [], end = [];
    if (startArray.length > endArray.length) {
      const temp = endArray;
      endArray = startArray;
      startArray = temp;
    }
    for (let n = 0;n < startArray.length; n += 2) {
      start.push({
        x: startArray[n],
        y: startArray[n + 1]
      });
    }
    for (let n = 0;n < endArray.length; n += 2) {
      end.push({
        x: endArray[n],
        y: endArray[n + 1]
      });
    }
    const newStart = [];
    end.forEach(function(point) {
      const pr = Util._getProjectionToLine(point, start, isClosed);
      newStart.push(pr.x);
      newStart.push(pr.y);
    });
    return newStart;
  },
  _prepareToStringify(obj) {
    let desc;
    obj.visitedByCircularReferenceRemoval = true;
    for (const key in obj) {
      if (!(obj.hasOwnProperty(key) && obj[key] && typeof obj[key] == "object")) {
        continue;
      }
      desc = Object.getOwnPropertyDescriptor(obj, key);
      if (obj[key].visitedByCircularReferenceRemoval || Util._isElement(obj[key])) {
        if (desc.configurable) {
          delete obj[key];
        } else {
          return null;
        }
      } else if (Util._prepareToStringify(obj[key]) === null) {
        if (desc.configurable) {
          delete obj[key];
        } else {
          return null;
        }
      }
    }
    delete obj.visitedByCircularReferenceRemoval;
    return obj;
  },
  _assign(target, source) {
    for (const key in source) {
      target[key] = source[key];
    }
    return target;
  },
  _getFirstPointerId(evt) {
    if (!evt.touches) {
      return evt.pointerId || 999;
    } else {
      return evt.changedTouches[0].identifier;
    }
  },
  releaseCanvas(...canvases) {
    if (!Konva.releaseCanvasOnDestroy)
      return;
    canvases.forEach((c) => {
      c.width = 0;
      c.height = 0;
    });
  },
  drawRoundedRectPath(context, width, height, cornerRadius) {
    let xOrigin = width < 0 ? width : 0;
    let yOrigin = height < 0 ? height : 0;
    width = Math.abs(width);
    height = Math.abs(height);
    let topLeft = 0;
    let topRight = 0;
    let bottomLeft = 0;
    let bottomRight = 0;
    if (typeof cornerRadius === "number") {
      topLeft = topRight = bottomLeft = bottomRight = Math.min(cornerRadius, width / 2, height / 2);
    } else {
      topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2);
      topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2);
      bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2);
      bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2);
    }
    context.moveTo(xOrigin + topLeft, yOrigin);
    context.lineTo(xOrigin + width - topRight, yOrigin);
    context.arc(xOrigin + width - topRight, yOrigin + topRight, topRight, Math.PI * 3 / 2, 0, false);
    context.lineTo(xOrigin + width, yOrigin + height - bottomRight);
    context.arc(xOrigin + width - bottomRight, yOrigin + height - bottomRight, bottomRight, 0, Math.PI / 2, false);
    context.lineTo(xOrigin + bottomLeft, yOrigin + height);
    context.arc(xOrigin + bottomLeft, yOrigin + height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
    context.lineTo(xOrigin, yOrigin + topLeft);
    context.arc(xOrigin + topLeft, yOrigin + topLeft, topLeft, Math.PI, Math.PI * 3 / 2, false);
  },
  drawRoundedPolygonPath(context, points, sides, radius, cornerRadius) {
    radius = Math.abs(radius);
    for (let i = 0;i < sides; i++) {
      const prev = points[(i - 1 + sides) % sides];
      const curr = points[i];
      const next = points[(i + 1) % sides];
      const vec1 = { x: curr.x - prev.x, y: curr.y - prev.y };
      const vec2 = { x: next.x - curr.x, y: next.y - curr.y };
      const len1 = Math.hypot(vec1.x, vec1.y);
      const len2 = Math.hypot(vec2.x, vec2.y);
      let currCornerRadius;
      if (typeof cornerRadius === "number") {
        currCornerRadius = cornerRadius;
      } else {
        currCornerRadius = i < cornerRadius.length ? cornerRadius[i] : 0;
      }
      const maxCornerRadius = radius * Math.cos(Math.PI / sides);
      currCornerRadius = maxCornerRadius * Math.min(1, currCornerRadius / radius * 2);
      const normalVec1 = { x: vec1.x / len1, y: vec1.y / len1 };
      const normalVec2 = { x: vec2.x / len2, y: vec2.y / len2 };
      const p1 = {
        x: curr.x - normalVec1.x * currCornerRadius,
        y: curr.y - normalVec1.y * currCornerRadius
      };
      const p2 = {
        x: curr.x + normalVec2.x * currCornerRadius,
        y: curr.y + normalVec2.y * currCornerRadius
      };
      if (i === 0) {
        context.moveTo(p1.x, p1.y);
      } else {
        context.lineTo(p1.x, p1.y);
      }
      context.arcTo(curr.x, curr.y, p2.x, p2.y, currCornerRadius);
    }
  }
};

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/Context.js
function simplifyArray(arr) {
  const retArr = [], len = arr.length, util = Util;
  for (let n = 0;n < len; n++) {
    let val = arr[n];
    if (util._isNumber(val)) {
      val = Math.round(val * 1000) / 1000;
    } else if (!util._isString(val)) {
      val = val + "";
    }
    retArr.push(val);
  }
  return retArr;
}
var COMMA = ",";
var OPEN_PAREN = "(";
var CLOSE_PAREN = ")";
var OPEN_PAREN_BRACKET = "([";
var CLOSE_BRACKET_PAREN = "])";
var SEMICOLON = ";";
var DOUBLE_PAREN = "()";
var EQUALS = "=";
var CONTEXT_METHODS = [
  "arc",
  "arcTo",
  "beginPath",
  "bezierCurveTo",
  "clearRect",
  "clip",
  "closePath",
  "createLinearGradient",
  "createPattern",
  "createRadialGradient",
  "drawImage",
  "ellipse",
  "fill",
  "fillText",
  "getImageData",
  "createImageData",
  "lineTo",
  "moveTo",
  "putImageData",
  "quadraticCurveTo",
  "rect",
  "roundRect",
  "restore",
  "rotate",
  "save",
  "scale",
  "setLineDash",
  "setTransform",
  "stroke",
  "strokeText",
  "transform",
  "translate"
];
var CONTEXT_PROPERTIES = [
  "fillStyle",
  "strokeStyle",
  "shadowColor",
  "shadowBlur",
  "shadowOffsetX",
  "shadowOffsetY",
  "letterSpacing",
  "lineCap",
  "lineDashOffset",
  "lineJoin",
  "lineWidth",
  "miterLimit",
  "direction",
  "font",
  "textAlign",
  "textBaseline",
  "globalAlpha",
  "globalCompositeOperation",
  "imageSmoothingEnabled",
  "filter"
];
var traceArrMax = 100;
var _cssFiltersSupported = null;
function isCSSFiltersSupported() {
  if (_cssFiltersSupported !== null) {
    return _cssFiltersSupported;
  }
  try {
    const canvas = Util.createCanvasElement();
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      _cssFiltersSupported = false;
      return false;
    }
    return !!ctx && "filter" in ctx;
  } catch (e) {
    _cssFiltersSupported = false;
    return false;
  }
}

class Context {
  constructor(canvas) {
    this.canvas = canvas;
    if (Konva.enableTrace) {
      this.traceArr = [];
      this._enableTrace();
    }
  }
  fillShape(shape) {
    if (shape.fillEnabled()) {
      this._fill(shape);
    }
  }
  _fill(shape) {}
  strokeShape(shape) {
    if (shape.hasStroke()) {
      this._stroke(shape);
    }
  }
  _stroke(shape) {}
  fillStrokeShape(shape) {
    if (shape.attrs.fillAfterStrokeEnabled) {
      this.strokeShape(shape);
      this.fillShape(shape);
    } else {
      this.fillShape(shape);
      this.strokeShape(shape);
    }
  }
  getTrace(relaxed, rounded) {
    let traceArr = this.traceArr, len = traceArr.length, str = "", n, trace, method, args;
    for (n = 0;n < len; n++) {
      trace = traceArr[n];
      method = trace.method;
      if (method) {
        args = trace.args;
        str += method;
        if (relaxed) {
          str += DOUBLE_PAREN;
        } else {
          if (Util._isArray(args[0])) {
            str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;
          } else {
            if (rounded) {
              args = args.map((a) => typeof a === "number" ? Math.floor(a) : a);
            }
            str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;
          }
        }
      } else {
        str += trace.property;
        if (!relaxed) {
          str += EQUALS + trace.val;
        }
      }
      str += SEMICOLON;
    }
    return str;
  }
  clearTrace() {
    this.traceArr = [];
  }
  _trace(str) {
    let traceArr = this.traceArr, len;
    traceArr.push(str);
    len = traceArr.length;
    if (len >= traceArrMax) {
      traceArr.shift();
    }
  }
  reset() {
    const pixelRatio = this.getCanvas().getPixelRatio();
    this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
  }
  getCanvas() {
    return this.canvas;
  }
  clear(bounds) {
    const canvas = this.getCanvas();
    if (bounds) {
      this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);
    } else {
      this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);
    }
  }
  _applyLineCap(shape) {
    const lineCap = shape.attrs.lineCap;
    if (lineCap) {
      this.setAttr("lineCap", lineCap);
    }
  }
  _applyOpacity(shape) {
    const absOpacity = shape.getAbsoluteOpacity();
    if (absOpacity !== 1) {
      this.setAttr("globalAlpha", absOpacity);
    }
  }
  _applyLineJoin(shape) {
    const lineJoin = shape.attrs.lineJoin;
    if (lineJoin) {
      this.setAttr("lineJoin", lineJoin);
    }
  }
  _applyMiterLimit(shape) {
    const miterLimit = shape.attrs.miterLimit;
    if (miterLimit != null) {
      this.setAttr("miterLimit", miterLimit);
    }
  }
  setAttr(attr, val) {
    this._context[attr] = val;
  }
  arc(x, y, radius, startAngle, endAngle, counterClockwise) {
    this._context.arc(x, y, radius, startAngle, endAngle, counterClockwise);
  }
  arcTo(x1, y1, x2, y2, radius) {
    this._context.arcTo(x1, y1, x2, y2, radius);
  }
  beginPath() {
    this._context.beginPath();
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  }
  clearRect(x, y, width, height) {
    this._context.clearRect(x, y, width, height);
  }
  clip(...args) {
    this._context.clip.apply(this._context, args);
  }
  closePath() {
    this._context.closePath();
  }
  createImageData(width, height) {
    const a = arguments;
    if (a.length === 2) {
      return this._context.createImageData(width, height);
    } else if (a.length === 1) {
      return this._context.createImageData(width);
    }
  }
  createLinearGradient(x0, y0, x1, y1) {
    return this._context.createLinearGradient(x0, y0, x1, y1);
  }
  createPattern(image, repetition) {
    return this._context.createPattern(image, repetition);
  }
  createRadialGradient(x0, y0, r0, x1, y1, r1) {
    return this._context.createRadialGradient(x0, y0, r0, x1, y1, r1);
  }
  drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
    const a = arguments, _context = this._context;
    if (a.length === 3) {
      _context.drawImage(image, sx, sy);
    } else if (a.length === 5) {
      _context.drawImage(image, sx, sy, sWidth, sHeight);
    } else if (a.length === 9) {
      _context.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
    }
  }
  ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise) {
    this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise);
  }
  isPointInPath(x, y, path, fillRule) {
    if (path) {
      return this._context.isPointInPath(path, x, y, fillRule);
    }
    return this._context.isPointInPath(x, y, fillRule);
  }
  fill(...args) {
    this._context.fill.apply(this._context, args);
  }
  fillRect(x, y, width, height) {
    this._context.fillRect(x, y, width, height);
  }
  strokeRect(x, y, width, height) {
    this._context.strokeRect(x, y, width, height);
  }
  fillText(text, x, y, maxWidth) {
    if (maxWidth) {
      this._context.fillText(text, x, y, maxWidth);
    } else {
      this._context.fillText(text, x, y);
    }
  }
  measureText(text) {
    return this._context.measureText(text);
  }
  getImageData(sx, sy, sw, sh) {
    return this._context.getImageData(sx, sy, sw, sh);
  }
  lineTo(x, y) {
    this._context.lineTo(x, y);
  }
  moveTo(x, y) {
    this._context.moveTo(x, y);
  }
  rect(x, y, width, height) {
    this._context.rect(x, y, width, height);
  }
  roundRect(x, y, width, height, radii) {
    this._context.roundRect(x, y, width, height, radii);
  }
  putImageData(imageData, dx, dy) {
    this._context.putImageData(imageData, dx, dy);
  }
  quadraticCurveTo(cpx, cpy, x, y) {
    this._context.quadraticCurveTo(cpx, cpy, x, y);
  }
  restore() {
    this._context.restore();
  }
  rotate(angle) {
    this._context.rotate(angle);
  }
  save() {
    this._context.save();
  }
  scale(x, y) {
    this._context.scale(x, y);
  }
  setLineDash(segments) {
    if (this._context.setLineDash) {
      this._context.setLineDash(segments);
    } else if ("mozDash" in this._context) {
      this._context["mozDash"] = segments;
    } else if ("webkitLineDash" in this._context) {
      this._context["webkitLineDash"] = segments;
    }
  }
  getLineDash() {
    return this._context.getLineDash();
  }
  setTransform(a, b, c, d, e, f) {
    this._context.setTransform(a, b, c, d, e, f);
  }
  stroke(path2d) {
    if (path2d) {
      this._context.stroke(path2d);
    } else {
      this._context.stroke();
    }
  }
  strokeText(text, x, y, maxWidth) {
    this._context.strokeText(text, x, y, maxWidth);
  }
  transform(a, b, c, d, e, f) {
    this._context.transform(a, b, c, d, e, f);
  }
  translate(x, y) {
    this._context.translate(x, y);
  }
  _enableTrace() {
    let that = this, len = CONTEXT_METHODS.length, origSetter = this.setAttr, n, args;
    const func = function(methodName) {
      let origMethod = that[methodName], ret;
      that[methodName] = function() {
        args = simplifyArray(Array.prototype.slice.call(arguments, 0));
        ret = origMethod.apply(that, arguments);
        that._trace({
          method: methodName,
          args
        });
        return ret;
      };
    };
    for (n = 0;n < len; n++) {
      func(CONTEXT_METHODS[n]);
    }
    that.setAttr = function() {
      origSetter.apply(that, arguments);
      const prop = arguments[0];
      let val = arguments[1];
      if (prop === "shadowOffsetX" || prop === "shadowOffsetY" || prop === "shadowBlur") {
        val = val / this.canvas.getPixelRatio();
      }
      that._trace({
        property: prop,
        val
      });
    };
  }
  _applyGlobalCompositeOperation(node) {
    const op = node.attrs.globalCompositeOperation;
    const def = !op || op === "source-over";
    if (!def) {
      this.setAttr("globalCompositeOperation", op);
    }
  }
}
CONTEXT_PROPERTIES.forEach(function(prop) {
  Object.defineProperty(Context.prototype, prop, {
    get() {
      return this._context[prop];
    },
    set(val) {
      this._context[prop] = val;
    }
  });
});

class SceneContext extends Context {
  constructor(canvas, { willReadFrequently = false } = {}) {
    super(canvas);
    this._context = canvas._canvas.getContext("2d", {
      willReadFrequently
    });
  }
  _fillColor(shape) {
    const fill = shape.fill();
    this.setAttr("fillStyle", fill);
    shape._fillFunc(this);
  }
  _fillPattern(shape) {
    this.setAttr("fillStyle", shape._getFillPattern());
    shape._fillFunc(this);
  }
  _fillLinearGradient(shape) {
    const grd = shape._getLinearGradient();
    if (grd) {
      this.setAttr("fillStyle", grd);
      shape._fillFunc(this);
    }
  }
  _fillRadialGradient(shape) {
    const grd = shape._getRadialGradient();
    if (grd) {
      this.setAttr("fillStyle", grd);
      shape._fillFunc(this);
    }
  }
  _fill(shape) {
    const hasColor = shape.fill(), fillPriority = shape.getFillPriority();
    if (hasColor && fillPriority === "color") {
      this._fillColor(shape);
      return;
    }
    const hasPattern = shape.getFillPatternImage();
    if (hasPattern && fillPriority === "pattern") {
      this._fillPattern(shape);
      return;
    }
    const hasLinearGradient = shape.getFillLinearGradientColorStops();
    if (hasLinearGradient && fillPriority === "linear-gradient") {
      this._fillLinearGradient(shape);
      return;
    }
    const hasRadialGradient = shape.getFillRadialGradientColorStops();
    if (hasRadialGradient && fillPriority === "radial-gradient") {
      this._fillRadialGradient(shape);
      return;
    }
    if (hasColor) {
      this._fillColor(shape);
    } else if (hasPattern) {
      this._fillPattern(shape);
    } else if (hasLinearGradient) {
      this._fillLinearGradient(shape);
    } else if (hasRadialGradient) {
      this._fillRadialGradient(shape);
    }
  }
  _strokeLinearGradient(shape) {
    const start = shape.getStrokeLinearGradientStartPoint(), end = shape.getStrokeLinearGradientEndPoint(), colorStops = shape.getStrokeLinearGradientColorStops(), grd = this.createLinearGradient(start.x, start.y, end.x, end.y);
    if (colorStops) {
      for (let n = 0;n < colorStops.length; n += 2) {
        grd.addColorStop(colorStops[n], colorStops[n + 1]);
      }
      this.setAttr("strokeStyle", grd);
    }
  }
  _stroke(shape) {
    const dash = shape.dash(), strokeScaleEnabled = shape.getStrokeScaleEnabled();
    if (shape.hasStroke()) {
      if (!strokeScaleEnabled) {
        this.save();
        const pixelRatio = this.getCanvas().getPixelRatio();
        this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      }
      this._applyLineCap(shape);
      if (dash && shape.dashEnabled()) {
        this.setLineDash(dash);
        this.setAttr("lineDashOffset", shape.dashOffset());
      }
      this.setAttr("lineWidth", shape.strokeWidth());
      if (!shape.getShadowForStrokeEnabled()) {
        this.setAttr("shadowColor", "rgba(0,0,0,0)");
      }
      const hasLinearGradient = shape.getStrokeLinearGradientColorStops();
      if (hasLinearGradient) {
        this._strokeLinearGradient(shape);
      } else {
        this.setAttr("strokeStyle", shape.stroke());
      }
      shape._strokeFunc(this);
      if (!strokeScaleEnabled) {
        this.restore();
      }
    }
  }
  _applyShadow(shape) {
    var _a, _b, _c;
    const color = (_a = shape.getShadowRGBA()) !== null && _a !== undefined ? _a : "black", blur = (_b = shape.getShadowBlur()) !== null && _b !== undefined ? _b : 5, offset = (_c = shape.getShadowOffset()) !== null && _c !== undefined ? _c : {
      x: 0,
      y: 0
    }, scale = shape.getAbsoluteScale(), ratio = this.canvas.getPixelRatio(), scaleX = scale.x * ratio, scaleY = scale.y * ratio;
    this.setAttr("shadowColor", color);
    this.setAttr("shadowBlur", blur * Math.min(Math.abs(scaleX), Math.abs(scaleY)));
    this.setAttr("shadowOffsetX", offset.x * scaleX);
    this.setAttr("shadowOffsetY", offset.y * scaleY);
  }
}

class HitContext extends Context {
  constructor(canvas) {
    super(canvas);
    this._context = canvas._canvas.getContext("2d", {
      willReadFrequently: true
    });
  }
  _fill(shape) {
    this.save();
    this.setAttr("fillStyle", shape.colorKey);
    shape._fillFuncHit(this);
    this.restore();
  }
  strokeShape(shape) {
    if (shape.hasHitStroke()) {
      this._stroke(shape);
    }
  }
  _stroke(shape) {
    if (shape.hasHitStroke()) {
      const strokeScaleEnabled = shape.getStrokeScaleEnabled();
      if (!strokeScaleEnabled) {
        this.save();
        const pixelRatio = this.getCanvas().getPixelRatio();
        this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      }
      this._applyLineCap(shape);
      const hitStrokeWidth = shape.hitStrokeWidth();
      const strokeWidth = hitStrokeWidth === "auto" ? shape.strokeWidth() : hitStrokeWidth;
      this.setAttr("lineWidth", strokeWidth);
      this.setAttr("strokeStyle", shape.colorKey);
      shape._strokeFuncHit(this);
      if (!strokeScaleEnabled) {
        this.restore();
      }
    }
  }
}

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/Canvas.js
var _pixelRatio;
function getDevicePixelRatio() {
  if (_pixelRatio) {
    return _pixelRatio;
  }
  const canvas = Util.createCanvasElement();
  const context = canvas.getContext("2d");
  _pixelRatio = function() {
    const devicePixelRatio = Konva._global.devicePixelRatio || 1, backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
    return devicePixelRatio / backingStoreRatio;
  }();
  Util.releaseCanvas(canvas);
  return _pixelRatio;
}

class Canvas {
  constructor(config) {
    this.pixelRatio = 1;
    this.width = 0;
    this.height = 0;
    this.isCache = false;
    const conf = config || {};
    const pixelRatio = conf.pixelRatio || Konva.pixelRatio || getDevicePixelRatio();
    this.pixelRatio = pixelRatio;
    this._canvas = Util.createCanvasElement();
    this._canvas.style.padding = "0";
    this._canvas.style.margin = "0";
    this._canvas.style.border = "0";
    this._canvas.style.background = "transparent";
    this._canvas.style.position = "absolute";
    this._canvas.style.top = "0";
    this._canvas.style.left = "0";
  }
  getContext() {
    return this.context;
  }
  getPixelRatio() {
    return this.pixelRatio;
  }
  setPixelRatio(pixelRatio) {
    const previousRatio = this.pixelRatio;
    this.pixelRatio = pixelRatio;
    this.setSize(this.getWidth() / previousRatio, this.getHeight() / previousRatio);
  }
  setWidth(width) {
    this.width = this._canvas.width = width * this.pixelRatio;
    this._canvas.style.width = width + "px";
    const pixelRatio = this.pixelRatio, _context = this.getContext()._context;
    _context.scale(pixelRatio, pixelRatio);
  }
  setHeight(height) {
    this.height = this._canvas.height = height * this.pixelRatio;
    this._canvas.style.height = height + "px";
    const pixelRatio = this.pixelRatio, _context = this.getContext()._context;
    _context.scale(pixelRatio, pixelRatio);
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  setSize(width, height) {
    this.setWidth(width || 0);
    this.setHeight(height || 0);
  }
  toDataURL(mimeType, quality) {
    try {
      return this._canvas.toDataURL(mimeType, quality);
    } catch (e) {
      try {
        return this._canvas.toDataURL();
      } catch (err) {
        Util.error("Unable to get data URL. " + err.message + " For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html.");
        return "";
      }
    }
  }
}

class SceneCanvas extends Canvas {
  constructor(config = { width: 0, height: 0, willReadFrequently: false }) {
    super(config);
    this.context = new SceneContext(this, {
      willReadFrequently: config.willReadFrequently
    });
    this.setSize(config.width, config.height);
  }
}

class HitCanvas extends Canvas {
  constructor(config = { width: 0, height: 0 }) {
    super(config);
    this.hitCanvas = true;
    this.context = new HitContext(this);
    this.setSize(config.width, config.height);
  }
}

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/DragAndDrop.js
var DD = {
  get isDragging() {
    let flag = false;
    DD._dragElements.forEach((elem) => {
      if (elem.dragStatus === "dragging") {
        flag = true;
      }
    });
    return flag;
  },
  justDragged: false,
  get node() {
    let node;
    DD._dragElements.forEach((elem) => {
      node = elem.node;
    });
    return node;
  },
  _dragElements: new Map,
  _drag(evt) {
    const nodesToFireEvents = [];
    DD._dragElements.forEach((elem, key) => {
      const { node } = elem;
      const stage = node.getStage();
      stage.setPointersPositions(evt);
      if (elem.pointerId === undefined) {
        elem.pointerId = Util._getFirstPointerId(evt);
      }
      const pos = stage._changedPointerPositions.find((pos2) => pos2.id === elem.pointerId);
      if (!pos) {
        return;
      }
      if (elem.dragStatus !== "dragging") {
        const dragDistance = node.dragDistance();
        const distance = Math.max(Math.abs(pos.x - elem.startPointerPos.x), Math.abs(pos.y - elem.startPointerPos.y));
        if (distance < dragDistance) {
          return;
        }
        node.startDrag({ evt });
        if (!node.isDragging()) {
          return;
        }
      }
      node._setDragPosition(evt, elem);
      nodesToFireEvents.push(node);
    });
    nodesToFireEvents.forEach((node) => {
      node.fire("dragmove", {
        type: "dragmove",
        target: node,
        evt
      }, true);
    });
  },
  _endDragBefore(evt) {
    const drawNodes = [];
    DD._dragElements.forEach((elem) => {
      const { node } = elem;
      const stage = node.getStage();
      if (evt) {
        stage.setPointersPositions(evt);
      }
      const pos = stage._changedPointerPositions.find((pos2) => pos2.id === elem.pointerId);
      if (!pos) {
        return;
      }
      if (elem.dragStatus === "dragging" || elem.dragStatus === "stopped") {
        DD.justDragged = true;
        Konva._mouseListenClick = false;
        Konva._touchListenClick = false;
        Konva._pointerListenClick = false;
        elem.dragStatus = "stopped";
      }
      const drawNode = elem.node.getLayer() || elem.node instanceof Konva["Stage"] && elem.node;
      if (drawNode && drawNodes.indexOf(drawNode) === -1) {
        drawNodes.push(drawNode);
      }
    });
    drawNodes.forEach((drawNode) => {
      drawNode.draw();
    });
  },
  _endDragAfter(evt) {
    DD._dragElements.forEach((elem, key) => {
      if (elem.dragStatus === "stopped") {
        elem.node.fire("dragend", {
          type: "dragend",
          target: elem.node,
          evt
        }, true);
      }
      if (elem.dragStatus !== "dragging") {
        DD._dragElements.delete(key);
      }
    });
  }
};
if (Konva.isBrowser) {
  window.addEventListener("mouseup", DD._endDragBefore, true);
  window.addEventListener("touchend", DD._endDragBefore, true);
  window.addEventListener("touchcancel", DD._endDragBefore, true);
  window.addEventListener("mousemove", DD._drag);
  window.addEventListener("touchmove", DD._drag);
  window.addEventListener("mouseup", DD._endDragAfter, false);
  window.addEventListener("touchend", DD._endDragAfter, false);
  window.addEventListener("touchcancel", DD._endDragAfter, false);
}

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/Validators.js
function _formatValue(val) {
  if (Util._isString(val)) {
    return '"' + val + '"';
  }
  if (Object.prototype.toString.call(val) === "[object Number]") {
    return val;
  }
  if (Util._isBoolean(val)) {
    return val;
  }
  return Object.prototype.toString.call(val);
}
function RGBComponent(val) {
  if (val > 255) {
    return 255;
  } else if (val < 0) {
    return 0;
  }
  return Math.round(val);
}
function getNumberValidator() {
  if (Konva.isUnminified) {
    return function(val, attr) {
      if (!Util._isNumber(val)) {
        Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number.');
      }
      return val;
    };
  }
}
function getNumberOrArrayOfNumbersValidator(noOfElements) {
  if (Konva.isUnminified) {
    return function(val, attr) {
      let isNumber = Util._isNumber(val);
      let isValidArray = Util._isArray(val) && val.length == noOfElements;
      if (!isNumber && !isValidArray) {
        Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number or Array<number>(' + noOfElements + ")");
      }
      return val;
    };
  }
}
function getNumberOrAutoValidator() {
  if (Konva.isUnminified) {
    return function(val, attr) {
      const isNumber = Util._isNumber(val);
      const isAuto = val === "auto";
      if (!(isNumber || isAuto)) {
        Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number or "auto".');
      }
      return val;
    };
  }
}
function getStringValidator() {
  if (Konva.isUnminified) {
    return function(val, attr) {
      if (!Util._isString(val)) {
        Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a string.');
      }
      return val;
    };
  }
}
function getStringOrGradientValidator() {
  if (Konva.isUnminified) {
    return function(val, attr) {
      const isString = Util._isString(val);
      const isGradient = Object.prototype.toString.call(val) === "[object CanvasGradient]" || val && val["addColorStop"];
      if (!(isString || isGradient)) {
        Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a string or a native gradient.');
      }
      return val;
    };
  }
}
function getNumberArrayValidator() {
  if (Konva.isUnminified) {
    return function(val, attr) {
      const TypedArray = Int8Array ? Object.getPrototypeOf(Int8Array) : null;
      if (TypedArray && val instanceof TypedArray) {
        return val;
      }
      if (!Util._isArray(val)) {
        Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a array of numbers.');
      } else {
        val.forEach(function(item) {
          if (!Util._isNumber(item)) {
            Util.warn('"' + attr + '" attribute has non numeric element ' + item + ". Make sure that all elements are numbers.");
          }
        });
      }
      return val;
    };
  }
}
function getBooleanValidator() {
  if (Konva.isUnminified) {
    return function(val, attr) {
      const isBool = val === true || val === false;
      if (!isBool) {
        Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a boolean.');
      }
      return val;
    };
  }
}
function getComponentValidator(components) {
  if (Konva.isUnminified) {
    return function(val, attr) {
      if (val === undefined || val === null) {
        return val;
      }
      if (!Util.isObject(val)) {
        Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be an object with properties ' + components);
      }
      return val;
    };
  }
}

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/Factory.js
var GET = "get";
var SET = "set";
var Factory = {
  addGetterSetter(constructor, attr, def, validator, after) {
    Factory.addGetter(constructor, attr, def);
    Factory.addSetter(constructor, attr, validator, after);
    Factory.addOverloadedGetterSetter(constructor, attr);
  },
  addGetter(constructor, attr, def) {
    const method = GET + Util._capitalize(attr);
    constructor.prototype[method] = constructor.prototype[method] || function() {
      const val = this.attrs[attr];
      return val === undefined ? def : val;
    };
  },
  addSetter(constructor, attr, validator, after) {
    const method = SET + Util._capitalize(attr);
    if (!constructor.prototype[method]) {
      Factory.overWriteSetter(constructor, attr, validator, after);
    }
  },
  overWriteSetter(constructor, attr, validator, after) {
    const method = SET + Util._capitalize(attr);
    constructor.prototype[method] = function(val) {
      if (validator && val !== undefined && val !== null) {
        val = validator.call(this, val, attr);
      }
      this._setAttr(attr, val);
      if (after) {
        after.call(this);
      }
      return this;
    };
  },
  addComponentsGetterSetter(constructor, attr, components, validator, after) {
    const len = components.length, capitalize = Util._capitalize, getter = GET + capitalize(attr), setter = SET + capitalize(attr);
    constructor.prototype[getter] = function() {
      const ret = {};
      for (let n = 0;n < len; n++) {
        const component = components[n];
        ret[component] = this.getAttr(attr + capitalize(component));
      }
      return ret;
    };
    const basicValidator = getComponentValidator(components);
    constructor.prototype[setter] = function(val) {
      const oldVal = this.attrs[attr];
      if (validator) {
        val = validator.call(this, val, attr);
      }
      if (basicValidator) {
        basicValidator.call(this, val, attr);
      }
      for (const key in val) {
        if (!val.hasOwnProperty(key)) {
          continue;
        }
        this._setAttr(attr + capitalize(key), val[key]);
      }
      if (!val) {
        components.forEach((component) => {
          this._setAttr(attr + capitalize(component), undefined);
        });
      }
      this._fireChangeEvent(attr, oldVal, val);
      if (after) {
        after.call(this);
      }
      return this;
    };
    Factory.addOverloadedGetterSetter(constructor, attr);
  },
  addOverloadedGetterSetter(constructor, attr) {
    const capitalizedAttr = Util._capitalize(attr), setter = SET + capitalizedAttr, getter = GET + capitalizedAttr;
    constructor.prototype[attr] = function() {
      if (arguments.length) {
        this[setter](arguments[0]);
        return this;
      }
      return this[getter]();
    };
  },
  addDeprecatedGetterSetter(constructor, attr, def, validator) {
    Util.error("Adding deprecated " + attr);
    const method = GET + Util._capitalize(attr);
    const message = attr + " property is deprecated and will be removed soon. Look at Konva change log for more information.";
    constructor.prototype[method] = function() {
      Util.error(message);
      const val = this.attrs[attr];
      return val === undefined ? def : val;
    };
    Factory.addSetter(constructor, attr, validator, function() {
      Util.error(message);
    });
    Factory.addOverloadedGetterSetter(constructor, attr);
  },
  backCompat(constructor, methods) {
    Util.each(methods, function(oldMethodName, newMethodName) {
      const method = constructor.prototype[newMethodName];
      const oldGetter = GET + Util._capitalize(oldMethodName);
      const oldSetter = SET + Util._capitalize(oldMethodName);
      function deprecated() {
        method.apply(this, arguments);
        Util.error('"' + oldMethodName + '" method is deprecated and will be removed soon. Use ""' + newMethodName + '" instead.');
      }
      constructor.prototype[oldMethodName] = deprecated;
      constructor.prototype[oldGetter] = deprecated;
      constructor.prototype[oldSetter] = deprecated;
    });
  },
  afterSetFilter() {
    this._filterUpToDate = false;
  }
};

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/Node.js
function parseCSSFilters(cssFilter) {
  const filterRegex = /(\w+)\(([^)]+)\)/g;
  let match;
  while ((match = filterRegex.exec(cssFilter)) !== null) {
    const [, filterName, filterValue] = match;
    switch (filterName) {
      case "blur": {
        const blurRadius = parseFloat(filterValue.replace("px", ""));
        return function(imageData) {
          this.blurRadius(blurRadius * 0.5);
          const KonvaFilters = Konva.Filters;
          if (KonvaFilters && KonvaFilters.Blur) {
            KonvaFilters.Blur.call(this, imageData);
          }
        };
      }
      case "brightness": {
        const brightness = filterValue.includes("%") ? parseFloat(filterValue) / 100 : parseFloat(filterValue);
        return function(imageData) {
          this.brightness(brightness);
          const KonvaFilters = Konva.Filters;
          if (KonvaFilters && KonvaFilters.Brightness) {
            KonvaFilters.Brightness.call(this, imageData);
          }
        };
      }
      case "contrast": {
        const contrast = parseFloat(filterValue);
        return function(imageData) {
          const konvaContrast = 100 * (Math.sqrt(contrast) - 1);
          this.contrast(konvaContrast);
          const KonvaFilters = Konva.Filters;
          if (KonvaFilters && KonvaFilters.Contrast) {
            KonvaFilters.Contrast.call(this, imageData);
          }
        };
      }
      case "grayscale": {
        return function(imageData) {
          const KonvaFilters = Konva.Filters;
          if (KonvaFilters && KonvaFilters.Grayscale) {
            KonvaFilters.Grayscale.call(this, imageData);
          }
        };
      }
      case "sepia": {
        return function(imageData) {
          const KonvaFilters = Konva.Filters;
          if (KonvaFilters && KonvaFilters.Sepia) {
            KonvaFilters.Sepia.call(this, imageData);
          }
        };
      }
      case "invert": {
        return function(imageData) {
          const KonvaFilters = Konva.Filters;
          if (KonvaFilters && KonvaFilters.Invert) {
            KonvaFilters.Invert.call(this, imageData);
          }
        };
      }
      default:
        Util.warn(`CSS filter "${filterName}" is not supported in fallback mode. Consider using function filters for better compatibility.`);
        break;
    }
  }
  return () => {};
}
var ABSOLUTE_OPACITY = "absoluteOpacity";
var ALL_LISTENERS = "allEventListeners";
var ABSOLUTE_TRANSFORM = "absoluteTransform";
var ABSOLUTE_SCALE = "absoluteScale";
var CANVAS = "canvas";
var CHANGE = "Change";
var CHILDREN = "children";
var KONVA = "konva";
var LISTENING = "listening";
var MOUSEENTER = "mouseenter";
var MOUSELEAVE = "mouseleave";
var POINTERENTER = "pointerenter";
var POINTERLEAVE = "pointerleave";
var TOUCHENTER = "touchenter";
var TOUCHLEAVE = "touchleave";
var SET2 = "set";
var SHAPE = "Shape";
var SPACE = " ";
var STAGE = "stage";
var TRANSFORM = "transform";
var UPPER_STAGE = "Stage";
var VISIBLE = "visible";
var TRANSFORM_CHANGE_STR = [
  "xChange.konva",
  "yChange.konva",
  "scaleXChange.konva",
  "scaleYChange.konva",
  "skewXChange.konva",
  "skewYChange.konva",
  "rotationChange.konva",
  "offsetXChange.konva",
  "offsetYChange.konva",
  "transformsEnabledChange.konva"
].join(SPACE);
var idCounter = 1;

class Node2 {
  constructor(config) {
    this._id = idCounter++;
    this.eventListeners = {};
    this.attrs = {};
    this.index = 0;
    this._allEventListeners = null;
    this.parent = null;
    this._cache = new Map;
    this._attachedDepsListeners = new Map;
    this._lastPos = null;
    this._batchingTransformChange = false;
    this._needClearTransformCache = false;
    this._filterUpToDate = false;
    this._isUnderCache = false;
    this._dragEventId = null;
    this._shouldFireChangeEvents = false;
    this.setAttrs(config);
    this._shouldFireChangeEvents = true;
  }
  hasChildren() {
    return false;
  }
  _clearCache(attr) {
    if ((attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM) && this._cache.get(attr)) {
      this._cache.get(attr).dirty = true;
    } else if (attr) {
      this._cache.delete(attr);
    } else {
      this._cache.clear();
    }
  }
  _getCache(attr, privateGetter) {
    let cache = this._cache.get(attr);
    const isTransform = attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM;
    const invalid = cache === undefined || isTransform && cache.dirty === true;
    if (invalid) {
      cache = privateGetter.call(this);
      this._cache.set(attr, cache);
    }
    return cache;
  }
  _calculate(name, deps, getter) {
    if (!this._attachedDepsListeners.get(name)) {
      const depsString = deps.map((dep) => dep + "Change.konva").join(SPACE);
      this.on(depsString, () => {
        this._clearCache(name);
      });
      this._attachedDepsListeners.set(name, true);
    }
    return this._getCache(name, getter);
  }
  _getCanvasCache() {
    return this._cache.get(CANVAS);
  }
  _clearSelfAndDescendantCache(attr) {
    this._clearCache(attr);
    if (attr === ABSOLUTE_TRANSFORM) {
      this.fire("absoluteTransformChange");
    }
  }
  clearCache() {
    if (this._cache.has(CANVAS)) {
      const { scene, filter, hit, buffer } = this._cache.get(CANVAS);
      Util.releaseCanvas(scene, filter, hit, buffer);
      this._cache.delete(CANVAS);
    }
    this._clearSelfAndDescendantCache();
    this._requestDraw();
    return this;
  }
  cache(config) {
    const conf = config || {};
    let rect = {};
    if (conf.x === undefined || conf.y === undefined || conf.width === undefined || conf.height === undefined) {
      rect = this.getClientRect({
        skipTransform: true,
        relativeTo: this.getParent() || undefined
      });
    }
    let width = Math.ceil(conf.width || rect.width), height = Math.ceil(conf.height || rect.height), pixelRatio = conf.pixelRatio, x = conf.x === undefined ? Math.floor(rect.x) : conf.x, y = conf.y === undefined ? Math.floor(rect.y) : conf.y, offset = conf.offset || 0, drawBorder = conf.drawBorder || false, hitCanvasPixelRatio = conf.hitCanvasPixelRatio || 1;
    if (!width || !height) {
      Util.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped.");
      return;
    }
    const extraPaddingX = Math.abs(Math.round(rect.x) - x) > 0.5 ? 1 : 0;
    const extraPaddingY = Math.abs(Math.round(rect.y) - y) > 0.5 ? 1 : 0;
    width += offset * 2 + extraPaddingX;
    height += offset * 2 + extraPaddingY;
    x -= offset;
    y -= offset;
    const cachedSceneCanvas = new SceneCanvas({
      pixelRatio,
      width,
      height
    }), cachedFilterCanvas = new SceneCanvas({
      pixelRatio,
      width: 0,
      height: 0,
      willReadFrequently: true
    }), cachedHitCanvas = new HitCanvas({
      pixelRatio: hitCanvasPixelRatio,
      width,
      height
    }), sceneContext = cachedSceneCanvas.getContext(), hitContext = cachedHitCanvas.getContext();
    const bufferCanvas = new SceneCanvas({
      width: cachedSceneCanvas.width / cachedSceneCanvas.pixelRatio + Math.abs(x),
      height: cachedSceneCanvas.height / cachedSceneCanvas.pixelRatio + Math.abs(y),
      pixelRatio: cachedSceneCanvas.pixelRatio
    }), bufferContext = bufferCanvas.getContext();
    cachedHitCanvas.isCache = true;
    cachedSceneCanvas.isCache = true;
    this._cache.delete(CANVAS);
    this._filterUpToDate = false;
    if (conf.imageSmoothingEnabled === false) {
      cachedSceneCanvas.getContext()._context.imageSmoothingEnabled = false;
      cachedFilterCanvas.getContext()._context.imageSmoothingEnabled = false;
    }
    sceneContext.save();
    hitContext.save();
    bufferContext.save();
    sceneContext.translate(-x, -y);
    hitContext.translate(-x, -y);
    bufferContext.translate(-x, -y);
    bufferCanvas.x = x;
    bufferCanvas.y = y;
    this._isUnderCache = true;
    this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
    this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
    this.drawScene(cachedSceneCanvas, this, bufferCanvas);
    this.drawHit(cachedHitCanvas, this);
    this._isUnderCache = false;
    sceneContext.restore();
    hitContext.restore();
    if (drawBorder) {
      sceneContext.save();
      sceneContext.beginPath();
      sceneContext.rect(0, 0, width, height);
      sceneContext.closePath();
      sceneContext.setAttr("strokeStyle", "red");
      sceneContext.setAttr("lineWidth", 5);
      sceneContext.stroke();
      sceneContext.restore();
    }
    this._cache.set(CANVAS, {
      scene: cachedSceneCanvas,
      filter: cachedFilterCanvas,
      hit: cachedHitCanvas,
      buffer: bufferCanvas,
      x,
      y
    });
    this._requestDraw();
    return this;
  }
  isCached() {
    return this._cache.has(CANVAS);
  }
  getClientRect(config) {
    throw new Error('abstract "getClientRect" method call');
  }
  _transformedRect(rect, top) {
    const points = [
      { x: rect.x, y: rect.y },
      { x: rect.x + rect.width, y: rect.y },
      { x: rect.x + rect.width, y: rect.y + rect.height },
      { x: rect.x, y: rect.y + rect.height }
    ];
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    const trans = this.getAbsoluteTransform(top);
    points.forEach(function(point) {
      const transformed = trans.point(point);
      if (minX === undefined) {
        minX = maxX = transformed.x;
        minY = maxY = transformed.y;
      }
      minX = Math.min(minX, transformed.x);
      minY = Math.min(minY, transformed.y);
      maxX = Math.max(maxX, transformed.x);
      maxY = Math.max(maxY, transformed.y);
    });
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  _drawCachedSceneCanvas(context) {
    context.save();
    context._applyOpacity(this);
    context._applyGlobalCompositeOperation(this);
    const canvasCache = this._getCanvasCache();
    context.translate(canvasCache.x, canvasCache.y);
    const cacheCanvas = this._getCachedSceneCanvas();
    const ratio = cacheCanvas.pixelRatio;
    context.drawImage(cacheCanvas._canvas, 0, 0, cacheCanvas.width / ratio, cacheCanvas.height / ratio);
    context.restore();
  }
  _drawCachedHitCanvas(context) {
    const canvasCache = this._getCanvasCache(), hitCanvas = canvasCache.hit;
    context.save();
    context.translate(canvasCache.x, canvasCache.y);
    context.drawImage(hitCanvas._canvas, 0, 0, hitCanvas.width / hitCanvas.pixelRatio, hitCanvas.height / hitCanvas.pixelRatio);
    context.restore();
  }
  _getCachedSceneCanvas() {
    let filters = this.filters(), cachedCanvas = this._getCanvasCache(), sceneCanvas = cachedCanvas.scene, filterCanvas = cachedCanvas.filter, filterContext = filterCanvas.getContext(), len, imageData, n, filter;
    if (!filters || filters.length === 0) {
      return sceneCanvas;
    }
    if (this._filterUpToDate) {
      return filterCanvas;
    }
    let useNativeOnly = true;
    for (let i = 0;i < filters.length; i++) {
      const fallbackRequired = typeof filters[i] === "string" && !isCSSFiltersSupported();
      if (fallbackRequired) {}
      if (typeof filters[i] !== "string" || !isCSSFiltersSupported()) {
        useNativeOnly = false;
        break;
      }
    }
    const ratio = sceneCanvas.pixelRatio;
    filterCanvas.setSize(sceneCanvas.width / sceneCanvas.pixelRatio, sceneCanvas.height / sceneCanvas.pixelRatio);
    if (useNativeOnly) {
      const finalFilter = filters.join(" ");
      filterContext.save();
      filterContext.setAttr("filter", finalFilter);
      filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio, sceneCanvas.getHeight() / ratio);
      filterContext.restore();
      this._filterUpToDate = true;
      return filterCanvas;
    }
    try {
      len = filters.length;
      filterContext.clear();
      filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio, sceneCanvas.getHeight() / ratio);
      imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight());
      for (n = 0;n < len; n++) {
        filter = filters[n];
        if (typeof filter === "string") {
          filter = parseCSSFilters(filter);
        }
        filter.call(this, imageData);
        filterContext.putImageData(imageData, 0, 0);
      }
    } catch (e) {
      Util.error("Unable to apply filter. " + e.message + " This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.");
    }
    this._filterUpToDate = true;
    return filterCanvas;
  }
  on(evtStr, handler) {
    if (this._cache) {
      this._cache.delete(ALL_LISTENERS);
    }
    if (arguments.length === 3) {
      return this._delegate.apply(this, arguments);
    }
    const events = evtStr.split(SPACE);
    for (let n = 0;n < events.length; n++) {
      const event = events[n];
      const parts = event.split(".");
      const baseEvent = parts[0];
      const name = parts[1] || "";
      if (!this.eventListeners[baseEvent]) {
        this.eventListeners[baseEvent] = [];
      }
      this.eventListeners[baseEvent].push({ name, handler });
    }
    return this;
  }
  off(evtStr, callback) {
    let events = (evtStr || "").split(SPACE), len = events.length, n, t, event, parts, baseEvent, name;
    this._cache && this._cache.delete(ALL_LISTENERS);
    if (!evtStr) {
      for (t in this.eventListeners) {
        this._off(t);
      }
    }
    for (n = 0;n < len; n++) {
      event = events[n];
      parts = event.split(".");
      baseEvent = parts[0];
      name = parts[1];
      if (baseEvent) {
        if (this.eventListeners[baseEvent]) {
          this._off(baseEvent, name, callback);
        }
      } else {
        for (t in this.eventListeners) {
          this._off(t, name, callback);
        }
      }
    }
    return this;
  }
  dispatchEvent(evt) {
    const e = {
      target: this,
      type: evt.type,
      evt
    };
    this.fire(evt.type, e);
    return this;
  }
  addEventListener(type, handler) {
    this.on(type, function(evt) {
      handler.call(this, evt.evt);
    });
    return this;
  }
  removeEventListener(type) {
    this.off(type);
    return this;
  }
  _delegate(event, selector, handler) {
    const stopNode = this;
    this.on(event, function(evt) {
      const targets = evt.target.findAncestors(selector, true, stopNode);
      for (let i = 0;i < targets.length; i++) {
        evt = Util.cloneObject(evt);
        evt.currentTarget = targets[i];
        handler.call(targets[i], evt);
      }
    });
  }
  remove() {
    if (this.isDragging()) {
      this.stopDrag();
    }
    DD._dragElements.delete(this._id);
    this._remove();
    return this;
  }
  _clearCaches() {
    this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
    this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
    this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
    this._clearSelfAndDescendantCache(STAGE);
    this._clearSelfAndDescendantCache(VISIBLE);
    this._clearSelfAndDescendantCache(LISTENING);
  }
  _remove() {
    this._clearCaches();
    const parent = this.getParent();
    if (parent && parent.children) {
      parent.children.splice(this.index, 1);
      parent._setChildrenIndices();
      this.parent = null;
    }
  }
  destroy() {
    this.remove();
    this.clearCache();
    return this;
  }
  getAttr(attr) {
    const method = "get" + Util._capitalize(attr);
    if (Util._isFunction(this[method])) {
      return this[method]();
    }
    return this.attrs[attr];
  }
  getAncestors() {
    let parent = this.getParent(), ancestors = [];
    while (parent) {
      ancestors.push(parent);
      parent = parent.getParent();
    }
    return ancestors;
  }
  getAttrs() {
    return this.attrs || {};
  }
  setAttrs(config) {
    this._batchTransformChanges(() => {
      let key, method;
      if (!config) {
        return this;
      }
      for (key in config) {
        if (key === CHILDREN) {
          continue;
        }
        method = SET2 + Util._capitalize(key);
        if (Util._isFunction(this[method])) {
          this[method](config[key]);
        } else {
          this._setAttr(key, config[key]);
        }
      }
    });
    return this;
  }
  isListening() {
    return this._getCache(LISTENING, this._isListening);
  }
  _isListening(relativeTo) {
    const listening = this.listening();
    if (!listening) {
      return false;
    }
    const parent = this.getParent();
    if (parent && parent !== relativeTo && this !== relativeTo) {
      return parent._isListening(relativeTo);
    } else {
      return true;
    }
  }
  isVisible() {
    return this._getCache(VISIBLE, this._isVisible);
  }
  _isVisible(relativeTo) {
    const visible = this.visible();
    if (!visible) {
      return false;
    }
    const parent = this.getParent();
    if (parent && parent !== relativeTo && this !== relativeTo) {
      return parent._isVisible(relativeTo);
    } else {
      return true;
    }
  }
  shouldDrawHit(top, skipDragCheck = false) {
    if (top) {
      return this._isVisible(top) && this._isListening(top);
    }
    const layer = this.getLayer();
    let layerUnderDrag = false;
    DD._dragElements.forEach((elem) => {
      if (elem.dragStatus !== "dragging") {
        return;
      } else if (elem.node.nodeType === "Stage") {
        layerUnderDrag = true;
      } else if (elem.node.getLayer() === layer) {
        layerUnderDrag = true;
      }
    });
    const dragSkip = !skipDragCheck && !Konva.hitOnDragEnabled && (layerUnderDrag || Konva.isTransforming());
    return this.isListening() && this.isVisible() && !dragSkip;
  }
  show() {
    this.visible(true);
    return this;
  }
  hide() {
    this.visible(false);
    return this;
  }
  getZIndex() {
    return this.index || 0;
  }
  getAbsoluteZIndex() {
    let depth = this.getDepth(), that = this, index = 0, nodes, len, n, child;
    function addChildren(children) {
      nodes = [];
      len = children.length;
      for (n = 0;n < len; n++) {
        child = children[n];
        index++;
        if (child.nodeType !== SHAPE) {
          nodes = nodes.concat(child.getChildren().slice());
        }
        if (child._id === that._id) {
          n = len;
        }
      }
      if (nodes.length > 0 && nodes[0].getDepth() <= depth) {
        addChildren(nodes);
      }
    }
    const stage = this.getStage();
    if (that.nodeType !== UPPER_STAGE && stage) {
      addChildren(stage.getChildren());
    }
    return index;
  }
  getDepth() {
    let depth = 0, parent = this.parent;
    while (parent) {
      depth++;
      parent = parent.parent;
    }
    return depth;
  }
  _batchTransformChanges(func) {
    this._batchingTransformChange = true;
    func();
    this._batchingTransformChange = false;
    if (this._needClearTransformCache) {
      this._clearCache(TRANSFORM);
      this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
    }
    this._needClearTransformCache = false;
  }
  setPosition(pos) {
    this._batchTransformChanges(() => {
      this.x(pos.x);
      this.y(pos.y);
    });
    return this;
  }
  getPosition() {
    return {
      x: this.x(),
      y: this.y()
    };
  }
  getRelativePointerPosition() {
    const stage = this.getStage();
    if (!stage) {
      return null;
    }
    const pos = stage.getPointerPosition();
    if (!pos) {
      return null;
    }
    const transform = this.getAbsoluteTransform().copy();
    transform.invert();
    return transform.point(pos);
  }
  getAbsolutePosition(top) {
    let haveCachedParent = false;
    let parent = this.parent;
    while (parent) {
      if (parent.isCached()) {
        haveCachedParent = true;
        break;
      }
      parent = parent.parent;
    }
    if (haveCachedParent && !top) {
      top = true;
    }
    const absoluteMatrix = this.getAbsoluteTransform(top).getMatrix(), absoluteTransform = new Transform, offset = this.offset();
    absoluteTransform.m = absoluteMatrix.slice();
    absoluteTransform.translate(offset.x, offset.y);
    return absoluteTransform.getTranslation();
  }
  setAbsolutePosition(pos) {
    const { x, y, ...origTrans } = this._clearTransform();
    this.attrs.x = x;
    this.attrs.y = y;
    this._clearCache(TRANSFORM);
    const it = this._getAbsoluteTransform().copy();
    it.invert();
    it.translate(pos.x, pos.y);
    pos = {
      x: this.attrs.x + it.getTranslation().x,
      y: this.attrs.y + it.getTranslation().y
    };
    this._setTransform(origTrans);
    this.setPosition({ x: pos.x, y: pos.y });
    this._clearCache(TRANSFORM);
    this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
    return this;
  }
  _setTransform(trans) {
    let key;
    for (key in trans) {
      this.attrs[key] = trans[key];
    }
  }
  _clearTransform() {
    const trans = {
      x: this.x(),
      y: this.y(),
      rotation: this.rotation(),
      scaleX: this.scaleX(),
      scaleY: this.scaleY(),
      offsetX: this.offsetX(),
      offsetY: this.offsetY(),
      skewX: this.skewX(),
      skewY: this.skewY()
    };
    this.attrs.x = 0;
    this.attrs.y = 0;
    this.attrs.rotation = 0;
    this.attrs.scaleX = 1;
    this.attrs.scaleY = 1;
    this.attrs.offsetX = 0;
    this.attrs.offsetY = 0;
    this.attrs.skewX = 0;
    this.attrs.skewY = 0;
    return trans;
  }
  move(change) {
    let { x: changeX, y: changeY } = change, x = this.x(), y = this.y();
    if (changeX !== undefined) {
      x += changeX;
    }
    if (changeY !== undefined) {
      y += changeY;
    }
    this.setPosition({ x, y });
    return this;
  }
  _eachAncestorReverse(func, top) {
    let family = [], parent = this.getParent(), len, n;
    if (top && top._id === this._id) {
      return;
    }
    family.unshift(this);
    while (parent && (!top || parent._id !== top._id)) {
      family.unshift(parent);
      parent = parent.parent;
    }
    len = family.length;
    for (n = 0;n < len; n++) {
      func(family[n]);
    }
  }
  rotate(theta) {
    this.rotation(this.rotation() + theta);
    return this;
  }
  moveToTop() {
    if (!this.parent) {
      Util.warn("Node has no parent. moveToTop function is ignored.");
      return false;
    }
    const index = this.index, len = this.parent.getChildren().length;
    if (index < len - 1) {
      this.parent.children.splice(index, 1);
      this.parent.children.push(this);
      this.parent._setChildrenIndices();
      return true;
    }
    return false;
  }
  moveUp() {
    if (!this.parent) {
      Util.warn("Node has no parent. moveUp function is ignored.");
      return false;
    }
    const index = this.index, len = this.parent.getChildren().length;
    if (index < len - 1) {
      this.parent.children.splice(index, 1);
      this.parent.children.splice(index + 1, 0, this);
      this.parent._setChildrenIndices();
      return true;
    }
    return false;
  }
  moveDown() {
    if (!this.parent) {
      Util.warn("Node has no parent. moveDown function is ignored.");
      return false;
    }
    const index = this.index;
    if (index > 0) {
      this.parent.children.splice(index, 1);
      this.parent.children.splice(index - 1, 0, this);
      this.parent._setChildrenIndices();
      return true;
    }
    return false;
  }
  moveToBottom() {
    if (!this.parent) {
      Util.warn("Node has no parent. moveToBottom function is ignored.");
      return false;
    }
    const index = this.index;
    if (index > 0) {
      this.parent.children.splice(index, 1);
      this.parent.children.unshift(this);
      this.parent._setChildrenIndices();
      return true;
    }
    return false;
  }
  setZIndex(zIndex) {
    if (!this.parent) {
      Util.warn("Node has no parent. zIndex parameter is ignored.");
      return this;
    }
    if (zIndex < 0 || zIndex >= this.parent.children.length) {
      Util.warn("Unexpected value " + zIndex + " for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to " + (this.parent.children.length - 1) + ".");
    }
    const index = this.index;
    this.parent.children.splice(index, 1);
    this.parent.children.splice(zIndex, 0, this);
    this.parent._setChildrenIndices();
    return this;
  }
  getAbsoluteOpacity() {
    return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);
  }
  _getAbsoluteOpacity() {
    let absOpacity = this.opacity();
    const parent = this.getParent();
    if (parent && !parent._isUnderCache) {
      absOpacity *= parent.getAbsoluteOpacity();
    }
    return absOpacity;
  }
  moveTo(newContainer) {
    if (this.getParent() !== newContainer) {
      this._remove();
      newContainer.add(this);
    }
    return this;
  }
  toObject() {
    let attrs = this.getAttrs(), key, val, getter, defaultValue, nonPlainObject;
    const obj = {
      attrs: {},
      className: this.getClassName()
    };
    for (key in attrs) {
      val = attrs[key];
      nonPlainObject = Util.isObject(val) && !Util._isPlainObject(val) && !Util._isArray(val);
      if (nonPlainObject) {
        continue;
      }
      getter = typeof this[key] === "function" && this[key];
      delete attrs[key];
      defaultValue = getter ? getter.call(this) : null;
      attrs[key] = val;
      if (defaultValue !== val) {
        obj.attrs[key] = val;
      }
    }
    return Util._prepareToStringify(obj);
  }
  toJSON() {
    return JSON.stringify(this.toObject());
  }
  getParent() {
    return this.parent;
  }
  findAncestors(selector, includeSelf, stopNode) {
    const res = [];
    if (includeSelf && this._isMatch(selector)) {
      res.push(this);
    }
    let ancestor = this.parent;
    while (ancestor) {
      if (ancestor === stopNode) {
        return res;
      }
      if (ancestor._isMatch(selector)) {
        res.push(ancestor);
      }
      ancestor = ancestor.parent;
    }
    return res;
  }
  isAncestorOf(node) {
    return false;
  }
  findAncestor(selector, includeSelf, stopNode) {
    return this.findAncestors(selector, includeSelf, stopNode)[0];
  }
  _isMatch(selector) {
    if (!selector) {
      return false;
    }
    if (typeof selector === "function") {
      return selector(this);
    }
    let selectorArr = selector.replace(/ /g, "").split(","), len = selectorArr.length, n, sel;
    for (n = 0;n < len; n++) {
      sel = selectorArr[n];
      if (!Util.isValidSelector(sel)) {
        Util.warn('Selector "' + sel + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".');
        Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".');
        Util.warn("Konva is awesome, right?");
      }
      if (sel.charAt(0) === "#") {
        if (this.id() === sel.slice(1)) {
          return true;
        }
      } else if (sel.charAt(0) === ".") {
        if (this.hasName(sel.slice(1))) {
          return true;
        }
      } else if (this.className === sel || this.nodeType === sel) {
        return true;
      }
    }
    return false;
  }
  getLayer() {
    const parent = this.getParent();
    return parent ? parent.getLayer() : null;
  }
  getStage() {
    return this._getCache(STAGE, this._getStage);
  }
  _getStage() {
    const parent = this.getParent();
    if (parent) {
      return parent.getStage();
    } else {
      return null;
    }
  }
  fire(eventType, evt = {}, bubble) {
    evt.target = evt.target || this;
    if (bubble) {
      this._fireAndBubble(eventType, evt);
    } else {
      this._fire(eventType, evt);
    }
    return this;
  }
  getAbsoluteTransform(top) {
    if (top) {
      return this._getAbsoluteTransform(top);
    } else {
      return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);
    }
  }
  _getAbsoluteTransform(top) {
    let at;
    if (top) {
      at = new Transform;
      this._eachAncestorReverse(function(node) {
        const transformsEnabled = node.transformsEnabled();
        if (transformsEnabled === "all") {
          at.multiply(node.getTransform());
        } else if (transformsEnabled === "position") {
          at.translate(node.x() - node.offsetX(), node.y() - node.offsetY());
        }
      }, top);
      return at;
    } else {
      at = this._cache.get(ABSOLUTE_TRANSFORM) || new Transform;
      if (this.parent) {
        this.parent.getAbsoluteTransform().copyInto(at);
      } else {
        at.reset();
      }
      const transformsEnabled = this.transformsEnabled();
      if (transformsEnabled === "all") {
        at.multiply(this.getTransform());
      } else if (transformsEnabled === "position") {
        const x = this.attrs.x || 0;
        const y = this.attrs.y || 0;
        const offsetX = this.attrs.offsetX || 0;
        const offsetY = this.attrs.offsetY || 0;
        at.translate(x - offsetX, y - offsetY);
      }
      at.dirty = false;
      return at;
    }
  }
  getAbsoluteScale(top) {
    let parent = this;
    while (parent) {
      if (parent._isUnderCache) {
        top = parent;
      }
      parent = parent.getParent();
    }
    const transform = this.getAbsoluteTransform(top);
    const attrs = transform.decompose();
    return {
      x: attrs.scaleX,
      y: attrs.scaleY
    };
  }
  getAbsoluteRotation() {
    return this.getAbsoluteTransform().decompose().rotation;
  }
  getTransform() {
    return this._getCache(TRANSFORM, this._getTransform);
  }
  _getTransform() {
    var _a, _b;
    const m = this._cache.get(TRANSFORM) || new Transform;
    m.reset();
    const x = this.x(), y = this.y(), rotation = Konva.getAngle(this.rotation()), scaleX = (_a = this.attrs.scaleX) !== null && _a !== undefined ? _a : 1, scaleY = (_b = this.attrs.scaleY) !== null && _b !== undefined ? _b : 1, skewX = this.attrs.skewX || 0, skewY = this.attrs.skewY || 0, offsetX = this.attrs.offsetX || 0, offsetY = this.attrs.offsetY || 0;
    if (x !== 0 || y !== 0) {
      m.translate(x, y);
    }
    if (rotation !== 0) {
      m.rotate(rotation);
    }
    if (skewX !== 0 || skewY !== 0) {
      m.skew(skewX, skewY);
    }
    if (scaleX !== 1 || scaleY !== 1) {
      m.scale(scaleX, scaleY);
    }
    if (offsetX !== 0 || offsetY !== 0) {
      m.translate(-1 * offsetX, -1 * offsetY);
    }
    m.dirty = false;
    return m;
  }
  clone(obj) {
    let attrs = Util.cloneObject(this.attrs), key, allListeners, len, n, listener;
    for (key in obj) {
      attrs[key] = obj[key];
    }
    const node = new this.constructor(attrs);
    for (key in this.eventListeners) {
      allListeners = this.eventListeners[key];
      len = allListeners.length;
      for (n = 0;n < len; n++) {
        listener = allListeners[n];
        if (listener.name.indexOf(KONVA) < 0) {
          if (!node.eventListeners[key]) {
            node.eventListeners[key] = [];
          }
          node.eventListeners[key].push(listener);
        }
      }
    }
    return node;
  }
  _toKonvaCanvas(config) {
    config = config || {};
    const box = this.getClientRect();
    const stage = this.getStage(), x = config.x !== undefined ? config.x : Math.floor(box.x), y = config.y !== undefined ? config.y : Math.floor(box.y), pixelRatio = config.pixelRatio || 1, canvas = new SceneCanvas({
      width: config.width || Math.ceil(box.width) || (stage ? stage.width() : 0),
      height: config.height || Math.ceil(box.height) || (stage ? stage.height() : 0),
      pixelRatio
    }), context = canvas.getContext();
    const bufferCanvas = new SceneCanvas({
      width: canvas.width / canvas.pixelRatio + Math.abs(x),
      height: canvas.height / canvas.pixelRatio + Math.abs(y),
      pixelRatio: canvas.pixelRatio
    });
    if (config.imageSmoothingEnabled === false) {
      context._context.imageSmoothingEnabled = false;
    }
    context.save();
    if (x || y) {
      context.translate(-1 * x, -1 * y);
    }
    this.drawScene(canvas, undefined, bufferCanvas);
    context.restore();
    return canvas;
  }
  toCanvas(config) {
    return this._toKonvaCanvas(config)._canvas;
  }
  toDataURL(config) {
    config = config || {};
    const mimeType = config.mimeType || null, quality = config.quality || null;
    const url = this._toKonvaCanvas(config).toDataURL(mimeType, quality);
    if (config.callback) {
      config.callback(url);
    }
    return url;
  }
  toImage(config) {
    return new Promise((resolve, reject) => {
      try {
        const callback = config === null || config === undefined ? undefined : config.callback;
        if (callback)
          delete config.callback;
        Util._urlToImage(this.toDataURL(config), function(img) {
          resolve(img);
          callback === null || callback === undefined || callback(img);
        });
      } catch (err) {
        reject(err);
      }
    });
  }
  toBlob(config) {
    return new Promise((resolve, reject) => {
      try {
        const callback = config === null || config === undefined ? undefined : config.callback;
        if (callback)
          delete config.callback;
        this.toCanvas(config).toBlob((blob) => {
          resolve(blob);
          callback === null || callback === undefined || callback(blob);
        }, config === null || config === undefined ? undefined : config.mimeType, config === null || config === undefined ? undefined : config.quality);
      } catch (err) {
        reject(err);
      }
    });
  }
  setSize(size) {
    this.width(size.width);
    this.height(size.height);
    return this;
  }
  getSize() {
    return {
      width: this.width(),
      height: this.height()
    };
  }
  getClassName() {
    return this.className || this.nodeType;
  }
  getType() {
    return this.nodeType;
  }
  getDragDistance() {
    if (this.attrs.dragDistance !== undefined) {
      return this.attrs.dragDistance;
    } else if (this.parent) {
      return this.parent.getDragDistance();
    } else {
      return Konva.dragDistance;
    }
  }
  _off(type, name, callback) {
    let evtListeners = this.eventListeners[type], i, evtName, handler;
    for (i = 0;i < evtListeners.length; i++) {
      evtName = evtListeners[i].name;
      handler = evtListeners[i].handler;
      if ((evtName !== "konva" || name === "konva") && (!name || evtName === name) && (!callback || callback === handler)) {
        evtListeners.splice(i, 1);
        if (evtListeners.length === 0) {
          delete this.eventListeners[type];
          break;
        }
        i--;
      }
    }
  }
  _fireChangeEvent(attr, oldVal, newVal) {
    this._fire(attr + CHANGE, {
      oldVal,
      newVal
    });
  }
  addName(name) {
    if (!this.hasName(name)) {
      const oldName = this.name();
      const newName = oldName ? oldName + " " + name : name;
      this.name(newName);
    }
    return this;
  }
  hasName(name) {
    if (!name) {
      return false;
    }
    const fullName = this.name();
    if (!fullName) {
      return false;
    }
    const names = (fullName || "").split(/\s/g);
    return names.indexOf(name) !== -1;
  }
  removeName(name) {
    const names = (this.name() || "").split(/\s/g);
    const index = names.indexOf(name);
    if (index !== -1) {
      names.splice(index, 1);
      this.name(names.join(" "));
    }
    return this;
  }
  setAttr(attr, val) {
    const func = this[SET2 + Util._capitalize(attr)];
    if (Util._isFunction(func)) {
      func.call(this, val);
    } else {
      this._setAttr(attr, val);
    }
    return this;
  }
  _requestDraw() {
    if (Konva.autoDrawEnabled) {
      const drawNode = this.getLayer() || this.getStage();
      drawNode === null || drawNode === undefined || drawNode.batchDraw();
    }
  }
  _setAttr(key, val) {
    const oldVal = this.attrs[key];
    if (oldVal === val && !Util.isObject(val)) {
      return;
    }
    if (val === undefined || val === null) {
      delete this.attrs[key];
    } else {
      this.attrs[key] = val;
    }
    if (this._shouldFireChangeEvents) {
      this._fireChangeEvent(key, oldVal, val);
    }
    this._requestDraw();
  }
  _setComponentAttr(key, component, val) {
    let oldVal;
    if (val !== undefined) {
      oldVal = this.attrs[key];
      if (!oldVal) {
        this.attrs[key] = this.getAttr(key);
      }
      this.attrs[key][component] = val;
      this._fireChangeEvent(key, oldVal, val);
    }
  }
  _fireAndBubble(eventType, evt, compareShape) {
    if (evt && this.nodeType === SHAPE) {
      evt.target = this;
    }
    const nonBubbling = [
      MOUSEENTER,
      MOUSELEAVE,
      POINTERENTER,
      POINTERLEAVE,
      TOUCHENTER,
      TOUCHLEAVE
    ];
    const shouldStop = nonBubbling.indexOf(eventType) !== -1 && (compareShape && (this === compareShape || this.isAncestorOf && this.isAncestorOf(compareShape)) || this.nodeType === "Stage" && !compareShape);
    if (!shouldStop) {
      this._fire(eventType, evt);
      const stopBubble = nonBubbling.indexOf(eventType) !== -1 && compareShape && compareShape.isAncestorOf && compareShape.isAncestorOf(this) && !compareShape.isAncestorOf(this.parent);
      if ((evt && !evt.cancelBubble || !evt) && this.parent && this.parent.isListening() && !stopBubble) {
        if (compareShape && compareShape.parent) {
          this._fireAndBubble.call(this.parent, eventType, evt, compareShape);
        } else {
          this._fireAndBubble.call(this.parent, eventType, evt);
        }
      }
    }
  }
  _getProtoListeners(eventType) {
    var _a, _b, _c;
    const allListeners = (_a = this._cache.get(ALL_LISTENERS)) !== null && _a !== undefined ? _a : {};
    let events = allListeners === null || allListeners === undefined ? undefined : allListeners[eventType];
    if (events === undefined) {
      events = [];
      let obj = Object.getPrototypeOf(this);
      while (obj) {
        const hierarchyEvents = (_c = (_b = obj.eventListeners) === null || _b === undefined ? undefined : _b[eventType]) !== null && _c !== undefined ? _c : [];
        events.push(...hierarchyEvents);
        obj = Object.getPrototypeOf(obj);
      }
      allListeners[eventType] = events;
      this._cache.set(ALL_LISTENERS, allListeners);
    }
    return events;
  }
  _fire(eventType, evt) {
    evt = evt || {};
    evt.currentTarget = this;
    evt.type = eventType;
    const topListeners = this._getProtoListeners(eventType);
    if (topListeners) {
      for (let i = 0;i < topListeners.length; i++) {
        topListeners[i].handler.call(this, evt);
      }
    }
    const selfListeners = this.eventListeners[eventType];
    if (selfListeners) {
      for (let i = 0;i < selfListeners.length; i++) {
        selfListeners[i].handler.call(this, evt);
      }
    }
  }
  draw() {
    this.drawScene();
    this.drawHit();
    return this;
  }
  _createDragElement(evt) {
    const pointerId = evt ? evt.pointerId : undefined;
    const stage = this.getStage();
    const ap = this.getAbsolutePosition();
    if (!stage) {
      return;
    }
    const pos = stage._getPointerById(pointerId) || stage._changedPointerPositions[0] || ap;
    DD._dragElements.set(this._id, {
      node: this,
      startPointerPos: pos,
      offset: {
        x: pos.x - ap.x,
        y: pos.y - ap.y
      },
      dragStatus: "ready",
      pointerId
    });
  }
  startDrag(evt, bubbleEvent = true) {
    if (!DD._dragElements.has(this._id)) {
      this._createDragElement(evt);
    }
    const elem = DD._dragElements.get(this._id);
    elem.dragStatus = "dragging";
    this.fire("dragstart", {
      type: "dragstart",
      target: this,
      evt: evt && evt.evt
    }, bubbleEvent);
  }
  _setDragPosition(evt, elem) {
    const pos = this.getStage()._getPointerById(elem.pointerId);
    if (!pos) {
      return;
    }
    let newNodePos = {
      x: pos.x - elem.offset.x,
      y: pos.y - elem.offset.y
    };
    const dbf = this.dragBoundFunc();
    if (dbf !== undefined) {
      const bounded = dbf.call(this, newNodePos, evt);
      if (!bounded) {
        Util.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.");
      } else {
        newNodePos = bounded;
      }
    }
    if (!this._lastPos || this._lastPos.x !== newNodePos.x || this._lastPos.y !== newNodePos.y) {
      this.setAbsolutePosition(newNodePos);
      this._requestDraw();
    }
    this._lastPos = newNodePos;
  }
  stopDrag(evt) {
    const elem = DD._dragElements.get(this._id);
    if (elem) {
      elem.dragStatus = "stopped";
    }
    DD._endDragBefore(evt);
    DD._endDragAfter(evt);
  }
  setDraggable(draggable) {
    this._setAttr("draggable", draggable);
    this._dragChange();
  }
  isDragging() {
    const elem = DD._dragElements.get(this._id);
    return elem ? elem.dragStatus === "dragging" : false;
  }
  _listenDrag() {
    this._dragCleanup();
    this.on("mousedown.konva touchstart.konva", function(evt) {
      const shouldCheckButton = evt.evt["button"] !== undefined;
      const canDrag = !shouldCheckButton || Konva.dragButtons.indexOf(evt.evt["button"]) >= 0;
      if (!canDrag) {
        return;
      }
      if (this.isDragging()) {
        return;
      }
      let hasDraggingChild = false;
      DD._dragElements.forEach((elem) => {
        if (this.isAncestorOf(elem.node)) {
          hasDraggingChild = true;
        }
      });
      if (!hasDraggingChild) {
        this._createDragElement(evt);
      }
    });
  }
  _dragChange() {
    if (this.attrs.draggable) {
      this._listenDrag();
    } else {
      this._dragCleanup();
      const stage = this.getStage();
      if (!stage) {
        return;
      }
      const dragElement = DD._dragElements.get(this._id);
      const isDragging = dragElement && dragElement.dragStatus === "dragging";
      const isReady = dragElement && dragElement.dragStatus === "ready";
      if (isDragging) {
        this.stopDrag();
      } else if (isReady) {
        DD._dragElements.delete(this._id);
      }
    }
  }
  _dragCleanup() {
    this.off("mousedown.konva");
    this.off("touchstart.konva");
  }
  isClientRectOnScreen(margin = { x: 0, y: 0 }) {
    const stage = this.getStage();
    if (!stage) {
      return false;
    }
    const screenRect = {
      x: -margin.x,
      y: -margin.y,
      width: stage.width() + 2 * margin.x,
      height: stage.height() + 2 * margin.y
    };
    return Util.haveIntersection(screenRect, this.getClientRect());
  }
  static create(data, container) {
    if (Util._isString(data)) {
      data = JSON.parse(data);
    }
    return this._createNode(data, container);
  }
  static _createNode(obj, container) {
    let className = Node2.prototype.getClassName.call(obj), children = obj.children, no, len, n;
    if (container) {
      obj.attrs.container = container;
    }
    if (!Konva[className]) {
      Util.warn('Can not find a node with class name "' + className + '". Fallback to "Shape".');
      className = "Shape";
    }
    const Class = Konva[className];
    no = new Class(obj.attrs);
    if (children) {
      len = children.length;
      for (n = 0;n < len; n++) {
        no.add(Node2._createNode(children[n]));
      }
    }
    return no;
  }
}
Node2.prototype.nodeType = "Node";
Node2.prototype._attrsAffectingSize = [];
Node2.prototype.eventListeners = {};
Node2.prototype.on.call(Node2.prototype, TRANSFORM_CHANGE_STR, function() {
  if (this._batchingTransformChange) {
    this._needClearTransformCache = true;
    return;
  }
  this._clearCache(TRANSFORM);
  this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
});
Node2.prototype.on.call(Node2.prototype, "visibleChange.konva", function() {
  this._clearSelfAndDescendantCache(VISIBLE);
});
Node2.prototype.on.call(Node2.prototype, "listeningChange.konva", function() {
  this._clearSelfAndDescendantCache(LISTENING);
});
Node2.prototype.on.call(Node2.prototype, "opacityChange.konva", function() {
  this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
});
var addGetterSetter = Factory.addGetterSetter;
addGetterSetter(Node2, "zIndex");
addGetterSetter(Node2, "absolutePosition");
addGetterSetter(Node2, "position");
addGetterSetter(Node2, "x", 0, getNumberValidator());
addGetterSetter(Node2, "y", 0, getNumberValidator());
addGetterSetter(Node2, "globalCompositeOperation", "source-over", getStringValidator());
addGetterSetter(Node2, "opacity", 1, getNumberValidator());
addGetterSetter(Node2, "name", "", getStringValidator());
addGetterSetter(Node2, "id", "", getStringValidator());
addGetterSetter(Node2, "rotation", 0, getNumberValidator());
Factory.addComponentsGetterSetter(Node2, "scale", ["x", "y"]);
addGetterSetter(Node2, "scaleX", 1, getNumberValidator());
addGetterSetter(Node2, "scaleY", 1, getNumberValidator());
Factory.addComponentsGetterSetter(Node2, "skew", ["x", "y"]);
addGetterSetter(Node2, "skewX", 0, getNumberValidator());
addGetterSetter(Node2, "skewY", 0, getNumberValidator());
Factory.addComponentsGetterSetter(Node2, "offset", ["x", "y"]);
addGetterSetter(Node2, "offsetX", 0, getNumberValidator());
addGetterSetter(Node2, "offsetY", 0, getNumberValidator());
addGetterSetter(Node2, "dragDistance", undefined, getNumberValidator());
addGetterSetter(Node2, "width", 0, getNumberValidator());
addGetterSetter(Node2, "height", 0, getNumberValidator());
addGetterSetter(Node2, "listening", true, getBooleanValidator());
addGetterSetter(Node2, "preventDefault", true, getBooleanValidator());
addGetterSetter(Node2, "filters", undefined, function(val) {
  this._filterUpToDate = false;
  return val;
});
addGetterSetter(Node2, "visible", true, getBooleanValidator());
addGetterSetter(Node2, "transformsEnabled", "all", getStringValidator());
addGetterSetter(Node2, "size");
addGetterSetter(Node2, "dragBoundFunc");
addGetterSetter(Node2, "draggable", false, getBooleanValidator());
Factory.backCompat(Node2, {
  rotateDeg: "rotate",
  setRotationDeg: "setRotation",
  getRotationDeg: "getRotation"
});

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/Container.js
class Container extends Node2 {
  constructor() {
    super(...arguments);
    this.children = [];
  }
  getChildren(filterFunc) {
    const children = this.children || [];
    if (filterFunc) {
      return children.filter(filterFunc);
    }
    return children;
  }
  hasChildren() {
    return this.getChildren().length > 0;
  }
  removeChildren() {
    this.getChildren().forEach((child) => {
      child.parent = null;
      child.index = 0;
      child.remove();
    });
    this.children = [];
    this._requestDraw();
    return this;
  }
  destroyChildren() {
    this.getChildren().forEach((child) => {
      child.parent = null;
      child.index = 0;
      child.destroy();
    });
    this.children = [];
    this._requestDraw();
    return this;
  }
  add(...children) {
    if (children.length === 0) {
      return this;
    }
    if (children.length > 1) {
      for (let i = 0;i < children.length; i++) {
        this.add(children[i]);
      }
      return this;
    }
    const child = children[0];
    if (child.getParent()) {
      child.moveTo(this);
      return this;
    }
    this._validateAdd(child);
    child.index = this.getChildren().length;
    child.parent = this;
    child._clearCaches();
    this.getChildren().push(child);
    this._fire("add", {
      child
    });
    this._requestDraw();
    return this;
  }
  destroy() {
    if (this.hasChildren()) {
      this.destroyChildren();
    }
    super.destroy();
    return this;
  }
  find(selector) {
    return this._generalFind(selector, false);
  }
  findOne(selector) {
    const result = this._generalFind(selector, true);
    return result.length > 0 ? result[0] : undefined;
  }
  _generalFind(selector, findOne) {
    const retArr = [];
    this._descendants((node) => {
      const valid = node._isMatch(selector);
      if (valid) {
        retArr.push(node);
      }
      if (valid && findOne) {
        return true;
      }
      return false;
    });
    return retArr;
  }
  _descendants(fn) {
    let shouldStop = false;
    const children = this.getChildren();
    for (const child of children) {
      shouldStop = fn(child);
      if (shouldStop) {
        return true;
      }
      if (!child.hasChildren()) {
        continue;
      }
      shouldStop = child._descendants(fn);
      if (shouldStop) {
        return true;
      }
    }
    return false;
  }
  toObject() {
    const obj = Node2.prototype.toObject.call(this);
    obj.children = [];
    this.getChildren().forEach((child) => {
      obj.children.push(child.toObject());
    });
    return obj;
  }
  isAncestorOf(node) {
    let parent = node.getParent();
    while (parent) {
      if (parent._id === this._id) {
        return true;
      }
      parent = parent.getParent();
    }
    return false;
  }
  clone(obj) {
    const node = Node2.prototype.clone.call(this, obj);
    this.getChildren().forEach(function(no) {
      node.add(no.clone());
    });
    return node;
  }
  getAllIntersections(pos) {
    const arr = [];
    this.find("Shape").forEach((shape) => {
      if (shape.isVisible() && shape.intersects(pos)) {
        arr.push(shape);
      }
    });
    return arr;
  }
  _clearSelfAndDescendantCache(attr) {
    var _a;
    super._clearSelfAndDescendantCache(attr);
    if (this.isCached()) {
      return;
    }
    (_a = this.children) === null || _a === undefined || _a.forEach(function(node) {
      node._clearSelfAndDescendantCache(attr);
    });
  }
  _setChildrenIndices() {
    var _a;
    (_a = this.children) === null || _a === undefined || _a.forEach(function(child, n) {
      child.index = n;
    });
    this._requestDraw();
  }
  drawScene(can, top, bufferCanvas) {
    const layer = this.getLayer(), canvas = can || layer && layer.getCanvas(), context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;
    const caching = canvas && canvas.isCache;
    if (!this.isVisible() && !caching) {
      return this;
    }
    if (cachedSceneCanvas) {
      context.save();
      const m = this.getAbsoluteTransform(top).getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      this._drawCachedSceneCanvas(context);
      context.restore();
    } else {
      this._drawChildren("drawScene", canvas, top, bufferCanvas);
    }
    return this;
  }
  drawHit(can, top) {
    if (!this.shouldDrawHit(top)) {
      return this;
    }
    const layer = this.getLayer(), canvas = can || layer && layer.hitCanvas, context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
    if (cachedHitCanvas) {
      context.save();
      const m = this.getAbsoluteTransform(top).getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      this._drawCachedHitCanvas(context);
      context.restore();
    } else {
      this._drawChildren("drawHit", canvas, top);
    }
    return this;
  }
  _drawChildren(drawMethod, canvas, top, bufferCanvas) {
    var _a;
    const context = canvas && canvas.getContext(), clipWidth = this.clipWidth(), clipHeight = this.clipHeight(), clipFunc = this.clipFunc(), hasClip = typeof clipWidth === "number" && typeof clipHeight === "number" || clipFunc;
    const selfCache = top === this;
    if (hasClip) {
      context.save();
      const transform = this.getAbsoluteTransform(top);
      let m = transform.getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      context.beginPath();
      let clipArgs;
      if (clipFunc) {
        clipArgs = clipFunc.call(this, context, this);
      } else {
        const clipX = this.clipX();
        const clipY = this.clipY();
        context.rect(clipX || 0, clipY || 0, clipWidth, clipHeight);
      }
      context.clip.apply(context, clipArgs);
      m = transform.copy().invert().getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    }
    const hasComposition = !selfCache && this.globalCompositeOperation() !== "source-over" && drawMethod === "drawScene";
    if (hasComposition) {
      context.save();
      context._applyGlobalCompositeOperation(this);
    }
    (_a = this.children) === null || _a === undefined || _a.forEach(function(child) {
      child[drawMethod](canvas, top, bufferCanvas);
    });
    if (hasComposition) {
      context.restore();
    }
    if (hasClip) {
      context.restore();
    }
  }
  getClientRect(config = {}) {
    var _a;
    const skipTransform = config.skipTransform;
    const relativeTo = config.relativeTo;
    let minX, minY, maxX, maxY;
    let selfRect = {
      x: Infinity,
      y: Infinity,
      width: 0,
      height: 0
    };
    const that = this;
    (_a = this.children) === null || _a === undefined || _a.forEach(function(child) {
      if (!child.visible()) {
        return;
      }
      const rect = child.getClientRect({
        relativeTo: that,
        skipShadow: config.skipShadow,
        skipStroke: config.skipStroke
      });
      if (rect.width === 0 && rect.height === 0) {
        return;
      }
      if (minX === undefined) {
        minX = rect.x;
        minY = rect.y;
        maxX = rect.x + rect.width;
        maxY = rect.y + rect.height;
      } else {
        minX = Math.min(minX, rect.x);
        minY = Math.min(minY, rect.y);
        maxX = Math.max(maxX, rect.x + rect.width);
        maxY = Math.max(maxY, rect.y + rect.height);
      }
    });
    const shapes = this.find("Shape");
    let hasVisible = false;
    for (let i = 0;i < shapes.length; i++) {
      const shape = shapes[i];
      if (shape._isVisible(this)) {
        hasVisible = true;
        break;
      }
    }
    if (hasVisible && minX !== undefined) {
      selfRect = {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    } else {
      selfRect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    }
    if (!skipTransform) {
      return this._transformedRect(selfRect, relativeTo);
    }
    return selfRect;
  }
}
Factory.addComponentsGetterSetter(Container, "clip", [
  "x",
  "y",
  "width",
  "height"
]);
Factory.addGetterSetter(Container, "clipX", undefined, getNumberValidator());
Factory.addGetterSetter(Container, "clipY", undefined, getNumberValidator());
Factory.addGetterSetter(Container, "clipWidth", undefined, getNumberValidator());
Factory.addGetterSetter(Container, "clipHeight", undefined, getNumberValidator());
Factory.addGetterSetter(Container, "clipFunc");

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/PointerEvents.js
var Captures = new Map;
var SUPPORT_POINTER_EVENTS = Konva._global["PointerEvent"] !== undefined;
function getCapturedShape(pointerId) {
  return Captures.get(pointerId);
}
function createEvent(evt) {
  return {
    evt,
    pointerId: evt.pointerId
  };
}
function hasPointerCapture(pointerId, shape) {
  return Captures.get(pointerId) === shape;
}
function setPointerCapture(pointerId, shape) {
  releaseCapture(pointerId);
  const stage = shape.getStage();
  if (!stage)
    return;
  Captures.set(pointerId, shape);
  if (SUPPORT_POINTER_EVENTS) {
    shape._fire("gotpointercapture", createEvent(new PointerEvent("gotpointercapture")));
  }
}
function releaseCapture(pointerId, target) {
  const shape = Captures.get(pointerId);
  if (!shape)
    return;
  const stage = shape.getStage();
  if (stage && stage.content) {}
  Captures.delete(pointerId);
  if (SUPPORT_POINTER_EVENTS) {
    shape._fire("lostpointercapture", createEvent(new PointerEvent("lostpointercapture")));
  }
}

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/Stage.js
var STAGE2 = "Stage";
var STRING = "string";
var PX = "px";
var MOUSEOUT = "mouseout";
var MOUSELEAVE2 = "mouseleave";
var MOUSEOVER = "mouseover";
var MOUSEENTER2 = "mouseenter";
var MOUSEMOVE = "mousemove";
var MOUSEDOWN = "mousedown";
var MOUSEUP = "mouseup";
var POINTERMOVE = "pointermove";
var POINTERDOWN = "pointerdown";
var POINTERUP = "pointerup";
var POINTERCANCEL = "pointercancel";
var LOSTPOINTERCAPTURE = "lostpointercapture";
var POINTEROUT = "pointerout";
var POINTERLEAVE2 = "pointerleave";
var POINTEROVER = "pointerover";
var POINTERENTER2 = "pointerenter";
var CONTEXTMENU = "contextmenu";
var TOUCHSTART = "touchstart";
var TOUCHEND = "touchend";
var TOUCHMOVE = "touchmove";
var TOUCHCANCEL = "touchcancel";
var WHEEL = "wheel";
var MAX_LAYERS_NUMBER = 5;
var EVENTS = [
  [MOUSEENTER2, "_pointerenter"],
  [MOUSEDOWN, "_pointerdown"],
  [MOUSEMOVE, "_pointermove"],
  [MOUSEUP, "_pointerup"],
  [MOUSELEAVE2, "_pointerleave"],
  [TOUCHSTART, "_pointerdown"],
  [TOUCHMOVE, "_pointermove"],
  [TOUCHEND, "_pointerup"],
  [TOUCHCANCEL, "_pointercancel"],
  [MOUSEOVER, "_pointerover"],
  [WHEEL, "_wheel"],
  [CONTEXTMENU, "_contextmenu"],
  [POINTERDOWN, "_pointerdown"],
  [POINTERMOVE, "_pointermove"],
  [POINTERUP, "_pointerup"],
  [POINTERCANCEL, "_pointercancel"],
  [POINTERLEAVE2, "_pointerleave"],
  [LOSTPOINTERCAPTURE, "_lostpointercapture"]
];
var EVENTS_MAP = {
  mouse: {
    [POINTEROUT]: MOUSEOUT,
    [POINTERLEAVE2]: MOUSELEAVE2,
    [POINTEROVER]: MOUSEOVER,
    [POINTERENTER2]: MOUSEENTER2,
    [POINTERMOVE]: MOUSEMOVE,
    [POINTERDOWN]: MOUSEDOWN,
    [POINTERUP]: MOUSEUP,
    [POINTERCANCEL]: "mousecancel",
    pointerclick: "click",
    pointerdblclick: "dblclick"
  },
  touch: {
    [POINTEROUT]: "touchout",
    [POINTERLEAVE2]: "touchleave",
    [POINTEROVER]: "touchover",
    [POINTERENTER2]: "touchenter",
    [POINTERMOVE]: TOUCHMOVE,
    [POINTERDOWN]: TOUCHSTART,
    [POINTERUP]: TOUCHEND,
    [POINTERCANCEL]: TOUCHCANCEL,
    pointerclick: "tap",
    pointerdblclick: "dbltap"
  },
  pointer: {
    [POINTEROUT]: POINTEROUT,
    [POINTERLEAVE2]: POINTERLEAVE2,
    [POINTEROVER]: POINTEROVER,
    [POINTERENTER2]: POINTERENTER2,
    [POINTERMOVE]: POINTERMOVE,
    [POINTERDOWN]: POINTERDOWN,
    [POINTERUP]: POINTERUP,
    [POINTERCANCEL]: POINTERCANCEL,
    pointerclick: "pointerclick",
    pointerdblclick: "pointerdblclick"
  }
};
var getEventType = (type) => {
  if (type.indexOf("pointer") >= 0) {
    return "pointer";
  }
  if (type.indexOf("touch") >= 0) {
    return "touch";
  }
  return "mouse";
};
var getEventsMap = (eventType) => {
  const type = getEventType(eventType);
  if (type === "pointer") {
    return Konva.pointerEventsEnabled && EVENTS_MAP.pointer;
  }
  if (type === "touch") {
    return EVENTS_MAP.touch;
  }
  if (type === "mouse") {
    return EVENTS_MAP.mouse;
  }
};
function checkNoClip(attrs = {}) {
  if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {
    Util.warn("Stage does not support clipping. Please use clip for Layers or Groups.");
  }
  return attrs;
}
var NO_POINTERS_MESSAGE = `Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);`;
var stages = [];

class Stage extends Container {
  constructor(config) {
    super(checkNoClip(config));
    this._pointerPositions = [];
    this._changedPointerPositions = [];
    this._buildDOM();
    this._bindContentEvents();
    stages.push(this);
    this.on("widthChange.konva heightChange.konva", this._resizeDOM);
    this.on("visibleChange.konva", this._checkVisibility);
    this.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva", () => {
      checkNoClip(this.attrs);
    });
    this._checkVisibility();
  }
  _validateAdd(child) {
    const isLayer = child.getType() === "Layer";
    const isFastLayer = child.getType() === "FastLayer";
    const valid = isLayer || isFastLayer;
    if (!valid) {
      Util.throw("You may only add layers to the stage.");
    }
  }
  _checkVisibility() {
    if (!this.content) {
      return;
    }
    const style = this.visible() ? "" : "none";
    this.content.style.display = style;
  }
  setContainer(container) {
    if (typeof container === STRING) {
      let id;
      if (container.charAt(0) === ".") {
        const className = container.slice(1);
        container = document.getElementsByClassName(className)[0];
      } else {
        if (container.charAt(0) !== "#") {
          id = container;
        } else {
          id = container.slice(1);
        }
        container = document.getElementById(id);
      }
      if (!container) {
        throw "Can not find container in document with id " + id;
      }
    }
    this._setAttr("container", container);
    if (this.content) {
      if (this.content.parentElement) {
        this.content.parentElement.removeChild(this.content);
      }
      container.appendChild(this.content);
    }
    return this;
  }
  shouldDrawHit() {
    return true;
  }
  clear() {
    const layers = this.children, len = layers.length;
    for (let n = 0;n < len; n++) {
      layers[n].clear();
    }
    return this;
  }
  clone(obj) {
    if (!obj) {
      obj = {};
    }
    obj.container = typeof document !== "undefined" && document.createElement("div");
    return Container.prototype.clone.call(this, obj);
  }
  destroy() {
    super.destroy();
    const content = this.content;
    if (content && Util._isInDocument(content)) {
      this.container().removeChild(content);
    }
    const index = stages.indexOf(this);
    if (index > -1) {
      stages.splice(index, 1);
    }
    Util.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas);
    return this;
  }
  getPointerPosition() {
    const pos = this._pointerPositions[0] || this._changedPointerPositions[0];
    if (!pos) {
      Util.warn(NO_POINTERS_MESSAGE);
      return null;
    }
    return {
      x: pos.x,
      y: pos.y
    };
  }
  _getPointerById(id) {
    return this._pointerPositions.find((p) => p.id === id);
  }
  getPointersPositions() {
    return this._pointerPositions;
  }
  getStage() {
    return this;
  }
  getContent() {
    return this.content;
  }
  _toKonvaCanvas(config) {
    config = { ...config };
    config.x = config.x || 0;
    config.y = config.y || 0;
    config.width = config.width || this.width();
    config.height = config.height || this.height();
    const canvas = new SceneCanvas({
      width: config.width,
      height: config.height,
      pixelRatio: config.pixelRatio || 1
    });
    const _context = canvas.getContext()._context;
    const layers = this.children;
    if (config.x || config.y) {
      _context.translate(-1 * config.x, -1 * config.y);
    }
    layers.forEach(function(layer) {
      if (!layer.isVisible()) {
        return;
      }
      const layerCanvas = layer._toKonvaCanvas(config);
      _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());
    });
    return canvas;
  }
  getIntersection(pos) {
    if (!pos) {
      return null;
    }
    const layers = this.children, len = layers.length, end = len - 1;
    for (let n = end;n >= 0; n--) {
      const shape = layers[n].getIntersection(pos);
      if (shape) {
        return shape;
      }
    }
    return null;
  }
  _resizeDOM() {
    const width = this.width();
    const height = this.height();
    if (this.content) {
      this.content.style.width = width + PX;
      this.content.style.height = height + PX;
    }
    this.bufferCanvas.setSize(width, height);
    this.bufferHitCanvas.setSize(width, height);
    this.children.forEach((layer) => {
      layer.setSize({ width, height });
      layer.draw();
    });
  }
  add(layer, ...rest) {
    if (arguments.length > 1) {
      for (let i = 0;i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    super.add(layer);
    const length = this.children.length;
    if (length > MAX_LAYERS_NUMBER) {
      Util.warn("The stage has " + length + " layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.");
    }
    layer.setSize({ width: this.width(), height: this.height() });
    layer.draw();
    if (Konva.isBrowser) {
      this.content.appendChild(layer.canvas._canvas);
    }
    return this;
  }
  getParent() {
    return null;
  }
  getLayer() {
    return null;
  }
  hasPointerCapture(pointerId) {
    return hasPointerCapture(pointerId, this);
  }
  setPointerCapture(pointerId) {
    setPointerCapture(pointerId, this);
  }
  releaseCapture(pointerId) {
    releaseCapture(pointerId, this);
  }
  getLayers() {
    return this.children;
  }
  _bindContentEvents() {
    if (!Konva.isBrowser) {
      return;
    }
    EVENTS.forEach(([event, methodName]) => {
      this.content.addEventListener(event, (evt) => {
        this[methodName](evt);
      }, { passive: false });
    });
  }
  _pointerenter(evt) {
    this.setPointersPositions(evt);
    const events = getEventsMap(evt.type);
    if (events) {
      this._fire(events.pointerenter, {
        evt,
        target: this,
        currentTarget: this
      });
    }
  }
  _pointerover(evt) {
    this.setPointersPositions(evt);
    const events = getEventsMap(evt.type);
    if (events) {
      this._fire(events.pointerover, {
        evt,
        target: this,
        currentTarget: this
      });
    }
  }
  _getTargetShape(evenType) {
    let shape = this[evenType + "targetShape"];
    if (shape && !shape.getStage()) {
      shape = null;
    }
    return shape;
  }
  _pointerleave(evt) {
    const events = getEventsMap(evt.type);
    const eventType = getEventType(evt.type);
    if (!events) {
      return;
    }
    this.setPointersPositions(evt);
    const targetShape = this._getTargetShape(eventType);
    const eventsEnabled = !(Konva.isDragging() || Konva.isTransforming()) || Konva.hitOnDragEnabled;
    if (targetShape && eventsEnabled) {
      targetShape._fireAndBubble(events.pointerout, { evt });
      targetShape._fireAndBubble(events.pointerleave, { evt });
      this._fire(events.pointerleave, {
        evt,
        target: this,
        currentTarget: this
      });
      this[eventType + "targetShape"] = null;
    } else if (eventsEnabled) {
      this._fire(events.pointerleave, {
        evt,
        target: this,
        currentTarget: this
      });
      this._fire(events.pointerout, {
        evt,
        target: this,
        currentTarget: this
      });
    }
    this.pointerPos = null;
    this._pointerPositions = [];
  }
  _pointerdown(evt) {
    const events = getEventsMap(evt.type);
    const eventType = getEventType(evt.type);
    if (!events) {
      return;
    }
    this.setPointersPositions(evt);
    let triggeredOnShape = false;
    this._changedPointerPositions.forEach((pos) => {
      const shape = this.getIntersection(pos);
      DD.justDragged = false;
      Konva["_" + eventType + "ListenClick"] = true;
      if (!shape || !shape.isListening()) {
        this[eventType + "ClickStartShape"] = undefined;
        return;
      }
      if (Konva.capturePointerEventsEnabled) {
        shape.setPointerCapture(pos.id);
      }
      this[eventType + "ClickStartShape"] = shape;
      shape._fireAndBubble(events.pointerdown, {
        evt,
        pointerId: pos.id
      });
      triggeredOnShape = true;
      const isTouch = evt.type.indexOf("touch") >= 0;
      if (shape.preventDefault() && evt.cancelable && isTouch) {
        evt.preventDefault();
      }
    });
    if (!triggeredOnShape) {
      this._fire(events.pointerdown, {
        evt,
        target: this,
        currentTarget: this,
        pointerId: this._pointerPositions[0].id
      });
    }
  }
  _pointermove(evt) {
    const events = getEventsMap(evt.type);
    const eventType = getEventType(evt.type);
    if (!events) {
      return;
    }
    const isTouchPointer = evt.type.indexOf("touch") >= 0 || evt.pointerType === "touch";
    if (Konva.isDragging() && DD.node.preventDefault() && evt.cancelable && isTouchPointer) {
      evt.preventDefault();
    }
    this.setPointersPositions(evt);
    const eventsEnabled = !(Konva.isDragging() || Konva.isTransforming()) || Konva.hitOnDragEnabled;
    if (!eventsEnabled) {
      return;
    }
    const processedShapesIds = {};
    let triggeredOnShape = false;
    const targetShape = this._getTargetShape(eventType);
    this._changedPointerPositions.forEach((pos) => {
      const shape = getCapturedShape(pos.id) || this.getIntersection(pos);
      const pointerId = pos.id;
      const event = { evt, pointerId };
      const differentTarget = targetShape !== shape;
      if (differentTarget && targetShape) {
        targetShape._fireAndBubble(events.pointerout, { ...event }, shape);
        targetShape._fireAndBubble(events.pointerleave, { ...event }, shape);
      }
      if (shape) {
        if (processedShapesIds[shape._id]) {
          return;
        }
        processedShapesIds[shape._id] = true;
      }
      if (shape && shape.isListening()) {
        triggeredOnShape = true;
        if (differentTarget) {
          shape._fireAndBubble(events.pointerover, { ...event }, targetShape);
          shape._fireAndBubble(events.pointerenter, { ...event }, targetShape);
          this[eventType + "targetShape"] = shape;
        }
        shape._fireAndBubble(events.pointermove, { ...event });
      } else {
        if (targetShape) {
          this._fire(events.pointerover, {
            evt,
            target: this,
            currentTarget: this,
            pointerId
          });
          this[eventType + "targetShape"] = null;
        }
      }
    });
    if (!triggeredOnShape) {
      this._fire(events.pointermove, {
        evt,
        target: this,
        currentTarget: this,
        pointerId: this._changedPointerPositions[0].id
      });
    }
  }
  _pointerup(evt) {
    const events = getEventsMap(evt.type);
    const eventType = getEventType(evt.type);
    if (!events) {
      return;
    }
    this.setPointersPositions(evt);
    const clickStartShape = this[eventType + "ClickStartShape"];
    const clickEndShape = this[eventType + "ClickEndShape"];
    const processedShapesIds = {};
    let skipPointerUpTrigger = false;
    this._changedPointerPositions.forEach((pos) => {
      const shape = getCapturedShape(pos.id) || this.getIntersection(pos);
      if (shape) {
        shape.releaseCapture(pos.id);
        if (processedShapesIds[shape._id]) {
          return;
        }
        processedShapesIds[shape._id] = true;
      }
      const pointerId = pos.id;
      const event = { evt, pointerId };
      let fireDblClick = false;
      if (Konva["_" + eventType + "InDblClickWindow"]) {
        fireDblClick = true;
        clearTimeout(this[eventType + "DblTimeout"]);
      } else if (!DD.justDragged) {
        Konva["_" + eventType + "InDblClickWindow"] = true;
        clearTimeout(this[eventType + "DblTimeout"]);
      }
      this[eventType + "DblTimeout"] = setTimeout(function() {
        Konva["_" + eventType + "InDblClickWindow"] = false;
      }, Konva.dblClickWindow);
      if (shape && shape.isListening()) {
        skipPointerUpTrigger = true;
        this[eventType + "ClickEndShape"] = shape;
        shape._fireAndBubble(events.pointerup, { ...event });
        if (Konva["_" + eventType + "ListenClick"] && clickStartShape && clickStartShape === shape) {
          shape._fireAndBubble(events.pointerclick, { ...event });
          if (fireDblClick && clickEndShape && clickEndShape === shape) {
            shape._fireAndBubble(events.pointerdblclick, { ...event });
          }
        }
      } else {
        this[eventType + "ClickEndShape"] = null;
        if (!skipPointerUpTrigger) {
          this._fire(events.pointerup, {
            evt,
            target: this,
            currentTarget: this,
            pointerId: this._changedPointerPositions[0].id
          });
          skipPointerUpTrigger = true;
        }
        if (Konva["_" + eventType + "ListenClick"]) {
          this._fire(events.pointerclick, {
            evt,
            target: this,
            currentTarget: this,
            pointerId
          });
        }
        if (fireDblClick) {
          this._fire(events.pointerdblclick, {
            evt,
            target: this,
            currentTarget: this,
            pointerId
          });
        }
      }
    });
    if (!skipPointerUpTrigger) {
      this._fire(events.pointerup, {
        evt,
        target: this,
        currentTarget: this,
        pointerId: this._changedPointerPositions[0].id
      });
    }
    Konva["_" + eventType + "ListenClick"] = false;
    if (evt.cancelable && eventType !== "touch" && eventType !== "pointer") {
      evt.preventDefault();
    }
  }
  _contextmenu(evt) {
    this.setPointersPositions(evt);
    const shape = this.getIntersection(this.getPointerPosition());
    if (shape && shape.isListening()) {
      shape._fireAndBubble(CONTEXTMENU, { evt });
    } else {
      this._fire(CONTEXTMENU, {
        evt,
        target: this,
        currentTarget: this
      });
    }
  }
  _wheel(evt) {
    this.setPointersPositions(evt);
    const shape = this.getIntersection(this.getPointerPosition());
    if (shape && shape.isListening()) {
      shape._fireAndBubble(WHEEL, { evt });
    } else {
      this._fire(WHEEL, {
        evt,
        target: this,
        currentTarget: this
      });
    }
  }
  _pointercancel(evt) {
    this.setPointersPositions(evt);
    const shape = getCapturedShape(evt.pointerId) || this.getIntersection(this.getPointerPosition());
    if (shape) {
      shape._fireAndBubble(POINTERUP, createEvent(evt));
    }
    releaseCapture(evt.pointerId);
  }
  _lostpointercapture(evt) {
    releaseCapture(evt.pointerId);
  }
  setPointersPositions(evt) {
    const contentPosition = this._getContentPosition();
    let x = null, y = null;
    evt = evt ? evt : window.event;
    if (evt.touches !== undefined) {
      this._pointerPositions = [];
      this._changedPointerPositions = [];
      Array.prototype.forEach.call(evt.touches, (touch) => {
        this._pointerPositions.push({
          id: touch.identifier,
          x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
          y: (touch.clientY - contentPosition.top) / contentPosition.scaleY
        });
      });
      Array.prototype.forEach.call(evt.changedTouches || evt.touches, (touch) => {
        this._changedPointerPositions.push({
          id: touch.identifier,
          x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
          y: (touch.clientY - contentPosition.top) / contentPosition.scaleY
        });
      });
    } else {
      x = (evt.clientX - contentPosition.left) / contentPosition.scaleX;
      y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;
      this.pointerPos = {
        x,
        y
      };
      this._pointerPositions = [{ x, y, id: Util._getFirstPointerId(evt) }];
      this._changedPointerPositions = [
        { x, y, id: Util._getFirstPointerId(evt) }
      ];
    }
  }
  _setPointerPosition(evt) {
    Util.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.');
    this.setPointersPositions(evt);
  }
  _getContentPosition() {
    if (!this.content || !this.content.getBoundingClientRect) {
      return {
        top: 0,
        left: 0,
        scaleX: 1,
        scaleY: 1
      };
    }
    const rect = this.content.getBoundingClientRect();
    return {
      top: rect.top,
      left: rect.left,
      scaleX: rect.width / this.content.clientWidth || 1,
      scaleY: rect.height / this.content.clientHeight || 1
    };
  }
  _buildDOM() {
    this.bufferCanvas = new SceneCanvas({
      width: this.width(),
      height: this.height()
    });
    this.bufferHitCanvas = new HitCanvas({
      pixelRatio: 1,
      width: this.width(),
      height: this.height()
    });
    if (!Konva.isBrowser) {
      return;
    }
    const container = this.container();
    if (!container) {
      throw "Stage has no container. A container is required.";
    }
    container.innerHTML = "";
    this.content = document.createElement("div");
    this.content.style.position = "relative";
    this.content.style.userSelect = "none";
    this.content.className = "konvajs-content";
    this.content.setAttribute("role", "presentation");
    container.appendChild(this.content);
    this._resizeDOM();
  }
  cache() {
    Util.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.");
    return this;
  }
  clearCache() {
    return this;
  }
  batchDraw() {
    this.getChildren().forEach(function(layer) {
      layer.batchDraw();
    });
    return this;
  }
}
Stage.prototype.nodeType = STAGE2;
_registerNode(Stage);
Factory.addGetterSetter(Stage, "container");
if (Konva.isBrowser) {
  document.addEventListener("visibilitychange", () => {
    stages.forEach((stage) => {
      stage.batchDraw();
    });
  });
}

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/Shape.js
var HAS_SHADOW = "hasShadow";
var SHADOW_RGBA = "shadowRGBA";
var patternImage = "patternImage";
var linearGradient = "linearGradient";
var radialGradient = "radialGradient";
var dummyContext;
function getDummyContext() {
  if (dummyContext) {
    return dummyContext;
  }
  dummyContext = Util.createCanvasElement().getContext("2d");
  return dummyContext;
}
var shapes = {};
function _fillFunc(context) {
  const fillRule = this.attrs.fillRule;
  if (fillRule) {
    context.fill(fillRule);
  } else {
    context.fill();
  }
}
function _strokeFunc(context) {
  context.stroke();
}
function _fillFuncHit(context) {
  const fillRule = this.attrs.fillRule;
  if (fillRule) {
    context.fill(fillRule);
  } else {
    context.fill();
  }
}
function _strokeFuncHit(context) {
  context.stroke();
}
function _clearHasShadowCache() {
  this._clearCache(HAS_SHADOW);
}
function _clearGetShadowRGBACache() {
  this._clearCache(SHADOW_RGBA);
}
function _clearFillPatternCache() {
  this._clearCache(patternImage);
}
function _clearLinearGradientCache() {
  this._clearCache(linearGradient);
}
function _clearRadialGradientCache() {
  this._clearCache(radialGradient);
}

class Shape extends Node2 {
  constructor(config) {
    super(config);
    let key;
    let attempts = 0;
    while (true) {
      key = Util.getHitColor();
      if (key && !(key in shapes)) {
        break;
      }
      attempts++;
      if (attempts >= 1e4) {
        Util.warn("Failed to find a unique color key for a shape. Konva may work incorrectly. Most likely your browser is using canvas farbling. Consider disabling it.");
        key = Util.getRandomColor();
        break;
      }
    }
    this.colorKey = key;
    shapes[key] = this;
  }
  getContext() {
    Util.warn("shape.getContext() method is deprecated. Please do not use it.");
    return this.getLayer().getContext();
  }
  getCanvas() {
    Util.warn("shape.getCanvas() method is deprecated. Please do not use it.");
    return this.getLayer().getCanvas();
  }
  getSceneFunc() {
    return this.attrs.sceneFunc || this["_sceneFunc"];
  }
  getHitFunc() {
    return this.attrs.hitFunc || this["_hitFunc"];
  }
  hasShadow() {
    return this._getCache(HAS_SHADOW, this._hasShadow);
  }
  _hasShadow() {
    return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY());
  }
  _getFillPattern() {
    return this._getCache(patternImage, this.__getFillPattern);
  }
  __getFillPattern() {
    if (this.fillPatternImage()) {
      const ctx = getDummyContext();
      const pattern = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || "repeat");
      if (pattern && pattern.setTransform) {
        const tr = new Transform;
        tr.translate(this.fillPatternX(), this.fillPatternY());
        tr.rotate(Konva.getAngle(this.fillPatternRotation()));
        tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY());
        tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());
        const m = tr.getMatrix();
        const matrix = typeof DOMMatrix === "undefined" ? {
          a: m[0],
          b: m[1],
          c: m[2],
          d: m[3],
          e: m[4],
          f: m[5]
        } : new DOMMatrix(m);
        pattern.setTransform(matrix);
      }
      return pattern;
    }
  }
  _getLinearGradient() {
    return this._getCache(linearGradient, this.__getLinearGradient);
  }
  __getLinearGradient() {
    const colorStops = this.fillLinearGradientColorStops();
    if (colorStops) {
      const ctx = getDummyContext();
      const start = this.fillLinearGradientStartPoint();
      const end = this.fillLinearGradientEndPoint();
      const grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
      for (let n = 0;n < colorStops.length; n += 2) {
        grd.addColorStop(colorStops[n], colorStops[n + 1]);
      }
      return grd;
    }
  }
  _getRadialGradient() {
    return this._getCache(radialGradient, this.__getRadialGradient);
  }
  __getRadialGradient() {
    const colorStops = this.fillRadialGradientColorStops();
    if (colorStops) {
      const ctx = getDummyContext();
      const start = this.fillRadialGradientStartPoint();
      const end = this.fillRadialGradientEndPoint();
      const grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());
      for (let n = 0;n < colorStops.length; n += 2) {
        grd.addColorStop(colorStops[n], colorStops[n + 1]);
      }
      return grd;
    }
  }
  getShadowRGBA() {
    return this._getCache(SHADOW_RGBA, this._getShadowRGBA);
  }
  _getShadowRGBA() {
    if (!this.hasShadow()) {
      return;
    }
    const rgba = Util.colorToRGBA(this.shadowColor());
    if (rgba) {
      return "rgba(" + rgba.r + "," + rgba.g + "," + rgba.b + "," + rgba.a * (this.shadowOpacity() || 1) + ")";
    }
  }
  hasFill() {
    return this._calculate("hasFill", [
      "fillEnabled",
      "fill",
      "fillPatternImage",
      "fillLinearGradientColorStops",
      "fillRadialGradientColorStops"
    ], () => {
      return this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops());
    });
  }
  hasStroke() {
    return this._calculate("hasStroke", [
      "strokeEnabled",
      "strokeWidth",
      "stroke",
      "strokeLinearGradientColorStops"
    ], () => {
      return this.strokeEnabled() && this.strokeWidth() && !!(this.stroke() || this.strokeLinearGradientColorStops());
    });
  }
  hasHitStroke() {
    const width = this.hitStrokeWidth();
    if (width === "auto") {
      return this.hasStroke();
    }
    return this.strokeEnabled() && !!width;
  }
  intersects(point) {
    const stage = this.getStage();
    if (!stage) {
      return false;
    }
    const bufferHitCanvas = stage.bufferHitCanvas;
    bufferHitCanvas.getContext().clear();
    this.drawHit(bufferHitCanvas, undefined, true);
    const p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;
    return p[3] > 0;
  }
  destroy() {
    Node2.prototype.destroy.call(this);
    delete shapes[this.colorKey];
    delete this.colorKey;
    return this;
  }
  _useBufferCanvas(forceFill) {
    var _a;
    const perfectDrawEnabled = (_a = this.attrs.perfectDrawEnabled) !== null && _a !== undefined ? _a : true;
    if (!perfectDrawEnabled) {
      return false;
    }
    const hasFill = forceFill || this.hasFill();
    const hasStroke = this.hasStroke();
    const isTransparent = this.getAbsoluteOpacity() !== 1;
    if (hasFill && hasStroke && isTransparent) {
      return true;
    }
    const hasShadow = this.hasShadow();
    const strokeForShadow = this.shadowForStrokeEnabled();
    if (hasFill && hasStroke && hasShadow && strokeForShadow) {
      return true;
    }
    return false;
  }
  setStrokeHitEnabled(val) {
    Util.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead.");
    if (val) {
      this.hitStrokeWidth("auto");
    } else {
      this.hitStrokeWidth(0);
    }
  }
  getStrokeHitEnabled() {
    if (this.hitStrokeWidth() === 0) {
      return false;
    } else {
      return true;
    }
  }
  getSelfRect() {
    const size = this.size();
    return {
      x: this._centroid ? -size.width / 2 : 0,
      y: this._centroid ? -size.height / 2 : 0,
      width: size.width,
      height: size.height
    };
  }
  getClientRect(config = {}) {
    let hasCachedParent = false;
    let parent = this.getParent();
    while (parent) {
      if (parent.isCached()) {
        hasCachedParent = true;
        break;
      }
      parent = parent.getParent();
    }
    const skipTransform = config.skipTransform;
    const relativeTo = config.relativeTo || hasCachedParent && this.getStage() || undefined;
    const fillRect = this.getSelfRect();
    const applyStroke = !config.skipStroke && this.hasStroke();
    const strokeWidth = applyStroke && this.strokeWidth() || 0;
    const fillAndStrokeWidth = fillRect.width + strokeWidth;
    const fillAndStrokeHeight = fillRect.height + strokeWidth;
    const applyShadow = !config.skipShadow && this.hasShadow();
    const shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;
    const shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;
    const preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);
    const preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);
    const blurRadius = applyShadow && this.shadowBlur() || 0;
    const width = preWidth + blurRadius * 2;
    const height = preHeight + blurRadius * 2;
    const rect = {
      width,
      height,
      x: -(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetX, 0) + fillRect.x,
      y: -(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetY, 0) + fillRect.y
    };
    if (!skipTransform) {
      return this._transformedRect(rect, relativeTo);
    }
    return rect;
  }
  drawScene(can, top, bufferCanvas) {
    const layer = this.getLayer();
    const canvas = can || layer.getCanvas(), context = canvas.getContext(), cachedCanvas = this._getCanvasCache(), drawFunc = this.getSceneFunc(), hasShadow = this.hasShadow();
    let stage;
    const skipBuffer = false;
    const cachingSelf = top === this;
    if (!this.isVisible() && !cachingSelf) {
      return this;
    }
    if (cachedCanvas) {
      context.save();
      const m = this.getAbsoluteTransform(top).getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      this._drawCachedSceneCanvas(context);
      context.restore();
      return this;
    }
    if (!drawFunc) {
      return this;
    }
    context.save();
    if (this._useBufferCanvas() && !skipBuffer) {
      stage = this.getStage();
      const bc = bufferCanvas || stage.bufferCanvas;
      const bufferContext = bc.getContext();
      bufferContext.clear();
      bufferContext.save();
      bufferContext._applyLineJoin(this);
      bufferContext._applyMiterLimit(this);
      const o = this.getAbsoluteTransform(top).getMatrix();
      bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
      drawFunc.call(this, bufferContext, this);
      bufferContext.restore();
      const ratio = bc.pixelRatio;
      if (hasShadow) {
        context._applyShadow(this);
      }
      if (!cachingSelf) {
        context._applyOpacity(this);
        context._applyGlobalCompositeOperation(this);
      }
      context.drawImage(bc._canvas, bc.x || 0, bc.y || 0, bc.width / ratio, bc.height / ratio);
    } else {
      context._applyLineJoin(this);
      context._applyMiterLimit(this);
      if (!cachingSelf) {
        const o = this.getAbsoluteTransform(top).getMatrix();
        context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
        context._applyOpacity(this);
        context._applyGlobalCompositeOperation(this);
      }
      if (hasShadow) {
        context._applyShadow(this);
      }
      drawFunc.call(this, context, this);
    }
    context.restore();
    return this;
  }
  drawHit(can, top, skipDragCheck = false) {
    if (!this.shouldDrawHit(top, skipDragCheck)) {
      return this;
    }
    const layer = this.getLayer(), canvas = can || layer.hitCanvas, context = canvas && canvas.getContext(), drawFunc = this.hitFunc() || this.sceneFunc(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
    if (!this.colorKey) {
      Util.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()");
    }
    if (cachedHitCanvas) {
      context.save();
      const m = this.getAbsoluteTransform(top).getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      this._drawCachedHitCanvas(context);
      context.restore();
      return this;
    }
    if (!drawFunc) {
      return this;
    }
    context.save();
    context._applyLineJoin(this);
    context._applyMiterLimit(this);
    const selfCache = this === top;
    if (!selfCache) {
      const o = this.getAbsoluteTransform(top).getMatrix();
      context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
    }
    drawFunc.call(this, context, this);
    context.restore();
    return this;
  }
  drawHitFromCache(alphaThreshold = 0) {
    const cachedCanvas = this._getCanvasCache(), sceneCanvas = this._getCachedSceneCanvas(), hitCanvas = cachedCanvas.hit, hitContext = hitCanvas.getContext(), hitWidth = hitCanvas.getWidth(), hitHeight = hitCanvas.getHeight();
    hitContext.clear();
    hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);
    try {
      const hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);
      const hitData = hitImageData.data;
      const len = hitData.length;
      const rgbColorKey = Util._hexToRgb(this.colorKey);
      for (let i = 0;i < len; i += 4) {
        const alpha = hitData[i + 3];
        if (alpha > alphaThreshold) {
          hitData[i] = rgbColorKey.r;
          hitData[i + 1] = rgbColorKey.g;
          hitData[i + 2] = rgbColorKey.b;
          hitData[i + 3] = 255;
        } else {
          hitData[i + 3] = 0;
        }
      }
      hitContext.putImageData(hitImageData, 0, 0);
    } catch (e) {
      Util.error("Unable to draw hit graph from cached scene canvas. " + e.message);
    }
    return this;
  }
  hasPointerCapture(pointerId) {
    return hasPointerCapture(pointerId, this);
  }
  setPointerCapture(pointerId) {
    setPointerCapture(pointerId, this);
  }
  releaseCapture(pointerId) {
    releaseCapture(pointerId, this);
  }
}
Shape.prototype._fillFunc = _fillFunc;
Shape.prototype._strokeFunc = _strokeFunc;
Shape.prototype._fillFuncHit = _fillFuncHit;
Shape.prototype._strokeFuncHit = _strokeFuncHit;
Shape.prototype._centroid = false;
Shape.prototype.nodeType = "Shape";
_registerNode(Shape);
Shape.prototype.eventListeners = {};
Shape.prototype.on.call(Shape.prototype, "shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", _clearHasShadowCache);
Shape.prototype.on.call(Shape.prototype, "shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", _clearGetShadowRGBACache);
Shape.prototype.on.call(Shape.prototype, "fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva", _clearFillPatternCache);
Shape.prototype.on.call(Shape.prototype, "fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva", _clearLinearGradientCache);
Shape.prototype.on.call(Shape.prototype, "fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva", _clearRadialGradientCache);
Factory.addGetterSetter(Shape, "stroke", undefined, getStringOrGradientValidator());
Factory.addGetterSetter(Shape, "strokeWidth", 2, getNumberValidator());
Factory.addGetterSetter(Shape, "fillAfterStrokeEnabled", false);
Factory.addGetterSetter(Shape, "hitStrokeWidth", "auto", getNumberOrAutoValidator());
Factory.addGetterSetter(Shape, "strokeHitEnabled", true, getBooleanValidator());
Factory.addGetterSetter(Shape, "perfectDrawEnabled", true, getBooleanValidator());
Factory.addGetterSetter(Shape, "shadowForStrokeEnabled", true, getBooleanValidator());
Factory.addGetterSetter(Shape, "lineJoin");
Factory.addGetterSetter(Shape, "lineCap");
Factory.addGetterSetter(Shape, "miterLimit");
Factory.addGetterSetter(Shape, "sceneFunc");
Factory.addGetterSetter(Shape, "hitFunc");
Factory.addGetterSetter(Shape, "dash");
Factory.addGetterSetter(Shape, "dashOffset", 0, getNumberValidator());
Factory.addGetterSetter(Shape, "shadowColor", undefined, getStringValidator());
Factory.addGetterSetter(Shape, "shadowBlur", 0, getNumberValidator());
Factory.addGetterSetter(Shape, "shadowOpacity", 1, getNumberValidator());
Factory.addComponentsGetterSetter(Shape, "shadowOffset", ["x", "y"]);
Factory.addGetterSetter(Shape, "shadowOffsetX", 0, getNumberValidator());
Factory.addGetterSetter(Shape, "shadowOffsetY", 0, getNumberValidator());
Factory.addGetterSetter(Shape, "fillPatternImage");
Factory.addGetterSetter(Shape, "fill", undefined, getStringOrGradientValidator());
Factory.addGetterSetter(Shape, "fillPatternX", 0, getNumberValidator());
Factory.addGetterSetter(Shape, "fillPatternY", 0, getNumberValidator());
Factory.addGetterSetter(Shape, "fillLinearGradientColorStops");
Factory.addGetterSetter(Shape, "strokeLinearGradientColorStops");
Factory.addGetterSetter(Shape, "fillRadialGradientStartRadius", 0);
Factory.addGetterSetter(Shape, "fillRadialGradientEndRadius", 0);
Factory.addGetterSetter(Shape, "fillRadialGradientColorStops");
Factory.addGetterSetter(Shape, "fillPatternRepeat", "repeat");
Factory.addGetterSetter(Shape, "fillEnabled", true);
Factory.addGetterSetter(Shape, "strokeEnabled", true);
Factory.addGetterSetter(Shape, "shadowEnabled", true);
Factory.addGetterSetter(Shape, "dashEnabled", true);
Factory.addGetterSetter(Shape, "strokeScaleEnabled", true);
Factory.addGetterSetter(Shape, "fillPriority", "color");
Factory.addComponentsGetterSetter(Shape, "fillPatternOffset", ["x", "y"]);
Factory.addGetterSetter(Shape, "fillPatternOffsetX", 0, getNumberValidator());
Factory.addGetterSetter(Shape, "fillPatternOffsetY", 0, getNumberValidator());
Factory.addComponentsGetterSetter(Shape, "fillPatternScale", ["x", "y"]);
Factory.addGetterSetter(Shape, "fillPatternScaleX", 1, getNumberValidator());
Factory.addGetterSetter(Shape, "fillPatternScaleY", 1, getNumberValidator());
Factory.addComponentsGetterSetter(Shape, "fillLinearGradientStartPoint", [
  "x",
  "y"
]);
Factory.addComponentsGetterSetter(Shape, "strokeLinearGradientStartPoint", [
  "x",
  "y"
]);
Factory.addGetterSetter(Shape, "fillLinearGradientStartPointX", 0);
Factory.addGetterSetter(Shape, "strokeLinearGradientStartPointX", 0);
Factory.addGetterSetter(Shape, "fillLinearGradientStartPointY", 0);
Factory.addGetterSetter(Shape, "strokeLinearGradientStartPointY", 0);
Factory.addComponentsGetterSetter(Shape, "fillLinearGradientEndPoint", [
  "x",
  "y"
]);
Factory.addComponentsGetterSetter(Shape, "strokeLinearGradientEndPoint", [
  "x",
  "y"
]);
Factory.addGetterSetter(Shape, "fillLinearGradientEndPointX", 0);
Factory.addGetterSetter(Shape, "strokeLinearGradientEndPointX", 0);
Factory.addGetterSetter(Shape, "fillLinearGradientEndPointY", 0);
Factory.addGetterSetter(Shape, "strokeLinearGradientEndPointY", 0);
Factory.addComponentsGetterSetter(Shape, "fillRadialGradientStartPoint", [
  "x",
  "y"
]);
Factory.addGetterSetter(Shape, "fillRadialGradientStartPointX", 0);
Factory.addGetterSetter(Shape, "fillRadialGradientStartPointY", 0);
Factory.addComponentsGetterSetter(Shape, "fillRadialGradientEndPoint", [
  "x",
  "y"
]);
Factory.addGetterSetter(Shape, "fillRadialGradientEndPointX", 0);
Factory.addGetterSetter(Shape, "fillRadialGradientEndPointY", 0);
Factory.addGetterSetter(Shape, "fillPatternRotation", 0);
Factory.addGetterSetter(Shape, "fillRule", undefined, getStringValidator());
Factory.backCompat(Shape, {
  dashArray: "dash",
  getDashArray: "getDash",
  setDashArray: "getDash",
  drawFunc: "sceneFunc",
  getDrawFunc: "getSceneFunc",
  setDrawFunc: "setSceneFunc",
  drawHitFunc: "hitFunc",
  getDrawHitFunc: "getHitFunc",
  setDrawHitFunc: "setHitFunc"
});

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/Layer.js
var BEFORE_DRAW = "beforeDraw";
var DRAW = "draw";
var INTERSECTION_OFFSETS = [
  { x: 0, y: 0 },
  { x: -1, y: -1 },
  { x: 1, y: -1 },
  { x: 1, y: 1 },
  { x: -1, y: 1 }
];
var INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;

class Layer extends Container {
  constructor(config) {
    super(config);
    this.canvas = new SceneCanvas;
    this.hitCanvas = new HitCanvas({
      pixelRatio: 1
    });
    this._waitingForDraw = false;
    this.on("visibleChange.konva", this._checkVisibility);
    this._checkVisibility();
    this.on("imageSmoothingEnabledChange.konva", this._setSmoothEnabled);
    this._setSmoothEnabled();
  }
  createPNGStream() {
    const c = this.canvas._canvas;
    return c.createPNGStream();
  }
  getCanvas() {
    return this.canvas;
  }
  getNativeCanvasElement() {
    return this.canvas._canvas;
  }
  getHitCanvas() {
    return this.hitCanvas;
  }
  getContext() {
    return this.getCanvas().getContext();
  }
  clear(bounds) {
    this.getContext().clear(bounds);
    this.getHitCanvas().getContext().clear(bounds);
    return this;
  }
  setZIndex(index) {
    super.setZIndex(index);
    const stage = this.getStage();
    if (stage && stage.content) {
      stage.content.removeChild(this.getNativeCanvasElement());
      if (index < stage.children.length - 1) {
        stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[index + 1].getCanvas()._canvas);
      } else {
        stage.content.appendChild(this.getNativeCanvasElement());
      }
    }
    return this;
  }
  moveToTop() {
    Node2.prototype.moveToTop.call(this);
    const stage = this.getStage();
    if (stage && stage.content) {
      stage.content.removeChild(this.getNativeCanvasElement());
      stage.content.appendChild(this.getNativeCanvasElement());
    }
    return true;
  }
  moveUp() {
    const moved = Node2.prototype.moveUp.call(this);
    if (!moved) {
      return false;
    }
    const stage = this.getStage();
    if (!stage || !stage.content) {
      return false;
    }
    stage.content.removeChild(this.getNativeCanvasElement());
    if (this.index < stage.children.length - 1) {
      stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[this.index + 1].getCanvas()._canvas);
    } else {
      stage.content.appendChild(this.getNativeCanvasElement());
    }
    return true;
  }
  moveDown() {
    if (Node2.prototype.moveDown.call(this)) {
      const stage = this.getStage();
      if (stage) {
        const children = stage.children;
        if (stage.content) {
          stage.content.removeChild(this.getNativeCanvasElement());
          stage.content.insertBefore(this.getNativeCanvasElement(), children[this.index + 1].getCanvas()._canvas);
        }
      }
      return true;
    }
    return false;
  }
  moveToBottom() {
    if (Node2.prototype.moveToBottom.call(this)) {
      const stage = this.getStage();
      if (stage) {
        const children = stage.children;
        if (stage.content) {
          stage.content.removeChild(this.getNativeCanvasElement());
          stage.content.insertBefore(this.getNativeCanvasElement(), children[1].getCanvas()._canvas);
        }
      }
      return true;
    }
    return false;
  }
  getLayer() {
    return this;
  }
  remove() {
    const _canvas = this.getNativeCanvasElement();
    Node2.prototype.remove.call(this);
    if (_canvas && _canvas.parentNode && Util._isInDocument(_canvas)) {
      _canvas.parentNode.removeChild(_canvas);
    }
    return this;
  }
  getStage() {
    return this.parent;
  }
  setSize({ width, height }) {
    this.canvas.setSize(width, height);
    this.hitCanvas.setSize(width, height);
    this._setSmoothEnabled();
    return this;
  }
  _validateAdd(child) {
    const type = child.getType();
    if (type !== "Group" && type !== "Shape") {
      Util.throw("You may only add groups and shapes to a layer.");
    }
  }
  _toKonvaCanvas(config) {
    config = { ...config };
    config.width = config.width || this.getWidth();
    config.height = config.height || this.getHeight();
    config.x = config.x !== undefined ? config.x : this.x();
    config.y = config.y !== undefined ? config.y : this.y();
    return Node2.prototype._toKonvaCanvas.call(this, config);
  }
  _checkVisibility() {
    const visible = this.visible();
    if (visible) {
      this.canvas._canvas.style.display = "block";
    } else {
      this.canvas._canvas.style.display = "none";
    }
  }
  _setSmoothEnabled() {
    this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled();
  }
  getWidth() {
    if (this.parent) {
      return this.parent.width();
    }
  }
  setWidth() {
    Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
  }
  getHeight() {
    if (this.parent) {
      return this.parent.height();
    }
  }
  setHeight() {
    Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
  }
  batchDraw() {
    if (!this._waitingForDraw) {
      this._waitingForDraw = true;
      Util.requestAnimFrame(() => {
        this.draw();
        this._waitingForDraw = false;
      });
    }
    return this;
  }
  getIntersection(pos) {
    if (!this.isListening() || !this.isVisible()) {
      return null;
    }
    let spiralSearchDistance = 1;
    let continueSearch = false;
    while (true) {
      for (let i = 0;i < INTERSECTION_OFFSETS_LEN; i++) {
        const intersectionOffset = INTERSECTION_OFFSETS[i];
        const obj = this._getIntersection({
          x: pos.x + intersectionOffset.x * spiralSearchDistance,
          y: pos.y + intersectionOffset.y * spiralSearchDistance
        });
        const shape = obj.shape;
        if (shape) {
          return shape;
        }
        continueSearch = !!obj.antialiased;
        if (!obj.antialiased) {
          break;
        }
      }
      if (continueSearch) {
        spiralSearchDistance += 1;
      } else {
        return null;
      }
    }
  }
  _getIntersection(pos) {
    const ratio = this.hitCanvas.pixelRatio;
    const p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data;
    const p3 = p[3];
    if (p3 === 255) {
      const colorKey = Util.getHitColorKey(p[0], p[1], p[2]);
      const shape = shapes[colorKey];
      if (shape) {
        return {
          shape
        };
      }
      return {
        antialiased: true
      };
    } else if (p3 > 0) {
      return {
        antialiased: true
      };
    }
    return {};
  }
  drawScene(can, top, bufferCanvas) {
    const layer = this.getLayer(), canvas = can || layer && layer.getCanvas();
    this._fire(BEFORE_DRAW, {
      node: this
    });
    if (this.clearBeforeDraw()) {
      canvas.getContext().clear();
    }
    Container.prototype.drawScene.call(this, canvas, top, bufferCanvas);
    this._fire(DRAW, {
      node: this
    });
    return this;
  }
  drawHit(can, top) {
    const layer = this.getLayer(), canvas = can || layer && layer.hitCanvas;
    if (layer && layer.clearBeforeDraw()) {
      layer.getHitCanvas().getContext().clear();
    }
    Container.prototype.drawHit.call(this, canvas, top);
    return this;
  }
  enableHitGraph() {
    this.hitGraphEnabled(true);
    return this;
  }
  disableHitGraph() {
    this.hitGraphEnabled(false);
    return this;
  }
  setHitGraphEnabled(val) {
    Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead.");
    this.listening(val);
  }
  getHitGraphEnabled(val) {
    Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead.");
    return this.listening();
  }
  toggleHitCanvas() {
    if (!this.parent || !this.parent["content"]) {
      return;
    }
    const parent = this.parent;
    const added = !!this.hitCanvas._canvas.parentNode;
    if (added) {
      parent.content.removeChild(this.hitCanvas._canvas);
    } else {
      parent.content.appendChild(this.hitCanvas._canvas);
    }
  }
  destroy() {
    Util.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas);
    return super.destroy();
  }
}
Layer.prototype.nodeType = "Layer";
_registerNode(Layer);
Factory.addGetterSetter(Layer, "imageSmoothingEnabled", true);
Factory.addGetterSetter(Layer, "clearBeforeDraw", true);
Factory.addGetterSetter(Layer, "hitGraphEnabled", true, getBooleanValidator());

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/FastLayer.js
class FastLayer extends Layer {
  constructor(attrs) {
    super(attrs);
    this.listening(false);
    Util.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.');
  }
}
FastLayer.prototype.nodeType = "FastLayer";
_registerNode(FastLayer);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/Group.js
class Group extends Container {
  _validateAdd(child) {
    const type = child.getType();
    if (type !== "Group" && type !== "Shape") {
      Util.throw("You may only add groups and shapes to groups.");
    }
  }
}
Group.prototype.nodeType = "Group";
_registerNode(Group);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/Animation.js
var now = function() {
  if (glob.performance && glob.performance.now) {
    return function() {
      return glob.performance.now();
    };
  }
  return function() {
    return new Date().getTime();
  };
}();

class Animation {
  constructor(func, layers) {
    this.id = Animation.animIdCounter++;
    this.frame = {
      time: 0,
      timeDiff: 0,
      lastTime: now(),
      frameRate: 0
    };
    this.func = func;
    this.setLayers(layers);
  }
  setLayers(layers) {
    let lays = [];
    if (layers) {
      lays = Array.isArray(layers) ? layers : [layers];
    }
    this.layers = lays;
    return this;
  }
  getLayers() {
    return this.layers;
  }
  addLayer(layer) {
    const layers = this.layers;
    const len = layers.length;
    for (let n = 0;n < len; n++) {
      if (layers[n]._id === layer._id) {
        return false;
      }
    }
    this.layers.push(layer);
    return true;
  }
  isRunning() {
    const a = Animation;
    const animations = a.animations;
    const len = animations.length;
    for (let n = 0;n < len; n++) {
      if (animations[n].id === this.id) {
        return true;
      }
    }
    return false;
  }
  start() {
    this.stop();
    this.frame.timeDiff = 0;
    this.frame.lastTime = now();
    Animation._addAnimation(this);
    return this;
  }
  stop() {
    Animation._removeAnimation(this);
    return this;
  }
  _updateFrameObject(time) {
    this.frame.timeDiff = time - this.frame.lastTime;
    this.frame.lastTime = time;
    this.frame.time += this.frame.timeDiff;
    this.frame.frameRate = 1000 / this.frame.timeDiff;
  }
  static _addAnimation(anim) {
    this.animations.push(anim);
    this._handleAnimation();
  }
  static _removeAnimation(anim) {
    const id = anim.id;
    const animations = this.animations;
    const len = animations.length;
    for (let n = 0;n < len; n++) {
      if (animations[n].id === id) {
        this.animations.splice(n, 1);
        break;
      }
    }
  }
  static _runFrames() {
    const layerHash = {};
    const animations = this.animations;
    for (let n = 0;n < animations.length; n++) {
      const anim = animations[n];
      const layers = anim.layers;
      const func = anim.func;
      anim._updateFrameObject(now());
      const layersLen = layers.length;
      let needRedraw;
      if (func) {
        needRedraw = func.call(anim, anim.frame) !== false;
      } else {
        needRedraw = true;
      }
      if (!needRedraw) {
        continue;
      }
      for (let i = 0;i < layersLen; i++) {
        const layer = layers[i];
        if (layer._id !== undefined) {
          layerHash[layer._id] = layer;
        }
      }
    }
    for (const key in layerHash) {
      if (!layerHash.hasOwnProperty(key)) {
        continue;
      }
      layerHash[key].batchDraw();
    }
  }
  static _animationLoop() {
    const Anim = Animation;
    if (Anim.animations.length) {
      Anim._runFrames();
      Util.requestAnimFrame(Anim._animationLoop);
    } else {
      Anim.animRunning = false;
    }
  }
  static _handleAnimation() {
    if (!this.animRunning) {
      this.animRunning = true;
      Util.requestAnimFrame(this._animationLoop);
    }
  }
}
Animation.animations = [];
Animation.animIdCounter = 0;
Animation.animRunning = false;

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/Tween.js
var blacklist = {
  node: 1,
  duration: 1,
  easing: 1,
  onFinish: 1,
  yoyo: 1
};
var PAUSED = 1;
var PLAYING = 2;
var REVERSING = 3;
var colorAttrs = ["fill", "stroke", "shadowColor"];
var idCounter2 = 0;

class TweenEngine {
  constructor(prop, propFunc, func, begin, finish, duration, yoyo) {
    this.prop = prop;
    this.propFunc = propFunc;
    this.begin = begin;
    this._pos = begin;
    this.duration = duration;
    this._change = 0;
    this.prevPos = 0;
    this.yoyo = yoyo;
    this._time = 0;
    this._position = 0;
    this._startTime = 0;
    this._finish = 0;
    this.func = func;
    this._change = finish - this.begin;
    this.pause();
  }
  fire(str) {
    const handler = this[str];
    if (handler) {
      handler();
    }
  }
  setTime(t) {
    if (t > this.duration) {
      if (this.yoyo) {
        this._time = this.duration;
        this.reverse();
      } else {
        this.finish();
      }
    } else if (t < 0) {
      if (this.yoyo) {
        this._time = 0;
        this.play();
      } else {
        this.reset();
      }
    } else {
      this._time = t;
      this.update();
    }
  }
  getTime() {
    return this._time;
  }
  setPosition(p) {
    this.prevPos = this._pos;
    this.propFunc(p);
    this._pos = p;
  }
  getPosition(t) {
    if (t === undefined) {
      t = this._time;
    }
    return this.func(t, this.begin, this._change, this.duration);
  }
  play() {
    this.state = PLAYING;
    this._startTime = this.getTimer() - this._time;
    this.onEnterFrame();
    this.fire("onPlay");
  }
  reverse() {
    this.state = REVERSING;
    this._time = this.duration - this._time;
    this._startTime = this.getTimer() - this._time;
    this.onEnterFrame();
    this.fire("onReverse");
  }
  seek(t) {
    this.pause();
    this._time = t;
    this.update();
    this.fire("onSeek");
  }
  reset() {
    this.pause();
    this._time = 0;
    this.update();
    this.fire("onReset");
  }
  finish() {
    this.pause();
    this._time = this.duration;
    this.update();
    this.fire("onFinish");
  }
  update() {
    this.setPosition(this.getPosition(this._time));
    this.fire("onUpdate");
  }
  onEnterFrame() {
    const t = this.getTimer() - this._startTime;
    if (this.state === PLAYING) {
      this.setTime(t);
    } else if (this.state === REVERSING) {
      this.setTime(this.duration - t);
    }
  }
  pause() {
    this.state = PAUSED;
    this.fire("onPause");
  }
  getTimer() {
    return new Date().getTime();
  }
}

class Tween {
  constructor(config) {
    const that = this, node = config.node, nodeId = node._id, easing = config.easing || Easings.Linear, yoyo = !!config.yoyo;
    let duration, key;
    if (typeof config.duration === "undefined") {
      duration = 0.3;
    } else if (config.duration === 0) {
      duration = 0.001;
    } else {
      duration = config.duration;
    }
    this.node = node;
    this._id = idCounter2++;
    const layers = node.getLayer() || (node instanceof Konva["Stage"] ? node.getLayers() : null);
    if (!layers) {
      Util.error("Tween constructor have `node` that is not in a layer. Please add node into layer first.");
    }
    this.anim = new Animation(function() {
      that.tween.onEnterFrame();
    }, layers);
    this.tween = new TweenEngine(key, function(i) {
      that._tweenFunc(i);
    }, easing, 0, 1, duration * 1000, yoyo);
    this._addListeners();
    if (!Tween.attrs[nodeId]) {
      Tween.attrs[nodeId] = {};
    }
    if (!Tween.attrs[nodeId][this._id]) {
      Tween.attrs[nodeId][this._id] = {};
    }
    if (!Tween.tweens[nodeId]) {
      Tween.tweens[nodeId] = {};
    }
    for (key in config) {
      if (blacklist[key] === undefined) {
        this._addAttr(key, config[key]);
      }
    }
    this.reset();
    this.onFinish = config.onFinish;
    this.onReset = config.onReset;
    this.onUpdate = config.onUpdate;
  }
  _addAttr(key, end) {
    const node = this.node, nodeId = node._id;
    let diff, len, trueEnd, trueStart, endRGBA;
    const tweenId = Tween.tweens[nodeId][key];
    if (tweenId) {
      delete Tween.attrs[nodeId][tweenId][key];
    }
    let start = node.getAttr(key);
    if (Util._isArray(end)) {
      diff = [];
      len = Math.max(end.length, start.length);
      if (key === "points" && end.length !== start.length) {
        if (end.length > start.length) {
          trueStart = start;
          start = Util._prepareArrayForTween(start, end, node.closed());
        } else {
          trueEnd = end;
          end = Util._prepareArrayForTween(end, start, node.closed());
        }
      }
      if (key.indexOf("fill") === 0) {
        for (let n = 0;n < len; n++) {
          if (n % 2 === 0) {
            diff.push(end[n] - start[n]);
          } else {
            const startRGBA = Util.colorToRGBA(start[n]);
            endRGBA = Util.colorToRGBA(end[n]);
            start[n] = startRGBA;
            diff.push({
              r: endRGBA.r - startRGBA.r,
              g: endRGBA.g - startRGBA.g,
              b: endRGBA.b - startRGBA.b,
              a: endRGBA.a - startRGBA.a
            });
          }
        }
      } else {
        for (let n = 0;n < len; n++) {
          diff.push(end[n] - start[n]);
        }
      }
    } else if (colorAttrs.indexOf(key) !== -1) {
      start = Util.colorToRGBA(start);
      endRGBA = Util.colorToRGBA(end);
      diff = {
        r: endRGBA.r - start.r,
        g: endRGBA.g - start.g,
        b: endRGBA.b - start.b,
        a: endRGBA.a - start.a
      };
    } else {
      diff = end - start;
    }
    Tween.attrs[nodeId][this._id][key] = {
      start,
      diff,
      end,
      trueEnd,
      trueStart
    };
    Tween.tweens[nodeId][key] = this._id;
  }
  _tweenFunc(i) {
    const node = this.node, attrs = Tween.attrs[node._id][this._id];
    let key, attr, start, diff, newVal, n, len, end;
    for (key in attrs) {
      attr = attrs[key];
      start = attr.start;
      diff = attr.diff;
      end = attr.end;
      if (Util._isArray(start)) {
        newVal = [];
        len = Math.max(start.length, end.length);
        if (key.indexOf("fill") === 0) {
          for (n = 0;n < len; n++) {
            if (n % 2 === 0) {
              newVal.push((start[n] || 0) + diff[n] * i);
            } else {
              newVal.push("rgba(" + Math.round(start[n].r + diff[n].r * i) + "," + Math.round(start[n].g + diff[n].g * i) + "," + Math.round(start[n].b + diff[n].b * i) + "," + (start[n].a + diff[n].a * i) + ")");
            }
          }
        } else {
          for (n = 0;n < len; n++) {
            newVal.push((start[n] || 0) + diff[n] * i);
          }
        }
      } else if (colorAttrs.indexOf(key) !== -1) {
        newVal = "rgba(" + Math.round(start.r + diff.r * i) + "," + Math.round(start.g + diff.g * i) + "," + Math.round(start.b + diff.b * i) + "," + (start.a + diff.a * i) + ")";
      } else {
        newVal = start + diff * i;
      }
      node.setAttr(key, newVal);
    }
  }
  _addListeners() {
    this.tween.onPlay = () => {
      this.anim.start();
    };
    this.tween.onReverse = () => {
      this.anim.start();
    };
    this.tween.onPause = () => {
      this.anim.stop();
    };
    this.tween.onFinish = () => {
      const node = this.node;
      const attrs = Tween.attrs[node._id][this._id];
      if (attrs.points && attrs.points.trueEnd) {
        node.setAttr("points", attrs.points.trueEnd);
      }
      if (this.onFinish) {
        this.onFinish.call(this);
      }
    };
    this.tween.onReset = () => {
      const node = this.node;
      const attrs = Tween.attrs[node._id][this._id];
      if (attrs.points && attrs.points.trueStart) {
        node.points(attrs.points.trueStart);
      }
      if (this.onReset) {
        this.onReset();
      }
    };
    this.tween.onUpdate = () => {
      if (this.onUpdate) {
        this.onUpdate.call(this);
      }
    };
  }
  play() {
    this.tween.play();
    return this;
  }
  reverse() {
    this.tween.reverse();
    return this;
  }
  reset() {
    this.tween.reset();
    return this;
  }
  seek(t) {
    this.tween.seek(t * 1000);
    return this;
  }
  pause() {
    this.tween.pause();
    return this;
  }
  finish() {
    this.tween.finish();
    return this;
  }
  destroy() {
    const nodeId = this.node._id, thisId = this._id, attrs = Tween.tweens[nodeId];
    this.pause();
    if (this.anim) {
      this.anim.stop();
    }
    for (const key in attrs) {
      delete Tween.tweens[nodeId][key];
    }
    delete Tween.attrs[nodeId][thisId];
    if (Tween.tweens[nodeId]) {
      if (Object.keys(Tween.tweens[nodeId]).length === 0) {
        delete Tween.tweens[nodeId];
      }
      if (Object.keys(Tween.attrs[nodeId]).length === 0) {
        delete Tween.attrs[nodeId];
      }
    }
  }
}
Tween.attrs = {};
Tween.tweens = {};
Node2.prototype.to = function(params) {
  const onFinish = params.onFinish;
  params.node = this;
  params.onFinish = function() {
    this.destroy();
    if (onFinish) {
      onFinish();
    }
  };
  const tween = new Tween(params);
  tween.play();
};
var Easings = {
  BackEaseIn(t, b, c, d) {
    const s = 1.70158;
    return c * (t /= d) * t * ((s + 1) * t - s) + b;
  },
  BackEaseOut(t, b, c, d) {
    const s = 1.70158;
    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
  },
  BackEaseInOut(t, b, c, d) {
    let s = 1.70158;
    if ((t /= d / 2) < 1) {
      return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
    }
    return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
  },
  ElasticEaseIn(t, b, c, d, a, p) {
    let s = 0;
    if (t === 0) {
      return b;
    }
    if ((t /= d) === 1) {
      return b + c;
    }
    if (!p) {
      p = d * 0.3;
    }
    if (!a || a < Math.abs(c)) {
      a = c;
      s = p / 4;
    } else {
      s = p / (2 * Math.PI) * Math.asin(c / a);
    }
    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
  },
  ElasticEaseOut(t, b, c, d, a, p) {
    let s = 0;
    if (t === 0) {
      return b;
    }
    if ((t /= d) === 1) {
      return b + c;
    }
    if (!p) {
      p = d * 0.3;
    }
    if (!a || a < Math.abs(c)) {
      a = c;
      s = p / 4;
    } else {
      s = p / (2 * Math.PI) * Math.asin(c / a);
    }
    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
  },
  ElasticEaseInOut(t, b, c, d, a, p) {
    let s = 0;
    if (t === 0) {
      return b;
    }
    if ((t /= d / 2) === 2) {
      return b + c;
    }
    if (!p) {
      p = d * (0.3 * 1.5);
    }
    if (!a || a < Math.abs(c)) {
      a = c;
      s = p / 4;
    } else {
      s = p / (2 * Math.PI) * Math.asin(c / a);
    }
    if (t < 1) {
      return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
    }
    return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
  },
  BounceEaseOut(t, b, c, d) {
    if ((t /= d) < 1 / 2.75) {
      return c * (7.5625 * t * t) + b;
    } else if (t < 2 / 2.75) {
      return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
    } else if (t < 2.5 / 2.75) {
      return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
    } else {
      return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
    }
  },
  BounceEaseIn(t, b, c, d) {
    return c - Easings.BounceEaseOut(d - t, 0, c, d) + b;
  },
  BounceEaseInOut(t, b, c, d) {
    if (t < d / 2) {
      return Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;
    } else {
      return Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
    }
  },
  EaseIn(t, b, c, d) {
    return c * (t /= d) * t + b;
  },
  EaseOut(t, b, c, d) {
    return -c * (t /= d) * (t - 2) + b;
  },
  EaseInOut(t, b, c, d) {
    if ((t /= d / 2) < 1) {
      return c / 2 * t * t + b;
    }
    return -c / 2 * (--t * (t - 2) - 1) + b;
  },
  StrongEaseIn(t, b, c, d) {
    return c * (t /= d) * t * t * t * t + b;
  },
  StrongEaseOut(t, b, c, d) {
    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
  },
  StrongEaseInOut(t, b, c, d) {
    if ((t /= d / 2) < 1) {
      return c / 2 * t * t * t * t * t + b;
    }
    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
  },
  Linear(t, b, c, d) {
    return c * t / d + b;
  }
};

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/_CoreInternals.js
var Konva2 = Util._assign(Konva, {
  Util,
  Transform,
  Node: Node2,
  Container,
  Stage,
  stages,
  Layer,
  FastLayer,
  Group,
  DD,
  Shape,
  shapes,
  Animation,
  Tween,
  Easings,
  Context,
  Canvas
});

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/shapes/Arc.js
class Arc extends Shape {
  _sceneFunc(context) {
    const angle = Konva.getAngle(this.angle()), clockwise = this.clockwise();
    context.beginPath();
    context.arc(0, 0, this.outerRadius(), 0, angle, clockwise);
    context.arc(0, 0, this.innerRadius(), angle, 0, !clockwise);
    context.closePath();
    context.fillStrokeShape(this);
  }
  getWidth() {
    return this.outerRadius() * 2;
  }
  getHeight() {
    return this.outerRadius() * 2;
  }
  setWidth(width) {
    this.outerRadius(width / 2);
  }
  setHeight(height) {
    this.outerRadius(height / 2);
  }
  getSelfRect() {
    const innerRadius = this.innerRadius();
    const outerRadius = this.outerRadius();
    const clockwise = this.clockwise();
    const angle = Konva.getAngle(clockwise ? 360 - this.angle() : this.angle());
    const boundLeftRatio = Math.cos(Math.min(angle, Math.PI));
    const boundRightRatio = 1;
    const boundTopRatio = Math.sin(Math.min(Math.max(Math.PI, angle), 3 * Math.PI / 2));
    const boundBottomRatio = Math.sin(Math.min(angle, Math.PI / 2));
    const boundLeft = boundLeftRatio * (boundLeftRatio > 0 ? innerRadius : outerRadius);
    const boundRight = boundRightRatio * (boundRightRatio > 0 ? outerRadius : innerRadius);
    const boundTop = boundTopRatio * (boundTopRatio > 0 ? innerRadius : outerRadius);
    const boundBottom = boundBottomRatio * (boundBottomRatio > 0 ? outerRadius : innerRadius);
    return {
      x: boundLeft,
      y: clockwise ? -1 * boundBottom : boundTop,
      width: boundRight - boundLeft,
      height: boundBottom - boundTop
    };
  }
}
Arc.prototype._centroid = true;
Arc.prototype.className = "Arc";
Arc.prototype._attrsAffectingSize = [
  "innerRadius",
  "outerRadius",
  "angle",
  "clockwise"
];
_registerNode(Arc);
Factory.addGetterSetter(Arc, "innerRadius", 0, getNumberValidator());
Factory.addGetterSetter(Arc, "outerRadius", 0, getNumberValidator());
Factory.addGetterSetter(Arc, "angle", 0, getNumberValidator());
Factory.addGetterSetter(Arc, "clockwise", false, getBooleanValidator());

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/shapes/Line.js
function getControlPoints(x0, y0, x1, y1, x2, y2, t) {
  const d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)), d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), fa = t * d01 / (d01 + d12), fb = t * d12 / (d01 + d12), p1x = x1 - fa * (x2 - x0), p1y = y1 - fa * (y2 - y0), p2x = x1 + fb * (x2 - x0), p2y = y1 + fb * (y2 - y0);
  return [p1x, p1y, p2x, p2y];
}
function expandPoints(p, tension) {
  const len = p.length, allPoints = [];
  for (let n = 2;n < len - 2; n += 2) {
    const cp = getControlPoints(p[n - 2], p[n - 1], p[n], p[n + 1], p[n + 2], p[n + 3], tension);
    if (isNaN(cp[0])) {
      continue;
    }
    allPoints.push(cp[0]);
    allPoints.push(cp[1]);
    allPoints.push(p[n]);
    allPoints.push(p[n + 1]);
    allPoints.push(cp[2]);
    allPoints.push(cp[3]);
  }
  return allPoints;
}

class Line extends Shape {
  constructor(config) {
    super(config);
    this.on("pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva", function() {
      this._clearCache("tensionPoints");
    });
  }
  _sceneFunc(context) {
    const points = this.points(), length = points.length, tension = this.tension(), closed = this.closed(), bezier = this.bezier();
    if (!length) {
      return;
    }
    let n = 0;
    context.beginPath();
    context.moveTo(points[0], points[1]);
    if (tension !== 0 && length > 4) {
      const tp = this.getTensionPoints();
      const len = tp.length;
      n = closed ? 0 : 4;
      if (!closed) {
        context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);
      }
      while (n < len - 2) {
        context.bezierCurveTo(tp[n++], tp[n++], tp[n++], tp[n++], tp[n++], tp[n++]);
      }
      if (!closed) {
        context.quadraticCurveTo(tp[len - 2], tp[len - 1], points[length - 2], points[length - 1]);
      }
    } else if (bezier) {
      n = 2;
      while (n < length) {
        context.bezierCurveTo(points[n++], points[n++], points[n++], points[n++], points[n++], points[n++]);
      }
    } else {
      for (n = 2;n < length; n += 2) {
        context.lineTo(points[n], points[n + 1]);
      }
    }
    if (closed) {
      context.closePath();
      context.fillStrokeShape(this);
    } else {
      context.strokeShape(this);
    }
  }
  getTensionPoints() {
    return this._getCache("tensionPoints", this._getTensionPoints);
  }
  _getTensionPoints() {
    if (this.closed()) {
      return this._getTensionPointsClosed();
    } else {
      return expandPoints(this.points(), this.tension());
    }
  }
  _getTensionPointsClosed() {
    const p = this.points(), len = p.length, tension = this.tension(), firstControlPoints = getControlPoints(p[len - 2], p[len - 1], p[0], p[1], p[2], p[3], tension), lastControlPoints = getControlPoints(p[len - 4], p[len - 3], p[len - 2], p[len - 1], p[0], p[1], tension), middle = expandPoints(p, tension), tp = [firstControlPoints[2], firstControlPoints[3]].concat(middle).concat([
      lastControlPoints[0],
      lastControlPoints[1],
      p[len - 2],
      p[len - 1],
      lastControlPoints[2],
      lastControlPoints[3],
      firstControlPoints[0],
      firstControlPoints[1],
      p[0],
      p[1]
    ]);
    return tp;
  }
  getWidth() {
    return this.getSelfRect().width;
  }
  getHeight() {
    return this.getSelfRect().height;
  }
  getSelfRect() {
    let points = this.points();
    if (points.length < 4) {
      return {
        x: points[0] || 0,
        y: points[1] || 0,
        width: 0,
        height: 0
      };
    }
    if (this.tension() !== 0) {
      points = [
        points[0],
        points[1],
        ...this._getTensionPoints(),
        points[points.length - 2],
        points[points.length - 1]
      ];
    } else {
      points = this.points();
    }
    let minX = points[0];
    let maxX = points[0];
    let minY = points[1];
    let maxY = points[1];
    let x, y;
    for (let i = 0;i < points.length / 2; i++) {
      x = points[i * 2];
      y = points[i * 2 + 1];
      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x);
      minY = Math.min(minY, y);
      maxY = Math.max(maxY, y);
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
}
Line.prototype.className = "Line";
Line.prototype._attrsAffectingSize = ["points", "bezier", "tension"];
_registerNode(Line);
Factory.addGetterSetter(Line, "closed", false);
Factory.addGetterSetter(Line, "bezier", false);
Factory.addGetterSetter(Line, "tension", 0, getNumberValidator());
Factory.addGetterSetter(Line, "points", [], getNumberArrayValidator());

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/BezierFunctions.js
var tValues = [
  [],
  [],
  [
    -0.5773502691896257,
    0.5773502691896257
  ],
  [
    0,
    -0.7745966692414834,
    0.7745966692414834
  ],
  [
    -0.33998104358485626,
    0.33998104358485626,
    -0.8611363115940526,
    0.8611363115940526
  ],
  [
    0,
    -0.5384693101056831,
    0.5384693101056831,
    -0.906179845938664,
    0.906179845938664
  ],
  [
    0.6612093864662645,
    -0.6612093864662645,
    -0.2386191860831969,
    0.2386191860831969,
    -0.932469514203152,
    0.932469514203152
  ],
  [
    0,
    0.4058451513773972,
    -0.4058451513773972,
    -0.7415311855993945,
    0.7415311855993945,
    -0.9491079123427585,
    0.9491079123427585
  ],
  [
    -0.1834346424956498,
    0.1834346424956498,
    -0.525532409916329,
    0.525532409916329,
    -0.7966664774136267,
    0.7966664774136267,
    -0.9602898564975363,
    0.9602898564975363
  ],
  [
    0,
    -0.8360311073266358,
    0.8360311073266358,
    -0.9681602395076261,
    0.9681602395076261,
    -0.3242534234038089,
    0.3242534234038089,
    -0.6133714327005904,
    0.6133714327005904
  ],
  [
    -0.14887433898163122,
    0.14887433898163122,
    -0.4333953941292472,
    0.4333953941292472,
    -0.6794095682990244,
    0.6794095682990244,
    -0.8650633666889845,
    0.8650633666889845,
    -0.9739065285171717,
    0.9739065285171717
  ],
  [
    0,
    -0.26954315595234496,
    0.26954315595234496,
    -0.5190961292068118,
    0.5190961292068118,
    -0.7301520055740494,
    0.7301520055740494,
    -0.8870625997680953,
    0.8870625997680953,
    -0.978228658146057,
    0.978228658146057
  ],
  [
    -0.1252334085114689,
    0.1252334085114689,
    -0.3678314989981802,
    0.3678314989981802,
    -0.5873179542866175,
    0.5873179542866175,
    -0.7699026741943047,
    0.7699026741943047,
    -0.9041172563704749,
    0.9041172563704749,
    -0.9815606342467192,
    0.9815606342467192
  ],
  [
    0,
    -0.2304583159551348,
    0.2304583159551348,
    -0.44849275103644687,
    0.44849275103644687,
    -0.6423493394403402,
    0.6423493394403402,
    -0.8015780907333099,
    0.8015780907333099,
    -0.9175983992229779,
    0.9175983992229779,
    -0.9841830547185881,
    0.9841830547185881
  ],
  [
    -0.10805494870734367,
    0.10805494870734367,
    -0.31911236892788974,
    0.31911236892788974,
    -0.5152486363581541,
    0.5152486363581541,
    -0.6872929048116855,
    0.6872929048116855,
    -0.827201315069765,
    0.827201315069765,
    -0.9284348836635735,
    0.9284348836635735,
    -0.9862838086968123,
    0.9862838086968123
  ],
  [
    0,
    -0.20119409399743451,
    0.20119409399743451,
    -0.3941513470775634,
    0.3941513470775634,
    -0.5709721726085388,
    0.5709721726085388,
    -0.7244177313601701,
    0.7244177313601701,
    -0.8482065834104272,
    0.8482065834104272,
    -0.937273392400706,
    0.937273392400706,
    -0.9879925180204854,
    0.9879925180204854
  ],
  [
    -0.09501250983763744,
    0.09501250983763744,
    -0.2816035507792589,
    0.2816035507792589,
    -0.45801677765722737,
    0.45801677765722737,
    -0.6178762444026438,
    0.6178762444026438,
    -0.755404408355003,
    0.755404408355003,
    -0.8656312023878318,
    0.8656312023878318,
    -0.9445750230732326,
    0.9445750230732326,
    -0.9894009349916499,
    0.9894009349916499
  ],
  [
    0,
    -0.17848418149584785,
    0.17848418149584785,
    -0.3512317634538763,
    0.3512317634538763,
    -0.5126905370864769,
    0.5126905370864769,
    -0.6576711592166907,
    0.6576711592166907,
    -0.7815140038968014,
    0.7815140038968014,
    -0.8802391537269859,
    0.8802391537269859,
    -0.9506755217687678,
    0.9506755217687678,
    -0.9905754753144174,
    0.9905754753144174
  ],
  [
    -0.0847750130417353,
    0.0847750130417353,
    -0.2518862256915055,
    0.2518862256915055,
    -0.41175116146284263,
    0.41175116146284263,
    -0.5597708310739475,
    0.5597708310739475,
    -0.6916870430603532,
    0.6916870430603532,
    -0.8037049589725231,
    0.8037049589725231,
    -0.8926024664975557,
    0.8926024664975557,
    -0.9558239495713977,
    0.9558239495713977,
    -0.9915651684209309,
    0.9915651684209309
  ],
  [
    0,
    -0.16035864564022537,
    0.16035864564022537,
    -0.31656409996362983,
    0.31656409996362983,
    -0.46457074137596094,
    0.46457074137596094,
    -0.600545304661681,
    0.600545304661681,
    -0.7209661773352294,
    0.7209661773352294,
    -0.8227146565371428,
    0.8227146565371428,
    -0.9031559036148179,
    0.9031559036148179,
    -0.96020815213483,
    0.96020815213483,
    -0.9924068438435844,
    0.9924068438435844
  ],
  [
    -0.07652652113349734,
    0.07652652113349734,
    -0.22778585114164507,
    0.22778585114164507,
    -0.37370608871541955,
    0.37370608871541955,
    -0.5108670019508271,
    0.5108670019508271,
    -0.636053680726515,
    0.636053680726515,
    -0.7463319064601508,
    0.7463319064601508,
    -0.8391169718222188,
    0.8391169718222188,
    -0.912234428251326,
    0.912234428251326,
    -0.9639719272779138,
    0.9639719272779138,
    -0.9931285991850949,
    0.9931285991850949
  ],
  [
    0,
    -0.1455618541608951,
    0.1455618541608951,
    -0.2880213168024011,
    0.2880213168024011,
    -0.4243421202074388,
    0.4243421202074388,
    -0.5516188358872198,
    0.5516188358872198,
    -0.6671388041974123,
    0.6671388041974123,
    -0.7684399634756779,
    0.7684399634756779,
    -0.8533633645833173,
    0.8533633645833173,
    -0.9200993341504008,
    0.9200993341504008,
    -0.9672268385663063,
    0.9672268385663063,
    -0.9937521706203895,
    0.9937521706203895
  ],
  [
    -0.06973927331972223,
    0.06973927331972223,
    -0.20786042668822127,
    0.20786042668822127,
    -0.34193582089208424,
    0.34193582089208424,
    -0.469355837986757,
    0.469355837986757,
    -0.5876404035069116,
    0.5876404035069116,
    -0.6944872631866827,
    0.6944872631866827,
    -0.7878168059792081,
    0.7878168059792081,
    -0.8658125777203002,
    0.8658125777203002,
    -0.926956772187174,
    0.926956772187174,
    -0.9700604978354287,
    0.9700604978354287,
    -0.9942945854823992,
    0.9942945854823992
  ],
  [
    0,
    -0.1332568242984661,
    0.1332568242984661,
    -0.26413568097034495,
    0.26413568097034495,
    -0.3903010380302908,
    0.3903010380302908,
    -0.5095014778460075,
    0.5095014778460075,
    -0.6196098757636461,
    0.6196098757636461,
    -0.7186613631319502,
    0.7186613631319502,
    -0.8048884016188399,
    0.8048884016188399,
    -0.8767523582704416,
    0.8767523582704416,
    -0.9329710868260161,
    0.9329710868260161,
    -0.9725424712181152,
    0.9725424712181152,
    -0.9947693349975522,
    0.9947693349975522
  ],
  [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ]
];
var cValues = [
  [],
  [],
  [1, 1],
  [
    0.8888888888888888,
    0.5555555555555556,
    0.5555555555555556
  ],
  [
    0.6521451548625461,
    0.6521451548625461,
    0.34785484513745385,
    0.34785484513745385
  ],
  [
    0.5688888888888889,
    0.47862867049936647,
    0.47862867049936647,
    0.23692688505618908,
    0.23692688505618908
  ],
  [
    0.3607615730481386,
    0.3607615730481386,
    0.46791393457269104,
    0.46791393457269104,
    0.17132449237917036,
    0.17132449237917036
  ],
  [
    0.4179591836734694,
    0.3818300505051189,
    0.3818300505051189,
    0.27970539148927664,
    0.27970539148927664,
    0.1294849661688697,
    0.1294849661688697
  ],
  [
    0.362683783378362,
    0.362683783378362,
    0.31370664587788727,
    0.31370664587788727,
    0.22238103445337448,
    0.22238103445337448,
    0.10122853629037626,
    0.10122853629037626
  ],
  [
    0.3302393550012598,
    0.1806481606948574,
    0.1806481606948574,
    0.08127438836157441,
    0.08127438836157441,
    0.31234707704000286,
    0.31234707704000286,
    0.26061069640293544,
    0.26061069640293544
  ],
  [
    0.29552422471475287,
    0.29552422471475287,
    0.26926671930999635,
    0.26926671930999635,
    0.21908636251598204,
    0.21908636251598204,
    0.1494513491505806,
    0.1494513491505806,
    0.06667134430868814,
    0.06667134430868814
  ],
  [
    0.2729250867779006,
    0.26280454451024665,
    0.26280454451024665,
    0.23319376459199048,
    0.23319376459199048,
    0.18629021092773426,
    0.18629021092773426,
    0.1255803694649046,
    0.1255803694649046,
    0.05566856711617366,
    0.05566856711617366
  ],
  [
    0.24914704581340277,
    0.24914704581340277,
    0.2334925365383548,
    0.2334925365383548,
    0.20316742672306592,
    0.20316742672306592,
    0.16007832854334622,
    0.16007832854334622,
    0.10693932599531843,
    0.10693932599531843,
    0.04717533638651183,
    0.04717533638651183
  ],
  [
    0.2325515532308739,
    0.22628318026289723,
    0.22628318026289723,
    0.2078160475368885,
    0.2078160475368885,
    0.17814598076194574,
    0.17814598076194574,
    0.13887351021978725,
    0.13887351021978725,
    0.09212149983772845,
    0.09212149983772845,
    0.04048400476531588,
    0.04048400476531588
  ],
  [
    0.2152638534631578,
    0.2152638534631578,
    0.2051984637212956,
    0.2051984637212956,
    0.18553839747793782,
    0.18553839747793782,
    0.15720316715819355,
    0.15720316715819355,
    0.12151857068790319,
    0.12151857068790319,
    0.08015808715976021,
    0.08015808715976021,
    0.03511946033175186,
    0.03511946033175186
  ],
  [
    0.2025782419255613,
    0.19843148532711158,
    0.19843148532711158,
    0.1861610000155622,
    0.1861610000155622,
    0.16626920581699392,
    0.16626920581699392,
    0.13957067792615432,
    0.13957067792615432,
    0.10715922046717194,
    0.10715922046717194,
    0.07036604748810812,
    0.07036604748810812,
    0.03075324199611727,
    0.03075324199611727
  ],
  [
    0.1894506104550685,
    0.1894506104550685,
    0.18260341504492358,
    0.18260341504492358,
    0.16915651939500254,
    0.16915651939500254,
    0.14959598881657674,
    0.14959598881657674,
    0.12462897125553388,
    0.12462897125553388,
    0.09515851168249279,
    0.09515851168249279,
    0.062253523938647894,
    0.062253523938647894,
    0.027152459411754096,
    0.027152459411754096
  ],
  [
    0.17944647035620653,
    0.17656270536699264,
    0.17656270536699264,
    0.16800410215645004,
    0.16800410215645004,
    0.15404576107681028,
    0.15404576107681028,
    0.13513636846852548,
    0.13513636846852548,
    0.11188384719340397,
    0.11188384719340397,
    0.08503614831717918,
    0.08503614831717918,
    0.0554595293739872,
    0.0554595293739872,
    0.02414830286854793,
    0.02414830286854793
  ],
  [
    0.1691423829631436,
    0.1691423829631436,
    0.16427648374583273,
    0.16427648374583273,
    0.15468467512626524,
    0.15468467512626524,
    0.14064291467065065,
    0.14064291467065065,
    0.12255520671147846,
    0.12255520671147846,
    0.10094204410628717,
    0.10094204410628717,
    0.07642573025488905,
    0.07642573025488905,
    0.0497145488949698,
    0.0497145488949698,
    0.02161601352648331,
    0.02161601352648331
  ],
  [
    0.1610544498487837,
    0.15896884339395434,
    0.15896884339395434,
    0.15276604206585967,
    0.15276604206585967,
    0.1426067021736066,
    0.1426067021736066,
    0.12875396253933621,
    0.12875396253933621,
    0.11156664554733399,
    0.11156664554733399,
    0.09149002162245,
    0.09149002162245,
    0.06904454273764123,
    0.06904454273764123,
    0.0448142267656996,
    0.0448142267656996,
    0.019461788229726478,
    0.019461788229726478
  ],
  [
    0.15275338713072584,
    0.15275338713072584,
    0.14917298647260374,
    0.14917298647260374,
    0.14209610931838204,
    0.14209610931838204,
    0.13168863844917664,
    0.13168863844917664,
    0.11819453196151841,
    0.11819453196151841,
    0.10193011981724044,
    0.10193011981724044,
    0.08327674157670475,
    0.08327674157670475,
    0.06267204833410907,
    0.06267204833410907,
    0.04060142980038694,
    0.04060142980038694,
    0.017614007139152118,
    0.017614007139152118
  ],
  [
    0.14608113364969041,
    0.14452440398997005,
    0.14452440398997005,
    0.13988739479107315,
    0.13988739479107315,
    0.13226893863333747,
    0.13226893863333747,
    0.12183141605372853,
    0.12183141605372853,
    0.10879729916714838,
    0.10879729916714838,
    0.09344442345603386,
    0.09344442345603386,
    0.0761001136283793,
    0.0761001136283793,
    0.057134425426857205,
    0.057134425426857205,
    0.036953789770852494,
    0.036953789770852494,
    0.016017228257774335,
    0.016017228257774335
  ],
  [
    0.13925187285563198,
    0.13925187285563198,
    0.13654149834601517,
    0.13654149834601517,
    0.13117350478706238,
    0.13117350478706238,
    0.12325237681051242,
    0.12325237681051242,
    0.11293229608053922,
    0.11293229608053922,
    0.10041414444288096,
    0.10041414444288096,
    0.08594160621706773,
    0.08594160621706773,
    0.06979646842452049,
    0.06979646842452049,
    0.052293335152683286,
    0.052293335152683286,
    0.03377490158481415,
    0.03377490158481415,
    0.0146279952982722,
    0.0146279952982722
  ],
  [
    0.13365457218610619,
    0.1324620394046966,
    0.1324620394046966,
    0.12890572218808216,
    0.12890572218808216,
    0.12304908430672953,
    0.12304908430672953,
    0.11499664022241136,
    0.11499664022241136,
    0.10489209146454141,
    0.10489209146454141,
    0.09291576606003515,
    0.09291576606003515,
    0.07928141177671895,
    0.07928141177671895,
    0.06423242140852585,
    0.06423242140852585,
    0.04803767173108467,
    0.04803767173108467,
    0.030988005856979445,
    0.030988005856979445,
    0.013411859487141771,
    0.013411859487141771
  ],
  [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ]
];
var binomialCoefficients = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]];
var getCubicArcLength = (xs, ys, t) => {
  let sum;
  let correctedT;
  const n = 20;
  const z = t / 2;
  sum = 0;
  for (let i = 0;i < n; i++) {
    correctedT = z * tValues[n][i] + z;
    sum += cValues[n][i] * BFunc(xs, ys, correctedT);
  }
  return z * sum;
};
var getQuadraticArcLength = (xs, ys, t) => {
  if (t === undefined) {
    t = 1;
  }
  const ax = xs[0] - 2 * xs[1] + xs[2];
  const ay = ys[0] - 2 * ys[1] + ys[2];
  const bx = 2 * xs[1] - 2 * xs[0];
  const by = 2 * ys[1] - 2 * ys[0];
  const A = 4 * (ax * ax + ay * ay);
  const B = 4 * (ax * bx + ay * by);
  const C = bx * bx + by * by;
  if (A === 0) {
    return t * Math.sqrt(Math.pow(xs[2] - xs[0], 2) + Math.pow(ys[2] - ys[0], 2));
  }
  const b = B / (2 * A);
  const c = C / A;
  const u = t + b;
  const k = c - b * b;
  const uuk = u * u + k > 0 ? Math.sqrt(u * u + k) : 0;
  const bbk = b * b + k > 0 ? Math.sqrt(b * b + k) : 0;
  const term = b + Math.sqrt(b * b + k) !== 0 ? k * Math.log(Math.abs((u + uuk) / (b + bbk))) : 0;
  return Math.sqrt(A) / 2 * (u * uuk - b * bbk + term);
};
function BFunc(xs, ys, t) {
  const xbase = getDerivative(1, t, xs);
  const ybase = getDerivative(1, t, ys);
  const combined = xbase * xbase + ybase * ybase;
  return Math.sqrt(combined);
}
var getDerivative = (derivative, t, vs) => {
  const n = vs.length - 1;
  let _vs;
  let value;
  if (n === 0) {
    return 0;
  }
  if (derivative === 0) {
    value = 0;
    for (let k = 0;k <= n; k++) {
      value += binomialCoefficients[n][k] * Math.pow(1 - t, n - k) * Math.pow(t, k) * vs[k];
    }
    return value;
  } else {
    _vs = new Array(n);
    for (let k = 0;k < n; k++) {
      _vs[k] = n * (vs[k + 1] - vs[k]);
    }
    return getDerivative(derivative - 1, t, _vs);
  }
};
var t2length = (length, totalLength, func) => {
  let error = 1;
  let t = length / totalLength;
  let step = (length - func(t)) / totalLength;
  let numIterations = 0;
  while (error > 0.001) {
    const increasedTLength = func(t + step);
    const increasedTError = Math.abs(length - increasedTLength) / totalLength;
    if (increasedTError < error) {
      error = increasedTError;
      t += step;
    } else {
      const decreasedTLength = func(t - step);
      const decreasedTError = Math.abs(length - decreasedTLength) / totalLength;
      if (decreasedTError < error) {
        error = decreasedTError;
        t -= step;
      } else {
        step /= 2;
      }
    }
    numIterations++;
    if (numIterations > 500) {
      break;
    }
  }
  return t;
};

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/shapes/Path.js
class Path extends Shape {
  constructor(config) {
    super(config);
    this.dataArray = [];
    this.pathLength = 0;
    this._readDataAttribute();
    this.on("dataChange.konva", function() {
      this._readDataAttribute();
    });
  }
  _readDataAttribute() {
    this.dataArray = Path.parsePathData(this.data());
    this.pathLength = Path.getPathLength(this.dataArray);
  }
  _sceneFunc(context) {
    const ca = this.dataArray;
    context.beginPath();
    let isClosed = false;
    for (let n = 0;n < ca.length; n++) {
      const c = ca[n].command;
      const p = ca[n].points;
      switch (c) {
        case "L":
          context.lineTo(p[0], p[1]);
          break;
        case "M":
          context.moveTo(p[0], p[1]);
          break;
        case "C":
          context.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
          break;
        case "Q":
          context.quadraticCurveTo(p[0], p[1], p[2], p[3]);
          break;
        case "A":
          const cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6], fs = p[7];
          const r = rx > ry ? rx : ry;
          const scaleX = rx > ry ? 1 : rx / ry;
          const scaleY = rx > ry ? ry / rx : 1;
          context.translate(cx, cy);
          context.rotate(psi);
          context.scale(scaleX, scaleY);
          context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
          context.scale(1 / scaleX, 1 / scaleY);
          context.rotate(-psi);
          context.translate(-cx, -cy);
          break;
        case "z":
          isClosed = true;
          context.closePath();
          break;
      }
    }
    if (!isClosed && !this.hasFill()) {
      context.strokeShape(this);
    } else {
      context.fillStrokeShape(this);
    }
  }
  getSelfRect() {
    let points = [];
    this.dataArray.forEach(function(data) {
      if (data.command === "A") {
        const start = data.points[4];
        const dTheta = data.points[5];
        const end = data.points[4] + dTheta;
        let inc = Math.PI / 180;
        if (Math.abs(start - end) < inc) {
          inc = Math.abs(start - end);
        }
        if (dTheta < 0) {
          for (let t = start - inc;t > end; t -= inc) {
            const point = Path.getPointOnEllipticalArc(data.points[0], data.points[1], data.points[2], data.points[3], t, 0);
            points.push(point.x, point.y);
          }
        } else {
          for (let t = start + inc;t < end; t += inc) {
            const point = Path.getPointOnEllipticalArc(data.points[0], data.points[1], data.points[2], data.points[3], t, 0);
            points.push(point.x, point.y);
          }
        }
      } else if (data.command === "C") {
        for (let t = 0;t <= 1; t += 0.01) {
          const point = Path.getPointOnCubicBezier(t, data.start.x, data.start.y, data.points[0], data.points[1], data.points[2], data.points[3], data.points[4], data.points[5]);
          points.push(point.x, point.y);
        }
      } else {
        points = points.concat(data.points);
      }
    });
    let minX = points[0];
    let maxX = points[0];
    let minY = points[1];
    let maxY = points[1];
    let x, y;
    for (let i = 0;i < points.length / 2; i++) {
      x = points[i * 2];
      y = points[i * 2 + 1];
      if (!isNaN(x)) {
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
      }
      if (!isNaN(y)) {
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  getLength() {
    return this.pathLength;
  }
  getPointAtLength(length) {
    return Path.getPointAtLengthOfDataArray(length, this.dataArray);
  }
  static getLineLength(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }
  static getPathLength(dataArray) {
    let pathLength = 0;
    for (let i = 0;i < dataArray.length; ++i) {
      pathLength += dataArray[i].pathLength;
    }
    return pathLength;
  }
  static getPointAtLengthOfDataArray(length, dataArray) {
    let points, i = 0, ii = dataArray.length;
    if (!ii) {
      return null;
    }
    while (i < ii && length > dataArray[i].pathLength) {
      length -= dataArray[i].pathLength;
      ++i;
    }
    if (i === ii) {
      points = dataArray[i - 1].points.slice(-2);
      return {
        x: points[0],
        y: points[1]
      };
    }
    if (length < 0.01) {
      const cmd = dataArray[i].command;
      if (cmd === "M") {
        points = dataArray[i].points.slice(0, 2);
        return {
          x: points[0],
          y: points[1]
        };
      } else {
        return {
          x: dataArray[i].start.x,
          y: dataArray[i].start.y
        };
      }
    }
    const cp = dataArray[i];
    const p = cp.points;
    switch (cp.command) {
      case "L":
        return Path.getPointOnLine(length, cp.start.x, cp.start.y, p[0], p[1]);
      case "C":
        return Path.getPointOnCubicBezier(t2length(length, Path.getPathLength(dataArray), (i2) => {
          return getCubicArcLength([cp.start.x, p[0], p[2], p[4]], [cp.start.y, p[1], p[3], p[5]], i2);
        }), cp.start.x, cp.start.y, p[0], p[1], p[2], p[3], p[4], p[5]);
      case "Q":
        return Path.getPointOnQuadraticBezier(t2length(length, Path.getPathLength(dataArray), (i2) => {
          return getQuadraticArcLength([cp.start.x, p[0], p[2]], [cp.start.y, p[1], p[3]], i2);
        }), cp.start.x, cp.start.y, p[0], p[1], p[2], p[3]);
      case "A":
        const cx = p[0], cy = p[1], rx = p[2], ry = p[3], dTheta = p[5], psi = p[6];
        let theta = p[4];
        theta += dTheta * length / cp.pathLength;
        return Path.getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi);
    }
    return null;
  }
  static getPointOnLine(dist, P1x, P1y, P2x, P2y, fromX, fromY) {
    fromX = fromX !== null && fromX !== undefined ? fromX : P1x;
    fromY = fromY !== null && fromY !== undefined ? fromY : P1y;
    const len = this.getLineLength(P1x, P1y, P2x, P2y);
    if (len < 0.0000000001) {
      return { x: P1x, y: P1y };
    }
    if (P2x === P1x) {
      return { x: fromX, y: fromY + (P2y > P1y ? dist : -dist) };
    }
    const m = (P2y - P1y) / (P2x - P1x);
    const run = Math.sqrt(dist * dist / (1 + m * m)) * (P2x < P1x ? -1 : 1);
    const rise = m * run;
    if (Math.abs(fromY - P1y - m * (fromX - P1x)) < 0.0000000001) {
      return { x: fromX + run, y: fromY + rise };
    }
    const u = ((fromX - P1x) * (P2x - P1x) + (fromY - P1y) * (P2y - P1y)) / (len * len);
    const ix = P1x + u * (P2x - P1x);
    const iy = P1y + u * (P2y - P1y);
    const pRise = this.getLineLength(fromX, fromY, ix, iy);
    const pRun = Math.sqrt(dist * dist - pRise * pRise);
    const adjustedRun = Math.sqrt(pRun * pRun / (1 + m * m)) * (P2x < P1x ? -1 : 1);
    const adjustedRise = m * adjustedRun;
    return { x: ix + adjustedRun, y: iy + adjustedRise };
  }
  static getPointOnCubicBezier(pct, P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y) {
    function CB1(t) {
      return t * t * t;
    }
    function CB2(t) {
      return 3 * t * t * (1 - t);
    }
    function CB3(t) {
      return 3 * t * (1 - t) * (1 - t);
    }
    function CB4(t) {
      return (1 - t) * (1 - t) * (1 - t);
    }
    const x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);
    const y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);
    return { x, y };
  }
  static getPointOnQuadraticBezier(pct, P1x, P1y, P2x, P2y, P3x, P3y) {
    function QB1(t) {
      return t * t;
    }
    function QB2(t) {
      return 2 * t * (1 - t);
    }
    function QB3(t) {
      return (1 - t) * (1 - t);
    }
    const x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);
    const y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);
    return { x, y };
  }
  static getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
    const cosPsi = Math.cos(psi), sinPsi = Math.sin(psi);
    const pt = {
      x: rx * Math.cos(theta),
      y: ry * Math.sin(theta)
    };
    return {
      x: cx + (pt.x * cosPsi - pt.y * sinPsi),
      y: cy + (pt.x * sinPsi + pt.y * cosPsi)
    };
  }
  static parsePathData(data) {
    if (!data) {
      return [];
    }
    let cs = data;
    const cc = [
      "m",
      "M",
      "l",
      "L",
      "v",
      "V",
      "h",
      "H",
      "z",
      "Z",
      "c",
      "C",
      "q",
      "Q",
      "t",
      "T",
      "s",
      "S",
      "a",
      "A"
    ];
    cs = cs.replace(new RegExp(" ", "g"), ",");
    for (let n = 0;n < cc.length; n++) {
      cs = cs.replace(new RegExp(cc[n], "g"), "|" + cc[n]);
    }
    const arr = cs.split("|");
    const ca = [];
    const coords = [];
    let cpx = 0;
    let cpy = 0;
    const re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi;
    let match;
    for (let n = 1;n < arr.length; n++) {
      let str = arr[n];
      let c = str.charAt(0);
      str = str.slice(1);
      coords.length = 0;
      while (match = re.exec(str)) {
        coords.push(match[0]);
      }
      let p = [];
      let arcParamIndex = c === "A" || c === "a" ? 0 : -1;
      for (let j = 0, jlen = coords.length;j < jlen; j++) {
        const token = coords[j];
        if (token === "00") {
          p.push(0, 0);
          if (arcParamIndex >= 0) {
            arcParamIndex += 2;
            if (arcParamIndex >= 7)
              arcParamIndex -= 7;
          }
          continue;
        }
        if (arcParamIndex >= 0) {
          if (arcParamIndex === 3) {
            if (/^[01]{2}\d+(?:\.\d+)?$/.test(token)) {
              p.push(parseInt(token[0], 10));
              p.push(parseInt(token[1], 10));
              p.push(parseFloat(token.slice(2)));
              arcParamIndex += 3;
              if (arcParamIndex >= 7)
                arcParamIndex -= 7;
              continue;
            }
            if (token === "11" || token === "10" || token === "01") {
              p.push(parseInt(token[0], 10));
              p.push(parseInt(token[1], 10));
              arcParamIndex += 2;
              if (arcParamIndex >= 7)
                arcParamIndex -= 7;
              continue;
            }
            if (token === "0" || token === "1") {
              p.push(parseInt(token, 10));
              arcParamIndex += 1;
              if (arcParamIndex >= 7)
                arcParamIndex -= 7;
              continue;
            }
          } else if (arcParamIndex === 4) {
            if (/^[01]\d+(?:\.\d+)?$/.test(token)) {
              p.push(parseInt(token[0], 10));
              p.push(parseFloat(token.slice(1)));
              arcParamIndex += 2;
              if (arcParamIndex >= 7)
                arcParamIndex -= 7;
              continue;
            }
            if (token === "0" || token === "1") {
              p.push(parseInt(token, 10));
              arcParamIndex += 1;
              if (arcParamIndex >= 7)
                arcParamIndex -= 7;
              continue;
            }
          }
          const parsedArc = parseFloat(token);
          if (!isNaN(parsedArc)) {
            p.push(parsedArc);
          } else {
            p.push(0);
          }
          arcParamIndex += 1;
          if (arcParamIndex >= 7)
            arcParamIndex -= 7;
        } else {
          const parsed = parseFloat(token);
          if (!isNaN(parsed)) {
            p.push(parsed);
          } else {
            p.push(0);
          }
        }
      }
      while (p.length > 0) {
        if (isNaN(p[0])) {
          break;
        }
        let cmd = "";
        let points = [];
        const startX = cpx, startY = cpy;
        let prevCmd, ctlPtx, ctlPty;
        let rx, ry, psi, fa, fs, x1, y1;
        switch (c) {
          case "l":
            cpx += p.shift();
            cpy += p.shift();
            cmd = "L";
            points.push(cpx, cpy);
            break;
          case "L":
            cpx = p.shift();
            cpy = p.shift();
            points.push(cpx, cpy);
            break;
          case "m":
            const dx = p.shift();
            const dy = p.shift();
            cpx += dx;
            cpy += dy;
            cmd = "M";
            if (ca.length > 2 && ca[ca.length - 1].command === "z") {
              for (let idx = ca.length - 2;idx >= 0; idx--) {
                if (ca[idx].command === "M") {
                  cpx = ca[idx].points[0] + dx;
                  cpy = ca[idx].points[1] + dy;
                  break;
                }
              }
            }
            points.push(cpx, cpy);
            c = "l";
            break;
          case "M":
            cpx = p.shift();
            cpy = p.shift();
            cmd = "M";
            points.push(cpx, cpy);
            c = "L";
            break;
          case "h":
            cpx += p.shift();
            cmd = "L";
            points.push(cpx, cpy);
            break;
          case "H":
            cpx = p.shift();
            cmd = "L";
            points.push(cpx, cpy);
            break;
          case "v":
            cpy += p.shift();
            cmd = "L";
            points.push(cpx, cpy);
            break;
          case "V":
            cpy = p.shift();
            cmd = "L";
            points.push(cpx, cpy);
            break;
          case "C":
            points.push(p.shift(), p.shift(), p.shift(), p.shift());
            cpx = p.shift();
            cpy = p.shift();
            points.push(cpx, cpy);
            break;
          case "c":
            points.push(cpx + p.shift(), cpy + p.shift(), cpx + p.shift(), cpy + p.shift());
            cpx += p.shift();
            cpy += p.shift();
            cmd = "C";
            points.push(cpx, cpy);
            break;
          case "S":
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === "C") {
              ctlPtx = cpx + (cpx - prevCmd.points[2]);
              ctlPty = cpy + (cpy - prevCmd.points[3]);
            }
            points.push(ctlPtx, ctlPty, p.shift(), p.shift());
            cpx = p.shift();
            cpy = p.shift();
            cmd = "C";
            points.push(cpx, cpy);
            break;
          case "s":
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === "C") {
              ctlPtx = cpx + (cpx - prevCmd.points[2]);
              ctlPty = cpy + (cpy - prevCmd.points[3]);
            }
            points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());
            cpx += p.shift();
            cpy += p.shift();
            cmd = "C";
            points.push(cpx, cpy);
            break;
          case "Q":
            points.push(p.shift(), p.shift());
            cpx = p.shift();
            cpy = p.shift();
            points.push(cpx, cpy);
            break;
          case "q":
            points.push(cpx + p.shift(), cpy + p.shift());
            cpx += p.shift();
            cpy += p.shift();
            cmd = "Q";
            points.push(cpx, cpy);
            break;
          case "T":
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === "Q") {
              ctlPtx = cpx + (cpx - prevCmd.points[0]);
              ctlPty = cpy + (cpy - prevCmd.points[1]);
            }
            cpx = p.shift();
            cpy = p.shift();
            cmd = "Q";
            points.push(ctlPtx, ctlPty, cpx, cpy);
            break;
          case "t":
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === "Q") {
              ctlPtx = cpx + (cpx - prevCmd.points[0]);
              ctlPty = cpy + (cpy - prevCmd.points[1]);
            }
            cpx += p.shift();
            cpy += p.shift();
            cmd = "Q";
            points.push(ctlPtx, ctlPty, cpx, cpy);
            break;
          case "A":
            rx = p.shift();
            ry = p.shift();
            psi = p.shift();
            fa = p.shift();
            fs = p.shift();
            x1 = cpx;
            y1 = cpy;
            cpx = p.shift();
            cpy = p.shift();
            cmd = "A";
            points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
            break;
          case "a":
            rx = p.shift();
            ry = p.shift();
            psi = p.shift();
            fa = p.shift();
            fs = p.shift();
            x1 = cpx;
            y1 = cpy;
            cpx += p.shift();
            cpy += p.shift();
            cmd = "A";
            points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
            break;
        }
        ca.push({
          command: cmd || c,
          points,
          start: {
            x: startX,
            y: startY
          },
          pathLength: this.calcLength(startX, startY, cmd || c, points)
        });
      }
      if (c === "z" || c === "Z") {
        ca.push({
          command: "z",
          points: [],
          start: undefined,
          pathLength: 0
        });
      }
    }
    return ca;
  }
  static calcLength(x, y, cmd, points) {
    let len, p1, p2, t;
    const path = Path;
    switch (cmd) {
      case "L":
        return path.getLineLength(x, y, points[0], points[1]);
      case "C":
        return getCubicArcLength([x, points[0], points[2], points[4]], [y, points[1], points[3], points[5]], 1);
      case "Q":
        return getQuadraticArcLength([x, points[0], points[2]], [y, points[1], points[3]], 1);
      case "A":
        len = 0;
        const start = points[4];
        const dTheta = points[5];
        const end = points[4] + dTheta;
        let inc = Math.PI / 180;
        if (Math.abs(start - end) < inc) {
          inc = Math.abs(start - end);
        }
        p1 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
        if (dTheta < 0) {
          for (t = start - inc;t > end; t -= inc) {
            p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
            len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
        } else {
          for (t = start + inc;t < end; t += inc) {
            p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
            len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
        }
        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
        return len;
    }
    return 0;
  }
  static convertEndpointToCenterParameterization(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {
    const psi = psiDeg * (Math.PI / 180);
    const xp = Math.cos(psi) * (x1 - x2) / 2 + Math.sin(psi) * (y1 - y2) / 2;
    const yp = -1 * Math.sin(psi) * (x1 - x2) / 2 + Math.cos(psi) * (y1 - y2) / 2;
    const lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    let f = Math.sqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp)));
    if (fa === fs) {
      f *= -1;
    }
    if (isNaN(f)) {
      f = 0;
    }
    const cxp = f * rx * yp / ry;
    const cyp = f * -ry * xp / rx;
    const cx = (x1 + x2) / 2 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
    const cy = (y1 + y2) / 2 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;
    const vMag = function(v2) {
      return Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
    };
    const vRatio = function(u2, v2) {
      return (u2[0] * v2[0] + u2[1] * v2[1]) / (vMag(u2) * vMag(v2));
    };
    const vAngle = function(u2, v2) {
      return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vRatio(u2, v2));
    };
    const theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
    const u = [(xp - cxp) / rx, (yp - cyp) / ry];
    const v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    let dTheta = vAngle(u, v);
    if (vRatio(u, v) <= -1) {
      dTheta = Math.PI;
    }
    if (vRatio(u, v) >= 1) {
      dTheta = 0;
    }
    if (fs === 0 && dTheta > 0) {
      dTheta = dTheta - 2 * Math.PI;
    }
    if (fs === 1 && dTheta < 0) {
      dTheta = dTheta + 2 * Math.PI;
    }
    return [cx, cy, rx, ry, theta, dTheta, psi, fs];
  }
}
Path.prototype.className = "Path";
Path.prototype._attrsAffectingSize = ["data"];
_registerNode(Path);
Factory.addGetterSetter(Path, "data");

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/shapes/Arrow.js
class Arrow extends Line {
  _sceneFunc(ctx) {
    super._sceneFunc(ctx);
    const PI2 = Math.PI * 2;
    const points = this.points();
    let tp = points;
    const fromTension = this.tension() !== 0 && points.length > 4;
    if (fromTension) {
      tp = this.getTensionPoints();
    }
    const length = this.pointerLength();
    const n = points.length;
    let dx, dy;
    if (fromTension) {
      const lp = [
        tp[tp.length - 4],
        tp[tp.length - 3],
        tp[tp.length - 2],
        tp[tp.length - 1],
        points[n - 2],
        points[n - 1]
      ];
      const lastLength = Path.calcLength(tp[tp.length - 4], tp[tp.length - 3], "C", lp);
      const previous = Path.getPointOnQuadraticBezier(Math.min(1, 1 - length / lastLength), lp[0], lp[1], lp[2], lp[3], lp[4], lp[5]);
      dx = points[n - 2] - previous.x;
      dy = points[n - 1] - previous.y;
    } else {
      dx = points[n - 2] - points[n - 4];
      dy = points[n - 1] - points[n - 3];
    }
    const radians = (Math.atan2(dy, dx) + PI2) % PI2;
    const width = this.pointerWidth();
    if (this.pointerAtEnding()) {
      ctx.save();
      ctx.beginPath();
      ctx.translate(points[n - 2], points[n - 1]);
      ctx.rotate(radians);
      ctx.moveTo(0, 0);
      ctx.lineTo(-length, width / 2);
      ctx.lineTo(-length, -width / 2);
      ctx.closePath();
      ctx.restore();
      this.__fillStroke(ctx);
    }
    if (this.pointerAtBeginning()) {
      ctx.save();
      ctx.beginPath();
      ctx.translate(points[0], points[1]);
      if (fromTension) {
        dx = (tp[0] + tp[2]) / 2 - points[0];
        dy = (tp[1] + tp[3]) / 2 - points[1];
      } else {
        dx = points[2] - points[0];
        dy = points[3] - points[1];
      }
      ctx.rotate((Math.atan2(-dy, -dx) + PI2) % PI2);
      ctx.moveTo(0, 0);
      ctx.lineTo(-length, width / 2);
      ctx.lineTo(-length, -width / 2);
      ctx.closePath();
      ctx.restore();
      this.__fillStroke(ctx);
    }
  }
  __fillStroke(ctx) {
    const isDashEnabled = this.dashEnabled();
    if (isDashEnabled) {
      this.attrs.dashEnabled = false;
      ctx.setLineDash([]);
    }
    ctx.fillStrokeShape(this);
    if (isDashEnabled) {
      this.attrs.dashEnabled = true;
    }
  }
  getSelfRect() {
    const lineRect = super.getSelfRect();
    const offset = this.pointerWidth() / 2;
    return {
      x: lineRect.x,
      y: lineRect.y - offset,
      width: lineRect.width,
      height: lineRect.height + offset * 2
    };
  }
}
Arrow.prototype.className = "Arrow";
_registerNode(Arrow);
Factory.addGetterSetter(Arrow, "pointerLength", 10, getNumberValidator());
Factory.addGetterSetter(Arrow, "pointerWidth", 10, getNumberValidator());
Factory.addGetterSetter(Arrow, "pointerAtBeginning", false);
Factory.addGetterSetter(Arrow, "pointerAtEnding", true);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/shapes/Circle.js
class Circle extends Shape {
  _sceneFunc(context) {
    context.beginPath();
    context.arc(0, 0, this.attrs.radius || 0, 0, Math.PI * 2, false);
    context.closePath();
    context.fillStrokeShape(this);
  }
  getWidth() {
    return this.radius() * 2;
  }
  getHeight() {
    return this.radius() * 2;
  }
  setWidth(width) {
    if (this.radius() !== width / 2) {
      this.radius(width / 2);
    }
  }
  setHeight(height) {
    if (this.radius() !== height / 2) {
      this.radius(height / 2);
    }
  }
}
Circle.prototype._centroid = true;
Circle.prototype.className = "Circle";
Circle.prototype._attrsAffectingSize = ["radius"];
_registerNode(Circle);
Factory.addGetterSetter(Circle, "radius", 0, getNumberValidator());

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/shapes/Ellipse.js
class Ellipse extends Shape {
  _sceneFunc(context) {
    const rx = this.radiusX(), ry = this.radiusY();
    context.beginPath();
    context.save();
    if (rx !== ry) {
      context.scale(1, ry / rx);
    }
    context.arc(0, 0, rx, 0, Math.PI * 2, false);
    context.restore();
    context.closePath();
    context.fillStrokeShape(this);
  }
  getWidth() {
    return this.radiusX() * 2;
  }
  getHeight() {
    return this.radiusY() * 2;
  }
  setWidth(width) {
    this.radiusX(width / 2);
  }
  setHeight(height) {
    this.radiusY(height / 2);
  }
}
Ellipse.prototype.className = "Ellipse";
Ellipse.prototype._centroid = true;
Ellipse.prototype._attrsAffectingSize = ["radiusX", "radiusY"];
_registerNode(Ellipse);
Factory.addComponentsGetterSetter(Ellipse, "radius", ["x", "y"]);
Factory.addGetterSetter(Ellipse, "radiusX", 0, getNumberValidator());
Factory.addGetterSetter(Ellipse, "radiusY", 0, getNumberValidator());

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/shapes/Image.js
class Image2 extends Shape {
  constructor(attrs) {
    super(attrs);
    this._loadListener = () => {
      this._requestDraw();
    };
    this.on("imageChange.konva", (props) => {
      this._removeImageLoad(props.oldVal);
      this._setImageLoad();
    });
    this._setImageLoad();
  }
  _setImageLoad() {
    const image = this.image();
    if (image && image.complete) {
      return;
    }
    if (image && image.readyState === 4) {
      return;
    }
    if (image && image["addEventListener"]) {
      image["addEventListener"]("load", this._loadListener);
    }
  }
  _removeImageLoad(image) {
    if (image && image["removeEventListener"]) {
      image["removeEventListener"]("load", this._loadListener);
    }
  }
  destroy() {
    this._removeImageLoad(this.image());
    super.destroy();
    return this;
  }
  _useBufferCanvas() {
    const hasCornerRadius = !!this.cornerRadius();
    const hasShadow = this.hasShadow();
    if (hasCornerRadius && hasShadow) {
      return true;
    }
    return super._useBufferCanvas(true);
  }
  _sceneFunc(context) {
    const width = this.getWidth();
    const height = this.getHeight();
    const cornerRadius = this.cornerRadius();
    const image = this.attrs.image;
    let params;
    if (image) {
      const cropWidth = this.attrs.cropWidth;
      const cropHeight = this.attrs.cropHeight;
      if (cropWidth && cropHeight) {
        params = [
          image,
          this.cropX(),
          this.cropY(),
          cropWidth,
          cropHeight,
          0,
          0,
          width,
          height
        ];
      } else {
        params = [image, 0, 0, width, height];
      }
    }
    if (this.hasFill() || this.hasStroke() || cornerRadius) {
      context.beginPath();
      cornerRadius ? Util.drawRoundedRectPath(context, width, height, cornerRadius) : context.rect(0, 0, width, height);
      context.closePath();
      context.fillStrokeShape(this);
    }
    if (image) {
      if (cornerRadius) {
        context.clip();
      }
      context.drawImage.apply(context, params);
    }
  }
  _hitFunc(context) {
    const width = this.width(), height = this.height(), cornerRadius = this.cornerRadius();
    context.beginPath();
    if (!cornerRadius) {
      context.rect(0, 0, width, height);
    } else {
      Util.drawRoundedRectPath(context, width, height, cornerRadius);
    }
    context.closePath();
    context.fillStrokeShape(this);
  }
  getWidth() {
    var _a, _b, _c;
    return (_c = (_a = this.attrs.width) !== null && _a !== undefined ? _a : (_b = this.image()) === null || _b === undefined ? undefined : _b.width) !== null && _c !== undefined ? _c : 0;
  }
  getHeight() {
    var _a, _b, _c;
    return (_c = (_a = this.attrs.height) !== null && _a !== undefined ? _a : (_b = this.image()) === null || _b === undefined ? undefined : _b.height) !== null && _c !== undefined ? _c : 0;
  }
  static fromURL(url, callback, onError = null) {
    const img = Util.createImageElement();
    img.onload = function() {
      const image = new Image2({
        image: img
      });
      callback(image);
    };
    img.onerror = onError;
    img.crossOrigin = "Anonymous";
    img.src = url;
  }
}
Image2.prototype.className = "Image";
Image2.prototype._attrsAffectingSize = ["image"];
_registerNode(Image2);
Factory.addGetterSetter(Image2, "cornerRadius", 0, getNumberOrArrayOfNumbersValidator(4));
Factory.addGetterSetter(Image2, "image");
Factory.addComponentsGetterSetter(Image2, "crop", ["x", "y", "width", "height"]);
Factory.addGetterSetter(Image2, "cropX", 0, getNumberValidator());
Factory.addGetterSetter(Image2, "cropY", 0, getNumberValidator());
Factory.addGetterSetter(Image2, "cropWidth", 0, getNumberValidator());
Factory.addGetterSetter(Image2, "cropHeight", 0, getNumberValidator());

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/shapes/Label.js
var ATTR_CHANGE_LIST = [
  "fontFamily",
  "fontSize",
  "fontStyle",
  "padding",
  "lineHeight",
  "text",
  "width",
  "height",
  "pointerDirection",
  "pointerWidth",
  "pointerHeight"
];
var CHANGE_KONVA = "Change.konva";
var NONE = "none";
var UP = "up";
var RIGHT = "right";
var DOWN = "down";
var LEFT = "left";
var attrChangeListLen = ATTR_CHANGE_LIST.length;

class Label extends Group {
  constructor(config) {
    super(config);
    this.on("add.konva", function(evt) {
      this._addListeners(evt.child);
      this._sync();
    });
  }
  getText() {
    return this.find("Text")[0];
  }
  getTag() {
    return this.find("Tag")[0];
  }
  _addListeners(text) {
    let that = this, n;
    const func = function() {
      that._sync();
    };
    for (n = 0;n < attrChangeListLen; n++) {
      text.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, func);
    }
  }
  getWidth() {
    return this.getText().width();
  }
  getHeight() {
    return this.getText().height();
  }
  _sync() {
    let text = this.getText(), tag = this.getTag(), width, height, pointerDirection, pointerWidth, x, y, pointerHeight;
    if (text && tag) {
      width = text.width();
      height = text.height();
      pointerDirection = tag.pointerDirection();
      pointerWidth = tag.pointerWidth();
      pointerHeight = tag.pointerHeight();
      x = 0;
      y = 0;
      switch (pointerDirection) {
        case UP:
          x = width / 2;
          y = -1 * pointerHeight;
          break;
        case RIGHT:
          x = width + pointerWidth;
          y = height / 2;
          break;
        case DOWN:
          x = width / 2;
          y = height + pointerHeight;
          break;
        case LEFT:
          x = -1 * pointerWidth;
          y = height / 2;
          break;
      }
      tag.setAttrs({
        x: -1 * x,
        y: -1 * y,
        width,
        height
      });
      text.setAttrs({
        x: -1 * x,
        y: -1 * y
      });
    }
  }
}
Label.prototype.className = "Label";
_registerNode(Label);

class Tag extends Shape {
  _sceneFunc(context) {
    const width = this.width(), height = this.height(), pointerDirection = this.pointerDirection(), pointerWidth = this.pointerWidth(), pointerHeight = this.pointerHeight(), cornerRadius = this.cornerRadius();
    let topLeft = 0;
    let topRight = 0;
    let bottomLeft = 0;
    let bottomRight = 0;
    if (typeof cornerRadius === "number") {
      topLeft = topRight = bottomLeft = bottomRight = Math.min(cornerRadius, width / 2, height / 2);
    } else {
      topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2);
      topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2);
      bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2);
      bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2);
    }
    context.beginPath();
    context.moveTo(topLeft, 0);
    if (pointerDirection === UP) {
      context.lineTo((width - pointerWidth) / 2, 0);
      context.lineTo(width / 2, -1 * pointerHeight);
      context.lineTo((width + pointerWidth) / 2, 0);
    }
    context.lineTo(width - topRight, 0);
    context.arc(width - topRight, topRight, topRight, Math.PI * 3 / 2, 0, false);
    if (pointerDirection === RIGHT) {
      context.lineTo(width, (height - pointerHeight) / 2);
      context.lineTo(width + pointerWidth, height / 2);
      context.lineTo(width, (height + pointerHeight) / 2);
    }
    context.lineTo(width, height - bottomRight);
    context.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);
    if (pointerDirection === DOWN) {
      context.lineTo((width + pointerWidth) / 2, height);
      context.lineTo(width / 2, height + pointerHeight);
      context.lineTo((width - pointerWidth) / 2, height);
    }
    context.lineTo(bottomLeft, height);
    context.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
    if (pointerDirection === LEFT) {
      context.lineTo(0, (height + pointerHeight) / 2);
      context.lineTo(-1 * pointerWidth, height / 2);
      context.lineTo(0, (height - pointerHeight) / 2);
    }
    context.lineTo(0, topLeft);
    context.arc(topLeft, topLeft, topLeft, Math.PI, Math.PI * 3 / 2, false);
    context.closePath();
    context.fillStrokeShape(this);
  }
  getSelfRect() {
    let x = 0, y = 0, pointerWidth = this.pointerWidth(), pointerHeight = this.pointerHeight(), direction = this.pointerDirection(), width = this.width(), height = this.height();
    if (direction === UP) {
      y -= pointerHeight;
      height += pointerHeight;
    } else if (direction === DOWN) {
      height += pointerHeight;
    } else if (direction === LEFT) {
      x -= pointerWidth * 1.5;
      width += pointerWidth;
    } else if (direction === RIGHT) {
      width += pointerWidth * 1.5;
    }
    return {
      x,
      y,
      width,
      height
    };
  }
}
Tag.prototype.className = "Tag";
_registerNode(Tag);
Factory.addGetterSetter(Tag, "pointerDirection", NONE);
Factory.addGetterSetter(Tag, "pointerWidth", 0, getNumberValidator());
Factory.addGetterSetter(Tag, "pointerHeight", 0, getNumberValidator());
Factory.addGetterSetter(Tag, "cornerRadius", 0, getNumberOrArrayOfNumbersValidator(4));

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/shapes/Rect.js
class Rect extends Shape {
  _sceneFunc(context) {
    const cornerRadius = this.cornerRadius(), width = this.width(), height = this.height();
    context.beginPath();
    if (!cornerRadius) {
      context.rect(0, 0, width, height);
    } else {
      Util.drawRoundedRectPath(context, width, height, cornerRadius);
    }
    context.closePath();
    context.fillStrokeShape(this);
  }
}
Rect.prototype.className = "Rect";
_registerNode(Rect);
Factory.addGetterSetter(Rect, "cornerRadius", 0, getNumberOrArrayOfNumbersValidator(4));

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/shapes/RegularPolygon.js
class RegularPolygon extends Shape {
  _sceneFunc(context) {
    const points = this._getPoints(), radius = this.radius(), sides = this.sides(), cornerRadius = this.cornerRadius();
    context.beginPath();
    if (!cornerRadius) {
      context.moveTo(points[0].x, points[0].y);
      for (let n = 1;n < points.length; n++) {
        context.lineTo(points[n].x, points[n].y);
      }
    } else {
      Util.drawRoundedPolygonPath(context, points, sides, radius, cornerRadius);
    }
    context.closePath();
    context.fillStrokeShape(this);
  }
  _getPoints() {
    const sides = this.attrs.sides;
    const radius = this.attrs.radius || 0;
    const points = [];
    for (let n = 0;n < sides; n++) {
      points.push({
        x: radius * Math.sin(n * 2 * Math.PI / sides),
        y: -1 * radius * Math.cos(n * 2 * Math.PI / sides)
      });
    }
    return points;
  }
  getSelfRect() {
    const points = this._getPoints();
    let minX = points[0].x;
    let maxX = points[0].x;
    let minY = points[0].y;
    let maxY = points[0].y;
    points.forEach((point) => {
      minX = Math.min(minX, point.x);
      maxX = Math.max(maxX, point.x);
      minY = Math.min(minY, point.y);
      maxY = Math.max(maxY, point.y);
    });
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  getWidth() {
    return this.radius() * 2;
  }
  getHeight() {
    return this.radius() * 2;
  }
  setWidth(width) {
    this.radius(width / 2);
  }
  setHeight(height) {
    this.radius(height / 2);
  }
}
RegularPolygon.prototype.className = "RegularPolygon";
RegularPolygon.prototype._centroid = true;
RegularPolygon.prototype._attrsAffectingSize = ["radius"];
_registerNode(RegularPolygon);
Factory.addGetterSetter(RegularPolygon, "radius", 0, getNumberValidator());
Factory.addGetterSetter(RegularPolygon, "sides", 0, getNumberValidator());
Factory.addGetterSetter(RegularPolygon, "cornerRadius", 0, getNumberOrArrayOfNumbersValidator(4));

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/shapes/Ring.js
var PIx2 = Math.PI * 2;

class Ring extends Shape {
  _sceneFunc(context) {
    context.beginPath();
    context.arc(0, 0, this.innerRadius(), 0, PIx2, false);
    context.moveTo(this.outerRadius(), 0);
    context.arc(0, 0, this.outerRadius(), PIx2, 0, true);
    context.closePath();
    context.fillStrokeShape(this);
  }
  getWidth() {
    return this.outerRadius() * 2;
  }
  getHeight() {
    return this.outerRadius() * 2;
  }
  setWidth(width) {
    this.outerRadius(width / 2);
  }
  setHeight(height) {
    this.outerRadius(height / 2);
  }
}
Ring.prototype.className = "Ring";
Ring.prototype._centroid = true;
Ring.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
_registerNode(Ring);
Factory.addGetterSetter(Ring, "innerRadius", 0, getNumberValidator());
Factory.addGetterSetter(Ring, "outerRadius", 0, getNumberValidator());

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/shapes/Sprite.js
class Sprite extends Shape {
  constructor(config) {
    super(config);
    this._updated = true;
    this.anim = new Animation(() => {
      const updated = this._updated;
      this._updated = false;
      return updated;
    });
    this.on("animationChange.konva", function() {
      this.frameIndex(0);
    });
    this.on("frameIndexChange.konva", function() {
      this._updated = true;
    });
    this.on("frameRateChange.konva", function() {
      if (!this.anim.isRunning()) {
        return;
      }
      clearInterval(this.interval);
      this._setInterval();
    });
  }
  _sceneFunc(context) {
    const anim = this.animation(), index = this.frameIndex(), ix4 = index * 4, set = this.animations()[anim], offsets = this.frameOffsets(), x = set[ix4 + 0], y = set[ix4 + 1], width = set[ix4 + 2], height = set[ix4 + 3], image = this.image();
    if (this.hasFill() || this.hasStroke()) {
      context.beginPath();
      context.rect(0, 0, width, height);
      context.closePath();
      context.fillStrokeShape(this);
    }
    if (image) {
      if (offsets) {
        const offset = offsets[anim], ix2 = index * 2;
        context.drawImage(image, x, y, width, height, offset[ix2 + 0], offset[ix2 + 1], width, height);
      } else {
        context.drawImage(image, x, y, width, height, 0, 0, width, height);
      }
    }
  }
  _hitFunc(context) {
    const anim = this.animation(), index = this.frameIndex(), ix4 = index * 4, set = this.animations()[anim], offsets = this.frameOffsets(), width = set[ix4 + 2], height = set[ix4 + 3];
    context.beginPath();
    if (offsets) {
      const offset = offsets[anim];
      const ix2 = index * 2;
      context.rect(offset[ix2 + 0], offset[ix2 + 1], width, height);
    } else {
      context.rect(0, 0, width, height);
    }
    context.closePath();
    context.fillShape(this);
  }
  _useBufferCanvas() {
    return super._useBufferCanvas(true);
  }
  _setInterval() {
    const that = this;
    this.interval = setInterval(function() {
      that._updateIndex();
    }, 1000 / this.frameRate());
  }
  start() {
    if (this.isRunning()) {
      return;
    }
    const layer = this.getLayer();
    this.anim.setLayers(layer);
    this._setInterval();
    this.anim.start();
  }
  stop() {
    this.anim.stop();
    clearInterval(this.interval);
  }
  isRunning() {
    return this.anim.isRunning();
  }
  _updateIndex() {
    const index = this.frameIndex(), animation = this.animation(), animations = this.animations(), anim = animations[animation], len = anim.length / 4;
    if (index < len - 1) {
      this.frameIndex(index + 1);
    } else {
      this.frameIndex(0);
    }
  }
}
Sprite.prototype.className = "Sprite";
_registerNode(Sprite);
Factory.addGetterSetter(Sprite, "animation");
Factory.addGetterSetter(Sprite, "animations");
Factory.addGetterSetter(Sprite, "frameOffsets");
Factory.addGetterSetter(Sprite, "image");
Factory.addGetterSetter(Sprite, "frameIndex", 0, getNumberValidator());
Factory.addGetterSetter(Sprite, "frameRate", 17, getNumberValidator());
Factory.backCompat(Sprite, {
  index: "frameIndex",
  getIndex: "getFrameIndex",
  setIndex: "setFrameIndex"
});

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/shapes/Star.js
class Star extends Shape {
  _sceneFunc(context) {
    const innerRadius = this.innerRadius(), outerRadius = this.outerRadius(), numPoints = this.numPoints();
    context.beginPath();
    context.moveTo(0, 0 - outerRadius);
    for (let n = 1;n < numPoints * 2; n++) {
      const radius = n % 2 === 0 ? outerRadius : innerRadius;
      const x = radius * Math.sin(n * Math.PI / numPoints);
      const y = -1 * radius * Math.cos(n * Math.PI / numPoints);
      context.lineTo(x, y);
    }
    context.closePath();
    context.fillStrokeShape(this);
  }
  getWidth() {
    return this.outerRadius() * 2;
  }
  getHeight() {
    return this.outerRadius() * 2;
  }
  setWidth(width) {
    this.outerRadius(width / 2);
  }
  setHeight(height) {
    this.outerRadius(height / 2);
  }
}
Star.prototype.className = "Star";
Star.prototype._centroid = true;
Star.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
_registerNode(Star);
Factory.addGetterSetter(Star, "numPoints", 5, getNumberValidator());
Factory.addGetterSetter(Star, "innerRadius", 0, getNumberValidator());
Factory.addGetterSetter(Star, "outerRadius", 0, getNumberValidator());

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/shapes/Text.js
function stringToArray(string) {
  return [...string].reduce((acc, char, index, array) => {
    if (/\p{Emoji}/u.test(char)) {
      const nextChar = array[index + 1];
      if (nextChar && /\p{Emoji_Modifier}|\u200D/u.test(nextChar)) {
        acc.push(char + nextChar);
        array[index + 1] = "";
      } else {
        acc.push(char);
      }
    } else if (/\p{Regional_Indicator}{2}/u.test(char + (array[index + 1] || ""))) {
      acc.push(char + array[index + 1]);
    } else if (index > 0 && /\p{Mn}|\p{Me}|\p{Mc}/u.test(char)) {
      acc[acc.length - 1] += char;
    } else if (char) {
      acc.push(char);
    }
    return acc;
  }, []);
}
var AUTO = "auto";
var CENTER = "center";
var INHERIT = "inherit";
var JUSTIFY = "justify";
var CHANGE_KONVA2 = "Change.konva";
var CONTEXT_2D = "2d";
var DASH = "-";
var LEFT2 = "left";
var TEXT = "text";
var TEXT_UPPER = "Text";
var TOP = "top";
var BOTTOM = "bottom";
var MIDDLE = "middle";
var NORMAL = "normal";
var PX_SPACE = "px ";
var SPACE2 = " ";
var RIGHT2 = "right";
var RTL = "rtl";
var WORD = "word";
var CHAR = "char";
var NONE2 = "none";
var ELLIPSIS = "";
var ATTR_CHANGE_LIST2 = [
  "direction",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontVariant",
  "padding",
  "align",
  "verticalAlign",
  "lineHeight",
  "text",
  "width",
  "height",
  "wrap",
  "ellipsis",
  "letterSpacing"
];
var attrChangeListLen2 = ATTR_CHANGE_LIST2.length;
function normalizeFontFamily(fontFamily) {
  return fontFamily.split(",").map((family) => {
    family = family.trim();
    const hasSpace = family.indexOf(" ") >= 0;
    const hasQuotes = family.indexOf('"') >= 0 || family.indexOf("'") >= 0;
    if (hasSpace && !hasQuotes) {
      family = `"${family}"`;
    }
    return family;
  }).join(", ");
}
var dummyContext2;
function getDummyContext2() {
  if (dummyContext2) {
    return dummyContext2;
  }
  dummyContext2 = Util.createCanvasElement().getContext(CONTEXT_2D);
  return dummyContext2;
}
function _fillFunc2(context) {
  context.fillText(this._partialText, this._partialTextX, this._partialTextY);
}
function _strokeFunc2(context) {
  context.setAttr("miterLimit", 2);
  context.strokeText(this._partialText, this._partialTextX, this._partialTextY);
}
function checkDefaultFill(config) {
  config = config || {};
  if (!config.fillLinearGradientColorStops && !config.fillRadialGradientColorStops && !config.fillPatternImage) {
    config.fill = config.fill || "black";
  }
  return config;
}

class Text extends Shape {
  constructor(config) {
    super(checkDefaultFill(config));
    this._partialTextX = 0;
    this._partialTextY = 0;
    for (let n = 0;n < attrChangeListLen2; n++) {
      this.on(ATTR_CHANGE_LIST2[n] + CHANGE_KONVA2, this._setTextData);
    }
    this._setTextData();
  }
  _sceneFunc(context) {
    var _a, _b;
    const textArr = this.textArr, textArrLen = textArr.length;
    if (!this.text()) {
      return;
    }
    let padding = this.padding(), fontSize = this.fontSize(), lineHeightPx = this.lineHeight() * fontSize, verticalAlign = this.verticalAlign(), direction = this.direction(), alignY = 0, align = this.align(), totalWidth = this.getWidth(), letterSpacing = this.letterSpacing(), charRenderFunc = this.charRenderFunc(), fill = this.fill(), textDecoration = this.textDecoration(), shouldUnderline = textDecoration.indexOf("underline") !== -1, shouldLineThrough = textDecoration.indexOf("line-through") !== -1, n;
    direction = direction === INHERIT ? context.direction : direction;
    let translateY = lineHeightPx / 2;
    let baseline = MIDDLE;
    if (!Konva.legacyTextRendering) {
      const metrics = this.measureSize("M");
      baseline = "alphabetic";
      const ascent = (_a = metrics.fontBoundingBoxAscent) !== null && _a !== undefined ? _a : metrics.actualBoundingBoxAscent;
      const descent = (_b = metrics.fontBoundingBoxDescent) !== null && _b !== undefined ? _b : metrics.actualBoundingBoxDescent;
      translateY = (ascent - descent) / 2 + lineHeightPx / 2;
    }
    if (direction === RTL) {
      context.setAttr("direction", direction);
    }
    context.setAttr("font", this._getContextFont());
    context.setAttr("textBaseline", baseline);
    context.setAttr("textAlign", LEFT2);
    if (verticalAlign === MIDDLE) {
      alignY = (this.getHeight() - textArrLen * lineHeightPx - padding * 2) / 2;
    } else if (verticalAlign === BOTTOM) {
      alignY = this.getHeight() - textArrLen * lineHeightPx - padding * 2;
    }
    context.translate(padding, alignY + padding);
    for (n = 0;n < textArrLen; n++) {
      let lineTranslateX = 0;
      let lineTranslateY = 0;
      const obj = textArr[n], text = obj.text, width = obj.width, lastLine = obj.lastInParagraph;
      context.save();
      if (align === RIGHT2) {
        lineTranslateX += totalWidth - width - padding * 2;
      } else if (align === CENTER) {
        lineTranslateX += (totalWidth - width - padding * 2) / 2;
      }
      if (shouldUnderline) {
        context.save();
        context.beginPath();
        const yOffset = !Konva.legacyTextRendering ? Math.round(fontSize / 4) : Math.round(fontSize / 2);
        const x = lineTranslateX;
        const y = translateY + lineTranslateY + yOffset;
        context.moveTo(x, y);
        const lineWidth = align === JUSTIFY && !lastLine ? totalWidth - padding * 2 : width;
        context.lineTo(x + Math.round(lineWidth), y);
        context.lineWidth = fontSize / 15;
        const gradient = this._getLinearGradient();
        context.strokeStyle = gradient || fill;
        context.stroke();
        context.restore();
      }
      const lineThroughStartX = lineTranslateX;
      if (direction !== RTL && (letterSpacing !== 0 || align === JUSTIFY || charRenderFunc)) {
        const spacesNumber = text.split(" ").length - 1;
        const array = stringToArray(text);
        for (let li = 0;li < array.length; li++) {
          const letter = array[li];
          if (letter === " " && !lastLine && align === JUSTIFY) {
            lineTranslateX += (totalWidth - padding * 2 - width) / spacesNumber;
          }
          this._partialTextX = lineTranslateX;
          this._partialTextY = translateY + lineTranslateY;
          this._partialText = letter;
          if (charRenderFunc) {
            context.save();
            const previousLines = textArr.slice(0, n);
            const previousGraphemes = previousLines.reduce((acc, line) => acc + stringToArray(line.text).length, 0);
            const charIndex = li + previousGraphemes;
            charRenderFunc({
              char: letter,
              index: charIndex,
              x: lineTranslateX,
              y: translateY + lineTranslateY,
              lineIndex: n,
              column: li,
              isLastInLine: lastLine,
              width: this.measureSize(letter).width,
              context
            });
          }
          context.fillStrokeShape(this);
          if (charRenderFunc) {
            context.restore();
          }
          lineTranslateX += this.measureSize(letter).width + letterSpacing;
        }
      } else {
        if (letterSpacing !== 0) {
          context.setAttr("letterSpacing", `${letterSpacing}px`);
        }
        this._partialTextX = lineTranslateX;
        this._partialTextY = translateY + lineTranslateY;
        this._partialText = text;
        context.fillStrokeShape(this);
      }
      if (shouldLineThrough) {
        context.save();
        context.beginPath();
        const yOffset = !Konva.legacyTextRendering ? -Math.round(fontSize / 4) : 0;
        const x = lineThroughStartX;
        context.moveTo(x, translateY + lineTranslateY + yOffset);
        const lineWidth = align === JUSTIFY && !lastLine ? totalWidth - padding * 2 : width;
        context.lineTo(x + Math.round(lineWidth), translateY + lineTranslateY + yOffset);
        context.lineWidth = fontSize / 15;
        const gradient = this._getLinearGradient();
        context.strokeStyle = gradient || fill;
        context.stroke();
        context.restore();
      }
      context.restore();
      if (textArrLen > 1) {
        translateY += lineHeightPx;
      }
    }
  }
  _hitFunc(context) {
    const width = this.getWidth(), height = this.getHeight();
    context.beginPath();
    context.rect(0, 0, width, height);
    context.closePath();
    context.fillStrokeShape(this);
  }
  setText(text) {
    const str = Util._isString(text) ? text : text === null || text === undefined ? "" : text + "";
    this._setAttr(TEXT, str);
    return this;
  }
  getWidth() {
    const isAuto = this.attrs.width === AUTO || this.attrs.width === undefined;
    return isAuto ? this.getTextWidth() + this.padding() * 2 : this.attrs.width;
  }
  getHeight() {
    const isAuto = this.attrs.height === AUTO || this.attrs.height === undefined;
    return isAuto ? this.fontSize() * this.textArr.length * this.lineHeight() + this.padding() * 2 : this.attrs.height;
  }
  getTextWidth() {
    return this.textWidth;
  }
  getTextHeight() {
    Util.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.");
    return this.textHeight;
  }
  measureSize(text) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    let _context = getDummyContext2(), fontSize = this.fontSize(), metrics;
    _context.save();
    _context.font = this._getContextFont();
    metrics = _context.measureText(text);
    _context.restore();
    const scaleFactor = fontSize / 100;
    return {
      actualBoundingBoxAscent: (_a = metrics.actualBoundingBoxAscent) !== null && _a !== undefined ? _a : 71.58203125 * scaleFactor,
      actualBoundingBoxDescent: (_b = metrics.actualBoundingBoxDescent) !== null && _b !== undefined ? _b : 0,
      actualBoundingBoxLeft: (_c = metrics.actualBoundingBoxLeft) !== null && _c !== undefined ? _c : -7.421875 * scaleFactor,
      actualBoundingBoxRight: (_d = metrics.actualBoundingBoxRight) !== null && _d !== undefined ? _d : 75.732421875 * scaleFactor,
      alphabeticBaseline: (_e = metrics.alphabeticBaseline) !== null && _e !== undefined ? _e : 0,
      emHeightAscent: (_f = metrics.emHeightAscent) !== null && _f !== undefined ? _f : 100 * scaleFactor,
      emHeightDescent: (_g = metrics.emHeightDescent) !== null && _g !== undefined ? _g : -20 * scaleFactor,
      fontBoundingBoxAscent: (_h = metrics.fontBoundingBoxAscent) !== null && _h !== undefined ? _h : 91 * scaleFactor,
      fontBoundingBoxDescent: (_j = metrics.fontBoundingBoxDescent) !== null && _j !== undefined ? _j : 21 * scaleFactor,
      hangingBaseline: (_k = metrics.hangingBaseline) !== null && _k !== undefined ? _k : 72.80000305175781 * scaleFactor,
      ideographicBaseline: (_l = metrics.ideographicBaseline) !== null && _l !== undefined ? _l : -21 * scaleFactor,
      width: metrics.width,
      height: fontSize
    };
  }
  _getContextFont() {
    return this.fontStyle() + SPACE2 + this.fontVariant() + SPACE2 + (this.fontSize() + PX_SPACE) + normalizeFontFamily(this.fontFamily());
  }
  _addTextLine(line) {
    const align = this.align();
    if (align === JUSTIFY) {
      line = line.trim();
    }
    const width = this._getTextWidth(line);
    return this.textArr.push({
      text: line,
      width,
      lastInParagraph: false
    });
  }
  _getTextWidth(text) {
    const letterSpacing = this.letterSpacing();
    const length = text.length;
    return getDummyContext2().measureText(text).width + letterSpacing * length;
  }
  _setTextData() {
    let lines = this.text().split(`
`), fontSize = +this.fontSize(), textWidth = 0, lineHeightPx = this.lineHeight() * fontSize, width = this.attrs.width, height = this.attrs.height, fixedWidth = width !== AUTO && width !== undefined, fixedHeight = height !== AUTO && height !== undefined, padding = this.padding(), maxWidth = width - padding * 2, maxHeightPx = height - padding * 2, currentHeightPx = 0, wrap = this.wrap(), shouldWrap = wrap !== NONE2, wrapAtWord = wrap !== CHAR && shouldWrap, shouldAddEllipsis = this.ellipsis();
    this.textArr = [];
    getDummyContext2().font = this._getContextFont();
    const additionalWidth = shouldAddEllipsis ? this._getTextWidth(ELLIPSIS) : 0;
    for (let i = 0, max = lines.length;i < max; ++i) {
      let line = lines[i];
      let lineWidth = this._getTextWidth(line);
      if (fixedWidth && lineWidth > maxWidth) {
        while (line.length > 0) {
          let low = 0, high = stringToArray(line).length, match = "", matchWidth = 0;
          while (low < high) {
            const mid = low + high >>> 1, lineArray = stringToArray(line), substr = lineArray.slice(0, mid + 1).join(""), substrWidth = this._getTextWidth(substr);
            const shouldConsiderEllipsis = shouldAddEllipsis && fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx;
            const effectiveWidth = shouldConsiderEllipsis ? substrWidth + additionalWidth : substrWidth;
            if (effectiveWidth <= maxWidth) {
              low = mid + 1;
              match = substr;
              matchWidth = substrWidth;
            } else {
              high = mid;
            }
          }
          if (match) {
            if (wrapAtWord) {
              const lineArray2 = stringToArray(line);
              const matchArray = stringToArray(match);
              const nextChar = lineArray2[matchArray.length];
              const nextIsSpaceOrDash = nextChar === SPACE2 || nextChar === DASH;
              let wrapIndex;
              if (nextIsSpaceOrDash && matchWidth <= maxWidth) {
                wrapIndex = matchArray.length;
              } else {
                const lastSpaceIndex = matchArray.lastIndexOf(SPACE2);
                const lastDashIndex = matchArray.lastIndexOf(DASH);
                wrapIndex = Math.max(lastSpaceIndex, lastDashIndex) + 1;
              }
              if (wrapIndex > 0) {
                low = wrapIndex;
                match = lineArray2.slice(0, low).join("");
                matchWidth = this._getTextWidth(match);
              }
            }
            match = match.trimRight();
            this._addTextLine(match);
            textWidth = Math.max(textWidth, matchWidth);
            currentHeightPx += lineHeightPx;
            const shouldHandleEllipsis = this._shouldHandleEllipsis(currentHeightPx);
            if (shouldHandleEllipsis) {
              this._tryToAddEllipsisToLastLine();
              break;
            }
            const lineArray = stringToArray(line);
            line = lineArray.slice(low).join("").trimLeft();
            if (line.length > 0) {
              lineWidth = this._getTextWidth(line);
              if (lineWidth <= maxWidth) {
                this._addTextLine(line);
                currentHeightPx += lineHeightPx;
                textWidth = Math.max(textWidth, lineWidth);
                break;
              }
            }
          } else {
            break;
          }
        }
      } else {
        this._addTextLine(line);
        currentHeightPx += lineHeightPx;
        textWidth = Math.max(textWidth, lineWidth);
        if (this._shouldHandleEllipsis(currentHeightPx) && i < max - 1) {
          this._tryToAddEllipsisToLastLine();
        }
      }
      if (this.textArr[this.textArr.length - 1]) {
        this.textArr[this.textArr.length - 1].lastInParagraph = true;
      }
      if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
        break;
      }
    }
    this.textHeight = fontSize;
    this.textWidth = textWidth;
  }
  _shouldHandleEllipsis(currentHeightPx) {
    const fontSize = +this.fontSize(), lineHeightPx = this.lineHeight() * fontSize, height = this.attrs.height, fixedHeight = height !== AUTO && height !== undefined, padding = this.padding(), maxHeightPx = height - padding * 2, wrap = this.wrap(), shouldWrap = wrap !== NONE2;
    return !shouldWrap || fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx;
  }
  _tryToAddEllipsisToLastLine() {
    const width = this.attrs.width, fixedWidth = width !== AUTO && width !== undefined, padding = this.padding(), maxWidth = width - padding * 2, shouldAddEllipsis = this.ellipsis();
    const lastLine = this.textArr[this.textArr.length - 1];
    if (!lastLine || !shouldAddEllipsis) {
      return;
    }
    if (fixedWidth) {
      const haveSpace = this._getTextWidth(lastLine.text + ELLIPSIS) < maxWidth;
      if (!haveSpace) {
        lastLine.text = lastLine.text.slice(0, lastLine.text.length - 3);
      }
    }
    this.textArr.splice(this.textArr.length - 1, 1);
    this._addTextLine(lastLine.text + ELLIPSIS);
  }
  getStrokeScaleEnabled() {
    return true;
  }
  _useBufferCanvas() {
    const hasLine = this.textDecoration().indexOf("underline") !== -1 || this.textDecoration().indexOf("line-through") !== -1;
    const hasShadow = this.hasShadow();
    if (hasLine && hasShadow) {
      return true;
    }
    return super._useBufferCanvas();
  }
}
Text.prototype._fillFunc = _fillFunc2;
Text.prototype._strokeFunc = _strokeFunc2;
Text.prototype.className = TEXT_UPPER;
Text.prototype._attrsAffectingSize = [
  "text",
  "fontSize",
  "padding",
  "wrap",
  "lineHeight",
  "letterSpacing"
];
_registerNode(Text);
Factory.overWriteSetter(Text, "width", getNumberOrAutoValidator());
Factory.overWriteSetter(Text, "height", getNumberOrAutoValidator());
Factory.addGetterSetter(Text, "direction", INHERIT);
Factory.addGetterSetter(Text, "fontFamily", "Arial");
Factory.addGetterSetter(Text, "fontSize", 12, getNumberValidator());
Factory.addGetterSetter(Text, "fontStyle", NORMAL);
Factory.addGetterSetter(Text, "fontVariant", NORMAL);
Factory.addGetterSetter(Text, "padding", 0, getNumberValidator());
Factory.addGetterSetter(Text, "align", LEFT2);
Factory.addGetterSetter(Text, "verticalAlign", TOP);
Factory.addGetterSetter(Text, "lineHeight", 1, getNumberValidator());
Factory.addGetterSetter(Text, "wrap", WORD);
Factory.addGetterSetter(Text, "ellipsis", false, getBooleanValidator());
Factory.addGetterSetter(Text, "letterSpacing", 0, getNumberValidator());
Factory.addGetterSetter(Text, "text", "", getStringValidator());
Factory.addGetterSetter(Text, "textDecoration", "");
Factory.addGetterSetter(Text, "charRenderFunc", undefined);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/shapes/TextPath.js
var EMPTY_STRING2 = "";
var NORMAL2 = "normal";
function _fillFunc3(context) {
  context.fillText(this.partialText, 0, 0);
}
function _strokeFunc3(context) {
  context.strokeText(this.partialText, 0, 0);
}

class TextPath extends Shape {
  constructor(config) {
    super(config);
    this.dummyCanvas = Util.createCanvasElement();
    this.dataArray = [];
    this._readDataAttribute();
    this.on("dataChange.konva", function() {
      this._readDataAttribute();
      this._setTextData();
    });
    this.on("textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva", this._setTextData);
    this._setTextData();
  }
  _getTextPathLength() {
    return Path.getPathLength(this.dataArray);
  }
  _getPointAtLength(length) {
    if (!this.attrs.data) {
      return null;
    }
    const totalLength = this.pathLength;
    if (length > totalLength) {
      return null;
    }
    return Path.getPointAtLengthOfDataArray(length, this.dataArray);
  }
  _readDataAttribute() {
    this.dataArray = Path.parsePathData(this.attrs.data);
    this.pathLength = this._getTextPathLength();
  }
  _sceneFunc(context) {
    context.setAttr("font", this._getContextFont());
    context.setAttr("textBaseline", this.textBaseline());
    context.setAttr("textAlign", "left");
    context.save();
    const textDecoration = this.textDecoration();
    const fill = this.fill();
    const fontSize = this.fontSize();
    const glyphInfo = this.glyphInfo;
    const hasUnderline = textDecoration.indexOf("underline") !== -1;
    const hasLineThrough = textDecoration.indexOf("line-through") !== -1;
    if (hasUnderline) {
      context.beginPath();
    }
    for (let i = 0;i < glyphInfo.length; i++) {
      context.save();
      const p0 = glyphInfo[i].p0;
      context.translate(p0.x, p0.y);
      context.rotate(glyphInfo[i].rotation);
      this.partialText = glyphInfo[i].text;
      context.fillStrokeShape(this);
      if (hasUnderline) {
        if (i === 0) {
          context.moveTo(0, fontSize / 2 + 1);
        }
        context.lineTo(glyphInfo[i].width, fontSize / 2 + 1);
      }
      context.restore();
    }
    if (hasUnderline) {
      context.strokeStyle = fill;
      context.lineWidth = fontSize / 20;
      context.stroke();
    }
    if (hasLineThrough) {
      context.beginPath();
      for (let i = 0;i < glyphInfo.length; i++) {
        context.save();
        const p0 = glyphInfo[i].p0;
        context.translate(p0.x, p0.y);
        context.rotate(glyphInfo[i].rotation);
        if (i === 0) {
          context.moveTo(0, 0);
        }
        context.lineTo(glyphInfo[i].width, 0);
        context.restore();
      }
      context.strokeStyle = fill;
      context.lineWidth = fontSize / 20;
      context.stroke();
    }
    context.restore();
  }
  _hitFunc(context) {
    context.beginPath();
    const glyphInfo = this.glyphInfo;
    if (glyphInfo.length >= 1) {
      const p0 = glyphInfo[0].p0;
      context.moveTo(p0.x, p0.y);
    }
    for (let i = 0;i < glyphInfo.length; i++) {
      const p1 = glyphInfo[i].p1;
      context.lineTo(p1.x, p1.y);
    }
    context.setAttr("lineWidth", this.fontSize());
    context.setAttr("strokeStyle", this.colorKey);
    context.stroke();
  }
  getTextWidth() {
    return this.textWidth;
  }
  getTextHeight() {
    Util.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.");
    return this.textHeight;
  }
  setText(text) {
    return Text.prototype.setText.call(this, text);
  }
  _getContextFont() {
    return Text.prototype._getContextFont.call(this);
  }
  _getTextSize(text) {
    const dummyCanvas = this.dummyCanvas;
    const _context = dummyCanvas.getContext("2d");
    _context.save();
    _context.font = this._getContextFont();
    const metrics = _context.measureText(text);
    _context.restore();
    return {
      width: metrics.width,
      height: parseInt(`${this.fontSize()}`, 10)
    };
  }
  _setTextData() {
    const charArr = stringToArray(this.text());
    const chars = [];
    let width = 0;
    for (let i = 0;i < charArr.length; i++) {
      chars.push({
        char: charArr[i],
        width: this._getTextSize(charArr[i]).width
      });
      width += chars[i].width;
    }
    const { height } = this._getTextSize(this.attrs.text);
    this.textWidth = width;
    this.textHeight = height;
    this.glyphInfo = [];
    if (!this.attrs.data) {
      return null;
    }
    const letterSpacing = this.letterSpacing();
    const align = this.align();
    const kerningFunc = this.kerningFunc();
    const textWidth = Math.max(this.textWidth + ((this.attrs.text || "").length - 1) * letterSpacing, 0);
    let offset = 0;
    if (align === "center") {
      offset = Math.max(0, this.pathLength / 2 - textWidth / 2);
    }
    if (align === "right") {
      offset = Math.max(0, this.pathLength - textWidth);
    }
    let offsetToGlyph = offset;
    for (let i = 0;i < chars.length; i++) {
      const charStartPoint = this._getPointAtLength(offsetToGlyph);
      if (!charStartPoint)
        return;
      const char = chars[i].char;
      let glyphWidth = chars[i].width + letterSpacing;
      if (char === " " && align === "justify") {
        const numberOfSpaces = this.text().split(" ").length - 1;
        glyphWidth += (this.pathLength - textWidth) / numberOfSpaces;
      }
      const charEndPoint = this._getPointAtLength(offsetToGlyph + glyphWidth);
      if (!charEndPoint) {
        return;
      }
      const width2 = Path.getLineLength(charStartPoint.x, charStartPoint.y, charEndPoint.x, charEndPoint.y);
      let kern = 0;
      if (kerningFunc) {
        try {
          kern = kerningFunc(chars[i - 1].char, char) * this.fontSize();
        } catch (e) {
          kern = 0;
        }
      }
      charStartPoint.x += kern;
      charEndPoint.x += kern;
      this.textWidth += kern;
      const midpoint = Path.getPointOnLine(kern + width2 / 2, charStartPoint.x, charStartPoint.y, charEndPoint.x, charEndPoint.y);
      const rotation = Math.atan2(charEndPoint.y - charStartPoint.y, charEndPoint.x - charStartPoint.x);
      this.glyphInfo.push({
        transposeX: midpoint.x,
        transposeY: midpoint.y,
        text: charArr[i],
        rotation,
        p0: charStartPoint,
        p1: charEndPoint,
        width: width2
      });
      offsetToGlyph += glyphWidth;
    }
  }
  getSelfRect() {
    if (!this.glyphInfo.length) {
      return {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    }
    const points = [];
    this.glyphInfo.forEach(function(info) {
      points.push(info.p0.x);
      points.push(info.p0.y);
      points.push(info.p1.x);
      points.push(info.p1.y);
    });
    let minX = points[0] || 0;
    let maxX = points[0] || 0;
    let minY = points[1] || 0;
    let maxY = points[1] || 0;
    let x, y;
    for (let i = 0;i < points.length / 2; i++) {
      x = points[i * 2];
      y = points[i * 2 + 1];
      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x);
      minY = Math.min(minY, y);
      maxY = Math.max(maxY, y);
    }
    const fontSize = this.fontSize();
    return {
      x: minX - fontSize / 2,
      y: minY - fontSize / 2,
      width: maxX - minX + fontSize,
      height: maxY - minY + fontSize
    };
  }
  destroy() {
    Util.releaseCanvas(this.dummyCanvas);
    return super.destroy();
  }
}
TextPath.prototype._fillFunc = _fillFunc3;
TextPath.prototype._strokeFunc = _strokeFunc3;
TextPath.prototype._fillFuncHit = _fillFunc3;
TextPath.prototype._strokeFuncHit = _strokeFunc3;
TextPath.prototype.className = "TextPath";
TextPath.prototype._attrsAffectingSize = ["text", "fontSize", "data"];
_registerNode(TextPath);
Factory.addGetterSetter(TextPath, "data");
Factory.addGetterSetter(TextPath, "fontFamily", "Arial");
Factory.addGetterSetter(TextPath, "fontSize", 12, getNumberValidator());
Factory.addGetterSetter(TextPath, "fontStyle", NORMAL2);
Factory.addGetterSetter(TextPath, "align", "left");
Factory.addGetterSetter(TextPath, "letterSpacing", 0, getNumberValidator());
Factory.addGetterSetter(TextPath, "textBaseline", "middle");
Factory.addGetterSetter(TextPath, "fontVariant", NORMAL2);
Factory.addGetterSetter(TextPath, "text", EMPTY_STRING2);
Factory.addGetterSetter(TextPath, "textDecoration", "");
Factory.addGetterSetter(TextPath, "kerningFunc", undefined);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/shapes/Transformer.js
var EVENTS_NAME = "tr-konva";
var ATTR_CHANGE_LIST3 = [
  "resizeEnabledChange",
  "rotateAnchorOffsetChange",
  "rotateEnabledChange",
  "enabledAnchorsChange",
  "anchorSizeChange",
  "borderEnabledChange",
  "borderStrokeChange",
  "borderStrokeWidthChange",
  "borderDashChange",
  "anchorStrokeChange",
  "anchorStrokeWidthChange",
  "anchorFillChange",
  "anchorCornerRadiusChange",
  "ignoreStrokeChange",
  "anchorStyleFuncChange"
].map((e) => e + `.${EVENTS_NAME}`).join(" ");
var NODES_RECT = "nodesRect";
var TRANSFORM_CHANGE_STR2 = [
  "widthChange",
  "heightChange",
  "scaleXChange",
  "scaleYChange",
  "skewXChange",
  "skewYChange",
  "rotationChange",
  "offsetXChange",
  "offsetYChange",
  "transformsEnabledChange",
  "strokeWidthChange",
  "draggableChange"
];
var ANGLES = {
  "top-left": -45,
  "top-center": 0,
  "top-right": 45,
  "middle-right": -90,
  "middle-left": 90,
  "bottom-left": -135,
  "bottom-center": 180,
  "bottom-right": 135
};
var TOUCH_DEVICE = "ontouchstart" in Konva._global;
function getCursor(anchorName, rad, rotateCursor) {
  if (anchorName === "rotater") {
    return rotateCursor;
  }
  rad += Util.degToRad(ANGLES[anchorName] || 0);
  const angle = (Util.radToDeg(rad) % 360 + 360) % 360;
  if (Util._inRange(angle, 315 + 22.5, 360) || Util._inRange(angle, 0, 22.5)) {
    return "ns-resize";
  } else if (Util._inRange(angle, 45 - 22.5, 45 + 22.5)) {
    return "nesw-resize";
  } else if (Util._inRange(angle, 90 - 22.5, 90 + 22.5)) {
    return "ew-resize";
  } else if (Util._inRange(angle, 135 - 22.5, 135 + 22.5)) {
    return "nwse-resize";
  } else if (Util._inRange(angle, 180 - 22.5, 180 + 22.5)) {
    return "ns-resize";
  } else if (Util._inRange(angle, 225 - 22.5, 225 + 22.5)) {
    return "nesw-resize";
  } else if (Util._inRange(angle, 270 - 22.5, 270 + 22.5)) {
    return "ew-resize";
  } else if (Util._inRange(angle, 315 - 22.5, 315 + 22.5)) {
    return "nwse-resize";
  } else {
    Util.error("Transformer has unknown angle for cursor detection: " + angle);
    return "pointer";
  }
}
var ANCHORS_NAMES = [
  "top-left",
  "top-center",
  "top-right",
  "middle-right",
  "middle-left",
  "bottom-left",
  "bottom-center",
  "bottom-right"
];
var MAX_SAFE_INTEGER = 1e8;
function getCenter(shape) {
  return {
    x: shape.x + shape.width / 2 * Math.cos(shape.rotation) + shape.height / 2 * Math.sin(-shape.rotation),
    y: shape.y + shape.height / 2 * Math.cos(shape.rotation) + shape.width / 2 * Math.sin(shape.rotation)
  };
}
function rotateAroundPoint(shape, angleRad, point) {
  const x = point.x + (shape.x - point.x) * Math.cos(angleRad) - (shape.y - point.y) * Math.sin(angleRad);
  const y = point.y + (shape.x - point.x) * Math.sin(angleRad) + (shape.y - point.y) * Math.cos(angleRad);
  return {
    ...shape,
    rotation: shape.rotation + angleRad,
    x,
    y
  };
}
function rotateAroundCenter(shape, deltaRad) {
  const center = getCenter(shape);
  return rotateAroundPoint(shape, deltaRad, center);
}
function getSnap(snaps, newRotationRad, tol) {
  let snapped = newRotationRad;
  for (let i = 0;i < snaps.length; i++) {
    const angle = Konva.getAngle(snaps[i]);
    const absDiff = Math.abs(angle - newRotationRad) % (Math.PI * 2);
    const dif = Math.min(absDiff, Math.PI * 2 - absDiff);
    if (dif < tol) {
      snapped = angle;
    }
  }
  return snapped;
}
var activeTransformersCount = 0;

class Transformer extends Group {
  constructor(config) {
    super(config);
    this._movingAnchorName = null;
    this._transforming = false;
    this._createElements();
    this._handleMouseMove = this._handleMouseMove.bind(this);
    this._handleMouseUp = this._handleMouseUp.bind(this);
    this.update = this.update.bind(this);
    this.on(ATTR_CHANGE_LIST3, this.update);
    if (this.getNode()) {
      this.update();
    }
  }
  attachTo(node) {
    this.setNode(node);
    return this;
  }
  setNode(node) {
    Util.warn("tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead.");
    return this.setNodes([node]);
  }
  getNode() {
    return this._nodes && this._nodes[0];
  }
  _getEventNamespace() {
    return EVENTS_NAME + this._id;
  }
  setNodes(nodes = []) {
    if (this._nodes && this._nodes.length) {
      this.detach();
    }
    const filteredNodes = nodes.filter((node) => {
      if (node.isAncestorOf(this)) {
        Util.error("Konva.Transformer cannot be an a child of the node you are trying to attach");
        return false;
      }
      return true;
    });
    this._nodes = nodes = filteredNodes;
    if (nodes.length === 1 && this.useSingleNodeRotation()) {
      this.rotation(nodes[0].getAbsoluteRotation());
    } else {
      this.rotation(0);
    }
    this._nodes.forEach((node) => {
      const onChange = () => {
        if (this.nodes().length === 1 && this.useSingleNodeRotation()) {
          this.rotation(this.nodes()[0].getAbsoluteRotation());
        }
        this._resetTransformCache();
        if (!this._transforming && !this.isDragging()) {
          this.update();
        }
      };
      if (node._attrsAffectingSize.length) {
        const additionalEvents = node._attrsAffectingSize.map((prop) => prop + "Change." + this._getEventNamespace()).join(" ");
        node.on(additionalEvents, onChange);
      }
      node.on(TRANSFORM_CHANGE_STR2.map((e) => e + `.${this._getEventNamespace()}`).join(" "), onChange);
      node.on(`absoluteTransformChange.${this._getEventNamespace()}`, onChange);
      this._proxyDrag(node);
    });
    this._resetTransformCache();
    const elementsCreated = !!this.findOne(".top-left");
    if (elementsCreated) {
      this.update();
    }
    return this;
  }
  _proxyDrag(node) {
    let lastPos;
    node.on(`dragstart.${this._getEventNamespace()}`, (e) => {
      lastPos = node.getAbsolutePosition();
      if (!this.isDragging() && node !== this.findOne(".back")) {
        this.startDrag(e, false);
      }
    });
    node.on(`dragmove.${this._getEventNamespace()}`, (e) => {
      if (!lastPos) {
        return;
      }
      const abs = node.getAbsolutePosition();
      const dx = abs.x - lastPos.x;
      const dy = abs.y - lastPos.y;
      this.nodes().forEach((otherNode) => {
        if (otherNode === node) {
          return;
        }
        if (otherNode.isDragging()) {
          return;
        }
        const otherAbs = otherNode.getAbsolutePosition();
        otherNode.setAbsolutePosition({
          x: otherAbs.x + dx,
          y: otherAbs.y + dy
        });
        otherNode.startDrag(e);
      });
      lastPos = null;
    });
  }
  getNodes() {
    return this._nodes || [];
  }
  getActiveAnchor() {
    return this._movingAnchorName;
  }
  detach() {
    if (this._nodes) {
      this._nodes.forEach((node) => {
        node.off("." + this._getEventNamespace());
      });
    }
    this._nodes = [];
    this._resetTransformCache();
  }
  _resetTransformCache() {
    this._clearCache(NODES_RECT);
    this._clearCache("transform");
    this._clearSelfAndDescendantCache("absoluteTransform");
  }
  _getNodeRect() {
    return this._getCache(NODES_RECT, this.__getNodeRect);
  }
  __getNodeShape(node, rot = this.rotation(), relative) {
    const rect = node.getClientRect({
      skipTransform: true,
      skipShadow: true,
      skipStroke: this.ignoreStroke()
    });
    const absScale = node.getAbsoluteScale(relative);
    const absPos = node.getAbsolutePosition(relative);
    const dx = rect.x * absScale.x - node.offsetX() * absScale.x;
    const dy = rect.y * absScale.y - node.offsetY() * absScale.y;
    const rotation = (Konva.getAngle(node.getAbsoluteRotation()) + Math.PI * 2) % (Math.PI * 2);
    const box = {
      x: absPos.x + dx * Math.cos(rotation) + dy * Math.sin(-rotation),
      y: absPos.y + dy * Math.cos(rotation) + dx * Math.sin(rotation),
      width: rect.width * absScale.x,
      height: rect.height * absScale.y,
      rotation
    };
    return rotateAroundPoint(box, -Konva.getAngle(rot), {
      x: 0,
      y: 0
    });
  }
  __getNodeRect() {
    const node = this.getNode();
    if (!node) {
      return {
        x: -MAX_SAFE_INTEGER,
        y: -MAX_SAFE_INTEGER,
        width: 0,
        height: 0,
        rotation: 0
      };
    }
    const totalPoints = [];
    this.nodes().map((node2) => {
      const box = node2.getClientRect({
        skipTransform: true,
        skipShadow: true,
        skipStroke: this.ignoreStroke()
      });
      const points = [
        { x: box.x, y: box.y },
        { x: box.x + box.width, y: box.y },
        { x: box.x + box.width, y: box.y + box.height },
        { x: box.x, y: box.y + box.height }
      ];
      const trans = node2.getAbsoluteTransform();
      points.forEach(function(point) {
        const transformed = trans.point(point);
        totalPoints.push(transformed);
      });
    });
    const tr = new Transform;
    tr.rotate(-Konva.getAngle(this.rotation()));
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    totalPoints.forEach(function(point) {
      const transformed = tr.point(point);
      if (minX === undefined) {
        minX = maxX = transformed.x;
        minY = maxY = transformed.y;
      }
      minX = Math.min(minX, transformed.x);
      minY = Math.min(minY, transformed.y);
      maxX = Math.max(maxX, transformed.x);
      maxY = Math.max(maxY, transformed.y);
    });
    tr.invert();
    const p = tr.point({ x: minX, y: minY });
    return {
      x: p.x,
      y: p.y,
      width: maxX - minX,
      height: maxY - minY,
      rotation: Konva.getAngle(this.rotation())
    };
  }
  getX() {
    return this._getNodeRect().x;
  }
  getY() {
    return this._getNodeRect().y;
  }
  getWidth() {
    return this._getNodeRect().width;
  }
  getHeight() {
    return this._getNodeRect().height;
  }
  _createElements() {
    this._createBack();
    ANCHORS_NAMES.forEach((name) => {
      this._createAnchor(name);
    });
    this._createAnchor("rotater");
  }
  _createAnchor(name) {
    const anchor = new Rect({
      stroke: "rgb(0, 161, 255)",
      fill: "white",
      strokeWidth: 1,
      name: name + " _anchor",
      dragDistance: 0,
      draggable: true,
      hitStrokeWidth: TOUCH_DEVICE ? 10 : "auto"
    });
    const self2 = this;
    anchor.on("mousedown touchstart", function(e) {
      self2._handleMouseDown(e);
    });
    anchor.on("dragstart", (e) => {
      anchor.stopDrag();
      e.cancelBubble = true;
    });
    anchor.on("dragend", (e) => {
      e.cancelBubble = true;
    });
    anchor.on("mouseenter", () => {
      const rad = Konva.getAngle(this.rotation());
      const rotateCursor = this.rotateAnchorCursor();
      const cursor = getCursor(name, rad, rotateCursor);
      anchor.getStage().content && (anchor.getStage().content.style.cursor = cursor);
      this._cursorChange = true;
    });
    anchor.on("mouseout", () => {
      anchor.getStage().content && (anchor.getStage().content.style.cursor = "");
      this._cursorChange = false;
    });
    this.add(anchor);
  }
  _createBack() {
    const back = new Shape({
      name: "back",
      width: 0,
      height: 0,
      sceneFunc(ctx, shape) {
        const tr = shape.getParent();
        const padding = tr.padding();
        ctx.beginPath();
        ctx.rect(-padding, -padding, shape.width() + padding * 2, shape.height() + padding * 2);
        ctx.moveTo(shape.width() / 2, -padding);
        if (tr.rotateEnabled() && tr.rotateLineVisible()) {
          ctx.lineTo(shape.width() / 2, -tr.rotateAnchorOffset() * Util._sign(shape.height()) - padding);
        }
        ctx.fillStrokeShape(shape);
      },
      hitFunc: (ctx, shape) => {
        if (!this.shouldOverdrawWholeArea()) {
          return;
        }
        const padding = this.padding();
        ctx.beginPath();
        ctx.rect(-padding, -padding, shape.width() + padding * 2, shape.height() + padding * 2);
        ctx.fillStrokeShape(shape);
      }
    });
    this.add(back);
    this._proxyDrag(back);
    back.on("dragstart", (e) => {
      e.cancelBubble = true;
    });
    back.on("dragmove", (e) => {
      e.cancelBubble = true;
    });
    back.on("dragend", (e) => {
      e.cancelBubble = true;
    });
    this.on("dragmove", (e) => {
      this.update();
    });
  }
  _handleMouseDown(e) {
    if (this._transforming) {
      return;
    }
    this._movingAnchorName = e.target.name().split(" ")[0];
    const attrs = this._getNodeRect();
    const width = attrs.width;
    const height = attrs.height;
    const hypotenuse = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
    this.sin = Math.abs(height / hypotenuse);
    this.cos = Math.abs(width / hypotenuse);
    if (typeof window !== "undefined") {
      window.addEventListener("mousemove", this._handleMouseMove);
      window.addEventListener("touchmove", this._handleMouseMove);
      window.addEventListener("mouseup", this._handleMouseUp, true);
      window.addEventListener("touchend", this._handleMouseUp, true);
    }
    this._transforming = true;
    const ap = e.target.getAbsolutePosition();
    const pos = e.target.getStage().getPointerPosition();
    this._anchorDragOffset = {
      x: pos.x - ap.x,
      y: pos.y - ap.y
    };
    activeTransformersCount++;
    this._fire("transformstart", { evt: e.evt, target: this.getNode() });
    this._nodes.forEach((target) => {
      target._fire("transformstart", { evt: e.evt, target });
    });
  }
  _handleMouseMove(e) {
    let x, y, newHypotenuse;
    const anchorNode = this.findOne("." + this._movingAnchorName);
    const stage = anchorNode.getStage();
    stage.setPointersPositions(e);
    const pp = stage.getPointerPosition();
    let newNodePos = {
      x: pp.x - this._anchorDragOffset.x,
      y: pp.y - this._anchorDragOffset.y
    };
    const oldAbs = anchorNode.getAbsolutePosition();
    if (this.anchorDragBoundFunc()) {
      newNodePos = this.anchorDragBoundFunc()(oldAbs, newNodePos, e);
    }
    anchorNode.setAbsolutePosition(newNodePos);
    const newAbs = anchorNode.getAbsolutePosition();
    if (oldAbs.x === newAbs.x && oldAbs.y === newAbs.y) {
      return;
    }
    if (this._movingAnchorName === "rotater") {
      const attrs = this._getNodeRect();
      x = anchorNode.x() - attrs.width / 2;
      y = -anchorNode.y() + attrs.height / 2;
      let delta = Math.atan2(-y, x) + Math.PI / 2;
      if (attrs.height < 0) {
        delta -= Math.PI;
      }
      const oldRotation = Konva.getAngle(this.rotation());
      const newRotation = oldRotation + delta;
      const tol = Konva.getAngle(this.rotationSnapTolerance());
      const snappedRot = getSnap(this.rotationSnaps(), newRotation, tol);
      const diff = snappedRot - attrs.rotation;
      const shape = rotateAroundCenter(attrs, diff);
      this._fitNodesInto(shape, e);
      return;
    }
    const shiftBehavior = this.shiftBehavior();
    let keepProportion;
    if (shiftBehavior === "inverted") {
      keepProportion = this.keepRatio() && !e.shiftKey;
    } else if (shiftBehavior === "none") {
      keepProportion = this.keepRatio();
    } else {
      keepProportion = this.keepRatio() || e.shiftKey;
    }
    let centeredScaling = this.centeredScaling() || e.altKey;
    if (this._movingAnchorName === "top-left") {
      if (keepProportion) {
        const comparePoint = centeredScaling ? {
          x: this.width() / 2,
          y: this.height() / 2
        } : {
          x: this.findOne(".bottom-right").x(),
          y: this.findOne(".bottom-right").y()
        };
        newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) + Math.pow(comparePoint.y - anchorNode.y(), 2));
        const reverseX = this.findOne(".top-left").x() > comparePoint.x ? -1 : 1;
        const reverseY = this.findOne(".top-left").y() > comparePoint.y ? -1 : 1;
        x = newHypotenuse * this.cos * reverseX;
        y = newHypotenuse * this.sin * reverseY;
        this.findOne(".top-left").x(comparePoint.x - x);
        this.findOne(".top-left").y(comparePoint.y - y);
      }
    } else if (this._movingAnchorName === "top-center") {
      this.findOne(".top-left").y(anchorNode.y());
    } else if (this._movingAnchorName === "top-right") {
      if (keepProportion) {
        const comparePoint = centeredScaling ? {
          x: this.width() / 2,
          y: this.height() / 2
        } : {
          x: this.findOne(".bottom-left").x(),
          y: this.findOne(".bottom-left").y()
        };
        newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) + Math.pow(comparePoint.y - anchorNode.y(), 2));
        const reverseX = this.findOne(".top-right").x() < comparePoint.x ? -1 : 1;
        const reverseY = this.findOne(".top-right").y() > comparePoint.y ? -1 : 1;
        x = newHypotenuse * this.cos * reverseX;
        y = newHypotenuse * this.sin * reverseY;
        this.findOne(".top-right").x(comparePoint.x + x);
        this.findOne(".top-right").y(comparePoint.y - y);
      }
      var pos = anchorNode.position();
      this.findOne(".top-left").y(pos.y);
      this.findOne(".bottom-right").x(pos.x);
    } else if (this._movingAnchorName === "middle-left") {
      this.findOne(".top-left").x(anchorNode.x());
    } else if (this._movingAnchorName === "middle-right") {
      this.findOne(".bottom-right").x(anchorNode.x());
    } else if (this._movingAnchorName === "bottom-left") {
      if (keepProportion) {
        const comparePoint = centeredScaling ? {
          x: this.width() / 2,
          y: this.height() / 2
        } : {
          x: this.findOne(".top-right").x(),
          y: this.findOne(".top-right").y()
        };
        newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) + Math.pow(anchorNode.y() - comparePoint.y, 2));
        const reverseX = comparePoint.x < anchorNode.x() ? -1 : 1;
        const reverseY = anchorNode.y() < comparePoint.y ? -1 : 1;
        x = newHypotenuse * this.cos * reverseX;
        y = newHypotenuse * this.sin * reverseY;
        anchorNode.x(comparePoint.x - x);
        anchorNode.y(comparePoint.y + y);
      }
      pos = anchorNode.position();
      this.findOne(".top-left").x(pos.x);
      this.findOne(".bottom-right").y(pos.y);
    } else if (this._movingAnchorName === "bottom-center") {
      this.findOne(".bottom-right").y(anchorNode.y());
    } else if (this._movingAnchorName === "bottom-right") {
      if (keepProportion) {
        const comparePoint = centeredScaling ? {
          x: this.width() / 2,
          y: this.height() / 2
        } : {
          x: this.findOne(".top-left").x(),
          y: this.findOne(".top-left").y()
        };
        newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) + Math.pow(anchorNode.y() - comparePoint.y, 2));
        const reverseX = this.findOne(".bottom-right").x() < comparePoint.x ? -1 : 1;
        const reverseY = this.findOne(".bottom-right").y() < comparePoint.y ? -1 : 1;
        x = newHypotenuse * this.cos * reverseX;
        y = newHypotenuse * this.sin * reverseY;
        this.findOne(".bottom-right").x(comparePoint.x + x);
        this.findOne(".bottom-right").y(comparePoint.y + y);
      }
    } else {
      console.error(new Error("Wrong position argument of selection resizer: " + this._movingAnchorName));
    }
    centeredScaling = this.centeredScaling() || e.altKey;
    if (centeredScaling) {
      const topLeft = this.findOne(".top-left");
      const bottomRight = this.findOne(".bottom-right");
      const topOffsetX = topLeft.x();
      const topOffsetY = topLeft.y();
      const bottomOffsetX = this.getWidth() - bottomRight.x();
      const bottomOffsetY = this.getHeight() - bottomRight.y();
      bottomRight.move({
        x: -topOffsetX,
        y: -topOffsetY
      });
      topLeft.move({
        x: bottomOffsetX,
        y: bottomOffsetY
      });
    }
    const absPos = this.findOne(".top-left").getAbsolutePosition();
    x = absPos.x;
    y = absPos.y;
    const width = this.findOne(".bottom-right").x() - this.findOne(".top-left").x();
    const height = this.findOne(".bottom-right").y() - this.findOne(".top-left").y();
    this._fitNodesInto({
      x,
      y,
      width,
      height,
      rotation: Konva.getAngle(this.rotation())
    }, e);
  }
  _handleMouseUp(e) {
    this._removeEvents(e);
  }
  getAbsoluteTransform() {
    return this.getTransform();
  }
  _removeEvents(e) {
    var _a;
    if (this._transforming) {
      this._transforming = false;
      if (typeof window !== "undefined") {
        window.removeEventListener("mousemove", this._handleMouseMove);
        window.removeEventListener("touchmove", this._handleMouseMove);
        window.removeEventListener("mouseup", this._handleMouseUp, true);
        window.removeEventListener("touchend", this._handleMouseUp, true);
      }
      const node = this.getNode();
      activeTransformersCount--;
      this._fire("transformend", { evt: e, target: node });
      (_a = this.getLayer()) === null || _a === undefined || _a.batchDraw();
      if (node) {
        this._nodes.forEach((target) => {
          var _a2;
          target._fire("transformend", { evt: e, target });
          (_a2 = target.getLayer()) === null || _a2 === undefined || _a2.batchDraw();
        });
      }
      this._movingAnchorName = null;
    }
  }
  _fitNodesInto(newAttrs, evt) {
    const oldAttrs = this._getNodeRect();
    const minSize = 1;
    if (Util._inRange(newAttrs.width, -this.padding() * 2 - minSize, minSize)) {
      this.update();
      return;
    }
    if (Util._inRange(newAttrs.height, -this.padding() * 2 - minSize, minSize)) {
      this.update();
      return;
    }
    const t = new Transform;
    t.rotate(Konva.getAngle(this.rotation()));
    if (this._movingAnchorName && newAttrs.width < 0 && this._movingAnchorName.indexOf("left") >= 0) {
      const offset = t.point({
        x: -this.padding() * 2,
        y: 0
      });
      newAttrs.x += offset.x;
      newAttrs.y += offset.y;
      newAttrs.width += this.padding() * 2;
      this._movingAnchorName = this._movingAnchorName.replace("left", "right");
      this._anchorDragOffset.x -= offset.x;
      this._anchorDragOffset.y -= offset.y;
    } else if (this._movingAnchorName && newAttrs.width < 0 && this._movingAnchorName.indexOf("right") >= 0) {
      const offset = t.point({
        x: this.padding() * 2,
        y: 0
      });
      this._movingAnchorName = this._movingAnchorName.replace("right", "left");
      this._anchorDragOffset.x -= offset.x;
      this._anchorDragOffset.y -= offset.y;
      newAttrs.width += this.padding() * 2;
    }
    if (this._movingAnchorName && newAttrs.height < 0 && this._movingAnchorName.indexOf("top") >= 0) {
      const offset = t.point({
        x: 0,
        y: -this.padding() * 2
      });
      newAttrs.x += offset.x;
      newAttrs.y += offset.y;
      this._movingAnchorName = this._movingAnchorName.replace("top", "bottom");
      this._anchorDragOffset.x -= offset.x;
      this._anchorDragOffset.y -= offset.y;
      newAttrs.height += this.padding() * 2;
    } else if (this._movingAnchorName && newAttrs.height < 0 && this._movingAnchorName.indexOf("bottom") >= 0) {
      const offset = t.point({
        x: 0,
        y: this.padding() * 2
      });
      this._movingAnchorName = this._movingAnchorName.replace("bottom", "top");
      this._anchorDragOffset.x -= offset.x;
      this._anchorDragOffset.y -= offset.y;
      newAttrs.height += this.padding() * 2;
    }
    if (this.boundBoxFunc()) {
      const bounded = this.boundBoxFunc()(oldAttrs, newAttrs);
      if (bounded) {
        newAttrs = bounded;
      } else {
        Util.warn("boundBoxFunc returned falsy. You should return new bound rect from it!");
      }
    }
    const baseSize = 1e7;
    const oldTr = new Transform;
    oldTr.translate(oldAttrs.x, oldAttrs.y);
    oldTr.rotate(oldAttrs.rotation);
    oldTr.scale(oldAttrs.width / baseSize, oldAttrs.height / baseSize);
    const newTr = new Transform;
    const newScaleX = newAttrs.width / baseSize;
    const newScaleY = newAttrs.height / baseSize;
    if (this.flipEnabled() === false) {
      newTr.translate(newAttrs.x, newAttrs.y);
      newTr.rotate(newAttrs.rotation);
      newTr.translate(newAttrs.width < 0 ? newAttrs.width : 0, newAttrs.height < 0 ? newAttrs.height : 0);
      newTr.scale(Math.abs(newScaleX), Math.abs(newScaleY));
    } else {
      newTr.translate(newAttrs.x, newAttrs.y);
      newTr.rotate(newAttrs.rotation);
      newTr.scale(newScaleX, newScaleY);
    }
    const delta = newTr.multiply(oldTr.invert());
    this._nodes.forEach((node) => {
      var _a;
      if (!node.getStage()) {
        return;
      }
      const parentTransform = node.getParent().getAbsoluteTransform();
      const localTransform = node.getTransform().copy();
      localTransform.translate(node.offsetX(), node.offsetY());
      const newLocalTransform = new Transform;
      newLocalTransform.multiply(parentTransform.copy().invert()).multiply(delta).multiply(parentTransform).multiply(localTransform);
      const attrs = newLocalTransform.decompose();
      node.setAttrs(attrs);
      (_a = node.getLayer()) === null || _a === undefined || _a.batchDraw();
    });
    this.rotation(Util._getRotation(newAttrs.rotation));
    this._nodes.forEach((node) => {
      this._fire("transform", { evt, target: node });
      node._fire("transform", { evt, target: node });
    });
    this._resetTransformCache();
    this.update();
    this.getLayer().batchDraw();
  }
  forceUpdate() {
    this._resetTransformCache();
    this.update();
  }
  _batchChangeChild(selector, attrs) {
    const anchor = this.findOne(selector);
    anchor.setAttrs(attrs);
  }
  update() {
    var _a;
    const attrs = this._getNodeRect();
    this.rotation(Util._getRotation(attrs.rotation));
    const width = attrs.width;
    const height = attrs.height;
    const enabledAnchors = this.enabledAnchors();
    const resizeEnabled = this.resizeEnabled();
    const padding = this.padding();
    const anchorSize = this.anchorSize();
    const anchors = this.find("._anchor");
    anchors.forEach((node) => {
      node.setAttrs({
        width: anchorSize,
        height: anchorSize,
        offsetX: anchorSize / 2,
        offsetY: anchorSize / 2,
        stroke: this.anchorStroke(),
        strokeWidth: this.anchorStrokeWidth(),
        fill: this.anchorFill(),
        cornerRadius: this.anchorCornerRadius()
      });
    });
    this._batchChangeChild(".top-left", {
      x: 0,
      y: 0,
      offsetX: anchorSize / 2 + padding,
      offsetY: anchorSize / 2 + padding,
      visible: resizeEnabled && enabledAnchors.indexOf("top-left") >= 0
    });
    this._batchChangeChild(".top-center", {
      x: width / 2,
      y: 0,
      offsetY: anchorSize / 2 + padding,
      visible: resizeEnabled && enabledAnchors.indexOf("top-center") >= 0
    });
    this._batchChangeChild(".top-right", {
      x: width,
      y: 0,
      offsetX: anchorSize / 2 - padding,
      offsetY: anchorSize / 2 + padding,
      visible: resizeEnabled && enabledAnchors.indexOf("top-right") >= 0
    });
    this._batchChangeChild(".middle-left", {
      x: 0,
      y: height / 2,
      offsetX: anchorSize / 2 + padding,
      visible: resizeEnabled && enabledAnchors.indexOf("middle-left") >= 0
    });
    this._batchChangeChild(".middle-right", {
      x: width,
      y: height / 2,
      offsetX: anchorSize / 2 - padding,
      visible: resizeEnabled && enabledAnchors.indexOf("middle-right") >= 0
    });
    this._batchChangeChild(".bottom-left", {
      x: 0,
      y: height,
      offsetX: anchorSize / 2 + padding,
      offsetY: anchorSize / 2 - padding,
      visible: resizeEnabled && enabledAnchors.indexOf("bottom-left") >= 0
    });
    this._batchChangeChild(".bottom-center", {
      x: width / 2,
      y: height,
      offsetY: anchorSize / 2 - padding,
      visible: resizeEnabled && enabledAnchors.indexOf("bottom-center") >= 0
    });
    this._batchChangeChild(".bottom-right", {
      x: width,
      y: height,
      offsetX: anchorSize / 2 - padding,
      offsetY: anchorSize / 2 - padding,
      visible: resizeEnabled && enabledAnchors.indexOf("bottom-right") >= 0
    });
    this._batchChangeChild(".rotater", {
      x: width / 2,
      y: -this.rotateAnchorOffset() * Util._sign(height) - padding,
      visible: this.rotateEnabled()
    });
    this._batchChangeChild(".back", {
      width,
      height,
      visible: this.borderEnabled(),
      stroke: this.borderStroke(),
      strokeWidth: this.borderStrokeWidth(),
      dash: this.borderDash(),
      draggable: this.nodes().some((node) => node.draggable()),
      x: 0,
      y: 0
    });
    const styleFunc = this.anchorStyleFunc();
    if (styleFunc) {
      anchors.forEach((node) => {
        styleFunc(node);
      });
    }
    (_a = this.getLayer()) === null || _a === undefined || _a.batchDraw();
  }
  isTransforming() {
    return this._transforming;
  }
  stopTransform() {
    if (this._transforming) {
      this._removeEvents();
      const anchorNode = this.findOne("." + this._movingAnchorName);
      if (anchorNode) {
        anchorNode.stopDrag();
      }
    }
  }
  destroy() {
    if (this.getStage() && this._cursorChange) {
      this.getStage().content && (this.getStage().content.style.cursor = "");
    }
    Group.prototype.destroy.call(this);
    this.detach();
    this._removeEvents();
    return this;
  }
  toObject() {
    return Node2.prototype.toObject.call(this);
  }
  clone(obj) {
    const node = Node2.prototype.clone.call(this, obj);
    return node;
  }
  getClientRect() {
    if (this.nodes().length > 0) {
      return super.getClientRect();
    } else {
      return { x: 0, y: 0, width: 0, height: 0 };
    }
  }
}
Transformer.isTransforming = () => {
  return activeTransformersCount > 0;
};
function validateAnchors(val) {
  if (!(val instanceof Array)) {
    Util.warn("enabledAnchors value should be an array");
  }
  if (val instanceof Array) {
    val.forEach(function(name) {
      if (ANCHORS_NAMES.indexOf(name) === -1) {
        Util.warn("Unknown anchor name: " + name + ". Available names are: " + ANCHORS_NAMES.join(", "));
      }
    });
  }
  return val || [];
}
Transformer.prototype.className = "Transformer";
_registerNode(Transformer);
Factory.addGetterSetter(Transformer, "enabledAnchors", ANCHORS_NAMES, validateAnchors);
Factory.addGetterSetter(Transformer, "flipEnabled", true, getBooleanValidator());
Factory.addGetterSetter(Transformer, "resizeEnabled", true);
Factory.addGetterSetter(Transformer, "anchorSize", 10, getNumberValidator());
Factory.addGetterSetter(Transformer, "rotateEnabled", true);
Factory.addGetterSetter(Transformer, "rotateLineVisible", true);
Factory.addGetterSetter(Transformer, "rotationSnaps", []);
Factory.addGetterSetter(Transformer, "rotateAnchorOffset", 50, getNumberValidator());
Factory.addGetterSetter(Transformer, "rotateAnchorCursor", "crosshair");
Factory.addGetterSetter(Transformer, "rotationSnapTolerance", 5, getNumberValidator());
Factory.addGetterSetter(Transformer, "borderEnabled", true);
Factory.addGetterSetter(Transformer, "anchorStroke", "rgb(0, 161, 255)");
Factory.addGetterSetter(Transformer, "anchorStrokeWidth", 1, getNumberValidator());
Factory.addGetterSetter(Transformer, "anchorFill", "white");
Factory.addGetterSetter(Transformer, "anchorCornerRadius", 0, getNumberValidator());
Factory.addGetterSetter(Transformer, "borderStroke", "rgb(0, 161, 255)");
Factory.addGetterSetter(Transformer, "borderStrokeWidth", 1, getNumberValidator());
Factory.addGetterSetter(Transformer, "borderDash");
Factory.addGetterSetter(Transformer, "keepRatio", true);
Factory.addGetterSetter(Transformer, "shiftBehavior", "default");
Factory.addGetterSetter(Transformer, "centeredScaling", false);
Factory.addGetterSetter(Transformer, "ignoreStroke", false);
Factory.addGetterSetter(Transformer, "padding", 0, getNumberValidator());
Factory.addGetterSetter(Transformer, "nodes");
Factory.addGetterSetter(Transformer, "node");
Factory.addGetterSetter(Transformer, "boundBoxFunc");
Factory.addGetterSetter(Transformer, "anchorDragBoundFunc");
Factory.addGetterSetter(Transformer, "anchorStyleFunc");
Factory.addGetterSetter(Transformer, "shouldOverdrawWholeArea", false);
Factory.addGetterSetter(Transformer, "useSingleNodeRotation", true);
Factory.backCompat(Transformer, {
  lineEnabled: "borderEnabled",
  rotateHandlerOffset: "rotateAnchorOffset",
  enabledHandlers: "enabledAnchors"
});

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/shapes/Wedge.js
class Wedge extends Shape {
  _sceneFunc(context) {
    context.beginPath();
    context.arc(0, 0, this.radius(), 0, Konva.getAngle(this.angle()), this.clockwise());
    context.lineTo(0, 0);
    context.closePath();
    context.fillStrokeShape(this);
  }
  getWidth() {
    return this.radius() * 2;
  }
  getHeight() {
    return this.radius() * 2;
  }
  setWidth(width) {
    this.radius(width / 2);
  }
  setHeight(height) {
    this.radius(height / 2);
  }
}
Wedge.prototype.className = "Wedge";
Wedge.prototype._centroid = true;
Wedge.prototype._attrsAffectingSize = ["radius"];
_registerNode(Wedge);
Factory.addGetterSetter(Wedge, "radius", 0, getNumberValidator());
Factory.addGetterSetter(Wedge, "angle", 0, getNumberValidator());
Factory.addGetterSetter(Wedge, "clockwise", false);
Factory.backCompat(Wedge, {
  angleDeg: "angle",
  getAngleDeg: "getAngle",
  setAngleDeg: "setAngle"
});

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/Blur.js
function BlurStack() {
  this.r = 0;
  this.g = 0;
  this.b = 0;
  this.a = 0;
  this.next = null;
}
var mul_table = [
  512,
  512,
  456,
  512,
  328,
  456,
  335,
  512,
  405,
  328,
  271,
  456,
  388,
  335,
  292,
  512,
  454,
  405,
  364,
  328,
  298,
  271,
  496,
  456,
  420,
  388,
  360,
  335,
  312,
  292,
  273,
  512,
  482,
  454,
  428,
  405,
  383,
  364,
  345,
  328,
  312,
  298,
  284,
  271,
  259,
  496,
  475,
  456,
  437,
  420,
  404,
  388,
  374,
  360,
  347,
  335,
  323,
  312,
  302,
  292,
  282,
  273,
  265,
  512,
  497,
  482,
  468,
  454,
  441,
  428,
  417,
  405,
  394,
  383,
  373,
  364,
  354,
  345,
  337,
  328,
  320,
  312,
  305,
  298,
  291,
  284,
  278,
  271,
  265,
  259,
  507,
  496,
  485,
  475,
  465,
  456,
  446,
  437,
  428,
  420,
  412,
  404,
  396,
  388,
  381,
  374,
  367,
  360,
  354,
  347,
  341,
  335,
  329,
  323,
  318,
  312,
  307,
  302,
  297,
  292,
  287,
  282,
  278,
  273,
  269,
  265,
  261,
  512,
  505,
  497,
  489,
  482,
  475,
  468,
  461,
  454,
  447,
  441,
  435,
  428,
  422,
  417,
  411,
  405,
  399,
  394,
  389,
  383,
  378,
  373,
  368,
  364,
  359,
  354,
  350,
  345,
  341,
  337,
  332,
  328,
  324,
  320,
  316,
  312,
  309,
  305,
  301,
  298,
  294,
  291,
  287,
  284,
  281,
  278,
  274,
  271,
  268,
  265,
  262,
  259,
  257,
  507,
  501,
  496,
  491,
  485,
  480,
  475,
  470,
  465,
  460,
  456,
  451,
  446,
  442,
  437,
  433,
  428,
  424,
  420,
  416,
  412,
  408,
  404,
  400,
  396,
  392,
  388,
  385,
  381,
  377,
  374,
  370,
  367,
  363,
  360,
  357,
  354,
  350,
  347,
  344,
  341,
  338,
  335,
  332,
  329,
  326,
  323,
  320,
  318,
  315,
  312,
  310,
  307,
  304,
  302,
  299,
  297,
  294,
  292,
  289,
  287,
  285,
  282,
  280,
  278,
  275,
  273,
  271,
  269,
  267,
  265,
  263,
  261,
  259
];
var shg_table = [
  9,
  11,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24
];
function filterGaussBlurRGBA(imageData, radius) {
  const { data: pixels, width, height } = imageData;
  let p, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr, pg, pb, pa, rbs;
  const div = radius + radius + 1, widthMinus1 = width - 1, heightMinus1 = height - 1, radiusPlus1 = radius + 1, sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2, stackStart = new BlurStack, mul_sum = mul_table[radius], shg_sum = shg_table[radius];
  let stackEnd = null, stack = stackStart, stackIn = null, stackOut = null;
  for (let i = 1;i < div; i++) {
    stack = stack.next = new BlurStack;
    if (i === radiusPlus1) {
      stackEnd = stack;
    }
  }
  stack.next = stackStart;
  yw = yi = 0;
  for (let y = 0;y < height; y++) {
    r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
    a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    a_sum += sumFactor * pa;
    stack = stackStart;
    for (let i = 0;i < radiusPlus1; i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }
    for (let i = 1;i < radiusPlus1; i++) {
      p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
      r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
      b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
      a_sum += (stack.a = pa = pixels[p + 3]) * rbs;
      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      a_in_sum += pa;
      stack = stack.next;
    }
    stackIn = stackStart;
    stackOut = stackEnd;
    for (let x = 0;x < width; x++) {
      pixels[yi + 3] = pa = a_sum * mul_sum >> shg_sum;
      if (pa !== 0) {
        pa = 255 / pa;
        pixels[yi] = (r_sum * mul_sum >> shg_sum) * pa;
        pixels[yi + 1] = (g_sum * mul_sum >> shg_sum) * pa;
        pixels[yi + 2] = (b_sum * mul_sum >> shg_sum) * pa;
      } else {
        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
      }
      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      a_sum -= a_out_sum;
      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      a_out_sum -= stackIn.a;
      p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;
      r_in_sum += stackIn.r = pixels[p];
      g_in_sum += stackIn.g = pixels[p + 1];
      b_in_sum += stackIn.b = pixels[p + 2];
      a_in_sum += stackIn.a = pixels[p + 3];
      r_sum += r_in_sum;
      g_sum += g_in_sum;
      b_sum += b_in_sum;
      a_sum += a_in_sum;
      stackIn = stackIn.next;
      r_out_sum += pr = stackOut.r;
      g_out_sum += pg = stackOut.g;
      b_out_sum += pb = stackOut.b;
      a_out_sum += pa = stackOut.a;
      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      a_in_sum -= pa;
      stackOut = stackOut.next;
      yi += 4;
    }
    yw += width;
  }
  for (let x = 0;x < width; x++) {
    g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
    yi = x << 2;
    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
    a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    a_sum += sumFactor * pa;
    stack = stackStart;
    for (let i = 0;i < radiusPlus1; i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }
    let yp = width;
    for (let i = 1;i <= radius; i++) {
      yi = yp + x << 2;
      r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
      b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
      a_sum += (stack.a = pa = pixels[yi + 3]) * rbs;
      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      a_in_sum += pa;
      stack = stack.next;
      if (i < heightMinus1) {
        yp += width;
      }
    }
    yi = x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (let y = 0;y < height; y++) {
      p = yi << 2;
      pixels[p + 3] = pa = a_sum * mul_sum >> shg_sum;
      if (pa > 0) {
        pa = 255 / pa;
        pixels[p] = (r_sum * mul_sum >> shg_sum) * pa;
        pixels[p + 1] = (g_sum * mul_sum >> shg_sum) * pa;
        pixels[p + 2] = (b_sum * mul_sum >> shg_sum) * pa;
      } else {
        pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
      }
      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      a_sum -= a_out_sum;
      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      a_out_sum -= stackIn.a;
      p = x + ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;
      r_sum += r_in_sum += stackIn.r = pixels[p];
      g_sum += g_in_sum += stackIn.g = pixels[p + 1];
      b_sum += b_in_sum += stackIn.b = pixels[p + 2];
      a_sum += a_in_sum += stackIn.a = pixels[p + 3];
      stackIn = stackIn.next;
      r_out_sum += pr = stackOut.r;
      g_out_sum += pg = stackOut.g;
      b_out_sum += pb = stackOut.b;
      a_out_sum += pa = stackOut.a;
      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      a_in_sum -= pa;
      stackOut = stackOut.next;
      yi += width;
    }
  }
}
var Blur = function Blur2(imageData) {
  const radius = Math.round(this.blurRadius());
  if (radius > 0) {
    filterGaussBlurRGBA(imageData, radius);
  }
};
Factory.addGetterSetter(Node2, "blurRadius", 0, getNumberValidator(), Factory.afterSetFilter);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/Brighten.js
var Brighten = function(imageData) {
  const brightness = this.brightness() * 255, data = imageData.data, len = data.length;
  for (let i = 0;i < len; i += 4) {
    data[i] += brightness;
    data[i + 1] += brightness;
    data[i + 2] += brightness;
  }
};
Factory.addGetterSetter(Node2, "brightness", 0, getNumberValidator(), Factory.afterSetFilter);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/Brightness.js
var Brightness = function(imageData) {
  const brightness = this.brightness(), data = imageData.data, len = data.length;
  for (let i = 0;i < len; i += 4) {
    data[i] = Math.min(255, data[i] * brightness);
    data[i + 1] = Math.min(255, data[i + 1] * brightness);
    data[i + 2] = Math.min(255, data[i + 2] * brightness);
  }
};

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/Contrast.js
var Contrast = function(imageData) {
  const adjust = Math.pow((this.contrast() + 100) / 100, 2);
  const data = imageData.data, nPixels = data.length;
  let red = 150, green = 150, blue = 150;
  for (let i = 0;i < nPixels; i += 4) {
    red = data[i];
    green = data[i + 1];
    blue = data[i + 2];
    red /= 255;
    red -= 0.5;
    red *= adjust;
    red += 0.5;
    red *= 255;
    green /= 255;
    green -= 0.5;
    green *= adjust;
    green += 0.5;
    green *= 255;
    blue /= 255;
    blue -= 0.5;
    blue *= adjust;
    blue += 0.5;
    blue *= 255;
    red = red < 0 ? 0 : red > 255 ? 255 : red;
    green = green < 0 ? 0 : green > 255 ? 255 : green;
    blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;
    data[i] = red;
    data[i + 1] = green;
    data[i + 2] = blue;
  }
};
Factory.addGetterSetter(Node2, "contrast", 0, getNumberValidator(), Factory.afterSetFilter);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/Emboss.js
var Emboss = function(imageData) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j;
  const data = imageData.data;
  const w = imageData.width;
  const h = imageData.height;
  const strength01 = Math.min(1, Math.max(0, (_b = (_a = this.embossStrength) === null || _a === undefined ? undefined : _a.call(this)) !== null && _b !== undefined ? _b : 0.5));
  const whiteLevel01 = Math.min(1, Math.max(0, (_d = (_c = this.embossWhiteLevel) === null || _c === undefined ? undefined : _c.call(this)) !== null && _d !== undefined ? _d : 0.5));
  const directionMap = {
    "top-left": 315,
    top: 270,
    "top-right": 225,
    right: 180,
    "bottom-right": 135,
    bottom: 90,
    "bottom-left": 45,
    left: 0
  };
  const directionDeg = (_g = directionMap[(_f = (_e = this.embossDirection) === null || _e === undefined ? undefined : _e.call(this)) !== null && _f !== undefined ? _f : "top-left"]) !== null && _g !== undefined ? _g : 315;
  const blend = !!((_j = (_h = this.embossBlend) === null || _h === undefined ? undefined : _h.call(this)) !== null && _j !== undefined ? _j : false);
  const strength = strength01 * 10;
  const bias = whiteLevel01 * 255;
  const dirRad = directionDeg * Math.PI / 180;
  const cx = Math.cos(dirRad);
  const cy = Math.sin(dirRad);
  const SCALE = 128 / 1020 * strength;
  const src = new Uint8ClampedArray(data);
  const lum = new Float32Array(w * h);
  for (let p = 0, i = 0;i < data.length; i += 4, p++) {
    lum[p] = 0.2126 * src[i] + 0.7152 * src[i + 1] + 0.0722 * src[i + 2];
  }
  const Gx = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
  const Gy = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
  const OFF = [-w - 1, -w, -w + 1, -1, 0, 1, w - 1, w, w + 1];
  const clamp8 = (v) => v < 0 ? 0 : v > 255 ? 255 : v;
  for (let y = 1;y < h - 1; y++) {
    for (let x = 1;x < w - 1; x++) {
      const p = y * w + x;
      let sx = 0, sy = 0;
      sx += lum[p + OFF[0]] * Gx[0];
      sy += lum[p + OFF[0]] * Gy[0];
      sx += lum[p + OFF[1]] * Gx[1];
      sy += lum[p + OFF[1]] * Gy[1];
      sx += lum[p + OFF[2]] * Gx[2];
      sy += lum[p + OFF[2]] * Gy[2];
      sx += lum[p + OFF[3]] * Gx[3];
      sy += lum[p + OFF[3]] * Gy[3];
      sx += lum[p + OFF[5]] * Gx[5];
      sy += lum[p + OFF[5]] * Gy[5];
      sx += lum[p + OFF[6]] * Gx[6];
      sy += lum[p + OFF[6]] * Gy[6];
      sx += lum[p + OFF[7]] * Gx[7];
      sy += lum[p + OFF[7]] * Gy[7];
      sx += lum[p + OFF[8]] * Gx[8];
      sy += lum[p + OFF[8]] * Gy[8];
      const r = cx * sx + cy * sy;
      const outGray = clamp8(bias + r * SCALE);
      const o = p * 4;
      if (blend) {
        const delta = outGray - bias;
        data[o] = clamp8(src[o] + delta);
        data[o + 1] = clamp8(src[o + 1] + delta);
        data[o + 2] = clamp8(src[o + 2] + delta);
        data[o + 3] = src[o + 3];
      } else {
        data[o] = data[o + 1] = data[o + 2] = outGray;
        data[o + 3] = src[o + 3];
      }
    }
  }
  for (let x = 0;x < w; x++) {
    let oTop = x * 4, oBot = ((h - 1) * w + x) * 4;
    data[oTop] = src[oTop];
    data[oTop + 1] = src[oTop + 1];
    data[oTop + 2] = src[oTop + 2];
    data[oTop + 3] = src[oTop + 3];
    data[oBot] = src[oBot];
    data[oBot + 1] = src[oBot + 1];
    data[oBot + 2] = src[oBot + 2];
    data[oBot + 3] = src[oBot + 3];
  }
  for (let y = 1;y < h - 1; y++) {
    let oL = y * w * 4, oR = (y * w + (w - 1)) * 4;
    data[oL] = src[oL];
    data[oL + 1] = src[oL + 1];
    data[oL + 2] = src[oL + 2];
    data[oL + 3] = src[oL + 3];
    data[oR] = src[oR];
    data[oR + 1] = src[oR + 1];
    data[oR + 2] = src[oR + 2];
    data[oR + 3] = src[oR + 3];
  }
  return imageData;
};
Factory.addGetterSetter(Node2, "embossStrength", 0.5, getNumberValidator(), Factory.afterSetFilter);
Factory.addGetterSetter(Node2, "embossWhiteLevel", 0.5, getNumberValidator(), Factory.afterSetFilter);
Factory.addGetterSetter(Node2, "embossDirection", "top-left", undefined, Factory.afterSetFilter);
Factory.addGetterSetter(Node2, "embossBlend", false, undefined, Factory.afterSetFilter);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/Enhance.js
function remap(fromValue, fromMin, fromMax, toMin, toMax) {
  const fromRange = fromMax - fromMin, toRange = toMax - toMin;
  if (fromRange === 0) {
    return toMin + toRange / 2;
  }
  if (toRange === 0) {
    return toMin;
  }
  let toValue = (fromValue - fromMin) / fromRange;
  toValue = toRange * toValue + toMin;
  return toValue;
}
var Enhance = function(imageData) {
  const data = imageData.data, nSubPixels = data.length;
  let rMin = data[0], rMax = rMin, r, gMin = data[1], gMax = gMin, g, bMin = data[2], bMax = bMin, b;
  const enhanceAmount = this.enhance();
  if (enhanceAmount === 0) {
    return;
  }
  for (let i = 0;i < nSubPixels; i += 4) {
    r = data[i + 0];
    if (r < rMin) {
      rMin = r;
    } else if (r > rMax) {
      rMax = r;
    }
    g = data[i + 1];
    if (g < gMin) {
      gMin = g;
    } else if (g > gMax) {
      gMax = g;
    }
    b = data[i + 2];
    if (b < bMin) {
      bMin = b;
    } else if (b > bMax) {
      bMax = b;
    }
  }
  if (rMax === rMin) {
    rMax = 255;
    rMin = 0;
  }
  if (gMax === gMin) {
    gMax = 255;
    gMin = 0;
  }
  if (bMax === bMin) {
    bMax = 255;
    bMin = 0;
  }
  let rGoalMax, rGoalMin, gGoalMax, gGoalMin, bGoalMax, bGoalMin;
  if (enhanceAmount > 0) {
    rGoalMax = rMax + enhanceAmount * (255 - rMax);
    rGoalMin = rMin - enhanceAmount * (rMin - 0);
    gGoalMax = gMax + enhanceAmount * (255 - gMax);
    gGoalMin = gMin - enhanceAmount * (gMin - 0);
    bGoalMax = bMax + enhanceAmount * (255 - bMax);
    bGoalMin = bMin - enhanceAmount * (bMin - 0);
  } else {
    const rMid = (rMax + rMin) * 0.5;
    rGoalMax = rMax + enhanceAmount * (rMax - rMid);
    rGoalMin = rMin + enhanceAmount * (rMin - rMid);
    const gMid = (gMax + gMin) * 0.5;
    gGoalMax = gMax + enhanceAmount * (gMax - gMid);
    gGoalMin = gMin + enhanceAmount * (gMin - gMid);
    const bMid = (bMax + bMin) * 0.5;
    bGoalMax = bMax + enhanceAmount * (bMax - bMid);
    bGoalMin = bMin + enhanceAmount * (bMin - bMid);
  }
  for (let i = 0;i < nSubPixels; i += 4) {
    data[i + 0] = remap(data[i + 0], rMin, rMax, rGoalMin, rGoalMax);
    data[i + 1] = remap(data[i + 1], gMin, gMax, gGoalMin, gGoalMax);
    data[i + 2] = remap(data[i + 2], bMin, bMax, bGoalMin, bGoalMax);
  }
};
Factory.addGetterSetter(Node2, "enhance", 0, getNumberValidator(), Factory.afterSetFilter);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/Grayscale.js
var Grayscale = function(imageData) {
  const data = imageData.data, len = data.length;
  for (let i = 0;i < len; i += 4) {
    const brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
    data[i] = brightness;
    data[i + 1] = brightness;
    data[i + 2] = brightness;
  }
};

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/HSL.js
Factory.addGetterSetter(Node2, "hue", 0, getNumberValidator(), Factory.afterSetFilter);
Factory.addGetterSetter(Node2, "saturation", 0, getNumberValidator(), Factory.afterSetFilter);
Factory.addGetterSetter(Node2, "luminance", 0, getNumberValidator(), Factory.afterSetFilter);
var HSL = function(imageData) {
  const data = imageData.data, nPixels = data.length, v = 1, s = Math.pow(2, this.saturation()), h = Math.abs(this.hue() + 360) % 360, l = this.luminance() * 127;
  const vsu = v * s * Math.cos(h * Math.PI / 180), vsw = v * s * Math.sin(h * Math.PI / 180);
  const rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw, rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw, rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
  const gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw, gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw, gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
  const br = 0.299 * v - 0.3 * vsu + 1.25 * vsw, bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw, bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;
  let r, g, b, a;
  for (let i = 0;i < nPixels; i += 4) {
    r = data[i + 0];
    g = data[i + 1];
    b = data[i + 2];
    a = data[i + 3];
    data[i + 0] = rr * r + rg * g + rb * b + l;
    data[i + 1] = gr * r + gg * g + gb * b + l;
    data[i + 2] = br * r + bg * g + bb * b + l;
    data[i + 3] = a;
  }
};

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/HSV.js
var HSV = function(imageData) {
  const data = imageData.data, nPixels = data.length, v = Math.pow(2, this.value()), s = Math.pow(2, this.saturation()), h = Math.abs(this.hue() + 360) % 360;
  const vsu = v * s * Math.cos(h * Math.PI / 180), vsw = v * s * Math.sin(h * Math.PI / 180);
  const rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw, rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw, rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
  const gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw, gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw, gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
  const br = 0.299 * v - 0.3 * vsu + 1.25 * vsw, bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw, bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;
  for (let i = 0;i < nPixels; i += 4) {
    const r = data[i + 0];
    const g = data[i + 1];
    const b = data[i + 2];
    const a = data[i + 3];
    data[i + 0] = rr * r + rg * g + rb * b;
    data[i + 1] = gr * r + gg * g + gb * b;
    data[i + 2] = br * r + bg * g + bb * b;
    data[i + 3] = a;
  }
};
Factory.addGetterSetter(Node2, "hue", 0, getNumberValidator(), Factory.afterSetFilter);
Factory.addGetterSetter(Node2, "saturation", 0, getNumberValidator(), Factory.afterSetFilter);
Factory.addGetterSetter(Node2, "value", 0, getNumberValidator(), Factory.afterSetFilter);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/Invert.js
var Invert = function(imageData) {
  const data = imageData.data, len = data.length;
  for (let i = 0;i < len; i += 4) {
    data[i] = 255 - data[i];
    data[i + 1] = 255 - data[i + 1];
    data[i + 2] = 255 - data[i + 2];
  }
};

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/Kaleidoscope.js
var ToPolar = function(src, dst, opt) {
  const srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2;
  let rMax = Math.sqrt(xMid * xMid + yMid * yMid);
  let x = xSize - xMid;
  let y = ySize - yMid;
  const rad = Math.sqrt(x * x + y * y);
  rMax = rad > rMax ? rad : rMax;
  const rSize = ySize, tSize = xSize;
  const conversion = 360 / tSize * Math.PI / 180;
  for (let theta = 0;theta < tSize; theta += 1) {
    const sin = Math.sin(theta * conversion);
    const cos = Math.cos(theta * conversion);
    for (let radius = 0;radius < rSize; radius += 1) {
      x = Math.floor(xMid + rMax * radius / rSize * cos);
      y = Math.floor(yMid + rMax * radius / rSize * sin);
      let i = (y * xSize + x) * 4;
      const r = srcPixels[i + 0];
      const g = srcPixels[i + 1];
      const b = srcPixels[i + 2];
      const a = srcPixels[i + 3];
      i = (theta + radius * xSize) * 4;
      dstPixels[i + 0] = r;
      dstPixels[i + 1] = g;
      dstPixels[i + 2] = b;
      dstPixels[i + 3] = a;
    }
  }
};
var FromPolar = function(src, dst, opt) {
  const srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2;
  let rMax = Math.sqrt(xMid * xMid + yMid * yMid);
  let x = xSize - xMid;
  let y = ySize - yMid;
  const rad = Math.sqrt(x * x + y * y);
  rMax = rad > rMax ? rad : rMax;
  const rSize = ySize, tSize = xSize, phaseShift = opt.polarRotation || 0;
  let x1, y1;
  for (x = 0;x < xSize; x += 1) {
    for (y = 0;y < ySize; y += 1) {
      const dx = x - xMid;
      const dy = y - yMid;
      const radius = Math.sqrt(dx * dx + dy * dy) * rSize / rMax;
      let theta = (Math.atan2(dy, dx) * 180 / Math.PI + 360 + phaseShift) % 360;
      theta = theta * tSize / 360;
      x1 = Math.floor(theta);
      y1 = Math.floor(radius);
      let i = (y1 * xSize + x1) * 4;
      const r = srcPixels[i + 0];
      const g = srcPixels[i + 1];
      const b = srcPixels[i + 2];
      const a = srcPixels[i + 3];
      i = (y * xSize + x) * 4;
      dstPixels[i + 0] = r;
      dstPixels[i + 1] = g;
      dstPixels[i + 2] = b;
      dstPixels[i + 3] = a;
    }
  }
};
var Kaleidoscope = function(imageData) {
  const { width: xSize, height: ySize } = imageData;
  let x, y, xoff, i, r, g, b, a, srcPos, dstPos;
  let power = Math.round(this.kaleidoscopePower());
  const angle = Math.round(this.kaleidoscopeAngle());
  const offset = Math.floor(xSize * (angle % 360) / 360);
  if (power < 1) {
    return;
  }
  const tempCanvas = Util.createCanvasElement();
  tempCanvas.width = xSize;
  tempCanvas.height = ySize;
  const scratchData = tempCanvas.getContext("2d").getImageData(0, 0, xSize, ySize);
  Util.releaseCanvas(tempCanvas);
  ToPolar(imageData, scratchData, {
    polarCenterX: xSize / 2,
    polarCenterY: ySize / 2
  });
  let minSectionSize = xSize / Math.pow(2, power);
  while (minSectionSize <= 8) {
    minSectionSize = minSectionSize * 2;
    power -= 1;
  }
  minSectionSize = Math.ceil(minSectionSize);
  let sectionSize = minSectionSize;
  let xStart = 0, xEnd = sectionSize, xDelta = 1;
  if (offset + minSectionSize > xSize) {
    xStart = sectionSize;
    xEnd = 0;
    xDelta = -1;
  }
  for (y = 0;y < ySize; y += 1) {
    for (x = xStart;x !== xEnd; x += xDelta) {
      xoff = Math.round(x + offset) % xSize;
      srcPos = (xSize * y + xoff) * 4;
      r = scratchData.data[srcPos + 0];
      g = scratchData.data[srcPos + 1];
      b = scratchData.data[srcPos + 2];
      a = scratchData.data[srcPos + 3];
      dstPos = (xSize * y + x) * 4;
      scratchData.data[dstPos + 0] = r;
      scratchData.data[dstPos + 1] = g;
      scratchData.data[dstPos + 2] = b;
      scratchData.data[dstPos + 3] = a;
    }
  }
  for (y = 0;y < ySize; y += 1) {
    sectionSize = Math.floor(minSectionSize);
    for (i = 0;i < power; i += 1) {
      for (x = 0;x < sectionSize + 1; x += 1) {
        srcPos = (xSize * y + x) * 4;
        r = scratchData.data[srcPos + 0];
        g = scratchData.data[srcPos + 1];
        b = scratchData.data[srcPos + 2];
        a = scratchData.data[srcPos + 3];
        dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;
        scratchData.data[dstPos + 0] = r;
        scratchData.data[dstPos + 1] = g;
        scratchData.data[dstPos + 2] = b;
        scratchData.data[dstPos + 3] = a;
      }
      sectionSize *= 2;
    }
  }
  FromPolar(scratchData, imageData, { polarRotation: 0 });
};
Factory.addGetterSetter(Node2, "kaleidoscopePower", 2, getNumberValidator(), Factory.afterSetFilter);
Factory.addGetterSetter(Node2, "kaleidoscopeAngle", 0, getNumberValidator(), Factory.afterSetFilter);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/Mask.js
function pixelAt(idata, x, y) {
  let idx = (y * idata.width + x) * 4;
  const d = [];
  d.push(idata.data[idx++], idata.data[idx++], idata.data[idx++], idata.data[idx++]);
  return d;
}
function rgbDistance(p1, p2) {
  return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2) + Math.pow(p1[2] - p2[2], 2));
}
function rgbMean(pTab) {
  const m = [0, 0, 0];
  for (let i = 0;i < pTab.length; i++) {
    m[0] += pTab[i][0];
    m[1] += pTab[i][1];
    m[2] += pTab[i][2];
  }
  m[0] /= pTab.length;
  m[1] /= pTab.length;
  m[2] /= pTab.length;
  return m;
}
function backgroundMask(idata, threshold) {
  const rgbv_no = pixelAt(idata, 0, 0);
  const rgbv_ne = pixelAt(idata, idata.width - 1, 0);
  const rgbv_so = pixelAt(idata, 0, idata.height - 1);
  const rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);
  const thres = threshold || 10;
  if (rgbDistance(rgbv_no, rgbv_ne) < thres && rgbDistance(rgbv_ne, rgbv_se) < thres && rgbDistance(rgbv_se, rgbv_so) < thres && rgbDistance(rgbv_so, rgbv_no) < thres) {
    const mean = rgbMean([rgbv_ne, rgbv_no, rgbv_se, rgbv_so]);
    const mask = [];
    for (let i = 0;i < idata.width * idata.height; i++) {
      const d = rgbDistance(mean, [
        idata.data[i * 4],
        idata.data[i * 4 + 1],
        idata.data[i * 4 + 2]
      ]);
      mask[i] = d < thres ? 0 : 255;
    }
    return mask;
  }
}
function applyMask(idata, mask) {
  for (let i = 0;i < idata.width * idata.height; i++) {
    idata.data[4 * i + 3] = mask[i];
  }
}
function erodeMask(mask, sw, sh) {
  const weights = [1, 1, 1, 1, 0, 1, 1, 1, 1];
  const side = Math.round(Math.sqrt(weights.length));
  const halfSide = Math.floor(side / 2);
  const maskResult = [];
  for (let y = 0;y < sh; y++) {
    for (let x = 0;x < sw; x++) {
      const so = y * sw + x;
      let a = 0;
      for (let cy = 0;cy < side; cy++) {
        for (let cx = 0;cx < side; cx++) {
          const scy = y + cy - halfSide;
          const scx = x + cx - halfSide;
          if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
            const srcOff = scy * sw + scx;
            const wt = weights[cy * side + cx];
            a += mask[srcOff] * wt;
          }
        }
      }
      maskResult[so] = a === 255 * 8 ? 255 : 0;
    }
  }
  return maskResult;
}
function dilateMask(mask, sw, sh) {
  const weights = [1, 1, 1, 1, 1, 1, 1, 1, 1];
  const side = Math.round(Math.sqrt(weights.length));
  const halfSide = Math.floor(side / 2);
  const maskResult = [];
  for (let y = 0;y < sh; y++) {
    for (let x = 0;x < sw; x++) {
      const so = y * sw + x;
      let a = 0;
      for (let cy = 0;cy < side; cy++) {
        for (let cx = 0;cx < side; cx++) {
          const scy = y + cy - halfSide;
          const scx = x + cx - halfSide;
          if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
            const srcOff = scy * sw + scx;
            const wt = weights[cy * side + cx];
            a += mask[srcOff] * wt;
          }
        }
      }
      maskResult[so] = a >= 255 * 4 ? 255 : 0;
    }
  }
  return maskResult;
}
function smoothEdgeMask(mask, sw, sh) {
  const weights = [
    1 / 9,
    1 / 9,
    1 / 9,
    1 / 9,
    1 / 9,
    1 / 9,
    1 / 9,
    1 / 9,
    1 / 9
  ];
  const side = Math.round(Math.sqrt(weights.length));
  const halfSide = Math.floor(side / 2);
  const maskResult = [];
  for (let y = 0;y < sh; y++) {
    for (let x = 0;x < sw; x++) {
      const so = y * sw + x;
      let a = 0;
      for (let cy = 0;cy < side; cy++) {
        for (let cx = 0;cx < side; cx++) {
          const scy = y + cy - halfSide;
          const scx = x + cx - halfSide;
          if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
            const srcOff = scy * sw + scx;
            const wt = weights[cy * side + cx];
            a += mask[srcOff] * wt;
          }
        }
      }
      maskResult[so] = a;
    }
  }
  return maskResult;
}
var Mask = function(imageData) {
  const threshold = this.threshold();
  let mask = backgroundMask(imageData, threshold);
  if (mask) {
    mask = erodeMask(mask, imageData.width, imageData.height);
    mask = dilateMask(mask, imageData.width, imageData.height);
    mask = smoothEdgeMask(mask, imageData.width, imageData.height);
    applyMask(imageData, mask);
  }
  return imageData;
};
Factory.addGetterSetter(Node2, "threshold", 0, getNumberValidator(), Factory.afterSetFilter);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/Noise.js
var Noise = function(imageData) {
  const amount = this.noise() * 255, data = imageData.data, nPixels = data.length, half = amount / 2;
  for (let i = 0;i < nPixels; i += 4) {
    data[i + 0] += half - 2 * half * Math.random();
    data[i + 1] += half - 2 * half * Math.random();
    data[i + 2] += half - 2 * half * Math.random();
  }
};
Factory.addGetterSetter(Node2, "noise", 0.2, getNumberValidator(), Factory.afterSetFilter);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/Pixelate.js
var Pixelate = function(imageData) {
  let pixelSize = Math.ceil(this.pixelSize()), width = imageData.width, height = imageData.height, nBinsX = Math.ceil(width / pixelSize), nBinsY = Math.ceil(height / pixelSize), data = imageData.data;
  if (pixelSize <= 0) {
    Util.error("pixelSize value can not be <= 0");
    return;
  }
  for (let xBin = 0;xBin < nBinsX; xBin += 1) {
    for (let yBin = 0;yBin < nBinsY; yBin += 1) {
      let red = 0;
      let green = 0;
      let blue = 0;
      let alpha = 0;
      const xBinStart = xBin * pixelSize;
      const xBinEnd = xBinStart + pixelSize;
      const yBinStart = yBin * pixelSize;
      const yBinEnd = yBinStart + pixelSize;
      let pixelsInBin = 0;
      for (let x = xBinStart;x < xBinEnd; x += 1) {
        if (x >= width) {
          continue;
        }
        for (let y = yBinStart;y < yBinEnd; y += 1) {
          if (y >= height) {
            continue;
          }
          const i = (width * y + x) * 4;
          red += data[i + 0];
          green += data[i + 1];
          blue += data[i + 2];
          alpha += data[i + 3];
          pixelsInBin += 1;
        }
      }
      red = red / pixelsInBin;
      green = green / pixelsInBin;
      blue = blue / pixelsInBin;
      alpha = alpha / pixelsInBin;
      for (let x = xBinStart;x < xBinEnd; x += 1) {
        if (x >= width) {
          continue;
        }
        for (let y = yBinStart;y < yBinEnd; y += 1) {
          if (y >= height) {
            continue;
          }
          const i = (width * y + x) * 4;
          data[i + 0] = red;
          data[i + 1] = green;
          data[i + 2] = blue;
          data[i + 3] = alpha;
        }
      }
    }
  }
};
Factory.addGetterSetter(Node2, "pixelSize", 8, getNumberValidator(), Factory.afterSetFilter);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/Posterize.js
var Posterize = function(imageData) {
  const levels = Math.round(this.levels() * 254) + 1, data = imageData.data, len = data.length, scale = 255 / levels;
  for (let i = 0;i < len; i += 1) {
    data[i] = Math.floor(data[i] / scale) * scale;
  }
};
Factory.addGetterSetter(Node2, "levels", 0.5, getNumberValidator(), Factory.afterSetFilter);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/RGB.js
var RGB = function(imageData) {
  const data = imageData.data, nPixels = data.length, red = this.red(), green = this.green(), blue = this.blue();
  for (let i = 0;i < nPixels; i += 4) {
    const brightness = (0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2]) / 255;
    data[i] = brightness * red;
    data[i + 1] = brightness * green;
    data[i + 2] = brightness * blue;
    data[i + 3] = data[i + 3];
  }
};
Factory.addGetterSetter(Node2, "red", 0, function(val) {
  this._filterUpToDate = false;
  if (val > 255) {
    return 255;
  } else if (val < 0) {
    return 0;
  } else {
    return Math.round(val);
  }
});
Factory.addGetterSetter(Node2, "green", 0, function(val) {
  this._filterUpToDate = false;
  if (val > 255) {
    return 255;
  } else if (val < 0) {
    return 0;
  } else {
    return Math.round(val);
  }
});
Factory.addGetterSetter(Node2, "blue", 0, RGBComponent, Factory.afterSetFilter);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/RGBA.js
var RGBA = function(imageData) {
  const data = imageData.data, nPixels = data.length, red = this.red(), green = this.green(), blue = this.blue(), alpha = this.alpha();
  for (let i = 0;i < nPixels; i += 4) {
    const ia = 1 - alpha;
    data[i] = red * alpha + data[i] * ia;
    data[i + 1] = green * alpha + data[i + 1] * ia;
    data[i + 2] = blue * alpha + data[i + 2] * ia;
  }
};
Factory.addGetterSetter(Node2, "red", 0, function(val) {
  this._filterUpToDate = false;
  if (val > 255) {
    return 255;
  } else if (val < 0) {
    return 0;
  } else {
    return Math.round(val);
  }
});
Factory.addGetterSetter(Node2, "green", 0, function(val) {
  this._filterUpToDate = false;
  if (val > 255) {
    return 255;
  } else if (val < 0) {
    return 0;
  } else {
    return Math.round(val);
  }
});
Factory.addGetterSetter(Node2, "blue", 0, RGBComponent, Factory.afterSetFilter);
Factory.addGetterSetter(Node2, "alpha", 1, function(val) {
  this._filterUpToDate = false;
  if (val > 1) {
    return 1;
  } else if (val < 0) {
    return 0;
  } else {
    return val;
  }
});

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/Sepia.js
var Sepia = function(imageData) {
  const data = imageData.data, nPixels = data.length;
  for (let i = 0;i < nPixels; i += 4) {
    const r = data[i + 0];
    const g = data[i + 1];
    const b = data[i + 2];
    data[i + 0] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
    data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
    data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
  }
};

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/Solarize.js
var Solarize = function(imageData) {
  const threshold = 128;
  const d = imageData.data;
  for (let i = 0;i < d.length; i += 4) {
    const r = d[i], g = d[i + 1], b = d[i + 2];
    const L = 0.2126 * r + 0.7152 * g + 0.0722 * b;
    if (L >= threshold) {
      d[i] = 255 - r;
      d[i + 1] = 255 - g;
      d[i + 2] = 255 - b;
    }
  }
  return imageData;
};

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/filters/Threshold.js
var Threshold = function(imageData) {
  const level = this.threshold() * 255, data = imageData.data, len = data.length;
  for (let i = 0;i < len; i += 1) {
    data[i] = data[i] < level ? 0 : 255;
  }
};
Factory.addGetterSetter(Node2, "threshold", 0.5, getNumberValidator(), Factory.afterSetFilter);

// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/_FullInternals.js
var Konva3 = Konva2.Util._assign(Konva2, {
  Arc,
  Arrow,
  Circle,
  Ellipse,
  Image: Image2,
  Label,
  Tag,
  Line,
  Path,
  Rect,
  RegularPolygon,
  Ring,
  Sprite,
  Star,
  Text,
  TextPath,
  Transformer,
  Wedge,
  Filters: {
    Blur,
    Brightness,
    Brighten,
    Contrast,
    Emboss,
    Enhance,
    Grayscale,
    HSL,
    HSV,
    Invert,
    Kaleidoscope,
    Mask,
    Noise,
    Pixelate,
    Posterize,
    RGB,
    RGBA,
    Sepia,
    Solarize,
    Threshold
  }
});

// ../../node_modules/.pnpm/react-konva@19.2.1_@types+react@19.2.7_konva@10.0.12_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/react-konva/es/ReactKonvaCore.js
var import_react2 = __toESM(require_react(), 1);
// ../../node_modules/.pnpm/konva@10.0.12/node_modules/konva/lib/Core.js
var Core_default = Konva2;

// ../../node_modules/.pnpm/react-konva@19.2.1_@types+react@19.2.7_konva@10.0.12_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/react-konva/es/ReactKonvaCore.js
var import_react_reconciler = __toESM(require_react_reconciler(), 1);
var import_constants2 = __toESM(require_constants(), 1);

// ../../node_modules/.pnpm/react-konva@19.2.1_@types+react@19.2.7_konva@10.0.12_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/react-konva/es/ReactKonvaHostConfig.js
var exports_ReactKonvaHostConfig = {};
__export(exports_ReactKonvaHostConfig, {
  warnsIfNotActing: () => warnsIfNotActing,
  waitForCommitToBeReady: () => waitForCommitToBeReady,
  unhideTextInstance: () => unhideTextInstance,
  unhideInstance: () => unhideInstance,
  trackSchedulerEvent: () => trackSchedulerEvent,
  suspendInstance: () => suspendInstance,
  supportsPersistence: () => supportsPersistence,
  supportsMutation: () => supportsMutation,
  supportsMicrotasks: () => supportsMicrotasks,
  supportsHydration: () => supportsHydration,
  startSuspendingCommit: () => startSuspendingCommit,
  shouldSetTextContent: () => shouldSetTextContent,
  shouldDeprioritizeSubtree: () => shouldDeprioritizeSubtree,
  shouldAttemptEagerTransition: () => shouldAttemptEagerTransition,
  setCurrentUpdatePriority: () => setCurrentUpdatePriority,
  scheduleTimeout: () => scheduleTimeout,
  scheduleMicrotask: () => scheduleMicrotask,
  run: () => import_scheduler.unstable_runWithPriority,
  resolveUpdatePriority: () => resolveUpdatePriority,
  resolveEventType: () => resolveEventType,
  resolveEventTimeStamp: () => resolveEventTimeStamp,
  resetTextContent: () => resetTextContent,
  resetFormInstance: () => resetFormInstance,
  resetAfterCommit: () => resetAfterCommit,
  requestPostPaintCallback: () => requestPostPaintCallback,
  removeChildFromContainer: () => removeChildFromContainer,
  removeChild: () => removeChild,
  prepareUpdate: () => prepareUpdate,
  prepareScopeUpdate: () => prepareScopeUpdate,
  preparePortalMount: () => preparePortalMount,
  prepareForCommit: () => prepareForCommit,
  preloadInstance: () => preloadInstance,
  now: () => import_scheduler.unstable_now,
  noTimeout: () => noTimeout,
  maySuspendCommit: () => maySuspendCommit,
  isPrimaryRenderer: () => isPrimaryRenderer,
  insertInContainerBefore: () => insertInContainerBefore,
  insertBefore: () => insertBefore,
  idlePriority: () => import_scheduler.unstable_IdlePriority,
  hideTextInstance: () => hideTextInstance,
  hideInstance: () => hideInstance,
  getRootHostContext: () => getRootHostContext,
  getPublicInstance: () => getPublicInstance,
  getInstanceFromScope: () => getInstanceFromScope,
  getInstanceFromNode: () => getInstanceFromNode,
  getCurrentUpdatePriority: () => getCurrentUpdatePriority,
  getCurrentEventPriority: () => getCurrentEventPriority,
  getChildHostContext: () => getChildHostContext,
  finalizeInitialChildren: () => finalizeInitialChildren,
  detachDeletedInstance: () => detachDeletedInstance,
  createTextInstance: () => createTextInstance,
  createInstance: () => createInstance,
  commitUpdate: () => commitUpdate,
  commitTextUpdate: () => commitTextUpdate,
  commitMount: () => commitMount,
  clearContainer: () => clearContainer,
  cancelTimeout: () => cancelTimeout,
  beforeActiveInstanceBlur: () => beforeActiveInstanceBlur,
  appendInitialChild: () => appendInitialChild,
  appendChildToContainer: () => appendChildToContainer,
  appendChild: () => appendChild,
  afterActiveInstanceBlur: () => afterActiveInstanceBlur,
  NotPendingTransition: () => NotPendingTransition,
  HostTransitionContext: () => HostTransitionContext
});
var import_react = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/react-konva@19.2.1_@types+react@19.2.7_konva@10.0.12_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/react-konva/es/makeUpdates.js
var propsToSkip = {
  children: true,
  ref: true,
  key: true,
  style: true,
  forwardedRef: true,
  unstable_applyCache: true,
  unstable_applyDrawHitFromCache: true
};
var zIndexWarningShowed = false;
var dragWarningShowed = false;
var EVENTS_NAMESPACE = ".react-konva-event";
var useStrictMode = false;
var DRAGGABLE_WARNING = `ReactKonva: You have a Konva node with draggable = true and position defined but no onDragMove or onDragEnd events are handled.
Position of a node will be changed during drag&drop, so you should update state of the react app as well.
Consider to add onDragMove or onDragEnd events.
For more info see: https://github.com/konvajs/react-konva/issues/256
`;
var Z_INDEX_WARNING = `ReactKonva: You are using "zIndex" attribute for a Konva node.
react-konva may get confused with ordering. Just define correct order of elements in your render function of a component.
For more info see: https://github.com/konvajs/react-konva/issues/194
`;
var EMPTY_PROPS = {};
function applyNodeProps(instance, props, oldProps = EMPTY_PROPS) {
  if (!zIndexWarningShowed && "zIndex" in props) {
    console.warn(Z_INDEX_WARNING);
    zIndexWarningShowed = true;
  }
  if (!dragWarningShowed && props.draggable) {
    var hasPosition = props.x !== undefined || props.y !== undefined;
    var hasEvents = props.onDragEnd || props.onDragMove;
    if (hasPosition && !hasEvents) {
      console.warn(DRAGGABLE_WARNING);
      dragWarningShowed = true;
    }
  }
  for (var key in oldProps) {
    if (propsToSkip[key]) {
      continue;
    }
    var isEvent = key.slice(0, 2) === "on";
    var propChanged = oldProps[key] !== props[key];
    if (isEvent && propChanged) {
      var eventName = key.substr(2).toLowerCase();
      if (eventName.substr(0, 7) === "content") {
        eventName = "content" + eventName.substr(7, 1).toUpperCase() + eventName.substr(8);
      }
      instance.off(eventName, oldProps[key]);
    }
    var toRemove = !props.hasOwnProperty(key);
    if (toRemove) {
      instance.setAttr(key, undefined);
    }
  }
  var strictUpdate = useStrictMode || props._useStrictMode;
  var updatedProps = {};
  var hasUpdates = false;
  const newEvents = {};
  for (var key in props) {
    if (propsToSkip[key]) {
      continue;
    }
    var isEvent = key.slice(0, 2) === "on";
    var toAdd = oldProps[key] !== props[key];
    if (isEvent && toAdd) {
      var eventName = key.substr(2).toLowerCase();
      if (eventName.substr(0, 7) === "content") {
        eventName = "content" + eventName.substr(7, 1).toUpperCase() + eventName.substr(8);
      }
      if (props[key]) {
        newEvents[eventName] = props[key];
      }
    }
    if (!isEvent && (props[key] !== oldProps[key] || strictUpdate && props[key] !== instance.getAttr(key))) {
      hasUpdates = true;
      updatedProps[key] = props[key];
    }
  }
  if (hasUpdates) {
    instance.setAttrs(updatedProps);
    updatePicture(instance);
  }
  for (var eventName in newEvents) {
    instance.off(eventName + EVENTS_NAMESPACE);
    instance.on(eventName + EVENTS_NAMESPACE, newEvents[eventName]);
  }
}
function updatePicture(node) {
  if (!Konva.autoDrawEnabled) {
    var drawingNode = node.getLayer() || node.getStage();
    drawingNode && drawingNode.batchDraw();
  }
}

// ../../node_modules/.pnpm/react-konva@19.2.1_@types+react@19.2.7_konva@10.0.12_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/react-konva/es/ReactKonvaHostConfig.js
var import_scheduler = __toESM(require_scheduler(), 1);
var import_constants = __toESM(require_constants(), 1);
var NO_CONTEXT = {};
var UPDATE_SIGNAL = {};
Core_default.Node.prototype._applyProps = applyNodeProps;
var currentUpdatePriority = import_constants.DefaultEventPriority;
function appendInitialChild(parentInstance, child) {
  if (typeof child === "string") {
    console.error(`Do not use plain text as child of Konva.Node. You are using text: ${child}`);
    return;
  }
  parentInstance.add(child);
  updatePicture(parentInstance);
}
function createInstance(type, props, internalInstanceHandle) {
  let NodeClass = Core_default[type];
  if (!NodeClass) {
    console.error(`Konva has no node with the type ${type}. Group will be used instead. If you use minimal version of react-konva, just import required nodes into Konva: "import "konva/lib/shapes/${type}"  If you want to render DOM elements as part of canvas tree take a look into this demo: https://konvajs.github.io/docs/react/DOM_Portal.html`);
    NodeClass = Core_default.Group;
  }
  const propsWithoutEvents = {};
  const propsWithOnlyEvents = {};
  for (var key in props) {
    if (key === "ref") {
      continue;
    }
    var isEvent = key.slice(0, 2) === "on";
    if (isEvent) {
      propsWithOnlyEvents[key] = props[key];
    } else {
      propsWithoutEvents[key] = props[key];
    }
  }
  const instance = new NodeClass(propsWithoutEvents);
  applyNodeProps(instance, propsWithOnlyEvents);
  return instance;
}
function createTextInstance(text, rootContainerInstance, internalInstanceHandle) {
  console.error(`Text components are not supported for now in ReactKonva. Your text is: "${text}"`);
}
function finalizeInitialChildren(domElement, type, props) {
  return false;
}
function getPublicInstance(instance) {
  return instance;
}
function prepareForCommit() {
  return null;
}
function preparePortalMount() {
  return null;
}
function prepareUpdate(domElement, type, oldProps, newProps) {
  return UPDATE_SIGNAL;
}
function resetAfterCommit() {}
function resetTextContent(domElement) {}
function shouldDeprioritizeSubtree(type, props) {
  return false;
}
function getRootHostContext() {
  return NO_CONTEXT;
}
function getChildHostContext() {
  return NO_CONTEXT;
}
var scheduleTimeout = setTimeout;
var cancelTimeout = clearTimeout;
var supportsMicrotasks = true;
var scheduleMicrotask = (fn) => {
  fn();
};
var noTimeout = -1;
function shouldSetTextContent(type, props) {
  return false;
}
var isPrimaryRenderer = false;
var warnsIfNotActing = false;
var supportsMutation = true;
var supportsPersistence = false;
var supportsHydration = false;
function appendChild(parentInstance, child) {
  if (child.parent === parentInstance) {
    child.moveToTop();
  } else {
    parentInstance.add(child);
  }
  updatePicture(parentInstance);
}
function appendChildToContainer(parentInstance, child) {
  if (child.parent === parentInstance) {
    child.moveToTop();
  } else {
    parentInstance.add(child);
  }
  updatePicture(parentInstance);
}
function insertBefore(parentInstance, child, beforeChild) {
  child._remove();
  parentInstance.add(child);
  child.setZIndex(beforeChild.getZIndex());
  updatePicture(parentInstance);
}
function insertInContainerBefore(parentInstance, child, beforeChild) {
  insertBefore(parentInstance, child, beforeChild);
}
function removeChild(parentInstance, child) {
  child.destroy();
  child.off(EVENTS_NAMESPACE);
  updatePicture(parentInstance);
}
function removeChildFromContainer(parentInstance, child) {
  child.destroy();
  child.off(EVENTS_NAMESPACE);
  updatePicture(parentInstance);
}
function commitTextUpdate(textInstance, oldText, newText) {
  console.error(`Text components are not yet supported in ReactKonva. You text is: "${newText}"`);
}
function commitMount(instance, type, newProps) {}
function commitUpdate(instance, type, oldProps, newProps) {
  applyNodeProps(instance, newProps, oldProps);
}
function hideInstance(instance) {
  instance.hide();
  updatePicture(instance);
}
function hideTextInstance(textInstance) {}
function unhideInstance(instance, props) {
  if (props.visible == null || props.visible) {
    instance.show();
  }
}
function unhideTextInstance(textInstance, text) {}
function clearContainer(container) {}
function detachDeletedInstance() {}
function getInstanceFromNode() {
  return null;
}
function beforeActiveInstanceBlur() {}
function afterActiveInstanceBlur() {}
function getCurrentEventPriority() {
  return import_constants.DefaultEventPriority;
}
function prepareScopeUpdate() {}
function getInstanceFromScope() {
  return null;
}
function setCurrentUpdatePriority(newPriority) {
  currentUpdatePriority = newPriority;
}
function getCurrentUpdatePriority() {
  return currentUpdatePriority;
}
function resolveUpdatePriority() {
  return import_constants.DiscreteEventPriority;
}
function shouldAttemptEagerTransition() {
  return false;
}
function trackSchedulerEvent() {}
function resolveEventType() {
  return null;
}
function resolveEventTimeStamp() {
  return -1.1;
}
function requestPostPaintCallback() {}
function maySuspendCommit() {
  return false;
}
function preloadInstance() {
  return true;
}
function startSuspendingCommit() {}
function suspendInstance() {}
function waitForCommitToBeReady() {
  return null;
}
var NotPendingTransition = null;
var HostTransitionContext = /* @__PURE__ */ import_react.default.createContext(null);
function resetFormInstance() {}

// ../../node_modules/.pnpm/its-fine@2.0.0_@types+react@19.2.7_react@19.2.3/node_modules/its-fine/dist/index.js
var o = __toESM(require_react(), 1);
function i(e, t, r) {
  if (!e)
    return;
  if (r(e) === true)
    return e;
  let n = t ? e.return : e.child;
  for (;n; ) {
    const u = i(n, t, r);
    if (u)
      return u;
    n = t ? null : n.sibling;
  }
}
function l(e) {
  try {
    return Object.defineProperties(e, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {}
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {}
      }
    });
  } catch (t) {
    return e;
  }
}
var a = /* @__PURE__ */ l(/* @__PURE__ */ o.createContext(null));

class m extends o.Component {
  render() {
    return /* @__PURE__ */ o.createElement(a.Provider, { value: this._reactInternals }, this.props.children);
  }
}
function c() {
  const e = o.useContext(a);
  if (e === null)
    throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const t = o.useId();
  return o.useMemo(() => {
    for (const n of [e, e == null ? undefined : e.alternate]) {
      if (!n)
        continue;
      const u = i(n, false, (d) => {
        let s = d.memoizedState;
        for (;s; ) {
          if (s.memoizedState === t)
            return true;
          s = s.next;
        }
      });
      if (u)
        return u;
    }
  }, [e, t]);
}
var p = Symbol.for("react.context");
var b = (e) => e !== null && typeof e == "object" && ("$$typeof" in e) && e.$$typeof === p;
function h() {
  const e = c(), [t] = o.useState(() => /* @__PURE__ */ new Map);
  t.clear();
  let r = e;
  for (;r; ) {
    const n = r.type;
    b(n) && n !== a && !t.has(n) && t.set(n, o.use(l(n))), r = r.return;
  }
  return t;
}
function x() {
  const e = h();
  return o.useMemo(() => Array.from(e.keys()).reduce((t, r) => (n) => /* @__PURE__ */ o.createElement(t, null, /* @__PURE__ */ o.createElement(r.Provider, { ...n, value: e.get(r) })), (t) => /* @__PURE__ */ o.createElement(m, { ...t })), [e]);
}

// ../../node_modules/.pnpm/react-konva@19.2.1_@types+react@19.2.7_konva@10.0.12_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/react-konva/es/ReactKonvaCore.js
if (import_react2.default.version.indexOf("19") === -1) {
  throw new Error("react-konva version 19 is only compatible with React 19. Make sure to have the last version of react-konva and react or downgrade react-konva to version 18.");
}
function usePrevious(value) {
  const ref = import_react2.default.useRef({});
  import_react2.default.useLayoutEffect(() => {
    ref.current = value;
  });
  import_react2.default.useLayoutEffect(() => {
    return () => {
      ref.current = {};
    };
  }, []);
  return ref.current;
}
var useIsReactStrictMode = () => {
  const memoCount = import_react2.default.useRef(0);
  import_react2.default.useMemo(() => {
    memoCount.current++;
  }, []);
  return memoCount.current > 1;
};
var StageWrap = (props) => {
  const container = import_react2.default.useRef(null);
  const stage = import_react2.default.useRef(null);
  const fiberRef = import_react2.default.useRef(null);
  const oldProps = usePrevious(props);
  const Bridge = x();
  const pendingDestroy = import_react2.default.useRef(null);
  const _setRef = (stage2) => {
    const { forwardedRef } = props;
    if (!forwardedRef) {
      return;
    }
    if (typeof forwardedRef === "function") {
      forwardedRef(stage2);
    } else {
      forwardedRef.current = stage2;
    }
  };
  const isStrictMode = useIsReactStrictMode();
  const destroyStage = () => {
    _setRef(null);
    KonvaRenderer.updateContainer(null, fiberRef.current, null);
    stage.current?.destroy();
    stage.current = null;
  };
  import_react2.default.useLayoutEffect(() => {
    if (pendingDestroy.current) {
      clearTimeout(pendingDestroy.current);
      pendingDestroy.current = null;
    }
    if (stage.current) {
      _setRef(stage.current);
    } else {
      stage.current = new Core_default.Stage({
        width: props.width,
        height: props.height,
        container: container.current
      });
      _setRef(stage.current);
      fiberRef.current = KonvaRenderer.createContainer(stage.current, import_constants2.ConcurrentRoot, null, false, null, "", console.error, console.error, console.error, null);
      KonvaRenderer.updateContainer(import_react2.default.createElement(Bridge, {}, props.children), fiberRef.current, null, () => {});
    }
    return () => {
      if (isStrictMode) {
        pendingDestroy.current = setTimeout(destroyStage, 0);
      } else {
        destroyStage();
      }
    };
  }, []);
  import_react2.default.useLayoutEffect(() => {
    _setRef(stage.current);
    applyNodeProps(stage.current, props, oldProps);
    KonvaRenderer.updateContainer(import_react2.default.createElement(Bridge, {}, props.children), fiberRef.current, null);
  });
  return import_react2.default.createElement("div", {
    ref: container,
    id: props.id,
    accessKey: props.accessKey,
    className: props.className,
    role: props.role,
    style: props.style,
    tabIndex: props.tabIndex,
    title: props.title
  });
};
var Layer2 = "Layer";
var Group2 = "Group";
var Rect2 = "Rect";
var Circle2 = "Circle";
var Ellipse2 = "Ellipse";
var Line2 = "Line";
var Image3 = "Image";
var Text2 = "Text";
var Star2 = "Star";
var Path2 = "Path";
var RegularPolygon2 = "RegularPolygon";
var Transformer2 = "Transformer";
var KonvaRenderer = import_react_reconciler.default(exports_ReactKonvaHostConfig);
var Stage2 = import_react2.default.forwardRef((props, ref) => {
  return import_react2.default.createElement(m, {}, import_react2.default.createElement(StageWrap, { ...props, forwardedRef: ref }));
});
// ../../src/utils/units.ts
var MM_PER_INCH = 25.4;
var PT_PER_INCH = 72;
function mmToPx(mm, options = {}) {
  const dpi = options.dpi ?? 96;
  return mm * dpi / MM_PER_INCH;
}
function pxToMm(px, options = {}) {
  const dpi = options.dpi ?? 96;
  return px * MM_PER_INCH / dpi;
}
function mmToPt(mm) {
  return mm * PT_PER_INCH / MM_PER_INCH;
}
function ptToMm(pt) {
  return pt * MM_PER_INCH / PT_PER_INCH;
}
function inToMm(inches) {
  return inches * MM_PER_INCH;
}
function mmToIn(mm) {
  return mm / MM_PER_INCH;
}
function toMm(value, unit, options = {}) {
  switch (unit) {
    case "mm":
      return value;
    case "pt":
      return ptToMm(value);
    case "px":
      return pxToMm(value, options);
    case "in":
      return inToMm(value);
    default: {
      const _exhaustive = unit;
      return _exhaustive;
    }
  }
}
function fromMm(mm, unit, options = {}) {
  switch (unit) {
    case "mm":
      return mm;
    case "pt":
      return mmToPt(mm);
    case "px":
      return mmToPx(mm, options);
    case "in":
      return mmToIn(mm);
    default: {
      const _exhaustive = unit;
      return _exhaustive;
    }
  }
}
function roundTo(value, digits) {
  const p2 = 10 ** digits;
  return Math.round(value * p2) / p2;
}

// ../../src/features/konva-editor/utils/textUtils.ts
var dpi = 96;
var measureText = (text, font) => {
  if (typeof document === "undefined")
    return { width: 0, height: 0 };
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  if (!ctx)
    return { width: 0, height: 0 };
  const weight = font.weight || "normal";
  ctx.font = `${weight} ${font.size}px ${font.family}`;
  const metrics = ctx.measureText(text);
  const height = font.size * 1.2;
  return {
    width: metrics.width,
    height
  };
};
var calculateTextDimensions = (text, fontSettings) => {
  const fontSizeMm = fontSettings.size || ptToMm(12);
  const font = {
    family: fontSettings.family || "Meiryo",
    size: mmToPx(fontSizeMm, { dpi }),
    weight: fontSettings.weight || 400
  };
  const lines = text.split(`
`);
  let maxLineLength = 0;
  for (const line of lines) {
    const { width } = measureText(line || " ", font);
    if (width > maxLineLength)
      maxLineLength = width;
  }
  const paddingMm = fontSettings.padding || 0;
  const paddingPx = mmToPx(paddingMm, { dpi });
  if (fontSettings.isVertical) {
    const columnSpacing = 1.5;
    const layoutFontSize = font.size;
    const columnWidth = layoutFontSize * columnSpacing;
    const charHeight = layoutFontSize;
    const numColumns = lines.length;
    let maxChars = 0;
    const autoIndent = true;
    const indentSize = 1;
    for (const line of lines) {
      const chars = Array.from(line);
      let len = chars.length;
      if (autoIndent && len > 0) {
        len += indentSize;
      }
      if (len === 0)
        len = 1;
      if (len > maxChars)
        maxChars = len;
    }
    if (maxChars === 0)
      maxChars = 1;
    const w = numColumns * columnWidth;
    const h2 = maxChars * charHeight;
    return {
      w: pxToMm(w + paddingPx * 2, { dpi }),
      h: pxToMm(h2 + paddingPx * 2, { dpi })
    };
  } else {
    const hLH = font.size * 1.2;
    const hStack = lines.length * hLH;
    return {
      w: pxToMm(maxLineLength + paddingPx * 2, { dpi }),
      h: pxToMm(hStack + paddingPx * 2, { dpi })
    };
  }
};

// ../../src/features/konva-editor/utils/textLayout.ts
var TEXT_LAYOUT_KEYS = ["text", "font", "fontSize", "fontWeight", "padding"];
function calculateVerticalTextHeight(text, fontSize, padding) {
  const lines = (text || "").split(`
`);
  const maxLineLength = Math.max(...lines.map((line) => Array.from(line).length), 1);
  const contentHeight = maxLineLength * fontSize;
  return contentHeight + padding * 2;
}
function calculateInitialTextBoxSize(text, font, options = {}) {
  const dpi2 = options.dpi ?? 96;
  const sizePx = mmToPx(font.sizeMm, { dpi: dpi2 });
  const { width, height } = measureText(text || " ", {
    family: font.family,
    size: sizePx,
    weight: font.weight
  });
  return {
    w: pxToMm(width + 10, { dpi: dpi2 }),
    h: pxToMm(height + 4, { dpi: dpi2 })
  };
}
function applyTextLayoutUpdates(currentNode, updates) {
  const hasLayoutChange = TEXT_LAYOUT_KEYS.some((key) => (key in updates));
  const nextNode = { ...currentNode, ...updates };
  const isVertical = "vertical" in updates ? updates.vertical : nextNode.vertical;
  if (!hasLayoutChange) {
    if ("vertical" in updates && updates.vertical === false) {
      const dims2 = calculateTextDimensions(nextNode.text ?? "", {
        family: nextNode.font,
        size: nextNode.fontSize,
        weight: nextNode.fontWeight,
        padding: nextNode.padding,
        isVertical: false
      });
      return { ...updates, ...dims2 };
    }
    if ("vertical" in updates && updates.vertical === true) {
      const fontSize = nextNode.fontSize ?? ptToMm(12);
      const padding = nextNode.padding ?? 10;
      const newH = calculateVerticalTextHeight(nextNode.text ?? "", fontSize, padding);
      return { ...updates, h: newH };
    }
    return updates;
  }
  if (isVertical) {
    const fontSize = nextNode.fontSize ?? ptToMm(12);
    const padding = nextNode.padding ?? 10;
    const newH = calculateVerticalTextHeight(nextNode.text ?? "", fontSize, padding);
    const finalUpdates = { ...updates, h: newH };
    if ("w" in finalUpdates) {
      delete finalUpdates.w;
    }
    return finalUpdates;
  }
  const dims = calculateTextDimensions(nextNode.text ?? "", {
    family: nextNode.font,
    size: nextNode.fontSize,
    weight: nextNode.fontWeight,
    padding: nextNode.padding,
    isVertical: false
  });
  return { ...updates, ...dims };
}

// ../../src/components/canvas/CanvasElementRenderer.tsx
var import_react9 = __toESM(require_react(), 1);

// ../../src/features/vertical-text/utils/glyph-detector.ts
var SMALL_HIRAGANA = "";
var SMALL_KATAKANA = "";
var PUNCTUATION = "";
var ROTATED_SYMBOLS = "";
var OPENING_BRACKETS = "";
var CLOSING_BRACKETS = "";
var isSmallKana = (char) => SMALL_HIRAGANA.includes(char) || SMALL_KATAKANA.includes(char);
var isPunctuation = (char) => PUNCTUATION.includes(char);
var isTopRightAlign = (char) => isSmallKana(char) || isPunctuation(char);
var isRotatedChar = (char) => {
  if (ROTATED_SYMBOLS.includes(char))
    return true;
  return false;
};
var isBracket = (char) => OPENING_BRACKETS.includes(char) || CLOSING_BRACKETS.includes(char);

// ../../src/features/vertical-text/utils/vertical-layout.ts
var TOP_RIGHT_OFFSET_RATIO = 0.55;
function calculateVerticalLayout(text, startX, startY, options) {
  const {
    fontSize,
    columnSpacing = 1.5,
    letterSpacing = 0,
    autoIndent = false,
    indentSize = 1,
    maxHeight
  } = options;
  const result = [];
  const paragraphs = text.split(`
`);
  const columnWidth = fontSize * columnSpacing;
  const charHeight = fontSize * (1 + letterSpacing);
  let currentColumn = 0;
  for (let pIdx = 0;pIdx < paragraphs.length; pIdx++) {
    const paragraph = paragraphs[pIdx];
    const chars = Array.from(paragraph);
    let rowInColumn = 0;
    if (autoIndent && chars.length > 0) {
      rowInColumn = indentSize;
    }
    for (let cIdx = 0;cIdx < chars.length; cIdx++) {
      const char = chars[cIdx];
      let x2 = startX - currentColumn * columnWidth;
      let y = startY + rowInColumn * charHeight;
      if (maxHeight && y + fontSize > startY + maxHeight) {
        currentColumn++;
        rowInColumn = 0;
        x2 = startX - currentColumn * columnWidth;
        y = startY + rowInColumn * charHeight;
      }
      const metric = calculateCharMetric(char, x2, y, fontSize, currentColumn, rowInColumn);
      result.push(metric);
      rowInColumn++;
    }
    currentColumn++;
  }
  return result;
}
function calculateCharMetric(char, baseX, baseY, fontSize, column, row) {
  let offsetX = 0;
  let offsetY = 0;
  let rotation = 0;
  if (isTopRightAlign(char)) {
    offsetX = fontSize * TOP_RIGHT_OFFSET_RATIO;
    offsetY = -fontSize * TOP_RIGHT_OFFSET_RATIO;
  } else if (isRotatedChar(char)) {
    rotation = 90;
  } else if (isBracket(char)) {
    rotation = 90;
  }
  return {
    char,
    x: baseX,
    y: baseY,
    offsetX,
    offsetY,
    rotation,
    column,
    row
  };
}

// ../../src/features/vertical-text/components/VerticalKonvaText.tsx
var jsx_dev_runtime = __toESM(require_jsx_dev_runtime(), 1);
function VerticalKonvaText({ node, visible = true }) {
  const {
    x: x2 = 0,
    y = 0,
    w = 100,
    text,
    fontSize = 16,
    font = "Noto Sans JP",
    fill = "#000000"
  } = node;
  const padding = node.padding !== undefined ? node.padding : 10;
  const COLUMN_SPACING = 1.5;
  const startX = w - padding - fontSize * (COLUMN_SPACING / 2 + 0.5);
  const charMetrics = calculateVerticalLayout(text, startX, padding, {
    fontSize,
    columnSpacing: COLUMN_SPACING,
    letterSpacing: 0
  });
  return /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Group2, {
    x: x2,
    y,
    visible,
    children: charMetrics.map((metric, index) => /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Text2, {
      text: metric.char,
      x: metric.x + metric.offsetX,
      y: metric.y + metric.offsetY,
      fontSize,
      fontFamily: font,
      fill,
      rotation: metric.rotation,
      offsetX: metric.rotation !== 0 ? fontSize / 2 : 0,
      offsetY: metric.rotation !== 0 ? fontSize / 2 : 0,
      width: fontSize,
      height: fontSize,
      align: "center",
      verticalAlign: "middle",
      lineHeight: 1,
      wrap: "none"
    }, `${node.id}-char-${index}`, false, undefined, this))
  }, undefined, false, undefined, this);
}

// ../../src/features/vertical-text/components/VerticalCaret.tsx
var import_react3 = __toESM(require_react(), 1);
var jsx_dev_runtime2 = __toESM(require_jsx_dev_runtime(), 1);
function VerticalCaret({ x: x2, y, width, visible = true }) {
  const [isVisible, setIsVisible] = import_react3.useState(true);
  import_react3.useEffect(() => {
    if (!visible)
      return;
    const interval = setInterval(() => {
      setIsVisible((prev) => !prev);
    }, 530);
    return () => clearInterval(interval);
  }, [visible]);
  if (!visible)
    return null;
  return /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Rect2, {
    x: x2,
    y,
    width,
    height: 1.5,
    fill: isVisible ? "#007AFF" : "transparent",
    listening: false
  }, undefined, false, undefined, this);
}

// ../../src/features/konva-editor/utils/textList.ts
var BULLET_MARKER = "";
var LIST_INDENT_STEP = 2;
var LIST_MARKER_INDENT = 1;
var LIST_MARKER_GAP = 1;
var MAX_LIST_LEVEL = 5;
var clamp = (value, min, max) => Math.min(max, Math.max(min, value));
var getIndentLength = (indent) => indent.replace(/\t/g, "  ").length;
var parseListLine = (line, options = {}) => {
  const match = line.match(/^(\s*)(|(\d+)\.)(\s*)(.*)$/);
  if (!match) {
    return { isList: false, level: 1, content: line, prefixLength: 0, indentLength: 0, gapLength: 0 };
  }
  const indentRaw = match[1] ?? "";
  const marker = match[2] ?? "";
  const spaceAfter = match[4] ?? "";
  const content = match[5] ?? "";
  const type = marker === BULLET_MARKER ? "bullet" : "number";
  const indentLength = getIndentLength(indentRaw);
  const gapLength = getIndentLength(spaceAfter);
  const level = options.vertical ? 1 : clamp(Math.floor(Math.max(indentLength - LIST_MARKER_INDENT, 0) / LIST_INDENT_STEP) + 1, 1, MAX_LIST_LEVEL);
  return {
    isList: true,
    type,
    level,
    content,
    prefixLength: indentRaw.length + marker.length + spaceAfter.length,
    indentLength,
    gapLength,
    markerText: marker
  };
};
var buildListLine = (content, type, level, options = {}) => {
  const safeLevel = options.vertical ? 1 : clamp(level, 1, MAX_LIST_LEVEL);
  const indent = options.vertical ? "" : " ".repeat(LIST_MARKER_INDENT + LIST_INDENT_STEP * (safeLevel - 1));
  const marker = type === "bullet" ? BULLET_MARKER : `${options.number ?? 1}.`;
  const gap = " ".repeat(LIST_MARKER_GAP);
  return `${indent}${marker}${gap}${content}`;
};
var normalizeListText = (text, options = {}) => {
  const lines = text.split(`
`);
  const counters = Array(MAX_LIST_LEVEL).fill(0);
  const normalized = lines.map((line) => {
    const parsed = parseListLine(line, options);
    if (!parsed.isList || !parsed.type) {
      counters.fill(0);
      return line;
    }
    const level = options.vertical ? 1 : parsed.level;
    if (parsed.type === "number") {
      counters[level - 1] += 1;
      for (let i2 = level;i2 < MAX_LIST_LEVEL; i2 += 1)
        counters[i2] = 0;
      return buildListLine(parsed.content, "number", level, { ...options, number: counters[level - 1] });
    }
    counters.fill(0);
    return buildListLine(parsed.content, "bullet", level, options);
  });
  return normalized.join(`
`);
};
var getListTypeFromText = (text, options = {}) => {
  const lines = text.split(`
`);
  let found = null;
  for (const line of lines) {
    const parsed = parseListLine(line, options);
    if (!parsed.isList || !parsed.type)
      continue;
    if (!found) {
      found = parsed.type;
      continue;
    }
    if (found !== parsed.type)
      return null;
  }
  return found;
};
var applyListFormatting = (text, type, options = {}) => {
  const lines = text.split(`
`);
  if (lines.every((line) => line.trim() === "")) {
    return buildListLine("", type, 1, options);
  }
  const withMarkers = lines.map((line) => {
    if (line.trim() === "")
      return line;
    const parsed = parseListLine(line, options);
    const level = options.vertical ? 1 : parsed.isList ? parsed.level : 1;
    const content = parsed.isList ? parsed.content : line;
    return buildListLine(content, type, level, options);
  });
  return normalizeListText(withMarkers.join(`
`), options);
};
var removeListFormatting = (text, options = {}) => {
  const lines = text.split(`
`);
  const cleaned = lines.map((line) => {
    const parsed = parseListLine(line, options);
    if (!parsed.isList)
      return line;
    return parsed.content;
  });
  return cleaned.join(`
`);
};
var getNextListNumber = (text, lineIndex, level, options = {}) => {
  const lines = text.split(`
`);
  const counters = Array(MAX_LIST_LEVEL).fill(0);
  const maxIndex = Math.min(lineIndex, lines.length - 1);
  for (let i2 = 0;i2 <= maxIndex; i2 += 1) {
    const parsed = parseListLine(lines[i2], options);
    if (!parsed.isList || parsed.type !== "number") {
      counters.fill(0);
      continue;
    }
    const lineLevel = options.vertical ? 1 : parsed.level;
    counters[lineLevel - 1] += 1;
    for (let j = lineLevel;j < MAX_LIST_LEVEL; j += 1)
      counters[j] = 0;
  }
  const safeLevel = options.vertical ? 1 : clamp(level, 1, MAX_LIST_LEVEL);
  return counters[safeLevel - 1] + 1;
};

// ../../src/components/canvas/renderers/TextRenderer.tsx
var jsx_dev_runtime3 = __toESM(require_jsx_dev_runtime(), 1);
var TextRenderer = ({
  element,
  commonProps,
  isEditing,
  dragState,
  invScale,
  onToggleCollapse
}) => {
  const {
    text,
    font,
    fontSize,
    fontWeight,
    italic,
    underline,
    lineThrough,
    fill,
    align,
    vAlign,
    stroke,
    strokeW,
    borderColor,
    borderWidth = 0,
    backgroundColor,
    padding = 0,
    cornerRadius = 0,
    hasFrame
  } = element;
  const fontSizeMm = fontSize ?? ptToMm(12);
  const lineHeight = 1.2;
  const numberMarkerScale = 0.75;
  const measureTextMm = (value, sizeMm) => {
    const sizePx = mmToPx(sizeMm, { dpi: 96 });
    const metrics = measureText(value || " ", {
      family: font || "Arial",
      size: sizePx,
      weight: fontWeight
    });
    return pxToMm(metrics.width, { dpi: 96 });
  };
  const renderListLines = (options) => {
    const lines = (text || "").split(`
`);
    const hasList = lines.some((line) => parseListLine(line, { vertical: false }).isList);
    if (!hasList)
      return null;
    return /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(Group2, {
      x: options.offsetX,
      y: options.offsetY,
      visible: options.visible,
      listening: false,
      children: lines.map((line, index) => {
        const parsed = parseListLine(line, { vertical: false });
        if (!parsed.isList || !parsed.type || !parsed.markerText) {
          return /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(Text2, {
            x: options.textX,
            y: options.textY + index * fontSizeMm * lineHeight,
            text: line,
            fontSize: fontSizeMm,
            fontFamily: font,
            fontStyle: `${italic ? "italic " : ""}${fontWeight && fontWeight >= 700 ? "bold" : ""} `.trim() || "normal",
            textDecoration: [underline ? "underline" : "", lineThrough ? "line-through" : ""].filter(Boolean).join(" "),
            fill,
            stroke,
            strokeWidth: strokeW,
            align: align === "l" ? "left" : align === "r" ? "right" : align === "c" ? "center" : "justify",
            verticalAlign: vAlign === "m" ? "middle" : vAlign === "b" ? "bottom" : "top",
            lineHeight,
            width: options.textW,
            listening: false
          }, `line-${index}`, false, undefined, this);
        }
        const indentSpaces = " ".repeat(parsed.indentLength);
        const gapSpaces = " ".repeat(parsed.gapLength);
        const markerSize = parsed.type === "number" ? fontSizeMm * numberMarkerScale : fontSizeMm;
        const markerYOffset = parsed.type === "number" ? (fontSizeMm - markerSize) / 2 : 0;
        const indentWidth = measureTextMm(indentSpaces, fontSizeMm);
        const markerWidth = measureTextMm(parsed.markerText, markerSize);
        const gapWidth = measureTextMm(gapSpaces, fontSizeMm);
        const lineWidth = indentWidth + markerWidth + gapWidth + measureTextMm(parsed.content, fontSizeMm);
        let lineX = options.textX;
        if (align === "c") {
          lineX = options.textX + Math.max(0, (options.textW - lineWidth) / 2);
        } else if (align === "r") {
          lineX = options.textX + Math.max(0, options.textW - lineWidth);
        }
        const baseY = options.textY + index * fontSizeMm * lineHeight;
        return /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(Group2, {
          children: [
            /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(Text2, {
              x: lineX,
              y: baseY,
              text: indentSpaces,
              fontSize: fontSizeMm,
              fontFamily: font,
              fontStyle: `${italic ? "italic " : ""}${fontWeight && fontWeight >= 700 ? "bold" : ""} `.trim() || "normal",
              fill,
              lineHeight,
              listening: false
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(Text2, {
              x: lineX + indentWidth,
              y: baseY + markerYOffset,
              text: parsed.markerText,
              fontSize: markerSize,
              fontFamily: font,
              fontStyle: `${italic ? "italic " : ""}${fontWeight && fontWeight >= 700 ? "bold" : ""} `.trim() || "normal",
              fill,
              lineHeight,
              listening: false
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(Text2, {
              x: lineX + indentWidth + markerWidth,
              y: baseY,
              text: gapSpaces,
              fontSize: fontSizeMm,
              fontFamily: font,
              fontStyle: `${italic ? "italic " : ""}${fontWeight && fontWeight >= 700 ? "bold" : ""} `.trim() || "normal",
              fill,
              lineHeight,
              listening: false
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(Text2, {
              x: lineX + indentWidth + markerWidth + gapWidth,
              y: baseY,
              text: parsed.content,
              fontSize: fontSizeMm,
              fontFamily: font,
              fontStyle: `${italic ? "italic " : ""}${fontWeight && fontWeight >= 700 ? "bold" : ""} `.trim() || "normal",
              textDecoration: [underline ? "underline" : "", lineThrough ? "line-through" : ""].filter(Boolean).join(" "),
              fill,
              stroke,
              strokeWidth: strokeW,
              lineHeight,
              listening: false
            }, undefined, false, undefined, this)
          ]
        }, `list-line-${index}`, true, undefined, this);
      })
    }, undefined, false, undefined, this);
  };
  const shouldShowBox = hasFrame !== undefined ? hasFrame : borderColor || borderWidth && borderWidth > 0 || backgroundColor;
  if (shouldShowBox) {
    const textX = padding;
    const textY = padding;
    const textW = Math.max(0, element.w - padding * 2);
    const textH = Math.max(0, element.h - padding * 2);
    const ratio = Math.max(0, Math.min(1, Number(cornerRadius)));
    const percent = ratio * 0.5;
    const minDim = Math.min(element.w, element.h);
    const actualCornerRadius = minDim * percent;
    const listLayer2 = !element.vertical ? renderListLines({
      offsetX: 0,
      offsetY: 0,
      textX,
      textY,
      textW,
      textH,
      visible: !isEditing
    }) : null;
    return /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(Group2, {
      ...commonProps,
      children: [
        dragState?.dropTargetId === element.id && dragState.canDrop && dragState.dropPosition !== "child" && /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(Line2, {
          points: dragState.dropPosition === "before" ? [0, -4, element.w, -4] : [0, element.h + 4, element.w, element.h + 4],
          stroke: "hsl(217, 91%, 60%)",
          strokeWidth: 4 * invScale,
          strokeCap: "round",
          listening: false
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(Rect2, {
          width: element.w,
          height: element.h,
          fill: backgroundColor,
          stroke: dragState?.dropTargetId === element.id ? dragState.canDrop ? dragState.dropPosition === "child" ? "hsl(142, 70%, 50%)" : borderColor : "hsl(0, 70%, 50%)" : borderColor,
          strokeWidth: dragState?.dropTargetId === element.id && dragState.canDrop ? dragState.dropPosition === "child" ? 3 * invScale : borderWidth : borderWidth,
          cornerRadius: actualCornerRadius
        }, undefined, false, undefined, this),
        dragState?.dropTargetId === element.id && !dragState.canDrop && /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(Path2, {
          x: element.w / 2 - 6,
          y: element.h / 2 - 6,
          data: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z",
          fill: "hsl(0, 70%, 50%)",
          scaleX: invScale,
          scaleY: invScale,
          opacity: 0.8,
          listening: false
        }, undefined, false, undefined, this),
        element.vertical ? /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(jsx_dev_runtime3.Fragment, {
          children: [
            /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(VerticalKonvaText, {
              node: { ...element, x: textX, y: textY },
              visible: true
            }, undefined, false, undefined, this),
            isEditing && (() => {
              const caretFontSize = fontSize || 16;
              const caretPadding = padding;
              const columnSpacing = 1.5;
              const startX = textW - caretFontSize * (columnSpacing / 2 + 0.5);
              const lines = (text || "").split(`
`);
              const columnIndex = lines.length - 1;
              const currentLineLength = lines.length > 0 ? Array.from(lines[lines.length - 1] || "").length : 0;
              const caretX = textX + startX - columnIndex * (caretFontSize * columnSpacing);
              const caretY = textY + caretPadding + currentLineLength * caretFontSize;
              return /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(VerticalCaret, {
                x: caretX - caretFontSize / 2,
                y: caretY,
                width: caretFontSize,
                visible: true
              }, undefined, false, undefined, this);
            })()
          ]
        }, undefined, true, undefined, this) : /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(jsx_dev_runtime3.Fragment, {
          children: [
            listLayer2,
            /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(Text2, {
              x: textX,
              y: textY,
              width: textW,
              height: textH,
              text,
              fontSize,
              fontFamily: font,
              fontStyle: `${italic ? "italic " : ""}${fontWeight && fontWeight >= 700 ? "bold" : ""} `.trim() || "normal",
              textDecoration: [underline ? "underline" : "", lineThrough ? "line-through" : ""].filter(Boolean).join(" "),
              fill,
              stroke,
              strokeWidth: strokeW,
              align: align === "l" ? "left" : align === "r" ? "right" : align === "c" ? "center" : "justify",
              verticalAlign: vAlign === "m" ? "middle" : vAlign === "b" ? "bottom" : "top",
              lineHeight,
              listening: false,
              visible: !listLayer2 && !isEditing
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this),
        element.data?.hasChildren && onToggleCollapse && (() => {
          const isCollapsed = !!element.data.isCollapsed;
          const buttonColor = isCollapsed ? "#22c55e" : "#ef4444";
          return /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(Group2, {
            x: element.w,
            y: 0,
            onMouseDown: (e) => {
              e.cancelBubble = true;
              onToggleCollapse(element.id);
            },
            onTap: (e) => {
              e.cancelBubble = true;
              onToggleCollapse(element.id);
            },
            onMouseEnter: (e) => {
              const container = e.target.getStage()?.container();
              if (container)
                container.style.cursor = "pointer";
            },
            onMouseLeave: (e) => {
              const container = e.target.getStage()?.container();
              if (container)
                container.style.cursor = "default";
            },
            children: [
              /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(Circle2, {
                radius: 8 * invScale,
                fill: "#ffffff",
                stroke: buttonColor,
                strokeWidth: 1.5 * invScale,
                shadowColor: "#000000",
                shadowBlur: 3 * invScale,
                shadowOpacity: 0.15
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(Path2, {
                x: -4 * invScale,
                y: -4 * invScale,
                width: 8 * invScale,
                height: 8 * invScale,
                data: isCollapsed ? "M4 1.5v5M1.5 4h5" : "M1.5 4h5",
                stroke: buttonColor,
                strokeWidth: 1.5,
                scale: { x: invScale, y: invScale },
                listening: false,
                lineCap: "round"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this);
        })()
      ]
    }, undefined, true, undefined, this);
  }
  if (element.vertical) {
    const caretFontSize = fontSize || 16;
    const padding2 = element.padding || 10;
    const columnSpacing = 1.5;
    const lines = (text || "").split(`
`);
    const currentLineLength = lines.length > 0 ? Array.from(lines[lines.length - 1] || "").length : 0;
    const startX = (element.w || 100) - padding2 - caretFontSize * (columnSpacing / 2 + 0.5);
    const columnIndex = lines.length - 1;
    const caretX = startX - columnIndex * (caretFontSize * columnSpacing);
    const caretY = padding2 + currentLineLength * caretFontSize;
    return /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(Group2, {
      ...commonProps,
      onMouseEnter: (e) => {
        if (isEditing) {
          const container = e.target.getStage()?.container();
          if (container)
            container.style.cursor = "vertical-text";
        }
      },
      onMouseLeave: (e) => {
        const container = e.target.getStage()?.container();
        if (container)
          container.style.cursor = "default";
      },
      children: [
        /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(VerticalKonvaText, {
          node: { ...element, x: 0, y: 0 },
          visible: true
        }, undefined, false, undefined, this),
        isEditing && /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(VerticalCaret, {
          x: caretX - caretFontSize / 2,
          y: caretY,
          width: caretFontSize,
          visible: true
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this);
  }
  const listLayer = !element.vertical ? renderListLines({
    offsetX: 0,
    offsetY: 0,
    textX: 0,
    textY: 0,
    textW: element.w,
    textH: element.h,
    visible: !isEditing
  }) : null;
  return /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(Group2, {
    ...commonProps,
    children: [
      listLayer,
      /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(Text2, {
        x: 0,
        y: 0,
        height: element.h,
        text,
        fontSize,
        fontFamily: font,
        fontStyle: `${italic ? "italic " : ""}${fontWeight && fontWeight >= 700 ? "bold" : ""} `.trim() || "normal",
        textDecoration: [underline ? "underline" : "", lineThrough ? "line-through" : ""].filter(Boolean).join(" "),
        fill,
        stroke,
        strokeWidth: strokeW,
        align: align === "l" ? "left" : align === "r" ? "right" : align === "c" ? "center" : "justify",
        verticalAlign: vAlign === "m" ? "middle" : vAlign === "b" ? "bottom" : "top",
        lineHeight,
        width: element.w,
        opacity: listLayer ? 0 : 1,
        visible: !isEditing
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/components/canvas/renderers/ShapeRenderer.tsx
var jsx_dev_runtime4 = __toESM(require_jsx_dev_runtime(), 1);
var ShapeRenderer = ({
  element,
  commonProps
}) => {
  const shape = element;
  switch (shape.shape) {
    case "rect":
      return /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Rect2, {
        ...commonProps,
        fill: shape.fill,
        stroke: shape.stroke,
        strokeWidth: shape.strokeW,
        cornerRadius: shape.radius
      }, undefined, false, undefined, this);
    case "circle":
      return /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Ellipse2, {
        ...commonProps,
        x: (shape.x || 0) + (shape.w || 0) / 2,
        y: (shape.y || 0) + (shape.h || 0) / 2,
        radiusX: (shape.w || 0) / 2,
        radiusY: (shape.h || 0) / 2,
        fill: shape.fill,
        stroke: shape.stroke,
        strokeWidth: shape.strokeW
      }, undefined, false, undefined, this);
    case "triangle":
      return /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Line2, {
        ...commonProps,
        points: [shape.w / 2, 0, shape.w, shape.h, 0, shape.h],
        closed: true,
        fill: shape.fill,
        stroke: shape.stroke,
        strokeWidth: shape.strokeW
      }, undefined, false, undefined, this);
    case "diamond":
      return /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Line2, {
        ...commonProps,
        points: [
          shape.w / 2,
          0,
          shape.w,
          shape.h / 2,
          shape.w / 2,
          shape.h,
          0,
          shape.h / 2
        ],
        closed: true,
        fill: shape.fill,
        stroke: shape.stroke,
        strokeWidth: shape.strokeW
      }, undefined, false, undefined, this);
    case "star":
      return /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Star2, {
        ...commonProps,
        x: (shape.x || 0) + shape.w / 2,
        y: (shape.y || 0) + shape.h / 2,
        numPoints: 5,
        innerRadius: Math.min(shape.w, shape.h) / 4,
        outerRadius: Math.min(shape.w, shape.h) / 2,
        fill: shape.fill,
        stroke: shape.stroke,
        strokeWidth: shape.strokeW
      }, undefined, false, undefined, this);
    case "trapezoid": {
      const w = shape.w;
      const h2 = shape.h;
      return /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Line2, {
        ...commonProps,
        points: [w * 0.2, 0, w * 0.8, 0, w, h2, 0, h2],
        closed: true,
        fill: shape.fill,
        stroke: shape.stroke,
        strokeWidth: shape.strokeW
      }, undefined, false, undefined, this);
    }
    case "cylinder": {
      const w = shape.w;
      const h2 = shape.h;
      const topH = Math.min(h2 * 0.2, 20);
      const rX = w / 2;
      const rY = topH / 2;
      return /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Group2, {
        ...commonProps,
        children: [
          /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Path2, {
            data: `M 0,${rY} L 0,${h2 - rY} A ${rX},${rY} 0 0 0 ${w},${h2 - rY} L ${w},${rY}`,
            fill: shape.fill,
            stroke: shape.stroke,
            strokeWidth: shape.strokeW
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Ellipse2, {
            x: rX,
            y: rY,
            radiusX: rX,
            radiusY: rY,
            fill: shape.fill,
            stroke: shape.stroke,
            strokeWidth: shape.strokeW
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this);
    }
    case "cone": {
      const baseH = Math.min(shape.h * 0.2, 20);
      return /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Group2, {
        ...commonProps,
        children: [
          /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Line2, {
            points: [shape.w / 2, 0, shape.w, shape.h - baseH / 2, 0, shape.h - baseH / 2],
            closed: true,
            fill: shape.fill,
            stroke: shape.stroke,
            strokeWidth: shape.strokeW
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Ellipse2, {
            x: shape.w / 2,
            y: shape.h - baseH / 2,
            radiusX: shape.w / 2,
            radiusY: baseH / 2,
            fill: shape.fill,
            stroke: shape.stroke,
            strokeWidth: shape.strokeW
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this);
    }
    case "heart":
      return /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Path2, {
        ...commonProps,
        data: "M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z",
        fill: shape.fill,
        stroke: shape.stroke,
        strokeWidth: shape.strokeW,
        scaleX: shape.w / 24,
        scaleY: shape.h / 24
      }, undefined, false, undefined, this);
    case "pentagon":
      return /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Line2, {
        ...commonProps,
        x: (shape.x || 0) + shape.w / 2,
        y: (shape.y || 0) + shape.h / 2,
        points: [
          0,
          -shape.h / 2,
          shape.w / 2,
          -shape.h * 0.12,
          shape.w * 0.31,
          shape.h / 2,
          -shape.w * 0.31,
          shape.h / 2,
          -shape.w / 2,
          -shape.h * 0.12
        ],
        closed: true,
        fill: shape.fill,
        stroke: shape.stroke,
        strokeWidth: shape.strokeW
      }, undefined, false, undefined, this);
    case "hexagon":
      return /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Line2, {
        ...commonProps,
        x: (shape.x || 0) + shape.w / 2,
        y: (shape.y || 0) + shape.h / 2,
        points: [
          -shape.w * 0.25,
          -shape.h / 2,
          shape.w * 0.25,
          -shape.h / 2,
          shape.w / 2,
          0,
          shape.w * 0.25,
          shape.h / 2,
          -shape.w * 0.25,
          shape.h / 2,
          -shape.w / 2,
          0
        ],
        closed: true,
        fill: shape.fill,
        stroke: shape.stroke,
        strokeWidth: shape.strokeW
      }, undefined, false, undefined, this);
    case "arrow-u":
      return /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Path2, {
        ...commonProps,
        data: "M12 4l-8 8h6v8h4v-8h6z",
        fill: shape.fill,
        stroke: shape.stroke,
        strokeWidth: shape.strokeW,
        scaleX: shape.w / 24,
        scaleY: shape.h / 24
      }, undefined, false, undefined, this);
    case "arrow-d":
      return /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Path2, {
        ...commonProps,
        data: "M12 20l-8-8h6v-8h4v8h6z",
        fill: shape.fill,
        stroke: shape.stroke,
        strokeWidth: shape.strokeW,
        scaleX: shape.w / 24,
        scaleY: shape.h / 24
      }, undefined, false, undefined, this);
    case "arrow-l":
      return /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Path2, {
        ...commonProps,
        data: "M4 12l8-8v6h8v4h-8v6z",
        fill: shape.fill,
        stroke: shape.stroke,
        strokeWidth: shape.strokeW,
        scaleX: shape.w / 24,
        scaleY: shape.h / 24
      }, undefined, false, undefined, this);
    case "arrow-r":
      return /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Path2, {
        ...commonProps,
        data: "M20 12l-8-8v6h-8v4h8v6z",
        fill: shape.fill,
        stroke: shape.stroke,
        strokeWidth: shape.strokeW,
        scaleX: shape.w / 24,
        scaleY: shape.h / 24
      }, undefined, false, undefined, this);
    case "house":
      return /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Path2, {
        ...commonProps,
        data: "M12 3L2 12h3v8h6v-6h2v6h6v-8h3L12 3z",
        fill: shape.fill,
        stroke: shape.stroke,
        strokeWidth: shape.strokeW,
        scaleX: shape.w / 24,
        scaleY: shape.h / 24
      }, undefined, false, undefined, this);
    default:
      return /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(Rect2, {
        ...commonProps,
        fill: shape.fill,
        stroke: shape.stroke
      }, undefined, false, undefined, this);
  }
};

// ../../src/components/canvas/renderers/LineRenderer.tsx
var import_react4 = __toESM(require_react(), 1);

// ../../src/components/canvas/LineMarker.tsx
var jsx_dev_runtime5 = __toESM(require_jsx_dev_runtime(), 1);
var LineMarker = ({
  x: x2,
  y,
  angle,
  type,
  color,
  size = 10,
  id
}) => {
  if (type === "none")
    return null;
  const commonProps = {
    id,
    x: x2,
    y,
    rotation: angle * 180 / Math.PI,
    fill: color,
    stroke: color,
    strokeWidth: 1
  };
  switch (type) {
    case "arrow":
    case "standard":
    case "open":
      return /* @__PURE__ */ jsx_dev_runtime5.jsxDEV(Line2, {
        ...commonProps,
        points: [-size, -size / 2, 0, 0, -size, size / 2],
        closed: false,
        fillEnabled: false,
        strokeWidth: 2
      }, undefined, false, undefined, this);
    case "triangle":
    case "filled":
      return /* @__PURE__ */ jsx_dev_runtime5.jsxDEV(Line2, {
        ...commonProps,
        points: [-size, -size / 2, 0, 0, -size, size / 2],
        closed: true,
        strokeWidth: 1
      }, undefined, false, undefined, this);
    case "circle":
      return /* @__PURE__ */ jsx_dev_runtime5.jsxDEV(Circle2, {
        ...commonProps,
        radius: size / 3,
        offsetX: size / 3
      }, undefined, false, undefined, this);
    case "diamond":
      return /* @__PURE__ */ jsx_dev_runtime5.jsxDEV(RegularPolygon2, {
        ...commonProps,
        sides: 4,
        radius: size / 2,
        offsetX: size / 2
      }, undefined, false, undefined, this);
    case "square":
      return /* @__PURE__ */ jsx_dev_runtime5.jsxDEV(Rect2, {
        ...commonProps,
        width: size * 0.6,
        height: size * 0.6,
        offsetX: size * 0.6,
        offsetY: size * 0.6 / 2,
        strokeWidth: 1
      }, undefined, false, undefined, this);
    default:
      return null;
  }
};

// ../../src/components/canvas/utils/connectionRouting.ts
var STUB_LENGTH = 20;
var getAnchorPointAndDirection = (geo, anchor) => {
  let x2 = geo.x;
  let y = geo.y;
  const w = geo.w;
  const h2 = geo.h;
  let nx = 0;
  let ny = 0;
  switch (anchor) {
    case "t":
      x2 += w / 2;
      ny = -1;
      break;
    case "b":
      x2 += w / 2;
      y += h2;
      ny = 1;
      break;
    case "l":
      y += h2 / 2;
      nx = -1;
      break;
    case "r":
      x2 += w;
      y += h2 / 2;
      nx = 1;
      break;
    case "tl":
      nx = -1;
      ny = -1;
      break;
    case "tr":
      x2 += w;
      nx = 1;
      ny = -1;
      break;
    case "bl":
      y += h2;
      nx = -1;
      ny = 1;
      break;
    case "br":
      x2 += w;
      y += h2;
      nx = 1;
      ny = 1;
      break;
    default:
      x2 += w / 2;
      y += h2 / 2;
      break;
  }
  return { x: x2, y, nx, ny };
};
var getOrthogonalConnectionPath = (startGeo, startAnchor, endGeo, endAnchor) => {
  let s = getAnchorPointAndDirection(startGeo, startAnchor);
  let e = getAnchorPointAndDirection(endGeo, endAnchor);
  const resolveDiagonal = (current, target) => {
    if (current.nx !== 0 && current.ny !== 0) {
      const dx = target.x - current.x;
      const dy = target.y - current.y;
      const matchX = dx >= 0 && current.nx > 0 || dx < 0 && current.nx < 0;
      const matchY = dy >= 0 && current.ny > 0 || dy < 0 && current.ny < 0;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (matchX)
          return { ...current, ny: 0 };
        if (matchY)
          return { ...current, nx: 0 };
        return { ...current, ny: 0 };
      } else {
        if (matchY)
          return { ...current, nx: 0 };
        if (matchX)
          return { ...current, ny: 0 };
        return { ...current, nx: 0 };
      }
    }
    return current;
  };
  s = resolveDiagonal(s, { x: e.x, y: e.y });
  e = resolveDiagonal(e, { x: s.x, y: s.y });
  const p0 = { x: s.x, y: s.y };
  const p1 = { x: s.x + s.nx * STUB_LENGTH, y: s.y + s.ny * STUB_LENGTH };
  const pE = { x: e.x, y: e.y };
  const pE_stub = { x: e.x + e.nx * STUB_LENGTH, y: e.y + e.ny * STUB_LENGTH };
  const path = computeOrthogonalSegments(p1, pE_stub, s.nx, s.ny, e.nx, e.ny);
  const points = [p0.x, p0.y];
  path.forEach((p2) => {
    points.push(p2.x, p2.y);
  });
  points.push(pE.x, pE.y);
  return points;
};
function computeOrthogonalSegments(a2, b2, startDirX, startDirY, endDirX, endDirY) {
  const dx = b2.x - a2.x;
  const dy = b2.y - a2.y;
  const midX = (a2.x + b2.x) / 2;
  const midY = (a2.y + b2.y) / 2;
  if (Math.abs(startDirX) > 0) {
    const goingCheck = startDirX * dx >= 0;
    const points = [a2];
    if (Math.abs(endDirX) > 0) {
      if (goingCheck) {
        points.push({ x: midX, y: a2.y });
        points.push({ x: midX, y: b2.y });
      } else {
        points.push({ x: a2.x, y: midY });
        points.push({ x: b2.x, y: midY });
      }
    } else {
      points.push({ x: b2.x, y: a2.y });
    }
    points.push(b2);
    return points;
  } else {
    const goingCheck = startDirY * dy >= 0;
    const points = [a2];
    if (Math.abs(endDirY) > 0) {
      if (goingCheck) {
        points.push({ x: a2.x, y: midY });
        points.push({ x: b2.x, y: midY });
      } else {
        points.push({ x: midX, y: a2.y });
        points.push({ x: midX, y: b2.y });
      }
    } else {
      points.push({ x: a2.x, y: b2.y });
    }
    points.push(b2);
    return points;
  }
}
var getOrthogonalPath = (start, startDir, end, endDir) => {
  let dirE = endDir;
  if (!dirE) {
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    if (Math.abs(dx) > Math.abs(dy)) {
      dirE = { x: dx > 0 ? -1 : 1, y: 0 };
    } else {
      dirE = { x: 0, y: dy > 0 ? -1 : 1 };
    }
  }
  const points = computeOrthogonalSegments(start, end, startDir.x, startDir.y, dirE.x, dirE.y);
  const flatPoints = [];
  points.forEach((p2) => {
    flatPoints.push(p2.x, p2.y);
  });
  return flatPoints;
};

// ../../src/components/canvas/utils/elementUtils.ts
var isWHElement = (node) => {
  return node.t !== "line";
};

// ../../src/components/canvas/renderers/LineRenderer.tsx
var jsx_dev_runtime6 = __toESM(require_jsx_dev_runtime(), 1);
var LineRenderer = ({
  element,
  commonProps,
  isSelected,
  readOnly,
  allElements,
  showGrid,
  gridSize = 15,
  snapStrength = 5,
  invScale,
  onChange
}) => {
  const line = element;
  const nodesForSnap = (allElements || []).filter((n) => n.id !== line.id);
  const isLineHandleDraggingRef = import_react4.useRef(false);
  const lineVisualRef = import_react4.useRef(null);
  const lineStartHandleRef = import_react4.useRef(null);
  const lineEndHandleRef = import_react4.useRef(null);
  const lineStartMarkerGroupRef = import_react4.useRef(null);
  const lineEndMarkerGroupRef = import_react4.useRef(null);
  const lineDraftPtsRef = import_react4.useRef(null);
  const anchorOverlayGroupRef = import_react4.useRef(null);
  const anchorCircleMapRef = import_react4.useRef(new Map);
  const lastHighlightedAnchorKeyRef = import_react4.useRef(null);
  const startConnDraftRef = import_react4.useRef(undefined);
  const endConnDraftRef = import_react4.useRef(undefined);
  const anchors = ["tl", "t", "tr", "l", "r", "bl", "b", "br"];
  const getAnchorPoint = (n, anchor) => {
    if (n.t === "line")
      return null;
    if (n.x === undefined || n.y === undefined || n.w === undefined || n.h === undefined)
      return null;
    const x2 = n.x;
    const y = n.y;
    const w = n.w;
    const h2 = n.h;
    switch (anchor) {
      case "tl":
        return { x: x2, y };
      case "t":
        return { x: x2 + w / 2, y };
      case "tr":
        return { x: x2 + w, y };
      case "l":
        return { x: x2, y: y + h2 / 2 };
      case "r":
        return { x: x2 + w, y: y + h2 / 2 };
      case "bl":
        return { x: x2, y: y + h2 };
      case "b":
        return { x: x2 + w / 2, y: y + h2 };
      case "br":
        return { x: x2 + w, y: y + h2 };
      default:
        return { x: x2 + w / 2, y: y + h2 / 2 };
    }
  };
  const resolveEndpoint = (conn) => {
    if (!conn)
      return null;
    const target = nodesForSnap.find((n) => n.id === conn.nodeId);
    if (!target)
      return null;
    return getAnchorPoint(target, conn.anchor);
  };
  const basePts = line.pts || [0, 0, 100, 0];
  const resolvedStart = resolveEndpoint(line.startConn);
  const resolvedEnd = resolveEndpoint(line.endConn);
  const pts = [...basePts];
  if (resolvedStart) {
    pts[0] = resolvedStart.x;
    pts[1] = resolvedStart.y;
  }
  if (resolvedEnd) {
    pts[pts.length - 2] = resolvedEnd.x;
    pts[pts.length - 1] = resolvedEnd.y;
  }
  const snapStep = showGrid && gridSize > 0 ? gridSize : snapStrength > 0 ? snapStrength : 0;
  const snapToGrid = (pos) => {
    if (!snapStep)
      return pos;
    return {
      x: Math.round(pos.x / snapStep) * snapStep,
      y: Math.round(pos.y / snapStep) * snapStep
    };
  };
  const snapAngle = (moving, fixed, step) => {
    const dx = moving.x - fixed.x;
    const dy = moving.y - fixed.y;
    const angle = Math.atan2(dy, dx);
    const dist = Math.sqrt(dx * dx + dy * dy);
    const snapAngle2 = Math.round(angle / step) * step;
    return {
      x: fixed.x + Math.cos(snapAngle2) * dist,
      y: fixed.y + Math.sin(snapAngle2) * dist
    };
  };
  const applyDraftToVisuals = (draftPts) => {
    const endIdx = Math.max(0, draftPts.length - 2);
    lineVisualRef.current?.points(draftPts);
    lineStartHandleRef.current?.position({ x: draftPts[0], y: draftPts[1] });
    lineEndHandleRef.current?.position({ x: draftPts[endIdx], y: draftPts[endIdx + 1] });
    const dx = draftPts[endIdx] - draftPts[0];
    const dy = draftPts[endIdx + 1] - draftPts[1];
    const angleToEnd = Math.atan2(dy, dx);
    const angleToStart = angleToEnd + Math.PI;
    if (lineStartMarkerGroupRef.current) {
      lineStartMarkerGroupRef.current.position({ x: draftPts[0], y: draftPts[1] });
      lineStartMarkerGroupRef.current.rotation(angleToStart * 180 / Math.PI);
    }
    if (lineEndMarkerGroupRef.current) {
      lineEndMarkerGroupRef.current.position({ x: draftPts[endIdx], y: draftPts[endIdx + 1] });
      lineEndMarkerGroupRef.current.rotation(angleToEnd * 180 / Math.PI);
    }
    lineVisualRef.current?.getLayer()?.batchDraw();
  };
  const startHandleDrag = (e) => {
    isLineHandleDraggingRef.current = true;
    lineDraftPtsRef.current = [...pts];
    startConnDraftRef.current = line.startConn;
    endConnDraftRef.current = line.endConn;
    if (anchorOverlayGroupRef.current) {
      anchorOverlayGroupRef.current.visible(true);
    }
    const group = e.target.getParent();
    if (group)
      group.draggable(false);
    e.cancelBubble = true;
  };
  const moveHandleDrag = (handleType, e) => {
    const base = lineDraftPtsRef.current || [...pts];
    const pointIndex = handleType === "start" ? 0 : base.length - 2;
    let nextPos = { x: e.target.x(), y: e.target.y() };
    let refPoint = { x: 0, y: 0 };
    if (pointIndex === 0)
      refPoint = { x: base[2], y: base[3] };
    else
      refPoint = { x: base[pointIndex - 2], y: base[pointIndex - 1] };
    const isOrthogonal = line.routing === "orthogonal";
    const isShift = e.evt.shiftKey;
    let newPts = [...base];
    if (isOrthogonal && !isShift) {
      nextPos = snapToGrid(nextPos);
    } else if (isShift) {
      const step = Math.PI / 4;
      nextPos = snapAngle(nextPos, refPoint, step);
    } else {
      nextPos = snapToGrid(nextPos);
    }
    const threshold = 12 * invScale;
    const showMargin = 80 * invScale;
    let best = null;
    const activeFill = "#059669";
    const baseStroke = "#0f766e";
    if (anchorOverlayGroupRef.current) {
      for (const circle of anchorCircleMapRef.current.values()) {
        circle.visible(false);
        circle.radius(5 * invScale);
        circle.fill("#ffffff");
        circle.stroke(baseStroke);
        circle.strokeWidth(2 * invScale);
        circle.opacity(0.95);
      }
      lastHighlightedAnchorKeyRef.current = null;
    }
    if (pointIndex === 0 || pointIndex === base.length - 2) {
      for (const n of nodesForSnap) {
        if (n.t === "line")
          continue;
        const nx = n.x ?? 0, ny = n.y ?? 0, nw = n.w ?? 0, nh = n.h ?? 0;
        if (nextPos.x < nx - showMargin || nextPos.x > nx + nw + showMargin || nextPos.y < ny - showMargin || nextPos.y > ny + nh + showMargin)
          continue;
        const isSmall = nw < 15 || nh < 15;
        for (const a2 of anchors) {
          if (isSmall && ["tl", "tr", "bl", "br"].includes(a2))
            continue;
          const p2 = getAnchorPoint(n, a2);
          if (!p2)
            continue;
          const key = `${n.id}:${a2} `;
          const circle = anchorCircleMapRef.current.get(key);
          if (circle)
            circle.visible(true);
          const dx = p2.x - nextPos.x;
          const dy = p2.y - nextPos.y;
          const d2 = dx * dx + dy * dy;
          if (d2 <= threshold * threshold && (!best || d2 < best.dist2)) {
            best = { nodeId: n.id, anchor: a2, x: p2.x, y: p2.y, dist2: d2 };
          }
        }
      }
    }
    if (best) {
      nextPos = { x: best.x, y: best.y };
      if (pointIndex === 0)
        startConnDraftRef.current = { nodeId: best.nodeId, anchor: best.anchor };
      else if (pointIndex === base.length - 2)
        endConnDraftRef.current = { nodeId: best.nodeId, anchor: best.anchor };
      const key = `${best.nodeId}:${best.anchor} `;
      const circle = anchorCircleMapRef.current.get(key);
      if (circle) {
        circle.visible(true);
        circle.radius(9 * invScale);
        circle.fill(activeFill);
      }
    } else {
      if (pointIndex === 0)
        startConnDraftRef.current = null;
      else if (pointIndex === base.length - 2)
        endConnDraftRef.current = null;
    }
    e.target.position(nextPos);
    if (isOrthogonal && !isShift) {
      const isStart = pointIndex === 0;
      const pStart = isStart ? nextPos : { x: base[0], y: base[1] };
      const pEnd = isStart ? { x: base[base.length - 2], y: base[base.length - 1] } : nextPos;
      const getDir = (conn) => {
        if (!conn)
          return null;
        const node = nodesForSnap.find((n) => n.id === conn.nodeId);
        if (!node)
          return null;
        if (!isWHElement(node))
          return null;
        const geo = { x: node.x, y: node.y, w: node.w, h: node.h, r: node.r };
        const info = getAnchorPointAndDirection(geo, conn.anchor);
        return { x: info.nx, y: info.ny };
      };
      const startDirInfo = getDir(startConnDraftRef.current || undefined);
      const endDirInfo = getDir(endConnDraftRef.current || undefined);
      const computedPath = getOrthogonalPath(pStart, startDirInfo || { x: 0, y: 0 }, pEnd, endDirInfo);
      if (computedPath.length > 0)
        newPts = computedPath;
    } else {
      newPts[pointIndex] = nextPos.x;
      newPts[pointIndex + 1] = nextPos.y;
    }
    lineDraftPtsRef.current = newPts;
    applyDraftToVisuals(newPts);
    e.cancelBubble = true;
  };
  const endHandleDrag = (e) => {
    e.cancelBubble = true;
    const next = lineDraftPtsRef.current;
    const group = e.target.getParent();
    if (group)
      group.draggable((readOnly ? false : !element.locked) && isSelected);
    if (anchorOverlayGroupRef.current) {
      anchorOverlayGroupRef.current.visible(false);
    }
    if (next) {
      const updated = {
        id: element.id,
        pts: next
      };
      if (startConnDraftRef.current !== undefined) {
        updated.startConn = startConnDraftRef.current ?? undefined;
      }
      if (endConnDraftRef.current !== undefined) {
        updated.endConn = endConnDraftRef.current ?? undefined;
      }
      onChange(updated);
    }
    setTimeout(() => {
      isLineHandleDraggingRef.current = false;
      lineDraftPtsRef.current = null;
      startConnDraftRef.current = undefined;
      endConnDraftRef.current = undefined;
    }, 0);
  };
  return /* @__PURE__ */ jsx_dev_runtime6.jsxDEV(Group2, {
    id: element.id,
    x: 0,
    y: 0,
    draggable: (readOnly ? false : !element.locked) && isSelected,
    onDragStart: commonProps.onDragStart,
    onDragEnd: (e) => {
      if (isLineHandleDraggingRef.current) {
        e.target.position({ x: 0, y: 0 });
        return;
      }
      const node = e.target;
      const dx = node.x();
      const dy = node.y();
      if (dx !== 0 || dy !== 0) {
        const newPts = pts.map((p2, i2) => i2 % 2 === 0 ? p2 + dx : p2 + dy);
        onChange({
          id: element.id,
          pts: newPts,
          startConn: undefined,
          endConn: undefined
        });
      }
      node.position({ x: 0, y: 0 });
    },
    onMouseDown: commonProps.onMouseDown,
    onTap: commonProps.onTap,
    onMouseEnter: commonProps.onMouseEnter,
    onMouseLeave: commonProps.onMouseLeave,
    dragBoundFunc: commonProps.dragBoundFunc,
    ref: commonProps.ref,
    children: [
      isSelected && !readOnly && /* @__PURE__ */ jsx_dev_runtime6.jsxDEV(Group2, {
        ref: (node) => {
          anchorOverlayGroupRef.current = node;
        },
        visible: false,
        listening: false,
        children: nodesForSnap.flatMap((n) => anchors.map((a2) => {
          const p2 = getAnchorPoint(n, a2);
          if (!p2)
            return null;
          const key = `${n.id}:${a2} `;
          return /* @__PURE__ */ jsx_dev_runtime6.jsxDEV(Circle2, {
            x: p2.x,
            y: p2.y,
            radius: 5 * invScale,
            fill: "#ffffff",
            stroke: "#0f766e",
            strokeWidth: 2 * invScale,
            opacity: 0.95,
            shadowColor: "#34d399",
            shadowBlur: 10 * invScale,
            shadowOpacity: 0.18,
            shadowEnabled: true,
            visible: false,
            ref: (node) => {
              if (node)
                anchorCircleMapRef.current.set(key, node);
              else
                anchorCircleMapRef.current.delete(key);
            }
          }, `anchor - ${key} `, false, undefined, this);
        }))
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime6.jsxDEV(Line2, {
        ref: (node) => {
          lineVisualRef.current = node;
        },
        name: "line-body",
        points: pts,
        stroke: line.stroke || "#000000",
        strokeWidth: line.strokeW ?? 0.2,
        dash: line.dash,
        lineCap: "round",
        lineJoin: "round",
        hitStrokeWidth: 20 * invScale,
        draggable: false
      }, undefined, false, undefined, this),
      (() => {
        const endIdx = Math.max(0, pts.length - 2);
        const dx = pts[endIdx] - pts[0];
        const dy = pts[endIdx + 1] - pts[1];
        const angleToEnd = Math.atan2(dy, dx);
        const angleToStart = angleToEnd + Math.PI;
        const startType = line.arrows?.[0] || "none";
        const endType = line.arrows?.[1] || "none";
        const color = line.stroke || "#000000";
        const size = Math.max(8 * invScale, (line.strokeW ?? 0.2) * 4);
        return /* @__PURE__ */ jsx_dev_runtime6.jsxDEV(jsx_dev_runtime6.Fragment, {
          children: [
            /* @__PURE__ */ jsx_dev_runtime6.jsxDEV(Group2, {
              ref: (node) => {
                lineStartMarkerGroupRef.current = node;
              },
              name: "line-marker-start",
              x: pts[0],
              y: pts[1],
              rotation: angleToStart * 180 / Math.PI,
              listening: false,
              children: /* @__PURE__ */ jsx_dev_runtime6.jsxDEV(LineMarker, {
                x: 0,
                y: 0,
                angle: 0,
                type: startType,
                color,
                size
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime6.jsxDEV(Group2, {
              ref: (node) => {
                lineEndMarkerGroupRef.current = node;
              },
              name: "line-marker-end",
              x: pts[endIdx],
              y: pts[endIdx + 1],
              rotation: angleToEnd * 180 / Math.PI,
              listening: false,
              children: /* @__PURE__ */ jsx_dev_runtime6.jsxDEV(LineMarker, {
                x: 0,
                y: 0,
                angle: 0,
                type: endType,
                color,
                size
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this);
      })(),
      isSelected && !readOnly && !element.locked && (() => {
        return /* @__PURE__ */ jsx_dev_runtime6.jsxDEV(jsx_dev_runtime6.Fragment, {
          children: [
            /* @__PURE__ */ jsx_dev_runtime6.jsxDEV(Circle2, {
              ref: (node) => {
                lineStartHandleRef.current = node;
              },
              name: "line-handle-start",
              x: pts[0],
              y: pts[1],
              radius: 6 * invScale,
              fill: "#ffffff",
              stroke: "#3b82f6",
              strokeWidth: 2 * invScale,
              draggable: true,
              onDragStart: startHandleDrag,
              onDragMove: (e) => moveHandleDrag("start", e),
              onDragEnd: endHandleDrag,
              onMouseDown: (e) => {
                e.cancelBubble = true;
              }
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime6.jsxDEV(Circle2, {
              ref: (node) => {
                lineEndHandleRef.current = node;
              },
              name: "line-handle-end",
              x: pts[pts.length - 2],
              y: pts[pts.length - 1],
              radius: 6 * invScale,
              fill: "#ffffff",
              stroke: "#3b82f6",
              strokeWidth: 2 * invScale,
              draggable: true,
              onDragStart: startHandleDrag,
              onDragMove: (e) => moveHandleDrag("end", e),
              onDragEnd: endHandleDrag,
              onMouseDown: (e) => {
                e.cancelBubble = true;
              }
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this);
      })()
    ]
  }, undefined, true, undefined, this);
};

// ../../src/components/canvas/renderers/TableRenderer.tsx
var jsx_dev_runtime7 = __toESM(require_jsx_dev_runtime(), 1);
var TableRenderer = ({
  element,
  commonProps,
  isSelected,
  readOnly,
  invScale,
  onChange,
  onCellClick,
  onCellDblClick,
  selectedCell: _selectedCell
}) => {
  const tableElement = element;
  const { rows, cols, cells } = tableElement.table;
  const rowCount = rows.length;
  const colCount = cols.length;
  const totalW = cols.reduce((acc, v) => acc + (v ?? 0), 0);
  const totalH = rows.reduce((acc, v) => acc + (v ?? 0), 0);
  const occupied = Array(rowCount).fill(null).map(() => Array(colCount).fill(false));
  const getRowY = (rowIndex) => {
    let y = 0;
    for (let i2 = 0;i2 < rowIndex; i2++) {
      if (rows[i2] !== undefined)
        y += rows[i2];
    }
    return y;
  };
  const getColX = (colIndex) => {
    let x2 = 0;
    for (let i2 = 0;i2 < colIndex; i2++) {
      if (cols[i2] !== undefined)
        x2 += cols[i2];
    }
    return x2;
  };
  const getRowHeight = (rowIndex, span = 1) => {
    let h2 = 0;
    for (let i2 = 0;i2 < span; i2++) {
      const rh = rows[rowIndex + i2];
      if (rh !== undefined)
        h2 += rh;
    }
    return h2;
  };
  const getColWidth = (colIndex, span = 1) => {
    let w = 0;
    for (let i2 = 0;i2 < span; i2++) {
      const cw = cols[colIndex + i2];
      if (cw !== undefined)
        w += cw;
    }
    return w;
  };
  const cellMap = new Map;
  for (const c2 of cells)
    cellMap.set(`${c2.r}:${c2.c} `, c2);
  const rendered = [];
  for (let r = 0;r < rowCount; r++) {
    for (let c2 = 0;c2 < colCount; c2++) {
      if (occupied[r][c2])
        continue;
      const cell = cellMap.get(`${r}:${c2} `);
      const rs = cell?.rs || 1;
      const cs = cell?.cs || 1;
      if (rs > 1 || cs > 1) {
        for (let rr = 0;rr < rs; rr++) {
          for (let cc = 0;cc < cs; cc++) {
            if (r + rr < rowCount && c2 + cc < colCount) {
              occupied[r + rr][c2 + cc] = true;
            }
          }
        }
      }
      const x2 = getColX(c2);
      const y = getRowY(r);
      const w = getColWidth(c2, cs);
      const h2 = getRowHeight(r, rs);
      const borderColor = cell?.borderColor || cell?.border || "#cccccc";
      const borderW = cell?.borderW ?? (cell?.border ? 0.2 : 0.2);
      const borderEnabled = borderW > 0;
      const bg = cell?.bg;
      const fontSize = cell?.fontSize ?? ptToMm(12);
      const fontFamily = cell?.font || "Meiryo";
      const color = cell?.color || "#000000";
      const align = cell?.align || "l";
      const vAlign = cell?.vAlign || "m";
      const isSelectedCell = isSelected && _selectedCell && _selectedCell.row === r && _selectedCell.col === c2;
      const cellId = `${tableElement.id}_cell_${r}_${c2} `;
      rendered.push(/* @__PURE__ */ jsx_dev_runtime7.jsxDEV(Group2, {
        x: x2,
        y,
        onClick: (e) => {
          e.cancelBubble = true;
          onCellClick?.(tableElement.id, r, c2);
        },
        onDblClick: (e) => {
          e.cancelBubble = true;
          onCellDblClick?.(tableElement.id, r, c2);
        },
        children: [
          /* @__PURE__ */ jsx_dev_runtime7.jsxDEV(Rect2, {
            id: cellId,
            x: 0,
            y: 0,
            width: w,
            height: h2,
            fill: bg || "transparent",
            stroke: borderEnabled ? borderColor : undefined,
            strokeWidth: borderEnabled ? borderW : 0
          }, undefined, false, undefined, this),
          !!cell?.v && /* @__PURE__ */ jsx_dev_runtime7.jsxDEV(Text2, {
            id: `${cellId} _text`,
            x: 4 * invScale,
            y: 0,
            width: Math.max(0, w - 8 * invScale),
            height: h2,
            text: cell.v,
            fontSize,
            fontFamily,
            fill: color,
            align: align === "r" ? "right" : align === "c" ? "center" : "left",
            verticalAlign: vAlign === "t" ? "top" : vAlign === "b" ? "bottom" : "middle",
            listening: false
          }, undefined, false, undefined, this),
          isSelectedCell && /* @__PURE__ */ jsx_dev_runtime7.jsxDEV(Rect2, {
            x: 0,
            y: 0,
            width: w,
            height: h2,
            stroke: "#3b82f6",
            strokeWidth: 2 * invScale,
            dash: [4, 4],
            fillEnabled: false,
            listening: false
          }, undefined, false, undefined, this)
        ]
      }, cellId, true, undefined, this));
    }
  }
  const handles = [];
  const HANDLE_SIZE = 8 * invScale;
  const MIN_ROW = 10;
  const MIN_COL = 10;
  if (isSelected && !readOnly) {
    for (let i2 = 0;i2 < rowCount - 1; i2++) {
      const boundaryY = getRowY(i2 + 1);
      handles.push(/* @__PURE__ */ jsx_dev_runtime7.jsxDEV(Rect2, {
        x: 0,
        y: boundaryY - HANDLE_SIZE / 2,
        width: totalW,
        height: HANDLE_SIZE,
        fill: "transparent",
        draggable: true,
        dragBoundFunc: function(pos) {
          const parent = this.getParent();
          if (!parent)
            return pos;
          const transform = parent.getAbsoluteTransform().copy();
          transform.invert();
          const localPos = transform.point(pos);
          const newLocal = { x: 0, y: localPos.y };
          return parent.getAbsoluteTransform().point(newLocal);
        },
        onMouseEnter: (e) => {
          const container = e.target.getStage()?.container();
          if (container)
            container.style.cursor = "row-resize";
        },
        onMouseLeave: (e) => {
          const container = e.target.getStage()?.container();
          if (container)
            container.style.cursor = "default";
        },
        onDragStart: (e) => {
          const node = e.target;
          node.fill("#3b82f6");
        },
        onDragEnd: (e) => {
          e.cancelBubble = true;
          const node = e.target;
          node.fill("transparent");
          const delta = node.y() - (boundaryY - HANDLE_SIZE / 2);
          node.position({ x: 0, y: boundaryY - HANDLE_SIZE / 2 });
          if (Math.abs(delta) < 0.01)
            return;
          const newRows = [...rows];
          const topH = (newRows[i2] ?? 0) + delta;
          const bottomH = (newRows[i2 + 1] ?? 0) - delta;
          if (topH >= MIN_ROW && bottomH >= MIN_ROW) {
            newRows[i2] = topH;
            newRows[i2 + 1] = bottomH;
            onChange({
              id: tableElement.id,
              h: newRows.reduce((acc, v) => acc + (v ?? 0), 0),
              table: {
                ...tableElement.table,
                rows: newRows
              }
            });
          }
        }
      }, `${tableElement.id}_row_handle_${i2} `, false, undefined, this));
    }
    for (let i2 = 0;i2 < colCount - 1; i2++) {
      const boundaryX = getColX(i2 + 1);
      handles.push(/* @__PURE__ */ jsx_dev_runtime7.jsxDEV(Rect2, {
        x: boundaryX - HANDLE_SIZE / 2,
        y: 0,
        width: HANDLE_SIZE,
        height: totalH,
        fill: "transparent",
        draggable: true,
        dragBoundFunc: function(pos) {
          const parent = this.getParent();
          if (!parent)
            return pos;
          const transform = parent.getAbsoluteTransform().copy();
          transform.invert();
          const localPos = transform.point(pos);
          const newLocal = { x: localPos.x, y: 0 };
          return parent.getAbsoluteTransform().point(newLocal);
        },
        onMouseEnter: (e) => {
          const container = e.target.getStage()?.container();
          if (container)
            container.style.cursor = "col-resize";
        },
        onMouseLeave: (e) => {
          const container = e.target.getStage()?.container();
          if (container)
            container.style.cursor = "default";
        },
        onDragStart: (e) => {
          const node = e.target;
          node.fill("#3b82f6");
        },
        onDragEnd: (e) => {
          e.cancelBubble = true;
          const node = e.target;
          node.fill("transparent");
          const delta = node.x() - (boundaryX - HANDLE_SIZE / 2);
          node.position({ x: boundaryX - HANDLE_SIZE / 2, y: 0 });
          if (Math.abs(delta) < 0.01)
            return;
          const newCols = [...cols];
          const leftW = (newCols[i2] ?? 0) + delta;
          const rightW = (newCols[i2 + 1] ?? 0) - delta;
          if (leftW >= MIN_COL && rightW >= MIN_COL) {
            newCols[i2] = leftW;
            newCols[i2 + 1] = rightW;
            onChange({
              id: tableElement.id,
              w: newCols.reduce((acc, v) => acc + (v ?? 0), 0),
              table: {
                ...tableElement.table,
                cols: newCols
              }
            });
          }
        }
      }, `${tableElement.id}_col_handle_${i2} `, false, undefined, this));
    }
  }
  return /* @__PURE__ */ jsx_dev_runtime7.jsxDEV(Group2, {
    ...commonProps,
    children: [
      rendered,
      /* @__PURE__ */ jsx_dev_runtime7.jsxDEV(Rect2, {
        width: tableElement.w,
        height: tableElement.h,
        fillEnabled: false,
        stroke: "transparent",
        strokeWidth: 1 * invScale,
        hitStrokeWidth: 40 * invScale,
        onMouseEnter: (e) => {
          const container = e.target.getStage()?.container();
          if (container)
            container.style.cursor = "move";
        },
        onMouseLeave: (e) => {
          const container = e.target.getStage()?.container();
          if (container)
            container.style.cursor = "default";
        },
        onMouseDown: (e) => {
          e.cancelBubble = true;
          commonProps.onSelect?.(e);
        },
        onClick: (e) => {
          e.cancelBubble = true;
        },
        onTap: (e) => {
          e.cancelBubble = true;
          commonProps.onSelect?.(e);
        }
      }, undefined, false, undefined, this),
      handles,
      isSelected && !_selectedCell && /* @__PURE__ */ jsx_dev_runtime7.jsxDEV(Rect2, {
        x: 0,
        y: 0,
        width: tableElement.w,
        height: tableElement.h,
        stroke: "#cccccc",
        strokeWidth: 1 * invScale,
        dash: [4, 4],
        fillEnabled: false,
        listening: false
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/components/canvas/renderers/SignatureRenderer.tsx
var jsx_dev_runtime8 = __toESM(require_jsx_dev_runtime(), 1);
var SignatureShape = ({ element }) => {
  const sig = element;
  return /* @__PURE__ */ jsx_dev_runtime8.jsxDEV(jsx_dev_runtime8.Fragment, {
    children: sig.strokes.map((stroke, index) => /* @__PURE__ */ jsx_dev_runtime8.jsxDEV(Line2, {
      points: stroke,
      stroke: sig.stroke,
      strokeWidth: sig.strokeW,
      tension: 0.5,
      lineCap: "round",
      lineJoin: "round",
      listening: false
    }, index, false, undefined, this))
  }, undefined, false, undefined, this);
};
var SignatureRenderer = ({
  element,
  commonProps,
  stageScale
}) => {
  const signature = element;
  const hitStrokeWidth = Math.max(10, (signature.strokeW ?? 0.2) * stageScale / 0.2);
  return /* @__PURE__ */ jsx_dev_runtime8.jsxDEV(Group2, {
    ...commonProps,
    children: [
      /* @__PURE__ */ jsx_dev_runtime8.jsxDEV(SignatureShape, {
        element: signature
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime8.jsxDEV(Rect2, {
        x: 0,
        y: 0,
        width: signature.w,
        height: signature.h,
        fill: "transparent",
        listening: true,
        hitStrokeWidth
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/components/canvas/CanvasImage.tsx
var import_react6 = __toESM(require_react(), 1);

// ../../src/utils/logger.ts
var createLogger = (_context) => {
  return {
    debug: (_message, ..._args) => {},
    info: (_message, ..._args) => {},
    warn: (_message, ..._args) => {},
    error: (_message, ..._args) => {}
  };
};
var createContextLogger = createLogger;

// ../../src/features/konva-editor/utils/canvasImageUtils.ts
var log = createContextLogger("CanvasImageUtils");
function getAssetBaseUrl() {
  const cfg = globalThis.__WYSIWYG_PDF__;
  return cfg?.assetBaseUrl ?? "";
}
async function findImageWithExtension(assetId) {
  if (!assetId)
    return null;
  if (assetId.startsWith("data:") || assetId.startsWith("blob:") || assetId.startsWith("http")) {
    return new Promise((resolve) => {
      const img = new Image;
      img.onload = () => resolve({ url: assetId, img });
      img.onerror = () => {
        log.error("Failed to load image from URL");
        resolve(null);
      };
      img.src = assetId;
    });
  }
  const base = getAssetBaseUrl();
  const baseUrl = `${base || ""}/assets/images/${assetId}`.replace(/([^:]\/\/)\/+/, "$1");
  const extensions = ["png", "jpg", "jpeg", "svg", "webp"];
  for (const ext of extensions) {
    try {
      const imageUrl = `${baseUrl}.${ext}`;
      const img = new Image;
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = reject;
        img.src = imageUrl;
      });
      return { url: imageUrl, img };
    } catch (_error) {}
  }
  return null;
}

// ../../src/i18n/I18nContext.tsx
var import_react5 = __toESM(require_react(), 1);
var jsx_dev_runtime9 = __toESM(require_jsx_dev_runtime(), 1);
var defaultT = (key, fallback) => fallback ?? key;
var I18nContext = import_react5.default.createContext({ t: defaultT });
var I18nProvider = ({ t, children }) => {
  const value = import_react5.default.useMemo(() => ({ t: t ?? defaultT }), [t]);
  return /* @__PURE__ */ jsx_dev_runtime9.jsxDEV(I18nContext.Provider, {
    value,
    children
  }, undefined, false, undefined, this);
};
var useI18n = () => {
  return import_react5.default.useContext(I18nContext);
};

// ../../src/components/canvas/CanvasImage.tsx
var jsx_dev_runtime10 = __toESM(require_jsx_dev_runtime(), 1);
var CanvasImage = import_react6.forwardRef(({ element, commonProps, invScale }, ref) => {
  const { t } = useI18n();
  const [image, setImage] = import_react6.useState(null);
  const [status, setStatus] = import_react6.useState("empty");
  import_react6.useEffect(() => {
    if (!element.src) {
      setStatus("empty");
      setImage(null);
      return;
    }
    setStatus("loading");
    if (element.src.startsWith("http") || element.src.startsWith("data:")) {
      const img = new window.Image;
      img.src = element.src;
      img.onload = () => {
        setImage(img);
        setStatus("loaded");
      };
      img.onerror = () => {
        setStatus("error");
      };
    } else {
      findImageWithExtension(element.src).then((result) => {
        if (result) {
          setImage(result.img);
          setStatus("loaded");
        } else {
          setStatus("error");
        }
      }).catch((_err) => {
        setStatus("error");
      });
    }
  }, [element.src]);
  const { ref: _ignoredRef, ...propsWithoutRef } = commonProps;
  if (status === "loaded" && image) {
    return /* @__PURE__ */ jsx_dev_runtime10.jsxDEV(Image3, {
      ...propsWithoutRef,
      image,
      width: element.w,
      height: element.h,
      ref,
      opacity: element.opacity ?? 1
    }, undefined, false, undefined, this);
  }
  const isError = status === "error";
  const isLoading = status === "loading";
  const bgColor = isError ? "#fee2e2" : isLoading ? "#eff6ff" : "#e5e7eb";
  const borderColor = isError ? "#ef4444" : isLoading ? "#3b82f6" : "#6b7280";
  const textColor = isError ? "#b91c1c" : isLoading ? "#1d4ed8" : "#374151";
  const labelText = isError ? t("error", "Error") : isLoading ? t("loading", "Loading...") : t("properties_element_image", "Image");
  return /* @__PURE__ */ jsx_dev_runtime10.jsxDEV(Group2, {
    ...propsWithoutRef,
    ref,
    children: [
      /* @__PURE__ */ jsx_dev_runtime10.jsxDEV(Rect2, {
        width: element.w,
        height: element.h,
        fill: bgColor,
        stroke: borderColor,
        strokeWidth: 3 * invScale
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime10.jsxDEV(Text2, {
        x: 0,
        y: 0,
        width: element.w,
        height: element.h,
        text: labelText,
        fill: textColor,
        align: "center",
        verticalAlign: "middle",
        fontSize: 14 * invScale,
        fontStyle: "bold",
        fontFamily: "Helvetica"
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
CanvasImage.displayName = "CanvasImage";

// ../../src/components/canvas/hooks/useCanvasDrag.ts
var import_react7 = __toESM(require_react(), 1);

// ../../src/components/canvas/utils/lineUtils.ts
var getUpdateForConnectedLines = (currentElementId, currentElementGeo, others) => {
  const connected = others.filter((n) => n.t === "line" && (n.startConn?.nodeId === currentElementId || n.endConn?.nodeId === currentElementId));
  if (connected.length === 0)
    return [];
  const updates = [];
  connected.forEach((ln) => {
    const sId = ln.startConn?.nodeId;
    const eId = ln.endConn?.nodeId;
    if (!sId || !eId)
      return;
    const sNode = sId === currentElementId ? currentElementGeo : others.find((n) => n.id === sId);
    const eNode = eId === currentElementId ? currentElementGeo : others.find((n) => n.id === eId);
    if (!sNode || !eNode || !isWHElement(sNode) || !isWHElement(eNode))
      return;
    const sGeo = { x: sNode.x, y: sNode.y, w: sNode.w, h: sNode.h, r: sNode.r };
    const eGeo = { x: eNode.x, y: eNode.y, w: eNode.w, h: eNode.h, r: eNode.r };
    let nextPts = [];
    if (ln.routing === "orthogonal") {
      nextPts = getOrthogonalConnectionPath(sGeo, ln.startConn?.anchor || "auto", eGeo, ln.endConn?.anchor || "auto");
    } else {
      const sP = getAnchorPointAndDirection(sGeo, ln.startConn?.anchor || "auto");
      const eP = getAnchorPointAndDirection(eGeo, ln.endConn?.anchor || "auto");
      nextPts = [sP.x, sP.y, eP.x, eP.y];
    }
    const currentPts = ln.pts || [];
    if (JSON.stringify(currentPts) !== JSON.stringify(nextPts)) {
      updates.push({
        id: ln.id,
        pts: nextPts
      });
    }
  });
  return updates;
};

// ../../src/components/canvas/utils/nodeOperations.ts
var calculateNodeMoveUpdates = (targetNode, newPos, allNodes) => {
  const updates = [];
  const finalX = newPos.x;
  const finalY = newPos.y;
  updates.push({
    id: targetNode.id,
    x: finalX,
    y: finalY
  });
  if (isWHElement(targetNode)) {
    const futureNode = { ...targetNode, x: finalX, y: finalY };
    const lineUpdates = getUpdateForConnectedLines(targetNode.id, futureNode, allNodes);
    updates.push(...lineUpdates);
  }
  return updates;
};

// ../../src/components/canvas/hooks/useCanvasDrag.ts
var useCanvasDrag = ({ element, allElements, onChange }) => {
  const handleDragEnd = import_react7.useCallback((e) => {
    if (isWHElement(element)) {
      const node = e.currentTarget;
      let newX = node.x();
      let newY = node.y();
      console.log(`[useCanvasDrag] handleDragEnd for ${element.t}:${element.id}`, { x: newX, y: newY });
      if (element.t === "shape") {
        if (["circle", "star", "pentagon", "hexagon"].includes(element.shape)) {
          newX -= element.w / 2;
          newY -= element.h / 2;
        }
      }
      const updates = calculateNodeMoveUpdates(element, { x: newX, y: newY }, allElements || []);
      onChange(updates);
    } else if (element.t === "line") {
      const node = e.currentTarget;
      const dx = node.x();
      const dy = node.y();
      const line = element;
      const newPts = line.pts.map((p2, i2) => i2 % 2 === 0 ? p2 + dx : p2 + dy);
      onChange({
        id: element.id,
        pts: newPts
      });
      node.x(0);
      node.y(0);
    }
  }, [element, onChange, allElements]);
  const handleDragMove = import_react7.useCallback((e) => {
    if (!isWHElement(element))
      return;
    if (!allElements || allElements.length === 0)
      return;
    const stage = e.currentTarget.getStage();
    if (!stage)
      return;
    const w = element.w ?? 0;
    const h2 = element.h ?? 0;
    let topLeftX = e.currentTarget.x();
    let topLeftY = e.currentTarget.y();
    if (element.t === "shape") {
      const shape = element;
      if (["circle", "star", "pentagon", "hexagon"].includes(shape.shape)) {
        topLeftX = topLeftX - w / 2;
        topLeftY = topLeftY - h2 / 2;
      }
    }
    const connected = allElements.filter((n) => n.t === "line" && (n.startConn?.nodeId === element.id || n.endConn?.nodeId === element.id));
    if (connected.length === 0)
      return;
    const currentGeo = { ...element, x: topLeftX, y: topLeftY };
    connected.forEach((ln) => {
      const lineGroup = stage.findOne(`#${ln.id}`);
      if (!lineGroup)
        return;
      const lineBody = lineGroup.findOne(".line-body");
      if (!lineBody)
        return;
      const sId = ln.startConn?.nodeId;
      const eId = ln.endConn?.nodeId;
      if (!sId || !eId)
        return;
      const sNode = sId === element.id ? currentGeo : allElements.find((n) => n.id === sId);
      const eNode = eId === element.id ? currentGeo : allElements.find((n) => n.id === eId);
      if (!sNode || !eNode || !isWHElement(sNode) || !isWHElement(eNode))
        return;
      const sGeo = { x: sNode.x, y: sNode.y, w: sNode.w, h: sNode.h, r: sNode.r };
      const eGeo = { x: eNode.x, y: eNode.y, w: eNode.w, h: eNode.h, r: eNode.r };
      let nextPts = [];
      if (ln.routing === "orthogonal") {
        nextPts = getOrthogonalConnectionPath(sGeo, ln.startConn?.anchor || "auto", eGeo, ln.endConn?.anchor || "auto");
      } else {
        const sP = getAnchorPointAndDirection(sGeo, ln.startConn?.anchor || "auto");
        const eP = getAnchorPointAndDirection(eGeo, ln.endConn?.anchor || "auto");
        nextPts = [sP.x, sP.y, eP.x, eP.y];
      }
      if (!nextPts || nextPts.length < 4)
        return;
      const endIdx = nextPts.length - 2;
      lineBody.points(nextPts);
      let dxStart = nextPts[2] - nextPts[0];
      let dyStart = nextPts[3] - nextPts[1];
      if (nextPts.length <= 2) {
        dxStart = nextPts[endIdx] - nextPts[0];
        dyStart = nextPts[endIdx + 1] - nextPts[1];
      }
      let dxEnd = nextPts[endIdx] - nextPts[endIdx - 2];
      let dyEnd = nextPts[endIdx + 1] - nextPts[endIdx - 1];
      if (nextPts.length <= 2) {
        dxEnd = dxStart;
        dyEnd = dyStart;
      }
      const angleStart = Math.atan2(dyStart, dxStart) + Math.PI;
      const angleEnd = Math.atan2(dyEnd, dxEnd);
      const startHandle = lineGroup.findOne(".line-handle-start");
      if (startHandle)
        startHandle.position({ x: nextPts[0], y: nextPts[1] });
      const endHandle = lineGroup.findOne(".line-handle-end");
      if (endHandle)
        endHandle.position({ x: nextPts[endIdx], y: nextPts[endIdx + 1] });
      const startMarker = lineGroup.findOne(".line-marker-start");
      if (startMarker) {
        startMarker.position({ x: nextPts[0], y: nextPts[1] });
        startMarker.rotation(angleStart * 180 / Math.PI);
      }
      const endMarker = lineGroup.findOne(".line-marker-end");
      if (endMarker) {
        endMarker.position({ x: nextPts[endIdx], y: nextPts[endIdx + 1] });
        endMarker.rotation(angleEnd * 180 / Math.PI);
      }
    });
    stage.batchDraw();
  }, [element, allElements]);
  return { handleDragEnd, handleDragMove };
};

// ../../src/components/canvas/hooks/useCanvasTransform.ts
var import_react8 = __toESM(require_react(), 1);
var useCanvasTransform = ({ element, allElements, shapeRef, onChange }) => {
  const handleTransformEnd = import_react8.useCallback(() => {
    const node = shapeRef.current;
    if (!node || !isWHElement(element))
      return;
    const scaleX = node.scaleX();
    const scaleY = node.scaleY();
    node.scaleX(1);
    node.scaleY(1);
    const newWidth = Math.max(5, node.width() * scaleX);
    const newHeight = Math.max(5, node.height() * scaleY);
    let newX = node.x();
    let newY = node.y();
    if (element.t === "shape") {
      const type = element.shape;
      if (["circle", "star", "pentagon", "hexagon"].includes(type)) {
        newX -= newWidth / 2;
        newY -= newHeight / 2;
      }
    }
    let elementUpdate;
    if (element.t === "table") {
      const tableElement = element;
      const oldWidth = tableElement.w || 1;
      const oldHeight = tableElement.h || 1;
      const widthRatio = newWidth / oldWidth;
      const heightRatio = newHeight / oldHeight;
      const newCols = tableElement.table.cols.map((w) => w * widthRatio);
      const newRows = tableElement.table.rows.map((h2) => h2 * heightRatio);
      elementUpdate = {
        id: element.id,
        x: newX,
        y: newY,
        w: newWidth,
        h: newHeight,
        r: node.rotation(),
        table: {
          ...tableElement.table,
          cols: newCols,
          rows: newRows
        }
      };
    } else if (element.t === "signature") {
      const signatureElement = element;
      const scaleX2 = newWidth / (signatureElement.w || 1);
      const scaleY2 = newHeight / (signatureElement.h || 1);
      const scaledStrokes = signatureElement.strokes.map((stroke) => {
        const scaled = [];
        for (let i2 = 0;i2 < stroke.length; i2 += 2) {
          const x2 = stroke[i2] * scaleX2;
          const y = stroke[i2 + 1] * scaleY2;
          scaled.push(x2, y);
        }
        return scaled;
      });
      elementUpdate = {
        id: element.id,
        x: newX,
        y: newY,
        w: newWidth,
        h: newHeight,
        r: node.rotation(),
        strokes: scaledStrokes
      };
    } else {
      elementUpdate = {
        id: element.id,
        x: newX,
        y: newY,
        w: newWidth,
        h: newHeight,
        r: node.rotation()
      };
    }
    const updates = [elementUpdate];
    if (allElements) {
      const currentGeo = { ...element, ...elementUpdate };
      const lineUpdates = getUpdateForConnectedLines(element.id, currentGeo, allElements);
      updates.push(...lineUpdates);
    }
    onChange(updates);
  }, [element, onChange, shapeRef, allElements]);
  return { handleTransformEnd };
};

// ../../src/components/canvas/CanvasElementRenderer.tsx
var jsx_dev_runtime11 = __toESM(require_jsx_dev_runtime(), 1);
var CanvasElementRenderer = ({
  element,
  isSelected,
  onSelect,
  onChange,
  onDblClick,
  onCellDblClick,
  onCellClick,
  onContextMenu,
  isEditing,
  editingCell: _editingCell,
  selectedCell: _selectedCell,
  renderCustom,
  readOnly,
  allElements,
  snapStrength = 5,
  gridSize = 15,
  showGrid = false,
  stageScale = 1,
  onToggleCollapse,
  onDragStart,
  onDragEnter,
  onDragLeave,
  dragState,
  onDragEnd
}) => {
  const shapeRef = import_react9.useRef(null);
  const trRef = import_react9.useRef(null);
  const [isShiftDown, setIsShiftDown] = import_react9.useState(false);
  const { handleDragEnd, handleDragMove } = useCanvasDrag({
    element,
    allElements,
    onChange
  });
  const { handleTransformEnd } = useCanvasTransform({
    element,
    allElements,
    shapeRef,
    onChange
  });
  const invScale = stageScale > 0 ? 1 / stageScale : 1;
  import_react9.useEffect(() => {
    const onKeyDown = (e) => {
      if (e.key === "Shift")
        setIsShiftDown(true);
    };
    const onKeyUp = (e) => {
      if (e.key === "Shift")
        setIsShiftDown(false);
    };
    const onBlur = () => setIsShiftDown(false);
    window.addEventListener("keydown", onKeyDown);
    window.addEventListener("keyup", onKeyUp);
    window.addEventListener("blur", onBlur);
    return () => {
      window.removeEventListener("keydown", onKeyDown);
      window.removeEventListener("keyup", onKeyUp);
      window.removeEventListener("blur", onBlur);
    };
  }, []);
  const rotationSnaps = import_react9.useMemo(() => {
    if (!isShiftDown)
      return;
    return [0, 45, 90, 135, 180, 225, 270, 315];
  }, [isShiftDown]);
  const rotationSnapTolerance = import_react9.useMemo(() => {
    return isShiftDown ? 23 : 0;
  }, [isShiftDown]);
  const handleShapeRef = import_react9.useCallback((node) => {
    shapeRef.current = node;
    if (isSelected && trRef.current) {
      if (node) {
        trRef.current.nodes([node]);
      } else {
        trRef.current.nodes([]);
      }
      trRef.current.getLayer()?.batchDraw();
    }
  }, [isSelected]);
  import_react9.useEffect(() => {
    if (isSelected && trRef.current && shapeRef.current) {
      trRef.current.nodes([shapeRef.current]);
      trRef.current.getLayer()?.batchDraw();
    }
  }, [isSelected]);
  import_react9.useEffect(() => {
    if (isSelected && trRef.current) {
      trRef.current.forceUpdate();
      trRef.current.getLayer()?.batchDraw();
    }
  }, [element.w, element.h, isSelected]);
  import_react9.useEffect(() => {
    if (!isSelected || !trRef.current)
      return;
    if (rotationSnaps) {
      trRef.current.rotationSnaps(rotationSnaps);
      trRef.current.rotationSnapTolerance(rotationSnapTolerance);
    } else {
      trRef.current.rotationSnaps([]);
      trRef.current.rotationSnapTolerance(0);
    }
    trRef.current.getLayer()?.batchDraw();
  }, [isSelected, rotationSnaps, rotationSnapTolerance]);
  import_react9.useEffect(() => {
    if (element.t !== "text" || !shapeRef.current)
      return;
    const node = shapeRef.current;
    if (!node)
      return;
    const height = node.height();
    const currentHeight = element.h ?? 0;
    if (Math.abs(height - currentHeight) > 1) {
      onChange({
        id: element.id,
        h: height
      });
    }
  }, [element, onChange]);
  const handleMouseEnter = import_react9.useCallback((e) => {
    if (readOnly)
      return;
    if (element.locked || isSelected)
      return;
    const container = e.target.getStage()?.container();
    if (container)
      container.style.cursor = "move";
  }, [readOnly, element.locked, isSelected]);
  const handleMouseLeave = import_react9.useCallback((e) => {
    if (readOnly)
      return;
    if (isSelected)
      return;
    const container = e.target.getStage()?.container();
    if (container)
      container.style.cursor = "default";
  }, [readOnly, isSelected]);
  const handleMindmapDragStart = import_react9.useCallback((e) => {
    if (element.t !== "text")
      return;
    if (!onDragStart)
      return;
    onDragStart(element.id, e);
  }, [element.t, element.id, onDragStart]);
  const handleMindmapDragEnter = import_react9.useCallback((e) => {
    if (element.t !== "text")
      return;
    if (!onDragEnter)
      return;
    onDragEnter(element.id, e);
  }, [element.t, element.id, onDragEnter]);
  const content = import_react9.useMemo(() => {
    const commonProps = {
      id: element.id,
      x: element.t === "line" ? 0 : element.x ?? 0,
      y: element.t === "line" ? 0 : element.y ?? 0,
      width: element.t === "line" ? 0 : element.w ?? 0,
      height: element.t === "line" ? 0 : element.h ?? 0,
      rotation: element.r || 0,
      draggable: readOnly ? false : !element.locked,
      onMouseDown: (e) => {
        if (onDragStart) {
          handleMindmapDragStart(e);
        }
        onSelect(e);
      },
      onTap: onSelect,
      onDblClick,
      ref: handleShapeRef,
      onDragMove: (e) => {
        if (onDragStart) {} else {
          handleDragMove(e);
        }
      },
      onDragEnd: (e) => {
        if (onDragStart) {
          console.log(`[CanvasElementRenderer] Mindmap onDragEnd for ${element.id}`);
          dragState && onDragEnd && onDragEnd();
        } else {
          console.log(`[CanvasElementRenderer] Default handleDragEnd for ${element.id}`);
          handleDragEnd(e);
        }
      },
      onTransformEnd: handleTransformEnd,
      visible: !element.hidden,
      onMouseEnter: (e) => {
        handleMouseEnter(e);
        if (onDragEnter) {
          handleMindmapDragEnter(e);
        }
      },
      onMouseLeave: (e) => {
        handleMouseLeave(e);
        onDragLeave?.(e);
      },
      onContextMenu: (e) => onContextMenu?.(e),
      dragBoundFunc: function(pos) {
        let snap = 0;
        if (showGrid && gridSize > 0) {
          snap = gridSize;
        } else if (snapStrength > 0) {
          snap = snapStrength;
        }
        if (snap <= 0)
          return pos;
        const stage = this.getStage();
        if (!stage)
          return pos;
        const transform = stage.getAbsoluteTransform().copy();
        transform.invert();
        const logicalPos = transform.point(pos);
        const snappedLogicalX = Math.round(logicalPos.x / snap) * snap;
        const snappedLogicalY = Math.round(logicalPos.y / snap) * snap;
        const absoluteTransform = stage.getAbsoluteTransform();
        const snappedPos = absoluteTransform.point({ x: snappedLogicalX, y: snappedLogicalY });
        return snappedPos;
      }
    };
    if (renderCustom) {
      const custom = renderCustom(element, commonProps, handleShapeRef);
      if (custom)
        return custom;
    }
    switch (element.t) {
      case "text":
        return /* @__PURE__ */ jsx_dev_runtime11.jsxDEV(TextRenderer, {
          element,
          commonProps,
          isEditing,
          dragState,
          invScale,
          onToggleCollapse
        }, undefined, false, undefined, this);
      case "shape":
        return /* @__PURE__ */ jsx_dev_runtime11.jsxDEV(ShapeRenderer, {
          element,
          commonProps
        }, undefined, false, undefined, this);
      case "line":
        return /* @__PURE__ */ jsx_dev_runtime11.jsxDEV(LineRenderer, {
          element,
          commonProps,
          isSelected,
          readOnly,
          allElements,
          showGrid,
          gridSize,
          snapStrength,
          invScale,
          onChange
        }, undefined, false, undefined, this);
      case "image":
        return /* @__PURE__ */ jsx_dev_runtime11.jsxDEV(CanvasImage, {
          element,
          commonProps,
          invScale,
          ref: handleShapeRef
        }, undefined, false, undefined, this);
      case "table":
        return /* @__PURE__ */ jsx_dev_runtime11.jsxDEV(TableRenderer, {
          element,
          commonProps,
          isSelected,
          readOnly,
          invScale,
          onChange,
          onCellClick,
          onCellDblClick,
          selectedCell: _selectedCell
        }, undefined, false, undefined, this);
      case "signature":
        return /* @__PURE__ */ jsx_dev_runtime11.jsxDEV(SignatureRenderer, {
          element,
          commonProps,
          stageScale
        }, undefined, false, undefined, this);
      default:
        return null;
    }
  }, [
    element,
    renderCustom,
    handleShapeRef,
    readOnly,
    isSelected,
    onChange,
    _selectedCell,
    allElements,
    gridSize,
    invScale,
    onCellClick,
    onCellDblClick,
    showGrid,
    snapStrength,
    handleDragMove,
    handleDragEnd,
    handleTransformEnd,
    handleMouseEnter,
    handleMouseLeave,
    onContextMenu,
    onSelect,
    onDblClick,
    isEditing,
    dragState,
    onToggleCollapse,
    stageScale,
    onDragStart,
    handleMindmapDragStart,
    onDragEnd,
    onDragEnter,
    handleMindmapDragEnter,
    onDragLeave
  ]);
  return /* @__PURE__ */ jsx_dev_runtime11.jsxDEV(jsx_dev_runtime11.Fragment, {
    children: [
      content,
      isSelected && !readOnly && element.t !== "line" && /* @__PURE__ */ jsx_dev_runtime11.jsxDEV(Transformer2, {
        ref: trRef,
        rotateEnabled: !element.locked,
        anchorSize: 8,
        borderStrokeWidth: element.locked ? 3 : 1,
        rotateAnchorOffset: 16,
        rotationSnaps,
        rotationSnapTolerance,
        enabledAnchors: !element.locked ? [
          "top-left",
          "top-right",
          "bottom-left",
          "bottom-right",
          "middle-left",
          "middle-right",
          "top-center",
          "bottom-center"
        ] : [],
        boundBoxFunc: (oldBox, newBox) => {
          if (newBox.width < 5 || newBox.height < 5)
            return oldBox;
          return newBox;
        }
      }, element.id, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/components/canvas/GridLayer.tsx
var jsx_dev_runtime12 = __toESM(require_jsx_dev_runtime(), 1);
var GridLayer = ({
  width,
  height,
  scale,
  gridSize = 50,
  visible = false
}) => {
  if (!visible)
    return null;
  const lines = [];
  for (let x2 = 0;x2 <= width; x2 += gridSize) {
    lines.push(/* @__PURE__ */ jsx_dev_runtime12.jsxDEV(Line2, {
      points: [x2, 0, x2, height],
      stroke: "#3b82f6",
      strokeWidth: 1 / scale,
      listening: false
    }, `v-${x2}`, false, undefined, this));
  }
  for (let y = 0;y <= height; y += gridSize) {
    lines.push(/* @__PURE__ */ jsx_dev_runtime12.jsxDEV(Line2, {
      points: [0, y, width, y],
      stroke: "#000000",
      strokeWidth: 1 / scale,
      listening: false
    }, `h-${y}`, false, undefined, this));
  }
  return /* @__PURE__ */ jsx_dev_runtime12.jsxDEV(Layer2, {
    name: "grid-layer",
    listening: false,
    opacity: 0.6,
    children: lines
  }, undefined, false, undefined, this);
};

// ../../src/components/canvas/hooks/useKeyboardShortcuts.ts
var import_react10 = __toESM(require_react(), 1);
var log2 = createContextLogger("useKeyboardShortcuts");
var useKeyboardShortcuts = (handlers) => {
  const handlersRef = import_react10.useRef(handlers);
  import_react10.useEffect(() => {
    handlersRef.current = handlers;
  }, [handlers]);
  import_react10.useEffect(() => {
    const handleKeyDown = (e) => {
      const target = e.target;
      if (["INPUT", "TEXTAREA"].includes(target.tagName) || target.isContentEditable) {
        return;
      }
      const ctrlOrCmd = e.metaKey || e.ctrlKey;
      const key = e.key.toLowerCase();
      const code = e.code;
      const currentHandlers = handlersRef.current;
      if (ctrlOrCmd && !e.shiftKey && (key === "z" || code === "KeyZ")) {
        e.preventDefault();
        log2.debug("Keyboard shortcut: Undo");
        currentHandlers.onUndo?.();
        return;
      }
      if (ctrlOrCmd && e.shiftKey && (key === "z" || code === "KeyZ") || ctrlOrCmd && (key === "y" || code === "KeyY")) {
        e.preventDefault();
        log2.debug("Keyboard shortcut: Redo");
        currentHandlers.onRedo?.();
        return;
      }
      if (e.key === "Delete" || e.key === "Backspace") {
        e.preventDefault();
        log2.debug("Keyboard shortcut: Delete");
        currentHandlers.onDelete?.();
        return;
      }
      if (ctrlOrCmd && e.key === "a") {
        e.preventDefault();
        log2.debug("Keyboard shortcut: Select All");
        currentHandlers.onSelectAll?.();
        return;
      }
      const stepMm = e.shiftKey ? 10 : 1;
      if (e.key === "ArrowUp") {
        e.preventDefault();
        log2.debug("Keyboard shortcut: Move Up", { stepMm });
        currentHandlers.onMoveUp?.(stepMm);
        return;
      }
      if (e.key === "ArrowDown") {
        e.preventDefault();
        log2.debug("Keyboard shortcut: Move Down", { stepMm });
        currentHandlers.onMoveDown?.(stepMm);
        return;
      }
      if (e.key === "ArrowLeft") {
        e.preventDefault();
        log2.debug("Keyboard shortcut: Move Left", { stepMm });
        currentHandlers.onMoveLeft?.(stepMm);
        return;
      }
      if (e.key === "ArrowRight") {
        e.preventDefault();
        log2.debug("Keyboard shortcut: Move Right", { stepMm });
        currentHandlers.onMoveRight?.(stepMm);
        return;
      }
      if (ctrlOrCmd && (key === "c" || code === "KeyC")) {
        e.preventDefault();
        log2.debug("Keyboard shortcut: Copy");
        currentHandlers.onCopy?.();
        return;
      }
      if (ctrlOrCmd && (key === "v" || code === "KeyV")) {
        e.preventDefault();
        log2.debug("Keyboard shortcut: Paste");
        currentHandlers.onPaste?.();
        return;
      }
    };
    window.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => {
      window.removeEventListener("keydown", handleKeyDown, { capture: true });
    };
  }, []);
};

// ../../src/components/canvas/TextEditOverlay.tsx
var import_react11 = __toESM(require_react(), 1);
var jsx_dev_runtime13 = __toESM(require_jsx_dev_runtime(), 1);
var TextEditOverlay = ({
  element,
  scale,
  stageNode,
  onUpdate,
  onFinish
}) => {
  const textareaRef = import_react11.useRef(null);
  const isComposing = import_react11.useRef(false);
  const [style, setStyle] = import_react11.useState({});
  import_react11.useLayoutEffect(() => {
    if (textareaRef.current) {
      if (document.activeElement !== textareaRef.current) {
        textareaRef.current.focus({ preventScroll: true });
      }
      if (!isComposing.current && document.activeElement !== textareaRef.current && textareaRef.current.value !== element.text) {
        textareaRef.current.value = element.text;
      }
    }
  }, [element.text]);
  import_react11.useLayoutEffect(() => {
    if (!stageNode || !element)
      return;
    const node = stageNode.findOne(`#${element.id}`);
    if (!node)
      return;
    const absolutePosition = node.getAbsolutePosition();
    const areaPosition = {
      x: absolutePosition.x,
      y: absolutePosition.y
    };
    const scaledW = element.w * scale;
    const scaledH = element.h * scale;
    const paddingMm = element.padding || 0;
    const padding = paddingMm * scale;
    const boxLeft = areaPosition.x + padding;
    const boxTop = areaPosition.y + padding;
    const boxW = Math.max(0, scaledW - padding * 2);
    const boxH = Math.max(0, scaledH - padding * 2);
    console.log("[TextEditOverlay] render:", {
      id: element.id,
      w: element.w,
      h: element.h,
      vertical: element.vertical,
      boxW,
      boxH,
      areaPosition
    });
    let newStyle = {
      position: "absolute",
      top: `${boxTop}px`,
      left: `${boxLeft}px`,
      width: `${boxW}px`,
      height: `${boxH}px`,
      fontSize: `${(element.fontSize ?? ptToMm(12)) * scale}px`,
      fontFamily: element.font || "Noto Sans JP",
      fontWeight: element.fontWeight || 400,
      fontStyle: element.italic ? "italic" : "normal",
      color: element.fill || "#000000",
      background: "rgba(255, 255, 255, 0.5)",
      border: "none",
      outline: "1px solid #007AFF",
      resize: "none",
      boxSizing: "border-box",
      margin: 0,
      overflow: "hidden",
      zIndex: 1000,
      transformOrigin: "top left",
      transform: `rotate(${element.r || 0}deg)`
    };
    if (element.vertical) {
      newStyle = {
        position: "absolute",
        left: `${areaPosition.x}px`,
        top: `${areaPosition.y}px`,
        width: "1px",
        height: "1px",
        opacity: 0,
        pointerEvents: "auto",
        background: "transparent",
        border: "none",
        outline: "none",
        fontSize: "16px",
        color: "transparent",
        caretColor: "transparent",
        resize: "none",
        overflow: "hidden",
        padding: 0,
        margin: 0,
        zIndex: 1000
      };
    } else {
      const vAlign = element.vAlign || "m";
      const dim = calculateTextDimensions(element.text, {
        family: element.font || "Arial",
        size: element.fontSize,
        weight: element.fontWeight,
        padding: 0
      });
      const scaledTextContentHeight = dim.h * scale;
      let extraTop = 0;
      if (vAlign === "m") {
        extraTop = (boxH - scaledTextContentHeight) / 2;
      } else if (vAlign === "b") {
        extraTop = boxH - scaledTextContentHeight;
      }
      const finalPaddingTop = Math.max(0, extraTop);
      newStyle = {
        ...newStyle,
        textAlign: element.align === "r" ? "right" : element.align === "c" ? "center" : element.align === "j" ? "justify" : "left",
        lineHeight: 1.2,
        textDecoration: [
          element.underline ? "underline" : "",
          element.lineThrough ? "line-through" : ""
        ].filter(Boolean).join(" "),
        paddingLeft: 0,
        paddingRight: 0,
        paddingBottom: 0,
        paddingTop: `${finalPaddingTop}px`,
        whiteSpace: "pre"
      };
    }
    setStyle(newStyle);
  }, [
    element.id,
    element.x,
    element.y,
    element.w,
    element.h,
    element.padding,
    element.vAlign,
    element.fontSize,
    element.font,
    element.fontWeight,
    element.text,
    element.vertical,
    scale,
    stageNode,
    element.italic,
    element.underline,
    element.lineThrough,
    element.fill,
    element.align,
    element.r
  ]);
  const handleFinish = () => {
    if (textareaRef.current) {
      onUpdate(textareaRef.current.value);
    }
    onFinish();
  };
  const handleKeyDown = (e) => {
    if (e.nativeEvent.isComposing || isComposing.current) {
      return;
    }
    if (e.key === "Tab") {
      const textarea = textareaRef.current;
      if (!textarea)
        return;
      e.preventDefault();
      if (element.vertical)
        return;
      const value = textarea.value;
      const selectionStart = textarea.selectionStart ?? 0;
      const selectionEnd = textarea.selectionEnd ?? 0;
      const lines = value.split(`
`);
      const lineStarts = [];
      let offset = 0;
      for (const line of lines) {
        lineStarts.push(offset);
        offset += line.length + 1;
      }
      const getLineIndex = (pos) => {
        for (let i2 = lineStarts.length - 1;i2 >= 0; i2 -= 1) {
          if (pos >= lineStarts[i2])
            return i2;
        }
        return 0;
      };
      const startLine = getLineIndex(selectionStart);
      const endLine = selectionEnd > 0 && value[selectionEnd - 1] === `
` ? getLineIndex(selectionEnd - 1) : getLineIndex(selectionEnd);
      let changed = false;
      const updatedLines = lines.map((line, index) => {
        if (index < startLine || index > endLine)
          return line;
        const parsed = parseListLine(line, { vertical: element.vertical });
        if (!parsed.isList || !parsed.type)
          return line;
        const delta = e.shiftKey ? -1 : 1;
        const nextLevel = Math.min(5, Math.max(1, parsed.level + delta));
        if (nextLevel === parsed.level)
          return line;
        changed = true;
        return buildListLine(parsed.content, parsed.type, nextLevel, { vertical: element.vertical });
      });
      if (!changed)
        return;
      const normalized = normalizeListText(updatedLines.join(`
`), { vertical: element.vertical });
      const newLines = normalized.split(`
`);
      const newLineStarts = [];
      let newOffset = 0;
      for (const line of newLines) {
        newLineStarts.push(newOffset);
        newOffset += line.length + 1;
      }
      const adjustPosition = (pos) => {
        const lineIndex = getLineIndex(pos);
        const oldLine = lines[lineIndex] ?? "";
        const newLine = newLines[lineIndex] ?? "";
        const oldLineStart = lineStarts[lineIndex] ?? 0;
        const newLineStart = newLineStarts[lineIndex] ?? 0;
        const column = pos - oldLineStart;
        const oldParsed = parseListLine(oldLine, { vertical: element.vertical });
        const newParsed = parseListLine(newLine, { vertical: element.vertical });
        const oldPrefix = oldParsed.isList ? oldParsed.prefixLength : 0;
        const newPrefix = newParsed.isList ? newParsed.prefixLength : 0;
        const prefixDelta = column >= oldPrefix ? newPrefix - oldPrefix : 0;
        const newColumn = Math.min(newLine.length, Math.max(0, column + prefixDelta));
        return newLineStart + newColumn;
      };
      const nextStart = adjustPosition(selectionStart);
      const nextEnd = adjustPosition(selectionEnd);
      textarea.value = normalized;
      textarea.selectionStart = nextStart;
      textarea.selectionEnd = nextEnd;
      onUpdate(normalized);
      return;
    }
    if (e.key === "Enter") {
      if (e.shiftKey) {
        return;
      }
      const textarea = textareaRef.current;
      if (!textarea)
        return;
      const selectionStart = textarea.selectionStart ?? 0;
      const selectionEnd = textarea.selectionEnd ?? 0;
      if (selectionStart === selectionEnd) {
        const value = textarea.value;
        const lines = value.split(`
`);
        let lineStart = 0;
        let lineIndex = 0;
        for (let i2 = 0;i2 < lines.length; i2 += 1) {
          const lineEnd = lineStart + lines[i2].length;
          if (selectionStart >= lineStart && selectionStart <= lineEnd) {
            lineIndex = i2;
            break;
          }
          lineStart = lineEnd + 1;
        }
        const lineText = lines[lineIndex] ?? "";
        const parsed = parseListLine(lineText, { vertical: element.vertical });
        if (parsed.isList && parsed.type) {
          e.preventDefault();
          if (parsed.content.trim() === "") {
            const before = value.slice(0, lineStart);
            const after = value.slice(lineStart + lineText.length);
            const updated2 = `${before}${after}`;
            textarea.value = updated2;
            textarea.selectionStart = lineStart;
            textarea.selectionEnd = lineStart;
            onUpdate(updated2);
            return;
          }
          const nextNumber = parsed.type === "number" ? getNextListNumber(value, lineIndex, parsed.level, { vertical: element.vertical }) : undefined;
          const newLine = buildListLine("", parsed.type, parsed.level, {
            vertical: element.vertical,
            number: nextNumber
          });
          const insert = `
${newLine}`;
          const updated = value.slice(0, selectionStart) + insert + value.slice(selectionEnd);
          const nextPos = selectionStart + insert.length;
          if (parsed.type === "number") {
            const normalized = normalizeListText(updated, { vertical: element.vertical });
            const oldLines = updated.split(`
`);
            const newLines = normalized.split(`
`);
            const oldLineStarts = [];
            const newLineStarts = [];
            let oldOffset = 0;
            let newOffset = 0;
            for (const line of oldLines) {
              oldLineStarts.push(oldOffset);
              oldOffset += line.length + 1;
            }
            for (const line of newLines) {
              newLineStarts.push(newOffset);
              newOffset += line.length + 1;
            }
            const getLineIndex = (pos) => {
              for (let i2 = oldLineStarts.length - 1;i2 >= 0; i2 -= 1) {
                if (pos >= oldLineStarts[i2])
                  return i2;
              }
              return 0;
            };
            const adjustPosition = (pos) => {
              const lineIndex2 = getLineIndex(pos);
              const oldLine = oldLines[lineIndex2] ?? "";
              const newLine2 = newLines[lineIndex2] ?? "";
              const oldLineStart = oldLineStarts[lineIndex2] ?? 0;
              const newLineStart = newLineStarts[lineIndex2] ?? 0;
              const column = pos - oldLineStart;
              const oldParsed = parseListLine(oldLine, { vertical: element.vertical });
              const newParsed = parseListLine(newLine2, { vertical: element.vertical });
              const oldPrefix = oldParsed.isList ? oldParsed.prefixLength : 0;
              const newPrefix = newParsed.isList ? newParsed.prefixLength : 0;
              const prefixDelta = column >= oldPrefix ? newPrefix - oldPrefix : 0;
              const newColumn = Math.min(newLine2.length, Math.max(0, column + prefixDelta));
              return newLineStart + newColumn;
            };
            const adjustedPos = adjustPosition(nextPos);
            textarea.value = normalized;
            textarea.selectionStart = adjustedPos;
            textarea.selectionEnd = adjustedPos;
            onUpdate(normalized);
            return;
          }
          textarea.value = updated;
          textarea.selectionStart = nextPos;
          textarea.selectionEnd = nextPos;
          onUpdate(updated);
          return;
        }
      }
      if (e.metaKey || e.ctrlKey) {
        e.preventDefault();
        handleFinish();
        return;
      }
    }
    if (e.key === "Escape") {
      handleFinish();
    }
  };
  const handleChange = (e) => {
    onUpdate(e.target.value);
  };
  const handleCompositionStart = () => {
    isComposing.current = true;
  };
  const handleCompositionEnd = (e) => {
    isComposing.current = false;
    handleChange({ target: { value: e.currentTarget.value } });
  };
  return /* @__PURE__ */ jsx_dev_runtime13.jsxDEV(jsx_dev_runtime13.Fragment, {
    children: /* @__PURE__ */ jsx_dev_runtime13.jsxDEV("textarea", {
      ref: textareaRef,
      style,
      defaultValue: element.text,
      onChange: handleChange,
      onBlur: handleFinish,
      onKeyDown: handleKeyDown,
      onCompositionStart: handleCompositionStart,
      onCompositionEnd: handleCompositionEnd,
      wrap: "off"
    }, undefined, false, undefined, this)
  }, undefined, false, undefined, this);
};

// ../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if (typeof e == "string" || typeof e == "number")
    n += e;
  else if (typeof e == "object")
    if (Array.isArray(e)) {
      var o2 = e.length;
      for (t = 0;t < o2; t++)
        e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else
      for (f in e)
        e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o2 = arguments.length;f < o2; f++)
    (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}

// ../../node_modules/.pnpm/tailwind-merge@2.6.0/node_modules/tailwind-merge/dist/bundle-mjs.mjs
var CLASS_PART_SEPARATOR = "-";
var createClassGroupUtils = (config) => {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  const getClassGroupId = (className) => {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
var getGroupRecursive = (classParts, classPartObject) => {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : undefined;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return classPartObject.validators.find(({
    validator
  }) => validator(classRest))?.classGroupId;
};
var arbitraryPropertyRegex = /^\[(.+)\]$/;
var getGroupIdForArbitraryProperty = (className) => {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
};
var createClassMap = (config) => {
  const {
    theme,
    prefix
  } = config;
  const classMap = {
    nextPart: new Map,
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
};
var processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
};
var getPart = (classPartObject, path) => {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: new Map,
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
};
var isThemeGetter = (func) => func.isThemeGetter;
var getPrefixedClassGroupEntries = (classGroupEntries, prefix) => {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
};
var createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => {
        return;
      },
      set: () => {}
    };
  }
  let cacheSize = 0;
  let cache = new Map;
  let previousCache = new Map;
  const update = (key, value) => {
    cache.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = new Map;
    }
  };
  return {
    get(key) {
      let value = cache.get(key);
      if (value !== undefined) {
        return value;
      }
      if ((value = previousCache.get(key)) !== undefined) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache.has(key)) {
        cache.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
};
var IMPORTANT_MODIFIER = "!";
var createParseClassName = (config) => {
  const {
    separator,
    experimentalParseClassName
  } = config;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  const parseClassName = (className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index = 0;index < className.length; index++) {
      let currentCharacter = className[index];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index, index + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index));
          modifierStart = index + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : undefined;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
  if (experimentalParseClassName) {
    return (className) => experimentalParseClassName({
      className,
      parseClassName
    });
  }
  return parseClassName;
};
var sortModifiers = (modifiers) => {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
};
var createConfigUtils = (config) => ({
  cache: createLruCache(config.cacheSize),
  parseClassName: createParseClassName(config),
  ...createClassGroupUtils(config)
});
var SPLIT_CLASSES_REGEX = /\s+/;
var mergeClassList = (classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index = classNames.length - 1;index >= 0; index -= 1) {
    const originalClassName = classNames[index];
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.includes(classId)) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i2 = 0;i2 < conflictGroups.length; ++i2) {
      const group = conflictGroups[i2];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
function twJoin() {
  let index = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index < arguments.length) {
    if (argument = arguments[index++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
var toValue = (mix) => {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k = 0;k < mix.length; k++) {
    if (mix[k]) {
      if (resolvedValue = toValue(mix[k])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
var fromTheme = (key) => {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
var arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
var fractionRegex = /^\d+\/\d+$/;
var stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
var colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
var shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
var imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
var isLength = (value) => isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
var isArbitraryLength = (value) => getIsArbitraryValue(value, "length", isLengthOnly);
var isNumber = (value) => Boolean(value) && !Number.isNaN(Number(value));
var isArbitraryNumber = (value) => getIsArbitraryValue(value, "number", isNumber);
var isInteger = (value) => Boolean(value) && Number.isInteger(Number(value));
var isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
var isArbitraryValue = (value) => arbitraryValueRegex.test(value);
var isTshirtSize = (value) => tshirtUnitRegex.test(value);
var sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
var isArbitrarySize = (value) => getIsArbitraryValue(value, sizeLabels, isNever);
var isArbitraryPosition = (value) => getIsArbitraryValue(value, "position", isNever);
var imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
var isArbitraryImage = (value) => getIsArbitraryValue(value, imageLabels, isImage);
var isArbitraryShadow = (value) => getIsArbitraryValue(value, "", isShadow);
var isAny = () => true;
var getIsArbitraryValue = (value, label, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return typeof label === "string" ? result[1] === label : label.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
var isLengthOnly = (value) => lengthUnitRegex.test(value) && !colorFunctionRegex.test(value);
var isNever = () => false;
var isShadow = (value) => shadowRegex.test(value);
var isImage = (value) => imageRegex.test(value);
var getDefaultConfig = () => {
  const colors = fromTheme("colors");
  const spacing = fromTheme("spacing");
  const blur = fromTheme("blur");
  const brightness = fromTheme("brightness");
  const borderColor = fromTheme("borderColor");
  const borderRadius = fromTheme("borderRadius");
  const borderSpacing = fromTheme("borderSpacing");
  const borderWidth = fromTheme("borderWidth");
  const contrast = fromTheme("contrast");
  const grayscale = fromTheme("grayscale");
  const hueRotate = fromTheme("hueRotate");
  const invert = fromTheme("invert");
  const gap = fromTheme("gap");
  const gradientColorStops = fromTheme("gradientColorStops");
  const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  const inset = fromTheme("inset");
  const margin = fromTheme("margin");
  const opacity = fromTheme("opacity");
  const padding = fromTheme("padding");
  const saturate = fromTheme("saturate");
  const scale = fromTheme("scale");
  const sepia = fromTheme("sepia");
  const skew = fromTheme("skew");
  const space = fromTheme("space");
  const translate = fromTheme("translate");
  const getOverscroll = () => ["auto", "contain", "none"];
  const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
  const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
  const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
  const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
  const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
  const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
  const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumberAndArbitrary(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumberAndArbitrary(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumberAndArbitrary(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumberAndArbitrary(),
      scale: getNumberAndArbitrary(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      container: ["container"],
      columns: [{
        columns: [isTshirtSize]
      }],
      "break-after": [{
        "break-after": getBreaks()
      }],
      "break-before": [{
        "break-before": getBreaks()
      }],
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      box: [{
        box: ["border", "content"]
      }],
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      isolation: ["isolate", "isolation-auto"],
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      "object-position": [{
        object: [...getPositions(), isArbitraryValue]
      }],
      overflow: [{
        overflow: getOverflow()
      }],
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      overscroll: [{
        overscroll: getOverscroll()
      }],
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      inset: [{
        inset: [inset]
      }],
      "inset-x": [{
        "inset-x": [inset]
      }],
      "inset-y": [{
        "inset-y": [inset]
      }],
      start: [{
        start: [inset]
      }],
      end: [{
        end: [inset]
      }],
      top: [{
        top: [inset]
      }],
      right: [{
        right: [inset]
      }],
      bottom: [{
        bottom: [inset]
      }],
      left: [{
        left: [inset]
      }],
      visibility: ["visible", "invisible", "collapse"],
      z: [{
        z: ["auto", isInteger, isArbitraryValue]
      }],
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      grow: [{
        grow: getZeroAndEmpty()
      }],
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      order: [{
        order: ["first", "last", "none", isInteger, isArbitraryValue]
      }],
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      gap: [{
        gap: [gap]
      }],
      "gap-x": [{
        "gap-x": [gap]
      }],
      "gap-y": [{
        "gap-y": [gap]
      }],
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      p: [{
        p: [padding]
      }],
      px: [{
        px: [padding]
      }],
      py: [{
        py: [padding]
      }],
      ps: [{
        ps: [padding]
      }],
      pe: [{
        pe: [padding]
      }],
      pt: [{
        pt: [padding]
      }],
      pr: [{
        pr: [padding]
      }],
      pb: [{
        pb: [padding]
      }],
      pl: [{
        pl: [padding]
      }],
      m: [{
        m: [margin]
      }],
      mx: [{
        mx: [margin]
      }],
      my: [{
        my: [margin]
      }],
      ms: [{
        ms: [margin]
      }],
      me: [{
        me: [margin]
      }],
      mt: [{
        mt: [margin]
      }],
      mr: [{
        mr: [margin]
      }],
      mb: [{
        mb: [margin]
      }],
      ml: [{
        ml: [margin]
      }],
      "space-x": [{
        "space-x": [space]
      }],
      "space-x-reverse": ["space-x-reverse"],
      "space-y": [{
        "space-y": [space]
      }],
      "space-y-reverse": ["space-y-reverse"],
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
      }],
      "min-w": [{
        "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      "max-w": [{
        "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize]
      }],
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      "min-h": [{
        "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      size: [{
        size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      "font-style": ["italic", "not-italic"],
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      "font-family": [{
        font: [isAny]
      }],
      "fvn-normal": ["normal-nums"],
      "fvn-ordinal": ["ordinal"],
      "fvn-slashed-zero": ["slashed-zero"],
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
      }],
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      "placeholder-color": [{
        placeholder: [colors]
      }],
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      "text-color": [{
        text: [colors]
      }],
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength, isArbitraryLength]
      }],
      "underline-offset": [{
        "underline-offset": ["auto", isLength, isArbitraryValue]
      }],
      "text-decoration-color": [{
        decoration: [colors]
      }],
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      content: [{
        content: ["none", isArbitraryValue]
      }],
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      "bg-color": [{
        bg: [colors]
      }],
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      rounded: [{
        rounded: [borderRadius]
      }],
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      "border-w": [{
        border: [borderWidth]
      }],
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      "divide-x-reverse": ["divide-x-reverse"],
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      "divide-y-reverse": ["divide-y-reverse"],
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      "divide-style": [{
        divide: getLineStyles()
      }],
      "border-color": [{
        border: [borderColor]
      }],
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      "border-color-s": [{
        "border-s": [borderColor]
      }],
      "border-color-e": [{
        "border-e": [borderColor]
      }],
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      "divide-color": [{
        divide: [borderColor]
      }],
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      "outline-offset": [{
        "outline-offset": [isLength, isArbitraryValue]
      }],
      "outline-w": [{
        outline: [isLength, isArbitraryLength]
      }],
      "outline-color": [{
        outline: [colors]
      }],
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      "ring-w-inset": ["ring-inset"],
      "ring-color": [{
        ring: [colors]
      }],
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      "ring-offset-w": [{
        "ring-offset": [isLength, isArbitraryLength]
      }],
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      "shadow-color": [{
        shadow: [isAny]
      }],
      opacity: [{
        opacity: [opacity]
      }],
      "mix-blend": [{
        "mix-blend": [...getBlendModes(), "plus-lighter", "plus-darker"]
      }],
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      filter: [{
        filter: ["", "none"]
      }],
      blur: [{
        blur: [blur]
      }],
      brightness: [{
        brightness: [brightness]
      }],
      contrast: [{
        contrast: [contrast]
      }],
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      grayscale: [{
        grayscale: [grayscale]
      }],
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      invert: [{
        invert: [invert]
      }],
      saturate: [{
        saturate: [saturate]
      }],
      sepia: [{
        sepia: [sepia]
      }],
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      caption: [{
        caption: ["top", "bottom"]
      }],
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      scale: [{
        scale: [scale]
      }],
      "scale-x": [{
        "scale-x": [scale]
      }],
      "scale-y": [{
        "scale-y": [scale]
      }],
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      "translate-x": [{
        "translate-x": [translate]
      }],
      "translate-y": [{
        "translate-y": [translate]
      }],
      "skew-x": [{
        "skew-x": [skew]
      }],
      "skew-y": [{
        "skew-y": [skew]
      }],
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      accent: [{
        accent: ["auto", colors]
      }],
      appearance: [{
        appearance: ["none", "auto"]
      }],
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      "caret-color": [{
        caret: [colors]
      }],
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      "touch-pz": ["touch-pinch-zoom"],
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      fill: [{
        fill: [colors, "none"]
      }],
      "stroke-w": [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      stroke: [{
        stroke: [colors, "none"]
      }],
      sr: ["sr-only", "not-sr-only"],
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
};
var twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);

// ../../src/lib/utils.ts
function cn(...inputs) {
  return twMerge(clsx(inputs));
}

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/createLucideIcon.js
var import_react13 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/shared/src/utils.js
var toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
var mergeClasses = (...classes) => classes.filter((className, index, array) => {
  return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
}).join(" ").trim();

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/Icon.js
var import_react12 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/Icon.js
var Icon = import_react12.forwardRef(({
  color = "currentColor",
  size = 24,
  strokeWidth = 2,
  absoluteStrokeWidth,
  className = "",
  children,
  iconNode,
  ...rest
}, ref) => {
  return import_react12.createElement("svg", {
    ref,
    ...defaultAttributes,
    width: size,
    height: size,
    stroke: color,
    strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
    className: mergeClasses("lucide", className),
    ...rest
  }, [
    ...iconNode.map(([tag, attrs]) => import_react12.createElement(tag, attrs)),
    ...Array.isArray(children) ? children : [children]
  ]);
});

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/createLucideIcon.js
var createLucideIcon = (iconName, iconNode) => {
  const Component2 = import_react13.forwardRef(({ className, ...props }, ref) => import_react13.createElement(Icon, {
    ref,
    iconNode,
    className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className),
    ...props
  }));
  Component2.displayName = `${iconName}`;
  return Component2;
};

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/align-center.js
var AlignCenter = createLucideIcon("AlignCenter", [
  ["path", { d: "M17 12H7", key: "16if0g" }],
  ["path", { d: "M19 18H5", key: "18s9l3" }],
  ["path", { d: "M21 6H3", key: "1jwq7v" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/align-justify.js
var AlignJustify = createLucideIcon("AlignJustify", [
  ["path", { d: "M3 12h18", key: "1i2n21" }],
  ["path", { d: "M3 18h18", key: "1h113x" }],
  ["path", { d: "M3 6h18", key: "d0wm0j" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/align-left.js
var AlignLeft = createLucideIcon("AlignLeft", [
  ["path", { d: "M15 12H3", key: "6jk70r" }],
  ["path", { d: "M17 18H3", key: "1amg6g" }],
  ["path", { d: "M21 6H3", key: "1jwq7v" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/align-right.js
var AlignRight = createLucideIcon("AlignRight", [
  ["path", { d: "M21 12H9", key: "dn1m92" }],
  ["path", { d: "M21 18H7", key: "1ygte8" }],
  ["path", { d: "M21 6H3", key: "1jwq7v" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/align-vertical-justify-center.js
var AlignVerticalJustifyCenter = createLucideIcon("AlignVerticalJustifyCenter", [
  ["rect", { width: "14", height: "6", x: "5", y: "16", rx: "2", key: "1i8z2d" }],
  ["rect", { width: "10", height: "6", x: "7", y: "2", rx: "2", key: "ypihtt" }],
  ["path", { d: "M2 12h20", key: "9i4pu4" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/arrow-down-to-line.js
var ArrowDownToLine = createLucideIcon("ArrowDownToLine", [
  ["path", { d: "M12 17V3", key: "1cwfxf" }],
  ["path", { d: "m6 11 6 6 6-6", key: "12ii2o" }],
  ["path", { d: "M19 21H5", key: "150jfl" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/arrow-down.js
var ArrowDown = createLucideIcon("ArrowDown", [
  ["path", { d: "M12 5v14", key: "s699le" }],
  ["path", { d: "m19 12-7 7-7-7", key: "1idqje" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/arrow-left-to-line.js
var ArrowLeftToLine = createLucideIcon("ArrowLeftToLine", [
  ["path", { d: "M3 19V5", key: "rwsyhb" }],
  ["path", { d: "m13 6-6 6 6 6", key: "1yhaz7" }],
  ["path", { d: "M7 12h14", key: "uoisry" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/arrow-left.js
var ArrowLeft = createLucideIcon("ArrowLeft", [
  ["path", { d: "m12 19-7-7 7-7", key: "1l729n" }],
  ["path", { d: "M19 12H5", key: "x3x0zl" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/arrow-right-to-line.js
var ArrowRightToLine = createLucideIcon("ArrowRightToLine", [
  ["path", { d: "M17 12H3", key: "8awo09" }],
  ["path", { d: "m11 18 6-6-6-6", key: "8c2y43" }],
  ["path", { d: "M21 5v14", key: "nzette" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/arrow-right.js
var ArrowRight = createLucideIcon("ArrowRight", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/arrow-up-to-line.js
var ArrowUpToLine = createLucideIcon("ArrowUpToLine", [
  ["path", { d: "M5 3h14", key: "7usisc" }],
  ["path", { d: "m18 13-6-6-6 6", key: "1kf1n9" }],
  ["path", { d: "M12 7v14", key: "1akyts" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/arrow-up.js
var ArrowUp = createLucideIcon("ArrowUp", [
  ["path", { d: "m5 12 7-7 7 7", key: "hav0vg" }],
  ["path", { d: "M12 19V5", key: "x0mq9r" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/bed-double.js
var BedDouble = createLucideIcon("BedDouble", [
  ["path", { d: "M2 20v-8a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v8", key: "1k78r4" }],
  ["path", { d: "M4 10V6a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v4", key: "fb3tl2" }],
  ["path", { d: "M12 4v6", key: "1dcgq2" }],
  ["path", { d: "M2 18h20", key: "ajqnye" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/bold.js
var Bold = createLucideIcon("Bold", [
  [
    "path",
    { d: "M6 12h9a4 4 0 0 1 0 8H7a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h7a4 4 0 0 1 0 8", key: "mg9rjx" }
  ]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/bring-to-front.js
var BringToFront = createLucideIcon("BringToFront", [
  ["rect", { x: "8", y: "8", width: "8", height: "8", rx: "2", key: "yj20xf" }],
  ["path", { d: "M4 10a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2", key: "1ltk23" }],
  ["path", { d: "M14 20a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2", key: "1q24h9" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/calendar.js
var Calendar = createLucideIcon("Calendar", [
  ["path", { d: "M8 2v4", key: "1cmpym" }],
  ["path", { d: "M16 2v4", key: "4m81vk" }],
  ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }],
  ["path", { d: "M3 10h18", key: "8toen8" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/check-check.js
var CheckCheck = createLucideIcon("CheckCheck", [
  ["path", { d: "M18 6 7 17l-5-5", key: "116fxf" }],
  ["path", { d: "m22 10-7.5 7.5L13 16", key: "ke71qq" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/check.js
var Check = createLucideIcon("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/chevron-down.js
var ChevronDown = createLucideIcon("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/chevron-left.js
var ChevronLeft = createLucideIcon("ChevronLeft", [
  ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/chevron-right.js
var ChevronRight = createLucideIcon("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/chevron-up.js
var ChevronUp = createLucideIcon("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/chevrons-down.js
var ChevronsDown = createLucideIcon("ChevronsDown", [
  ["path", { d: "m7 6 5 5 5-5", key: "1lc07p" }],
  ["path", { d: "m7 13 5 5 5-5", key: "1d48rs" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/chevrons-up.js
var ChevronsUp = createLucideIcon("ChevronsUp", [
  ["path", { d: "m17 11-5-5-5 5", key: "e8nh98" }],
  ["path", { d: "m17 18-5-5-5 5", key: "2avn1x" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/circle-alert.js
var CircleAlert = createLucideIcon("CircleAlert", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
  ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/circle.js
var Circle3 = createLucideIcon("Circle", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/clipboard-paste.js
var ClipboardPaste = createLucideIcon("ClipboardPaste", [
  [
    "path",
    { d: "M15 2H9a1 1 0 0 0-1 1v2c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V3c0-.6-.4-1-1-1Z", key: "1pp7kr" }
  ],
  [
    "path",
    {
      d: "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2M16 4h2a2 2 0 0 1 2 2v2M11 14h10",
      key: "2ik1ml"
    }
  ],
  ["path", { d: "m17 10 4 4-4 4", key: "vp2hj1" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/clock.js
var Clock = createLucideIcon("Clock", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/copy.js
var Copy = createLucideIcon("Copy", [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/database.js
var Database = createLucideIcon("Database", [
  ["ellipse", { cx: "12", cy: "5", rx: "9", ry: "3", key: "msslwz" }],
  ["path", { d: "M3 5V19A9 3 0 0 0 21 19V5", key: "1wlel7" }],
  ["path", { d: "M3 12A9 3 0 0 0 21 12", key: "mv7ke4" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/diamond.js
var Diamond = createLucideIcon("Diamond", [
  [
    "path",
    {
      d: "M2.7 10.3a2.41 2.41 0 0 0 0 3.41l7.59 7.59a2.41 2.41 0 0 0 3.41 0l7.59-7.59a2.41 2.41 0 0 0 0-3.41l-7.59-7.59a2.41 2.41 0 0 0-3.41 0Z",
      key: "1f1r0c"
    }
  ]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/download.js
var Download = createLucideIcon("Download", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }],
  ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/ellipsis.js
var Ellipsis = createLucideIcon("Ellipsis", [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "19", cy: "12", r: "1", key: "1wjl8i" }],
  ["circle", { cx: "5", cy: "12", r: "1", key: "1pcz8c" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/file-down.js
var FileDown = createLucideIcon("FileDown", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M12 18v-6", key: "17g6i2" }],
  ["path", { d: "m9 15 3 3 3-3", key: "1npd3o" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/folder-open.js
var FolderOpen = createLucideIcon("FolderOpen", [
  [
    "path",
    {
      d: "m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2",
      key: "usdka0"
    }
  ]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/hash.js
var Hash = createLucideIcon("Hash", [
  ["line", { x1: "4", x2: "20", y1: "9", y2: "9", key: "4lhtct" }],
  ["line", { x1: "4", x2: "20", y1: "15", y2: "15", key: "vyu0kd" }],
  ["line", { x1: "10", x2: "8", y1: "3", y2: "21", key: "1ggp8o" }],
  ["line", { x1: "16", x2: "14", y1: "3", y2: "21", key: "weycgp" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/heart.js
var Heart = createLucideIcon("Heart", [
  [
    "path",
    {
      d: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z",
      key: "c3ymky"
    }
  ]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/hexagon.js
var Hexagon = createLucideIcon("Hexagon", [
  [
    "path",
    {
      d: "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z",
      key: "yt0hxn"
    }
  ]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/house.js
var House = createLucideIcon("House", [
  ["path", { d: "M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8", key: "5wwlr5" }],
  [
    "path",
    {
      d: "M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",
      key: "1d0kgt"
    }
  ]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/image.js
var Image4 = createLucideIcon("Image", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2", key: "1m3agn" }],
  ["circle", { cx: "9", cy: "9", r: "2", key: "af1f0g" }],
  ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21", key: "1xmnt7" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/italic.js
var Italic = createLucideIcon("Italic", [
  ["line", { x1: "19", x2: "10", y1: "4", y2: "4", key: "15jd3p" }],
  ["line", { x1: "14", x2: "5", y1: "20", y2: "20", key: "bu0au3" }],
  ["line", { x1: "15", x2: "9", y1: "4", y2: "20", key: "uljnxc" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/keyboard.js
var Keyboard = createLucideIcon("Keyboard", [
  ["path", { d: "M10 8h.01", key: "1r9ogq" }],
  ["path", { d: "M12 12h.01", key: "1mp3jc" }],
  ["path", { d: "M14 8h.01", key: "1primd" }],
  ["path", { d: "M16 12h.01", key: "1l6xoz" }],
  ["path", { d: "M18 8h.01", key: "emo2bl" }],
  ["path", { d: "M6 8h.01", key: "x9i8wu" }],
  ["path", { d: "M7 16h10", key: "wp8him" }],
  ["path", { d: "M8 12h.01", key: "czm47f" }],
  ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/layers.js
var Layers = createLucideIcon("Layers", [
  [
    "path",
    {
      d: "M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z",
      key: "zw3jo"
    }
  ],
  [
    "path",
    {
      d: "M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12",
      key: "1wduqc"
    }
  ],
  [
    "path",
    {
      d: "M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17",
      key: "kqbvx6"
    }
  ]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/layout-template.js
var LayoutTemplate = createLucideIcon("LayoutTemplate", [
  ["rect", { width: "18", height: "7", x: "3", y: "3", rx: "1", key: "f1a2em" }],
  ["rect", { width: "9", height: "7", x: "3", y: "14", rx: "1", key: "jqznyg" }],
  ["rect", { width: "5", height: "7", x: "16", y: "14", rx: "1", key: "q5h2i8" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/link.js
var Link = createLucideIcon("Link", [
  ["path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71", key: "1cjeqo" }],
  ["path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71", key: "19qd67" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/loader-circle.js
var LoaderCircle = createLucideIcon("LoaderCircle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/maximize.js
var Maximize = createLucideIcon("Maximize", [
  ["path", { d: "M8 3H5a2 2 0 0 0-2 2v3", key: "1dcmit" }],
  ["path", { d: "M21 8V5a2 2 0 0 0-2-2h-3", key: "1e4gt3" }],
  ["path", { d: "M3 16v3a2 2 0 0 0 2 2h3", key: "wsl5sc" }],
  ["path", { d: "M16 21h3a2 2 0 0 0 2-2v-3", key: "18trek" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/minimize.js
var Minimize = createLucideIcon("Minimize", [
  ["path", { d: "M8 3v3a2 2 0 0 1-2 2H3", key: "hohbtr" }],
  ["path", { d: "M21 8h-3a2 2 0 0 1-2-2V3", key: "5jw1f3" }],
  ["path", { d: "M3 16h3a2 2 0 0 1 2 2v3", key: "198tvr" }],
  ["path", { d: "M16 21v-3a2 2 0 0 1 2-2h3", key: "ph8mxp" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/minus.js
var Minus = createLucideIcon("Minus", [["path", { d: "M5 12h14", key: "1ays0h" }]]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/mouse-pointer-2.js
var MousePointer2 = createLucideIcon("MousePointer2", [
  [
    "path",
    {
      d: "M4.037 4.688a.495.495 0 0 1 .651-.651l16 6.5a.5.5 0 0 1-.063.947l-6.124 1.58a2 2 0 0 0-1.438 1.435l-1.579 6.126a.5.5 0 0 1-.947.063z",
      key: "edeuup"
    }
  ]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/palette.js
var Palette = createLucideIcon("Palette", [
  ["circle", { cx: "13.5", cy: "6.5", r: ".5", fill: "currentColor", key: "1okk4w" }],
  ["circle", { cx: "17.5", cy: "10.5", r: ".5", fill: "currentColor", key: "f64h9f" }],
  ["circle", { cx: "8.5", cy: "7.5", r: ".5", fill: "currentColor", key: "fotxhn" }],
  ["circle", { cx: "6.5", cy: "12.5", r: ".5", fill: "currentColor", key: "qy21gx" }],
  [
    "path",
    {
      d: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z",
      key: "12rzf8"
    }
  ]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/pen-tool.js
var PenTool = createLucideIcon("PenTool", [
  [
    "path",
    {
      d: "M15.707 21.293a1 1 0 0 1-1.414 0l-1.586-1.586a1 1 0 0 1 0-1.414l5.586-5.586a1 1 0 0 1 1.414 0l1.586 1.586a1 1 0 0 1 0 1.414z",
      key: "nt11vn"
    }
  ],
  [
    "path",
    {
      d: "m18 13-1.375-6.874a1 1 0 0 0-.746-.776L3.235 2.028a1 1 0 0 0-1.207 1.207L5.35 15.879a1 1 0 0 0 .776.746L13 18",
      key: "15qc1e"
    }
  ],
  ["path", { d: "m2.3 2.3 7.286 7.286", key: "1wuzzi" }],
  ["circle", { cx: "11", cy: "11", r: "2", key: "xmgehs" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/pentagon.js
var Pentagon = createLucideIcon("Pentagon", [
  [
    "path",
    {
      d: "M10.83 2.38a2 2 0 0 1 2.34 0l8 5.74a2 2 0 0 1 .73 2.25l-3.04 9.26a2 2 0 0 1-1.9 1.37H7.04a2 2 0 0 1-1.9-1.37L2.1 10.37a2 2 0 0 1 .73-2.25z",
      key: "2hea0t"
    }
  ]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/play.js
var Play = createLucideIcon("Play", [
  ["polygon", { points: "6 3 20 12 6 21 6 3", key: "1oa8hb" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/redo-2.js
var Redo2 = createLucideIcon("Redo2", [
  ["path", { d: "m15 14 5-5-5-5", key: "12vg1m" }],
  ["path", { d: "M20 9H9.5A5.5 5.5 0 0 0 4 14.5A5.5 5.5 0 0 0 9.5 20H13", key: "6uklza" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/redo.js
var Redo = createLucideIcon("Redo", [
  ["path", { d: "M21 7v6h-6", key: "3ptur4" }],
  ["path", { d: "M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7", key: "1kgawr" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/refresh-cw.js
var RefreshCw = createLucideIcon("RefreshCw", [
  ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
  ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
  ["path", { d: "M8 16H3v5", key: "1cv678" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/save.js
var Save = createLucideIcon("Save", [
  [
    "path",
    {
      d: "M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z",
      key: "1c8476"
    }
  ],
  ["path", { d: "M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7", key: "1ydtos" }],
  ["path", { d: "M7 3v4a1 1 0 0 0 1 1h7", key: "t51u73" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/search.js
var Search = createLucideIcon("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/send-to-back.js
var SendToBack = createLucideIcon("SendToBack", [
  ["rect", { x: "14", y: "14", width: "8", height: "8", rx: "2", key: "1b0bso" }],
  ["rect", { x: "2", y: "2", width: "8", height: "8", rx: "2", key: "1x09vl" }],
  ["path", { d: "M7 14v1a2 2 0 0 0 2 2h1", key: "pao6x6" }],
  ["path", { d: "M14 7h1a2 2 0 0 1 2 2v1", key: "19tdru" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/settings-2.js
var Settings2 = createLucideIcon("Settings2", [
  ["path", { d: "M20 7h-9", key: "3s1dr2" }],
  ["path", { d: "M14 17H5", key: "gfn3mx" }],
  ["circle", { cx: "17", cy: "17", r: "3", key: "18b49y" }],
  ["circle", { cx: "7", cy: "7", r: "3", key: "dfmy0x" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/shapes.js
var Shapes = createLucideIcon("Shapes", [
  [
    "path",
    {
      d: "M8.3 10a.7.7 0 0 1-.626-1.079L11.4 3a.7.7 0 0 1 1.198-.043L16.3 8.9a.7.7 0 0 1-.572 1.1Z",
      key: "1bo67w"
    }
  ],
  ["rect", { x: "3", y: "14", width: "7", height: "7", rx: "1", key: "1bkyp8" }],
  ["circle", { cx: "17.5", cy: "17.5", r: "3.5", key: "w3z12y" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/square.js
var Square = createLucideIcon("Square", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/star.js
var Star3 = createLucideIcon("Star", [
  [
    "path",
    {
      d: "M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z",
      key: "r04s7s"
    }
  ]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/strikethrough.js
var Strikethrough = createLucideIcon("Strikethrough", [
  ["path", { d: "M16 4H9a3 3 0 0 0-2.83 4", key: "43sutm" }],
  ["path", { d: "M14 12a4 4 0 0 1 0 8H6", key: "nlfj13" }],
  ["line", { x1: "4", x2: "20", y1: "12", y2: "12", key: "1e0a9i" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/table.js
var Table = createLucideIcon("Table", [
  ["path", { d: "M12 3v18", key: "108xh3" }],
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M3 9h18", key: "1pudct" }],
  ["path", { d: "M3 15h18", key: "5xshup" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/trash-2.js
var Trash2 = createLucideIcon("Trash2", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/triangle.js
var Triangle = createLucideIcon("Triangle", [
  [
    "path",
    { d: "M13.73 4a2 2 0 0 0-3.46 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z", key: "14u9p9" }
  ]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/type.js
var Type = createLucideIcon("Type", [
  ["polyline", { points: "4 7 4 4 20 4 20 7", key: "1nosan" }],
  ["line", { x1: "9", x2: "15", y1: "20", y2: "20", key: "swin9y" }],
  ["line", { x1: "12", x2: "12", y1: "4", y2: "20", key: "1tx1rr" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/underline.js
var Underline = createLucideIcon("Underline", [
  ["path", { d: "M6 4v6a6 6 0 0 0 12 0V4", key: "9kb039" }],
  ["line", { x1: "4", x2: "20", y1: "20", y2: "20", key: "nun2al" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/undo-2.js
var Undo2 = createLucideIcon("Undo2", [
  ["path", { d: "M9 14 4 9l5-5", key: "102s5s" }],
  ["path", { d: "M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5a5.5 5.5 0 0 1-5.5 5.5H11", key: "f3b9sd" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/undo.js
var Undo = createLucideIcon("Undo", [
  ["path", { d: "M3 7v6h6", key: "1v2h90" }],
  ["path", { d: "M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13", key: "1r6uu6" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/upload.js
var Upload = createLucideIcon("Upload", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "17 8 12 3 7 8", key: "t8dd8p" }],
  ["line", { x1: "12", x2: "12", y1: "3", y2: "15", key: "widbto" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/x.js
var X = createLucideIcon("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/zoom-in.js
var ZoomIn = createLucideIcon("ZoomIn", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65", key: "13gj7c" }],
  ["line", { x1: "11", x2: "11", y1: "8", y2: "14", key: "1vmskp" }],
  ["line", { x1: "8", x2: "14", y1: "11", y2: "11", key: "durymu" }]
]);

// ../../node_modules/.pnpm/lucide-react@0.470.0_react@19.2.3/node_modules/lucide-react/dist/esm/icons/zoom-out.js
var ZoomOut = createLucideIcon("ZoomOut", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65", key: "13gj7c" }],
  ["line", { x1: "8", x2: "14", y1: "11", y2: "11", key: "durymu" }]
]);
// ../../src/components/canvas/ObjectContextMenu.tsx
var import_react14 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var jsx_dev_runtime14 = __toESM(require_jsx_dev_runtime(), 1);
var ObjectContextMenu = ({
  visible,
  x: x2,
  y,
  onClose,
  onAction
}) => {
  const { t } = useI18n();
  const ref = import_react14.useRef(null);
  const [position, setPosition] = import_react14.useState({ x: x2, y });
  const handleAction = (action) => {
    onAction(action);
    onClose();
  };
  import_react14.useEffect(() => {
    const handleClickOutside = (event) => {
      if (ref.current && !ref.current.contains(event.target)) {
        onClose();
      }
    };
    if (visible) {
      document.addEventListener("mousedown", handleClickOutside);
      if (ref.current) {
        const rect = ref.current.getBoundingClientRect();
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        let adjustedX = x2;
        let adjustedY = y;
        if (x2 + rect.width > windowWidth) {
          adjustedX = windowWidth - rect.width - 8;
        }
        if (y + rect.height > windowHeight) {
          adjustedY = windowHeight - rect.height - 8;
        }
        if (adjustedX !== x2 || adjustedY !== y) {
          setPosition({ x: adjustedX, y: adjustedY });
        }
      }
    }
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [visible, onClose, x2, y]);
  import_react14.useEffect(() => {
    if (visible) {
      setPosition({ x: x2, y });
    }
  }, [x2, y, visible]);
  if (!visible)
    return null;
  const itemClass = "flex items-center w-full px-3 py-2 text-sm text-left hover:bg-accent text-foreground gap-2 cursor-pointer";
  return import_react_dom.createPortal(/* @__PURE__ */ jsx_dev_runtime14.jsxDEV("div", {
    ref,
    className: "fixed z-50 bg-popover text-popover-foreground border border-border rounded shadow-lg w-48 py-1",
    style: { top: position.y, left: position.x },
    onContextMenu: (e) => e.preventDefault(),
    role: "menu",
    tabIndex: -1,
    children: [
      /* @__PURE__ */ jsx_dev_runtime14.jsxDEV("button", {
        type: "button",
        onClick: () => handleAction("bringToFront"),
        className: itemClass,
        children: [
          /* @__PURE__ */ jsx_dev_runtime14.jsxDEV(BringToFront, {
            className: "w-4 h-4"
          }, undefined, false, undefined, this),
          t("ctx_bring_to_front", "")
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime14.jsxDEV("button", {
        type: "button",
        onClick: () => handleAction("sendToBack"),
        className: itemClass,
        children: [
          /* @__PURE__ */ jsx_dev_runtime14.jsxDEV(SendToBack, {
            className: "w-4 h-4"
          }, undefined, false, undefined, this),
          t("ctx_send_to_back", "")
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime14.jsxDEV("div", {
        className: "my-1 border-t border-border"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime14.jsxDEV("button", {
        type: "button",
        onClick: () => handleAction("bringForward"),
        className: itemClass,
        children: [
          /* @__PURE__ */ jsx_dev_runtime14.jsxDEV(ArrowUp, {
            className: "w-4 h-4"
          }, undefined, false, undefined, this),
          t("ctx_bring_forward", "")
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime14.jsxDEV("button", {
        type: "button",
        onClick: () => handleAction("sendBackward"),
        className: itemClass,
        children: [
          /* @__PURE__ */ jsx_dev_runtime14.jsxDEV(ArrowDown, {
            className: "w-4 h-4"
          }, undefined, false, undefined, this),
          t("ctx_send_backward", "")
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this), document.body);
};

// ../../src/utils/reorderUtils.ts
var reorderNodes = (nodes, targetId, action) => {
  const currentIndex = nodes.findIndex((n) => n.id === targetId);
  if (currentIndex === -1)
    return nodes;
  const newNodes = [...nodes];
  const [target] = newNodes.splice(currentIndex, 1);
  switch (action) {
    case "bringToFront":
      newNodes.push(target);
      break;
    case "sendToBack":
      newNodes.unshift(target);
      break;
    case "bringForward":
      if (currentIndex < nodes.length - 1) {
        newNodes.splice(currentIndex + 1, 0, target);
      } else {
        newNodes.push(target);
      }
      break;
    case "sendBackward":
      if (currentIndex > 0) {
        newNodes.splice(currentIndex - 1, 0, target);
      } else {
        newNodes.unshift(target);
      }
      break;
  }
  return newNodes;
};

// ../../src/components/canvas/KonvaCanvasEditor.tsx
var jsx_dev_runtime15 = __toESM(require_jsx_dev_runtime(), 1);
var KonvaCanvasEditor = import_react15.forwardRef(({
  elements,
  selectedIds,
  onSelect,
  onChange,
  zoom,
  paperWidth,
  paperHeight,
  background,
  overlay,
  renderCustom,
  readOnly = false,
  onUndo,
  onRedo,
  onDelete,
  onStageMouseDown,
  onStageMouseMove,
  onStageMouseUp,
  showGrid = false,
  snapStrength = 5,
  gridSize = 5,
  onCreateElements,
  initialScrollCenter,
  onToggleCollapse,
  onDragStart,
  onDragMove,
  onDragEnter,
  onDragLeave,
  onDragEnd,
  dragState,
  className,
  showPaperBorder = true,
  onReorderNodes,
  onContextMenu
}, ref) => {
  const containerRef = import_react15.useRef(null);
  const stageRef = import_react15.useRef(null);
  const [editingElementId, setEditingElementId] = import_react15.useState(null);
  const [contextMenu, setContextMenu] = import_react15.useState({
    visible: false,
    x: 0,
    y: 0,
    elementId: null
  });
  const handleDefaultContextMenu = import_react15.useCallback((e, element) => {
    e.evt.preventDefault();
    if (!selectedIds.includes(element.id)) {
      onSelect([element.id]);
    }
    setContextMenu({
      visible: true,
      x: e.evt.clientX,
      y: e.evt.clientY,
      elementId: element.id
    });
  }, [selectedIds, onSelect]);
  const handleReorder = import_react15.useCallback((action) => {
    if (!contextMenu.elementId || !onReorderNodes)
      return;
    const newElements = reorderNodes(elements, contextMenu.elementId, action);
    onReorderNodes(newElements.map((el) => el.id));
    setContextMenu((prev) => ({ ...prev, visible: false }));
  }, [elements, contextMenu.elementId, onReorderNodes]);
  import_react15.useImperativeHandle(ref, () => ({
    getStage: () => stageRef.current,
    copy: handleCopy,
    paste: handlePaste
  }));
  const dpi2 = 96;
  const displayScale = mmToPx(1, { dpi: dpi2 }) * zoom;
  const stageWidth = paperWidth * displayScale;
  const stageHeight = paperHeight * displayScale;
  const initialScrollDone = import_react15.useRef(false);
  import_react15.default.useEffect(() => {
    if (initialScrollCenter && containerRef.current && !initialScrollDone.current) {
      requestAnimationFrame(() => {
        if (!containerRef.current)
          return;
        const { clientWidth, clientHeight } = containerRef.current;
        if (clientWidth === 0 || clientHeight === 0)
          return;
        const targetX = initialScrollCenter.x * displayScale;
        const targetY = initialScrollCenter.y * displayScale;
        const scrollLeft = Math.max(0, targetX - clientWidth / 2);
        const scrollTop = Math.max(0, targetY - clientHeight / 2);
        containerRef.current.scrollTo(scrollLeft, scrollTop);
        initialScrollDone.current = true;
      });
    }
  }, [initialScrollCenter, displayScale]);
  const handleSelect = (id, e) => {
    if (readOnly)
      return;
    if (!id) {
      onSelect([]);
      return;
    }
    const isMultiSelect = e?.evt?.shiftKey || e?.evt?.ctrlKey || e?.evt?.metaKey;
    if (isMultiSelect) {
      if (selectedIds.includes(id)) {
        onSelect(selectedIds.filter((s) => s !== id));
      } else {
        onSelect([...selectedIds, id]);
      }
    } else {
      onSelect([id]);
    }
  };
  const handleElementDblClick = (element) => {
    if (readOnly)
      return;
    if (element.t === "text") {
      setEditingElementId(element.id);
    }
  };
  const handleTextUpdate = (text, rect) => {
    if (!editingElementId)
      return;
    const element = elements.find((el) => el.id === editingElementId);
    if (!element || element.t !== "text") {
      onChange({ id: editingElementId, text });
      return;
    }
    const textNode = element;
    if (rect) {
      onChange({
        id: editingElementId,
        text,
        x: rect.x,
        y: rect.y,
        w: rect.w,
        h: rect.h
      });
      return;
    }
    const updatePatch = applyTextLayoutUpdates(textNode, { text });
    onChange({
      id: editingElementId,
      ...updatePatch
    });
  };
  const handleTextEditFinish = () => {
    setEditingElementId(null);
  };
  const handleSelectAll = () => {
    if (readOnly)
      return;
    onSelect(elements.map((el) => el.id));
  };
  const [pasteCount, setPasteCount] = import_react15.useState(1);
  const handleCopy = () => {
    if (selectedIds.length === 0)
      return;
    const selectedElements = elements.filter((el) => selectedIds.includes(el.id));
    if (selectedElements.length > 0) {
      localStorage.setItem("__konva_clipboard", JSON.stringify(selectedElements));
      setPasteCount(1);
    }
  };
  const handlePaste = () => {
    if (readOnly) {
      return;
    }
    if (!onCreateElements) {
      return;
    }
    try {
      const json = localStorage.getItem("__konva_clipboard");
      if (!json)
        return;
      const clipboardElements = JSON.parse(json);
      if (!Array.isArray(clipboardElements) || clipboardElements.length === 0)
        return;
      const step = paperWidth * 0.01;
      const offset = step * pasteCount;
      const newElements = clipboardElements.map((el) => {
        const newId = crypto.randomUUID();
        const newEl = { ...el, id: newId };
        if ("x" in newEl && "y" in newEl && typeof newEl.x === "number" && typeof newEl.y === "number") {
          newEl.x += offset;
          newEl.y += offset;
        }
        return newEl;
      });
      onCreateElements(newElements);
      onSelect(newElements.map((e) => e.id));
      setPasteCount((prev) => prev + 1);
    } catch (e) {
      console.error("Failed to paste elements", e);
    }
  };
  const isPanning = import_react15.useRef(false);
  const lastMousePos = import_react15.useRef({ x: 0, y: 0 });
  const shortcutsHandlers = {
    onUndo,
    onRedo,
    onDelete,
    onCopy: handleCopy,
    onPaste: handlePaste,
    onSelectAll: handleSelectAll,
    onMoveUp: () => {},
    onMoveDown: () => {},
    onMoveLeft: () => {},
    onMoveRight: () => {}
  };
  useKeyboardShortcuts(shortcutsHandlers);
  const handleNodeDragStart = import_react15.useCallback((nodeId, e) => {
    const pos = e.target.getStage()?.getPointerPosition();
    if (pos) {
      onDragStart?.(nodeId, { x: pos.x, y: pos.y });
    }
  }, [onDragStart]);
  const handleNodeDragEnter = import_react15.useCallback((nodeId, e) => {
    const pos = e.target.getStage()?.getPointerPosition();
    const rect = e.target.getClientRect();
    if (pos && rect) {
      const relativeY = (pos.y - rect.y) / rect.height;
      onDragEnter?.(nodeId, relativeY);
    }
  }, [onDragEnter]);
  const editingElement = editingElementId ? elements.find((el) => el.id === editingElementId) : undefined;
  return /* @__PURE__ */ jsx_dev_runtime15.jsxDEV("div", {
    ref: containerRef,
    className: cn("w-full h-full bg-gray-100 dark:bg-gray-900 overflow-auto flex scrollbar-thin p-2", className),
    style: {
      cursor: isPanning.current ? "grabbing" : "default",
      minWidth: 0,
      minHeight: 0
    },
    children: /* @__PURE__ */ jsx_dev_runtime15.jsxDEV("div", {
      className: cn("relative bg-white dark:bg-gray-800 w-fit h-fit", showPaperBorder && "shadow-lg border-2 border-gray-500"),
      children: [
        /* @__PURE__ */ jsx_dev_runtime15.jsxDEV(Stage2, {
          width: stageWidth,
          height: stageHeight,
          scaleX: displayScale,
          scaleY: displayScale,
          ref: stageRef,
          onContextMenu: (e) => {
            e.evt.preventDefault();
          },
          onMouseDown: (e) => {
            if (onStageMouseDown) {
              onStageMouseDown(e);
            }
            const isBackground = e.target === e.target.getStage() || e.target.name() === "paper-background";
            if (isBackground) {
              if (!onStageMouseDown) {
                handleSelect(null, e);
                setEditingElementId(null);
              }
              isPanning.current = true;
              lastMousePos.current = { x: e.evt.clientX, y: e.evt.clientY };
              if (containerRef.current)
                containerRef.current.style.cursor = "grabbing";
            }
          },
          onMouseMove: (e) => {
            onStageMouseMove?.(e);
            if (onDragMove) {
              const pos = e.target.getStage()?.getPointerPosition();
              if (pos) {
                onDragMove({ x: pos.x, y: pos.y });
              }
            }
            if (isPanning.current && containerRef.current) {
              e.evt.preventDefault();
              const dx = e.evt.clientX - lastMousePos.current.x;
              const dy = e.evt.clientY - lastMousePos.current.y;
              containerRef.current.scrollLeft -= dx;
              containerRef.current.scrollTop -= dy;
              lastMousePos.current = { x: e.evt.clientX, y: e.evt.clientY };
            }
          },
          onMouseUp: (e) => {
            onStageMouseUp?.(e);
            onDragEnd?.();
            if (isPanning.current) {
              isPanning.current = false;
              if (containerRef.current)
                containerRef.current.style.cursor = "default";
            }
          },
          onMouseLeave: () => {
            if (isPanning.current) {
              isPanning.current = false;
              if (containerRef.current)
                containerRef.current.style.cursor = "default";
            }
          },
          onTouchStart: (e) => {
            onStageMouseDown?.(e);
            if (!onStageMouseDown && (e.target === e.target.getStage() || e.target.name() === "paper-background")) {
              handleSelect(null, e);
              setEditingElementId(null);
            }
          },
          onTouchMove: (e) => onStageMouseMove?.(e),
          onTouchEnd: (e) => onStageMouseUp?.(e),
          children: [
            /* @__PURE__ */ jsx_dev_runtime15.jsxDEV(Layer2, {
              name: "paper-layer",
              children: background || /* @__PURE__ */ jsx_dev_runtime15.jsxDEV(Rect2, {
                name: "paper-background",
                x: 0,
                y: 0,
                width: paperWidth,
                height: paperHeight,
                fill: "#ffffff",
                listening: true
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime15.jsxDEV(GridLayer, {
              width: paperWidth,
              height: paperHeight,
              scale: displayScale,
              visible: showGrid,
              gridSize: gridSize > 0 ? gridSize : 50
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime15.jsxDEV(Layer2, {
              children: elements.map((element) => /* @__PURE__ */ jsx_dev_runtime15.jsxDEV(CanvasElementRenderer, {
                element,
                isSelected: selectedIds.includes(element.id),
                allElements: elements,
                stageScale: displayScale,
                onSelect: (e) => handleSelect(element.id, e),
                onChange,
                onDblClick: () => handleElementDblClick(element),
                isEditing: element.id === editingElementId,
                renderCustom,
                snapStrength,
                showGrid,
                gridSize,
                onToggleCollapse,
                onDragStart: onDragStart ? handleNodeDragStart : undefined,
                onDragEnter: onDragStart ? handleNodeDragEnter : undefined,
                onDragLeave: onDragStart ? onDragLeave : undefined,
                dragState,
                onContextMenu: (e) => {
                  if (onContextMenu) {
                    onContextMenu(e, element);
                  } else {
                    handleDefaultContextMenu(e, element);
                  }
                }
              }, element.id, false, undefined, this))
            }, undefined, false, undefined, this),
            overlay && /* @__PURE__ */ jsx_dev_runtime15.jsxDEV(Layer2, {
              name: "overlay-layer",
              listening: false,
              children: overlay
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this),
        editingElement && /* @__PURE__ */ jsx_dev_runtime15.jsxDEV(TextEditOverlay, {
          element: editingElement,
          scale: displayScale,
          stageNode: stageRef.current,
          onUpdate: handleTextUpdate,
          onFinish: handleTextEditFinish
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime15.jsxDEV(ObjectContextMenu, {
          visible: contextMenu.visible,
          x: contextMenu.x,
          y: contextMenu.y,
          onClose: () => setContextMenu((prev) => ({ ...prev, visible: false })),
          onAction: handleReorder
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this);
});
KonvaCanvasEditor.displayName = "KonvaCanvasEditor";

// ../../src/components/canvas/KonvaViewer.tsx
var jsx_dev_runtime16 = __toESM(require_jsx_dev_runtime(), 1);
var KonvaViewer = import_react16.forwardRef(({ elements, zoom, paperWidth, paperHeight, background, overlay, renderCustom }, ref) => {
  const editorRef = import_react16.useRef(null);
  import_react16.useImperativeHandle(ref, () => ({
    getStage: () => editorRef.current?.getStage() ?? null
  }));
  return /* @__PURE__ */ jsx_dev_runtime16.jsxDEV(KonvaCanvasEditor, {
    ref: editorRef,
    elements,
    selectedIds: [],
    onSelect: () => {},
    onChange: () => {},
    zoom,
    paperWidth,
    paperHeight,
    background,
    overlay,
    renderCustom,
    readOnly: true,
    showGrid: false
  }, undefined, false, undefined, this);
});
KonvaViewer.displayName = "KonvaViewer";
// ../../src/features/bed-layout-editor/BedLayoutEditor.tsx
var import_react17 = __toESM(require_react(), 1);

// ../../src/features/konva-editor/renderers/bed-elements/BedElement.tsx
var jsx_dev_runtime17 = __toESM(require_jsx_dev_runtime(), 1);
var BedOverlayText = ({ element, bedStatus, absolute = true }) => {
  const data = element.data || {};
  const localLabel = element.name || data.label || "Bed";
  const localPatientName = data.patientName || "-";
  const localBP = data.bloodPressure || "-";
  const label = bedStatus ? bedStatus.bedId : localLabel;
  const patientName = bedStatus?.patientName || localPatientName;
  const bloodPressure = bedStatus?.vitals?.bp ? `${bedStatus.vitals.bp.systolic}/${bedStatus.vitals.bp.diastolic}` : localBP;
  const width = element.w || 100;
  const height = element.h || 60;
  const rotation = element.r || 0;
  return /* @__PURE__ */ jsx_dev_runtime17.jsxDEV(Group2, {
    id: `${element.id}__overlay_text`,
    x: absolute ? element.x ?? 0 : 0,
    y: absolute ? element.y ?? 0 : 0,
    rotation: absolute ? rotation : 0,
    listening: false,
    children: /* @__PURE__ */ jsx_dev_runtime17.jsxDEV(Group2, {
      x: width / 2,
      y: height / 2,
      rotation: -rotation,
      listening: false,
      children: (() => {
        const fontSize = Math.min(ptToMm(10), height * 0.3);
        const lineHeight = 1.2;
        const isEditorMode = !bedStatus;
        let renderLines = [];
        if (isEditorMode) {
          renderLines = [element.name ?? "Bed"];
        } else {
          renderLines = [
            label || "",
            patientName !== "-" ? patientName : "",
            bloodPressure !== "-" ? bloodPressure : ""
          ];
        }
        const maxLen = renderLines.reduce((m2, s) => Math.max(m2, s.length), 0);
        const textPadding = ptToMm(6);
        const estimatedCharWidth = fontSize * 0.75;
        const textAreaWidth = Math.max(ptToMm(20), maxLen * estimatedCharWidth + textPadding);
        const totalHeight = renderLines.length * fontSize * lineHeight;
        const startY = (height - totalHeight) / 2;
        return renderLines.map((text, index) => /* @__PURE__ */ jsx_dev_runtime17.jsxDEV(OutlinedText, {
          x: -textAreaWidth / 2,
          y: startY + index * fontSize * lineHeight - height / 2,
          width: textAreaWidth,
          text,
          fontSize,
          fontFamily: "Meiryo",
          fontStyle: "bold",
          align: "center",
          fill: "#000000",
          wrap: "none",
          lineHeight,
          listening: false
        }, index, false, undefined, this));
      })()
    }, undefined, false, undefined, this)
  }, undefined, false, undefined, this);
};
var OutlinedText = (props) => {
  return /* @__PURE__ */ jsx_dev_runtime17.jsxDEV(Group2, {
    children: [
      /* @__PURE__ */ jsx_dev_runtime17.jsxDEV(Text2, {
        ...props,
        fill: "white",
        stroke: "white",
        strokeWidth: ptToMm(1),
        shadowBlur: 0,
        shadowOffset: { x: 0, y: 0 },
        shadowOpacity: 0
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime17.jsxDEV(Text2, {
        ...props
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
var BedElement = ({
  element,
  isSelected: _isSelected,
  shapeRef,
  onClick,
  onTap,
  onMouseEnter,
  onMouseLeave,
  onContextMenu,
  bedStatus,
  enableStatusStyling = false,
  renderText = true,
  ...otherProps
}) => {
  const data = element.data || {};
  let strokeColor = "#3b82f6";
  const bgColor = "#ffffff";
  let strokeWidth = 0.4;
  const bw = data.borderW;
  if (typeof bw === "number" && Number.isFinite(bw)) {
    strokeWidth = Math.max(0, bw);
  }
  if (enableStatusStyling && bedStatus) {
    const hasAlerts = (bedStatus.alerts?.length ?? 0) > 0;
    switch (bedStatus.status) {
      case "occupied": {
        strokeColor = hasAlerts ? "#ef4444" : "#22c55e";
        break;
      }
      case "cleaning": {
        strokeColor = "#06b6d4";
        break;
      }
      case "maintenance": {
        strokeColor = "#64748b";
        break;
      }
      default: {
        strokeColor = "#3b82f6";
        break;
      }
    }
  }
  const width = element.w || 100;
  const height = element.h || 60;
  const rotation = element.r || 0;
  const cornerR = 1;
  const pillowR = 0.5;
  const pillowW = Math.min(3, width * 0.25);
  const pillowH = height * 0.8;
  const pillowX = 1;
  const pillowY = (height - pillowH) / 2;
  return /* @__PURE__ */ jsx_dev_runtime17.jsxDEV(Group2, {
    id: element.id,
    ...otherProps,
    rotation,
    ref: shapeRef,
    onClick,
    onTap,
    onMouseEnter,
    onMouseLeave,
    onContextMenu,
    children: [
      /* @__PURE__ */ jsx_dev_runtime17.jsxDEV(Rect2, {
        width,
        height,
        fill: bgColor,
        stroke: strokeColor,
        strokeWidth,
        cornerRadius: cornerR,
        shadowColor: "transparent",
        shadowBlur: 0,
        shadowOpacity: 0
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime17.jsxDEV(Rect2, {
        x: pillowX,
        y: pillowY,
        width: pillowW,
        height: pillowH,
        fill: "#e5e7eb",
        opacity: 0.5,
        cornerRadius: pillowR,
        listening: false
      }, undefined, false, undefined, this),
      renderText && /* @__PURE__ */ jsx_dev_runtime17.jsxDEV(BedOverlayText, {
        element,
        bedStatus,
        absolute: false
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/viewers/components/PaperBackground.tsx
var jsx_dev_runtime18 = __toESM(require_jsx_dev_runtime(), 1);
var PaperBackground = ({ document: document2, surfaceId }) => {
  let width = 0;
  let height = 0;
  const surface = surfaceId ? document2.surfaces.find((s) => s.id === surfaceId) : document2.surfaces.find((s) => s.type === "canvas") ?? document2.surfaces[0];
  width = surface?.w ?? 0;
  height = surface?.h ?? 0;
  return /* @__PURE__ */ jsx_dev_runtime18.jsxDEV(Group2, {
    children: /* @__PURE__ */ jsx_dev_runtime18.jsxDEV(Rect2, {
      name: "paper-background",
      x: 0,
      y: 0,
      width,
      height,
      fill: "white"
    }, undefined, false, undefined, this)
  }, undefined, false, undefined, this);
};

// ../../src/features/bed-layout-editor/BedLayoutEditor.tsx
var jsx_dev_runtime19 = __toESM(require_jsx_dev_runtime(), 1);
var BedLayoutEditor = import_react17.default.forwardRef(({
  document: document2,
  name,
  zoom,
  selection,
  onSelect,
  onChangeElement,
  onDelete,
  onUndo: _onUndo,
  onRedo: _onRedo,
  showGrid = false,
  snapStrength = 5,
  gridSize = 15,
  surfaceId,
  onCreateNodes,
  onReorderNodes
}, ref) => {
  const editorRef = import_react17.default.useRef(null);
  const resolvedSurfaceId = surfaceId || document2.surfaces.find((s) => s.type === "canvas")?.id || document2.surfaces[0]?.id || "layout";
  import_react17.default.useImperativeHandle(ref, () => ({
    downloadImage: () => {
      const stage = editorRef.current?.getStage();
      if (stage) {
        const gridLayer = stage.findOne(".grid-layer");
        const wasGridVisible = gridLayer?.visible();
        const transformers = stage.find("Transformer").filter((n) => n.getClassName?.() === "Transformer");
        const transformerVisibility = transformers.map((tr) => tr.visible());
        try {
          gridLayer?.hide();
          transformers.forEach((tr) => {
            tr.hide();
          });
          const dataURL = stage.toDataURL({ pixelRatio: 2 });
          const link = window.document.createElement("a");
          link.download = `${name || document2.title || "bed-layout"}.png`;
          link.href = dataURL;
          window.document.body.appendChild(link);
          link.click();
          window.document.body.removeChild(link);
        } finally {
          if (gridLayer && wasGridVisible) {
            gridLayer.show();
          }
          transformers.forEach((tr, idx) => {
            const prev = transformerVisibility[idx];
            if (prev)
              tr.show();
          });
        }
      }
    },
    copy: () => editorRef.current?.copy(),
    paste: () => editorRef.current?.paste()
  }));
  const surface = document2.surfaces.find((s) => s.id === resolvedSurfaceId) || document2.surfaces[0];
  const paperWidth = surface?.w ?? 0;
  const paperHeight = surface?.h ?? 0;
  const elements = document2.nodes.filter((n) => n.s === resolvedSurfaceId);
  return /* @__PURE__ */ jsx_dev_runtime19.jsxDEV(jsx_dev_runtime19.Fragment, {
    children: /* @__PURE__ */ jsx_dev_runtime19.jsxDEV(KonvaCanvasEditor, {
      ref: editorRef,
      elements,
      selectedIds: selection,
      onSelect,
      onChange: onChangeElement,
      zoom,
      paperWidth,
      paperHeight,
      onDelete: () => {
        if (selection.length > 0 && onDelete) {
          const id = selection[0];
          if (id)
            onDelete(id);
        }
      },
      onUndo: _onUndo,
      onRedo: _onRedo,
      background: /* @__PURE__ */ jsx_dev_runtime19.jsxDEV(PaperBackground, {
        document: document2,
        surfaceId: resolvedSurfaceId
      }, undefined, false, undefined, this),
      renderCustom: (el, commonProps, handleShapeRef) => {
        if (el.t === "widget" && el.widget === "bed") {
          const { ref: _ignoredRef, ...propsWithoutRef } = commonProps;
          return /* @__PURE__ */ jsx_dev_runtime19.jsxDEV(BedElement, {
            ...propsWithoutRef,
            element: el,
            isSelected: selection.includes(el.id),
            shapeRef: handleShapeRef
          }, undefined, false, undefined, this);
        }
        return null;
      },
      showGrid,
      snapStrength,
      gridSize,
      onCreateElements: onCreateNodes,
      onReorderNodes
    }, undefined, false, undefined, this)
  }, undefined, false, undefined, this);
});
BedLayoutEditor.displayName = "BedLayoutEditor";
// ../../node_modules/.pnpm/@radix-ui+react-slot@1.2.4_@types+react@19.2.7_react@19.2.3/node_modules/@radix-ui/react-slot/dist/index.mjs
var React7 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/@radix-ui+react-compose-refs@1.1.2_@types+react@19.2.7_react@19.2.3/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React6 = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== undefined) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i2 = 0;i2 < cleanups.length; i2++) {
          const cleanup = cleanups[i2];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i2], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React6.useCallback(composeRefs(...refs), refs);
}

// ../../node_modules/.pnpm/@radix-ui+react-slot@1.2.4_@types+react@19.2.7_react@19.2.3/node_modules/@radix-ui/react-slot/dist/index.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var REACT_LAZY_TYPE = Symbol.for("react.lazy");
var use2 = React7[" use ".trim().toString()];
function isPromiseLike(value) {
  return typeof value === "object" && value !== null && "then" in value;
}
function isLazyComponent(element) {
  return element != null && typeof element === "object" && "$$typeof" in element && element.$$typeof === REACT_LAZY_TYPE && "_payload" in element && isPromiseLike(element._payload);
}
function createSlot(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
  const Slot2 = React7.forwardRef((props, forwardedRef) => {
    let { children, ...slotProps } = props;
    if (isLazyComponent(children) && typeof use2 === "function") {
      children = use2(children._payload);
    }
    const childrenArray = React7.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React7.Children.count(newElement) > 1)
            return React7.Children.only(null);
          return React7.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ import_jsx_runtime.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: React7.isValidElement(newElement) ? React7.cloneElement(newElement, undefined, newChildren) : null });
    }
    return /* @__PURE__ */ import_jsx_runtime.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
var Slot = /* @__PURE__ */ createSlot("Slot");
function createSlotClone(ownerName) {
  const SlotClone = React7.forwardRef((props, forwardedRef) => {
    let { children, ...slotProps } = props;
    if (isLazyComponent(children) && typeof use2 === "function") {
      children = use2(children._payload);
    }
    if (React7.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React7.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React7.cloneElement(children, props2);
    }
    return React7.Children.count(children) > 1 ? React7.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function isSlottable(child) {
  return React7.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// ../../node_modules/.pnpm/class-variance-authority@0.7.1/node_modules/class-variance-authority/dist/index.mjs
var falsyToString = (value) => typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
var cx = clsx;
var cva = (base, config) => (props) => {
  var _config_compoundVariants;
  if ((config === null || config === undefined ? undefined : config.variants) == null)
    return cx(base, props === null || props === undefined ? undefined : props.class, props === null || props === undefined ? undefined : props.className);
  const { variants, defaultVariants } = config;
  const getVariantClassNames = Object.keys(variants).map((variant) => {
    const variantProp = props === null || props === undefined ? undefined : props[variant];
    const defaultVariantProp = defaultVariants === null || defaultVariants === undefined ? undefined : defaultVariants[variant];
    if (variantProp === null)
      return null;
    const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
    return variants[variant][variantKey];
  });
  const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {
    let [key, value] = param;
    if (value === undefined) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
  const getCompoundVariantClassNames = config === null || config === undefined ? undefined : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === undefined ? undefined : _config_compoundVariants.reduce((acc, param) => {
    let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
    return Object.entries(compoundVariantOptions).every((param2) => {
      let [key, value] = param2;
      return Array.isArray(value) ? value.includes({
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key]) : {
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key] === value;
    }) ? [
      ...acc,
      cvClass,
      cvClassName
    ] : acc;
  }, []);
  return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === undefined ? undefined : props.class, props === null || props === undefined ? undefined : props.className);
};

// ../../src/components/ui/Button.tsx
var React8 = __toESM(require_react(), 1);

// ../../src/utils/utils.ts
function cn2(...inputs) {
  return twMerge(clsx(inputs));
}

// ../../src/components/ui/Button.tsx
var jsx_dev_runtime20 = __toESM(require_jsx_dev_runtime(), 1);
var buttonVariants = cva("inline-flex min-h-[44px] min-w-[64px] items-center justify-center gap-2 whitespace-nowrap rounded-[6px] border border-solid text-base font-semibold shadow-sm transition-all duration-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 hover:brightness-95 active:shadow-none active:translate-y-[1px]", {
  variants: {
    variant: {
      default: "bg-primary text-primary-foreground border-border",
      secondary: "bg-secondary text-secondary-foreground border-border",
      tertiary: "bg-muted text-muted-foreground border-border",
      positive: "bg-primary text-primary-foreground border-border",
      negative: "bg-secondary text-secondary-foreground border-border",
      delete: "bg-destructive text-destructive-foreground border-border",
      warning: "bg-accent text-accent-foreground border-border",
      pause: "bg-accent text-accent-foreground border-border",
      info: "bg-accent text-accent-foreground border-border",
      outline: "bg-transparent border-input text-foreground",
      ghost: "bg-transparent border-transparent text-foreground shadow-none",
      text: "bg-transparent border-transparent text-foreground shadow-none hover:bg-accent hover:text-accent-foreground",
      abort: "bg-secondary text-secondary-foreground border-border",
      link: "bg-transparent text-primary underline-offset-4 underline shadow-none border-none min-h-0 min-w-0 hover:brightness-100",
      "outline-positive": "bg-transparent border-primary text-primary",
      "outline-negative": "bg-transparent border-input text-foreground",
      "outline-abort": "bg-transparent border-input text-muted-foreground",
      "outline-delete": "bg-transparent border-destructive text-destructive",
      "outline-info": "bg-transparent border-accent text-accent",
      "outline-warning": "bg-transparent border-accent text-accent",
      "circle-help": "bg-accent text-accent-foreground border-none shadow-sm rounded-full min-w-0 hover:brightness-110",
      "circle-alert": "bg-accent text-accent-foreground border-none shadow-sm rounded-full min-w-0 hover:brightness-110",
      fab: "bg-primary text-primary-foreground border-border rounded-full shadow-sm hover:shadow-md min-h-0 min-w-0"
    },
    size: {
      default: "px-4 py-2 text-base",
      sm: "px-3 py-1.5 text-sm min-h-[36px] min-w-[48px]",
      lg: "px-6 py-3 text-lg min-h-[52px] min-w-[80px]",
      icon: "h-11 w-11 p-0",
      fab: "h-14 w-14 p-0",
      circle: "h-8 w-8 min-h-[32px] min-w-[32px] p-0 text-sm rounded-full"
    }
  },
  defaultVariants: {
    variant: "default",
    size: "default"
  }
});
var ButtonComponent = React8.forwardRef(({
  className,
  variant,
  size,
  asChild = false,
  icon: Icon2,
  children,
  disabled,
  loading = false,
  success = false,
  error = false,
  ...props
}, ref) => {
  const statefulVariant = success ? "positive" : error ? "delete" : variant;
  const resolvedVariant = statefulVariant || "default";
  if (asChild) {
    return /* @__PURE__ */ jsx_dev_runtime20.jsxDEV(Slot, {
      className: cn2(buttonVariants({ variant: resolvedVariant, size }), className),
      ref,
      ...props,
      children
    }, undefined, false, undefined, this);
  }
  const renderContent = () => {
    if (success) {
      return /* @__PURE__ */ jsx_dev_runtime20.jsxDEV(Check, {
        className: "h-5 w-5 flex-shrink-0"
      }, undefined, false, undefined, this);
    }
    if (error) {
      return /* @__PURE__ */ jsx_dev_runtime20.jsxDEV(X, {
        className: "h-5 w-5 flex-shrink-0"
      }, undefined, false, undefined, this);
    }
    if (loading) {
      return /* @__PURE__ */ jsx_dev_runtime20.jsxDEV("div", {
        className: "h-5 w-5 flex-shrink-0 rounded-full border-2 border-current border-t-transparent animate-spin"
      }, undefined, false, undefined, this);
    }
    return /* @__PURE__ */ jsx_dev_runtime20.jsxDEV(jsx_dev_runtime20.Fragment, {
      children: [
        Icon2 && /* @__PURE__ */ jsx_dev_runtime20.jsxDEV(Icon2, {
          className: cn2("h-5 w-5", children ? "mr-2" : "")
        }, undefined, false, undefined, this),
        children
      ]
    }, undefined, true, undefined, this);
  };
  return /* @__PURE__ */ jsx_dev_runtime20.jsxDEV("button", {
    className: cn2(buttonVariants({ variant: resolvedVariant, size }), (loading || success || error) && "hover:!brightness-100", className),
    ref,
    disabled: disabled || loading || success || error,
    ...props,
    children: renderContent()
  }, undefined, false, undefined, this);
});
var Button = React8.memo(ButtonComponent);
Button.displayName = "Button";

// ../../src/features/report-editor/components/Header/EditorHeader.tsx
var jsx_dev_runtime21 = __toESM(require_jsx_dev_runtime(), 1);
var EditorHeader = ({
  templateName,
  onTemplateNameChange,
  orientation,
  onOrientationChange,
  orientationOptions,
  canUndo,
  canRedo,
  onUndo,
  onRedo,
  onDownloadImage,
  onDownloadPdf,
  onSave,
  onBack,
  onShowShortcuts,
  onSettingsClick,
  loadMenu,
  children,
  i18nOverrides
}) => {
  const { t } = useI18n();
  const resolveText = (key, defaultValue) => {
    if (i18nOverrides?.[key])
      return i18nOverrides[key];
    return t(key, defaultValue ?? key);
  };
  const defaultOptions = [
    { label: resolveText("orientations_portrait", "Portrait"), value: "portrait" },
    { label: resolveText("orientations_landscape", "Landscape"), value: "landscape" }
  ];
  const currentOptions = orientationOptions || defaultOptions;
  return /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("div", {
    className: "px-5 py-3 bg-secondary border-b border-border flex items-center justify-between shrink-0 h-16 transition-colors shadow-sm",
    children: [
      /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("div", {
        className: "flex items-center gap-4 min-w-0 flex-1 mr-4",
        children: [
          /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("button", {
            type: "button",
            onClick: onBack,
            className: "flex items-center text-sm font-medium text-muted-foreground hover:text-foreground transition-colors whitespace-nowrap shrink-0",
            children: [
              /* @__PURE__ */ jsx_dev_runtime21.jsxDEV(ChevronLeft, {
                className: "w-4 h-4 mr-1"
              }, undefined, false, undefined, this),
              resolveText("back", "Back")
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("div", {
            className: "h-6 w-px bg-border shrink-0"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("input", {
            type: "text",
            value: templateName,
            onChange: (e) => onTemplateNameChange(e.target.value),
            className: "border border-border rounded-md px-3 py-1.5 text-sm w-full max-w-64 bg-background text-foreground focus:outline-none focus:ring-1 focus:ring-ring transition-colors min-w-[50px]"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("div", {
        className: "flex items-center gap-3 shrink-0",
        children: [
          /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("div", {
            className: "flex items-center gap-2 border border-border rounded-md px-2 py-1 bg-background",
            children: [
              /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("span", {
                className: "text-xs font-medium text-muted-foreground whitespace-nowrap",
                children: [
                  resolveText("editor_orientation", "Orientation"),
                  ":"
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("select", {
                value: orientation,
                onChange: (e) => onOrientationChange(e.target.value),
                className: "text-xs bg-transparent border-none focus:ring-0 text-foreground cursor-pointer outline-none",
                children: currentOptions.map((opt) => /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("option", {
                  value: opt.value,
                  children: opt.label
                }, opt.value, false, undefined, this))
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("div", {
            className: "h-6 w-px bg-border mx-1"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("button", {
            type: "button",
            onClick: onUndo,
            disabled: !canUndo,
            className: "p-2 rounded-md hover:bg-accent text-muted-foreground disabled:opacity-30 transition-colors",
            title: resolveText("toolbar_undo", "Undo"),
            children: /* @__PURE__ */ jsx_dev_runtime21.jsxDEV(Undo, {
              className: "w-4 h-4"
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("button", {
            type: "button",
            onClick: onRedo,
            disabled: !canRedo,
            className: "p-2 rounded-md hover:bg-accent text-muted-foreground disabled:opacity-30 transition-colors",
            title: resolveText("toolbar_redo", "Redo"),
            children: /* @__PURE__ */ jsx_dev_runtime21.jsxDEV(Redo, {
              className: "w-4 h-4"
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("div", {
            className: "h-6 w-px bg-border mx-1"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime21.jsxDEV(Button, {
            variant: "circle-help",
            size: "circle",
            onClick: onShowShortcuts,
            title: resolveText("toolbar_shortcuts", "Shortcuts"),
            children: "?"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("div", {
            className: "h-6 w-px bg-border mx-1"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("button", {
            type: "button",
            onClick: onDownloadImage,
            className: "flex items-center gap-2 px-3 py-1.5 text-sm font-medium text-foreground hover:bg-accent rounded-md border border-border transition-colors shadow-sm whitespace-nowrap flex-shrink-0",
            children: [
              /* @__PURE__ */ jsx_dev_runtime21.jsxDEV(Image4, {
                className: "w-4 h-4"
              }, undefined, false, undefined, this),
              resolveText("header_image", "Image")
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("button", {
            type: "button",
            onClick: onDownloadPdf,
            className: "flex items-center gap-2 px-3 py-1.5 text-sm font-medium text-foreground hover:bg-accent rounded-md border border-border transition-colors shadow-sm whitespace-nowrap flex-shrink-0",
            children: [
              /* @__PURE__ */ jsx_dev_runtime21.jsxDEV(Download, {
                className: "w-4 h-4"
              }, undefined, false, undefined, this),
              resolveText("header_pdf", "PDF")
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("div", {
            className: "h-6 w-px bg-border mx-1"
          }, undefined, false, undefined, this),
          loadMenu,
          /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("button", {
            type: "button",
            onClick: onSave,
            className: "flex items-center gap-2 px-3 py-1.5 text-sm font-medium text-primary-foreground bg-primary hover:bg-primary/90 rounded-md shadow-sm transition-colors whitespace-nowrap flex-shrink-0",
            children: [
              /* @__PURE__ */ jsx_dev_runtime21.jsxDEV(Save, {
                className: "w-4 h-4"
              }, undefined, false, undefined, this),
              resolveText("save", "Save")
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime21.jsxDEV("div", {
            className: "h-6 w-px bg-border mx-1"
          }, undefined, false, undefined, this),
          onSettingsClick && /* @__PURE__ */ jsx_dev_runtime21.jsxDEV(Button, {
            variant: "ghost",
            size: "icon",
            onClick: onSettingsClick,
            className: "text-muted-foreground hover:text-foreground",
            title: resolveText("header_settings", "Settings"),
            children: /* @__PURE__ */ jsx_dev_runtime21.jsxDEV(Settings2, {
              className: "w-5 h-5"
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          children
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/bed-layout-editor/components/Header/BedLayoutHeader.tsx
var jsx_dev_runtime22 = __toESM(require_jsx_dev_runtime(), 1);
var BedLayoutHeader = (props) => {
  const { t } = useI18n();
  const { i18nOverrides } = props;
  const resolveText = (key, defaultValue) => {
    if (i18nOverrides?.[key])
      return i18nOverrides[key];
    return t(key, defaultValue ?? key);
  };
  return /* @__PURE__ */ jsx_dev_runtime22.jsxDEV(EditorHeader, {
    ...props,
    orientationOptions: [
      { label: resolveText("orientations_portrait", "Portrait"), value: "portrait" },
      { label: resolveText("orientations_landscape", "Landscape"), value: "landscape" },
      { label: resolveText("orientations_square", "Square"), value: "square" }
    ]
  }, undefined, false, undefined, this);
};
// ../../src/features/konva-editor/components/PropertyPanel/UnifiedPropertyPanel.tsx
var import_react23 = __toESM(require_react(), 1);

// ../../src/features/konva-editor/constants/propertyPanel/presets.ts
var DEFAULT_FONT_FAMILIES = [
  "Meiryo",
  "Arial",
  "Times New Roman",
  "Courier New",
  "Helvetica"
];
var DEFAULT_FONT_SIZES = [
  8,
  9,
  10,
  10.5,
  11,
  12,
  14,
  16,
  18,
  20,
  22,
  24,
  26,
  28,
  32,
  36,
  40,
  44,
  48,
  54,
  60,
  66,
  72,
  80,
  88,
  96
];
var WIDGET_PRESETS = {
  "posSize:full": {
    type: "posSize",
    props: { showX: true, showY: true, showW: true, showH: true }
  },
  "posSize:position": {
    type: "posSize",
    props: { showX: true, showY: true, showW: false, showH: false }
  },
  "posSize:size": {
    type: "posSize",
    props: { showX: false, showY: false, showW: true, showH: true }
  },
  "font:full": {
    type: "font",
    grid: { cols: 2, gap: 8 },
    props: {
      showFamily: true,
      showSize: true,
      showColor: false,
      showBold: true,
      showItalic: true,
      showUnderline: true,
      showStrikethrough: true
    }
  },
  "font:basic": {
    type: "font",
    grid: { cols: 2, gap: 8 },
    props: { showFamily: true, showSize: true, showColor: true }
  },
  "font:style": {
    type: "font",
    props: { showBold: true, showItalic: true, showUnderline: true }
  },
  "align:horizontal": {
    type: "alignment",
    labelKey: "properties_text_align",
    props: { options: ["l", "c", "r"] }
  },
  "align:horizontal-simple": {
    type: "alignment",
    props: { options: ["l", "c", "r"] }
  },
  "align:vertical": {
    type: "vAlignment",
    labelKey: "properties_vertical_align",
    props: { options: ["t", "m", "b"] }
  },
  "fill:default": {
    type: "fill",
    labelKey: "properties_fill_color"
  },
  "border:default": {
    type: "border",
    labelKey: "properties_border_color",
    props: { showColor: true, showWidth: true }
  },
  "stroke:color": {
    type: "colorPicker",
    labelKey: "properties_line_color",
    props: { fieldKey: "stroke" }
  },
  "stroke:width": {
    type: "stroke",
    labelKey: "properties_line_width",
    props: { showColor: false, showWidth: true, minWidth: 0, maxWidth: 20, step: 0.2 }
  },
  "stroke:full": {
    type: "stroke",
    labelKey: "properties_stroke",
    props: { showColor: true, showWidth: true, minWidth: 0, maxWidth: 20, step: 0.2 }
  },
  "lineStyle:default": {
    type: "lineStyle",
    labelKey: "properties_line_style",
    props: { options: ["solid", "dashed", "dotted"] }
  },
  "arrow:start": {
    type: "arrowhead",
    labelKey: "properties_arrow_start",
    props: { position: "start" }
  },
  "arrow:end": {
    type: "arrowhead",
    labelKey: "properties_arrow_end",
    props: { position: "end" }
  },
  "binding:field": {
    type: "dataBinding",
    props: { mode: "field" }
  },
  "binding:repeater": {
    type: "dataBinding",
    props: { mode: "repeater" }
  },
  "image:preview": {
    type: "image",
    props: { showPreview: true, showUploader: true, maxPreviewHeight: 120 }
  },
  "textContent:default": {
    type: "textContent",
    props: { rows: 3 }
  },
  "list:default": {
    type: "list",
    labelKey: "properties_list"
  },
  "labelField:name": {
    type: "labelField",
    labelKey: "label",
    props: { fieldKey: "name" }
  },
  "custom:delete": {
    type: "custom",
    props: { renderKey: "deleteButton" }
  },
  "custom:table": {
    type: "custom",
    props: { renderKey: "tableProperties" }
  }
};
var SECTION_PRESETS = {
  "sec:text-vertical": {
    id: "common-text-vertical",
    condition: (node) => node.t === "text",
    widgets: [
      {
        type: "checkbox",
        labelKey: "properties_vertical_text",
        props: { fieldKey: "vertical" }
      }
    ]
  },
  "sec:posSize": {
    id: "common-pos-size",
    widgets: ["posSize:full"]
  },
  "sec:delete": {
    id: "common-delete",
    widgets: ["custom:delete"]
  },
  "sec:text-font": {
    id: "text-font",
    widgets: ["font:full"]
  },
  "sec:text-style": {
    id: "text-style",
    grid: { cols: 3, gap: 4 },
    widgets: [
      {
        type: "colorPicker",
        labelKey: "properties_font_color",
        props: { fieldKey: "fill" }
      },
      {
        type: "colorPicker",
        labelKey: "properties_background_color",
        props: { fieldKey: "backgroundColor" }
      },
      {
        type: "colorPicker",
        labelKey: "properties_border_color_box",
        props: { fieldKey: "borderColor" }
      },
      {
        type: "numberInput",
        labelKey: "properties_border_width_box",
        props: { fieldKey: "borderWidth", min: 0, step: 0.1, unit: "mm" }
      },
      {
        type: "numberInput",
        labelKey: "properties_padding",
        props: { fieldKey: "padding", min: 0, step: 0.5, unit: "mm" }
      },
      {
        type: "select",
        labelKey: "properties_corner_radius",
        props: {
          fieldKey: "cornerRadius",
          options: [
            { value: "0", labelKey: "0%" },
            { value: "0.25", labelKey: "25%" },
            { value: "0.5", labelKey: "50%" },
            { value: "0.75", labelKey: "75%" },
            { value: "1", labelKey: "100%" }
          ]
        }
      }
    ]
  },
  "sec:text-alignment": {
    id: "text-alignment",
    widgets: ["align:horizontal", "align:vertical"]
  },
  "sec:text-list": {
    id: "text-list",
    widgets: ["list:default"]
  },
  "sec:text-content": {
    id: "text-content",
    widgets: ["textContent:default"]
  },
  "sec:text-binding": {
    id: "text-binding",
    widgets: ["binding:field"]
  },
  "sec:shape-colors": {
    id: "shape-colors",
    grid: { cols: 2, gap: 4 },
    widgets: ["fill:default", "border:default"]
  },
  "sec:shape-stroke": {
    id: "shape-stroke",
    widgets: ["stroke:width"]
  },
  "sec:line-style": {
    id: "line-style",
    widgets: [
      "stroke:color",
      "stroke:width",
      "lineStyle:default",
      {
        type: "checkbox",
        labelKey: "properties_smart_connection",
        props: { fieldKey: "routing" }
      }
    ]
  },
  "sec:line-arrow": {
    id: "line-arrow",
    grid: { cols: 2, gap: 4 },
    widgets: ["arrow:start", "arrow:end"]
  },
  "sec:image-preview": {
    id: "image-preview",
    widgets: ["image:preview"]
  },
  "sec:table-custom": {
    id: "table-custom",
    widgets: ["custom:table"]
  },
  "sec:table-binding": {
    id: "table-binding",
    widgets: ["binding:repeater"]
  },
  "sec:signature-style": {
    id: "signature-style",
    widgets: ["stroke:color", "stroke:width"]
  },
  "sec:signature-tolerance": {
    id: "signature-tolerance",
    widgets: [
      {
        type: "slider",
        labelKey: "properties_signature_optimization",
        props: { fieldKey: "tolerance", min: 1, max: 3, step: 0.1, showValue: true }
      }
    ]
  },
  "sec:bed-label": {
    id: "bed-label",
    widgets: [
      {
        type: "labelField",
        labelKey: "properties_bed_name",
        props: { fieldKey: "name" }
      }
    ]
  }
};

// ../../src/features/konva-editor/constants/propertyPanel/objects.ts
var TEXT_OBJECT_CONFIG = {
  objectType: "text",
  header: { iconName: "Type", labelKey: "properties_element_text" },
  sections: [
    {
      id: "text-font",
      widgets: [
        {
          type: "font",
          grid: { cols: 2, gap: 8 },
          props: {
            showFamily: true,
            showSize: true,
            showColor: true,
            showBold: true,
            showItalic: true,
            showUnderline: true,
            showStrikethrough: true
          }
        }
      ]
    },
    {
      id: "text-frame",
      labelKey: "properties_frame",
      grid: { cols: 2, gap: 2 },
      widgets: [
        {
          type: "checkbox",
          labelKey: "properties_show_frame",
          props: { fieldKey: "hasFrame" }
        },
        {
          type: "colorPicker",
          labelKey: "properties_background_color",
          props: { fieldKey: "backgroundColor" },
          condition: (node) => node.hasFrame === true
        },
        {
          type: "colorPicker",
          labelKey: "properties_border_color_box",
          props: { fieldKey: "borderColor" },
          condition: (node) => node.hasFrame === true
        },
        {
          type: "numberInput",
          labelKey: "properties_border_width_box",
          props: { fieldKey: "borderWidth", min: 0, step: 0.2, unit: "mm" },
          condition: (node) => node.hasFrame === true
        },
        {
          type: "numberInput",
          labelKey: "properties_padding",
          props: { fieldKey: "padding", min: 0, step: 0.5, unit: "mm" },
          condition: (node) => node.hasFrame === true
        },
        {
          type: "select",
          labelKey: "properties_corner_radius",
          props: {
            fieldKey: "cornerRadius",
            options: [
              { value: "0", labelKey: "0%" },
              { value: "0.25", labelKey: "25%" },
              { value: "0.5", labelKey: "50%" },
              { value: "0.75", labelKey: "75%" },
              { value: "1", labelKey: "100%" }
            ]
          },
          condition: (node) => node.hasFrame === true
        }
      ]
    },
    "sec:text-alignment",
    "sec:text-list",
    "sec:text-content",
    "sec:text-binding"
  ]
};
var BED_LAYOUT_TEXT_OBJECT_CONFIG = {
  objectType: "text",
  header: { iconName: "Type", labelKey: "properties_element_text" },
  sections: ["sec:text-font", "sec:text-colors", "sec:text-alignment", "sec:text-list", "sec:text-content"]
};
var SHAPE_OBJECT_CONFIG = {
  objectType: "shape",
  header: { iconName: "Square", labelKey: "properties_element_shape" },
  sections: [
    "sec:shape-colors",
    "sec:shape-stroke",
    {
      id: "shape-polygon",
      condition: (node) => node.shape === "star",
      widgets: [
        {
          type: "polygon",
          labelKey: "properties_vertex_count",
          props: { min: 3, max: 12, step: 1 }
        }
      ]
    }
  ]
};
var LINE_OBJECT_CONFIG = {
  objectType: "line",
  header: { iconName: "Minus", labelKey: "properties_element_line" },
  sections: ["sec:line-style", "sec:line-arrow"]
};
var IMAGE_OBJECT_CONFIG = {
  objectType: "image",
  header: { iconName: "Image", labelKey: "properties_element_image" },
  sections: ["sec:image-preview"]
};
var TABLE_OBJECT_CONFIG = {
  objectType: "table",
  header: { iconName: "Table", labelKey: "properties_element_table" },
  sections: ["sec:table-custom", "sec:table-binding"]
};
var SIGNATURE_OBJECT_CONFIG = {
  objectType: "signature",
  header: { iconName: "PenTool", labelKey: "toolbar_signature" },
  sections: ["sec:signature-style", "sec:signature-tolerance"]
};
var WIDGET_BED_OBJECT_CONFIG = {
  objectType: "widget:bed",
  header: { iconName: "Bed", labelKey: "toolbar_bed" },
  sections: ["sec:posSize", "sec:bed-label"]
};

// ../../src/features/konva-editor/constants/propertyPanel/layouts.ts
var DEFAULT_PANEL_LAYOUT = {
  width: 256,
  padding: 16,
  sectionGap: 16,
  backgroundColor: "secondary"
};
var REPORT_PANEL_CONFIG = {
  editorType: "report",
  layout: { ...DEFAULT_PANEL_LAYOUT, width: 288 },
  defaultSections: ["sec:text-vertical", "sec:posSize"],
  objects: [
    TEXT_OBJECT_CONFIG,
    SHAPE_OBJECT_CONFIG,
    LINE_OBJECT_CONFIG,
    IMAGE_OBJECT_CONFIG,
    TABLE_OBJECT_CONFIG,
    SIGNATURE_OBJECT_CONFIG
  ]
};
var BED_LAYOUT_PANEL_CONFIG = {
  editorType: "bedLayout",
  layout: DEFAULT_PANEL_LAYOUT,
  defaultSections: ["sec:text-vertical", "sec:posSize"],
  objects: [
    BED_LAYOUT_TEXT_OBJECT_CONFIG,
    SHAPE_OBJECT_CONFIG,
    LINE_OBJECT_CONFIG,
    IMAGE_OBJECT_CONFIG,
    WIDGET_BED_OBJECT_CONFIG
  ]
};

// ../../src/features/konva-editor/constants/propertyPanel/utils.ts
function getObjectConfig(config, node) {
  if (node.t === "widget") {
    const widgetNode = node;
    return config.objects.find((obj) => obj.objectType === `widget:${widgetNode.widget}`);
  }
  return config.objects.find((obj) => obj.objectType === node.t);
}

// ../../src/features/konva-editor/components/PropertyPanel/shared.tsx
var jsx_dev_runtime23 = __toESM(require_jsx_dev_runtime(), 1);
var WidgetLabel = ({ htmlFor, children, className }) => /* @__PURE__ */ jsx_dev_runtime23.jsxDEV("label", {
  htmlFor,
  className: cn("block text-[13px] text-muted-foreground mb-0.5", className),
  children
}, undefined, false, undefined, this);
var WidgetInput = ({ className, inputClassName, ...props }) => /* @__PURE__ */ jsx_dev_runtime23.jsxDEV("input", {
  className: cn("w-full px-1.5 py-1 border border-border rounded text-[13px]", "bg-background text-foreground", "focus:outline-none focus:ring-1 focus:ring-ring", inputClassName, className),
  ...props
}, undefined, false, undefined, this);
var WidgetSelect = ({ className, children, ...props }) => /* @__PURE__ */ jsx_dev_runtime23.jsxDEV("select", {
  className: cn("w-full px-1.5 py-1 border border-border rounded text-[13px]", "bg-background text-foreground", "focus:outline-none focus:ring-1 focus:ring-ring", className),
  ...props,
  children
}, undefined, false, undefined, this);
var GridContainer = ({ grid, children }) => {
  if (!grid)
    return /* @__PURE__ */ jsx_dev_runtime23.jsxDEV(jsx_dev_runtime23.Fragment, {
      children
    }, undefined, false, undefined, this);
  return /* @__PURE__ */ jsx_dev_runtime23.jsxDEV("div", {
    className: "grid w-full",
    style: {
      gridTemplateColumns: `repeat(${grid.cols}, 1fr)`,
      gap: `${grid.gap ?? 8}px`
    },
    children
  }, undefined, false, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/PosSizeWidget.tsx
var jsx_dev_runtime24 = __toESM(require_jsx_dev_runtime(), 1);
var PosSizeWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  const props = config.props ?? { showX: true, showY: true, showW: true, showH: true };
  return /* @__PURE__ */ jsx_dev_runtime24.jsxDEV("div", {
    className: "w-full grid grid-cols-2 gap-1",
    children: [
      props.showX && /* @__PURE__ */ jsx_dev_runtime24.jsxDEV("div", {
        className: "w-full",
        children: [
          /* @__PURE__ */ jsx_dev_runtime24.jsxDEV(WidgetLabel, {
            children: resolveText("properties_x", "X")
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime24.jsxDEV("div", {
            className: "flex items-center gap-1",
            children: [
              /* @__PURE__ */ jsx_dev_runtime24.jsxDEV(WidgetInput, {
                type: "number",
                value: Math.round(node.x ?? 0),
                onChange: (e) => onChange({ x: Number(e.target.value) }),
                className: "w-20"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime24.jsxDEV("span", {
                className: "text-[12px] text-muted-foreground",
                children: "mm"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      props.showY && /* @__PURE__ */ jsx_dev_runtime24.jsxDEV("div", {
        className: "w-full",
        children: [
          /* @__PURE__ */ jsx_dev_runtime24.jsxDEV(WidgetLabel, {
            children: resolveText("properties_y", "Y")
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime24.jsxDEV("div", {
            className: "flex items-center gap-1",
            children: [
              /* @__PURE__ */ jsx_dev_runtime24.jsxDEV(WidgetInput, {
                type: "number",
                value: Math.round(node.y ?? 0),
                onChange: (e) => onChange({ y: Number(e.target.value) }),
                className: "w-20"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime24.jsxDEV("span", {
                className: "text-[12px] text-muted-foreground",
                children: "mm"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      props.showW && /* @__PURE__ */ jsx_dev_runtime24.jsxDEV("div", {
        className: "w-full",
        children: [
          /* @__PURE__ */ jsx_dev_runtime24.jsxDEV(WidgetLabel, {
            children: resolveText("properties_width", "W")
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime24.jsxDEV("div", {
            className: "flex items-center gap-1",
            children: [
              /* @__PURE__ */ jsx_dev_runtime24.jsxDEV(WidgetInput, {
                type: "number",
                min: 0,
                value: Math.round(node.w ?? 0),
                onChange: (e) => onChange({ w: Math.max(0, Number(e.target.value)) }),
                className: "w-20"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime24.jsxDEV("span", {
                className: "text-[12px] text-muted-foreground",
                children: "mm"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      props.showH && /* @__PURE__ */ jsx_dev_runtime24.jsxDEV("div", {
        className: "w-full",
        children: [
          /* @__PURE__ */ jsx_dev_runtime24.jsxDEV(WidgetLabel, {
            children: resolveText("properties_height", "H")
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime24.jsxDEV("div", {
            className: "flex items-center gap-1",
            children: [
              /* @__PURE__ */ jsx_dev_runtime24.jsxDEV(WidgetInput, {
                type: "number",
                min: 0,
                value: Math.round(node.h ?? 0),
                onChange: (e) => onChange({ h: Math.max(0, Number(e.target.value)) }),
                className: "w-20"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime24.jsxDEV("span", {
                className: "text-[12px] text-muted-foreground",
                children: "mm"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../node_modules/.pnpm/react-colorful@5.6.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/react-colorful/dist/index.mjs
var import_react18 = __toESM(require_react(), 1);
function u() {
  return (u = Object.assign || function(e2) {
    for (var r3 = 1;r3 < arguments.length; r3++) {
      var t2 = arguments[r3];
      for (var n2 in t2)
        Object.prototype.hasOwnProperty.call(t2, n2) && (e2[n2] = t2[n2]);
    }
    return e2;
  }).apply(this, arguments);
}
function c2(e2, r3) {
  if (e2 == null)
    return {};
  var t2, n2, o3 = {}, a3 = Object.keys(e2);
  for (n2 = 0;n2 < a3.length; n2++)
    r3.indexOf(t2 = a3[n2]) >= 0 || (o3[t2] = e2[t2]);
  return o3;
}
function i2(e2) {
  var t2 = import_react18.useRef(e2), n2 = import_react18.useRef(function(e3) {
    t2.current && t2.current(e3);
  });
  return t2.current = e2, n2.current;
}
var s = function(e2, r3, t2) {
  return r3 === undefined && (r3 = 0), t2 === undefined && (t2 = 1), e2 > t2 ? t2 : e2 < r3 ? r3 : e2;
};
var f = function(e2) {
  return "touches" in e2;
};
var v = function(e2) {
  return e2 && e2.ownerDocument.defaultView || self;
};
var d = function(e2, r3, t2) {
  var n2 = e2.getBoundingClientRect(), o3 = f(r3) ? function(e3, r4) {
    for (var t3 = 0;t3 < e3.length; t3++)
      if (e3[t3].identifier === r4)
        return e3[t3];
    return e3[0];
  }(r3.touches, t2) : r3;
  return { left: s((o3.pageX - (n2.left + v(e2).pageXOffset)) / n2.width), top: s((o3.pageY - (n2.top + v(e2).pageYOffset)) / n2.height) };
};
var h2 = function(e2) {
  !f(e2) && e2.preventDefault();
};
var m2 = import_react18.default.memo(function(o3) {
  var { onMove: a3, onKey: l3 } = o3, s2 = c2(o3, ["onMove", "onKey"]), m3 = import_react18.useRef(null), g = i2(a3), p2 = i2(l3), b2 = import_react18.useRef(null), _ = import_react18.useRef(false), x2 = import_react18.useMemo(function() {
    var e2 = function(e3) {
      h2(e3), (f(e3) ? e3.touches.length > 0 : e3.buttons > 0) && m3.current ? g(d(m3.current, e3, b2.current)) : t2(false);
    }, r3 = function() {
      return t2(false);
    };
    function t2(t3) {
      var n2 = _.current, o4 = v(m3.current), a4 = t3 ? o4.addEventListener : o4.removeEventListener;
      a4(n2 ? "touchmove" : "mousemove", e2), a4(n2 ? "touchend" : "mouseup", r3);
    }
    return [function(e3) {
      var r4 = e3.nativeEvent, n2 = m3.current;
      if (n2 && (h2(r4), !function(e4, r5) {
        return r5 && !f(e4);
      }(r4, _.current) && n2)) {
        if (f(r4)) {
          _.current = true;
          var o4 = r4.changedTouches || [];
          o4.length && (b2.current = o4[0].identifier);
        }
        n2.focus(), g(d(n2, r4, b2.current)), t2(true);
      }
    }, function(e3) {
      var r4 = e3.which || e3.keyCode;
      r4 < 37 || r4 > 40 || (e3.preventDefault(), p2({ left: r4 === 39 ? 0.05 : r4 === 37 ? -0.05 : 0, top: r4 === 40 ? 0.05 : r4 === 38 ? -0.05 : 0 }));
    }, t2];
  }, [p2, g]), C = x2[0], E = x2[1], H = x2[2];
  return import_react18.useEffect(function() {
    return H;
  }, [H]), import_react18.default.createElement("div", u({}, s2, { onTouchStart: C, onMouseDown: C, className: "react-colorful__interactive", ref: m3, onKeyDown: E, tabIndex: 0, role: "slider" }));
});
var g = function(e2) {
  return e2.filter(Boolean).join(" ");
};
var p2 = function(r3) {
  var { color: t2, left: n2, top: o3 } = r3, a3 = o3 === undefined ? 0.5 : o3, l3 = g(["react-colorful__pointer", r3.className]);
  return import_react18.default.createElement("div", { className: l3, style: { top: 100 * a3 + "%", left: 100 * n2 + "%" } }, import_react18.default.createElement("div", { className: "react-colorful__pointer-fill", style: { backgroundColor: t2 } }));
};
var b2 = function(e2, r3, t2) {
  return r3 === undefined && (r3 = 0), t2 === undefined && (t2 = Math.pow(10, r3)), Math.round(t2 * e2) / t2;
};
var _ = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
var x2 = function(e2) {
  return L(C(e2));
};
var C = function(e2) {
  return e2[0] === "#" && (e2 = e2.substring(1)), e2.length < 6 ? { r: parseInt(e2[0] + e2[0], 16), g: parseInt(e2[1] + e2[1], 16), b: parseInt(e2[2] + e2[2], 16), a: e2.length === 4 ? b2(parseInt(e2[3] + e2[3], 16) / 255, 2) : 1 } : { r: parseInt(e2.substring(0, 2), 16), g: parseInt(e2.substring(2, 4), 16), b: parseInt(e2.substring(4, 6), 16), a: e2.length === 8 ? b2(parseInt(e2.substring(6, 8), 16) / 255, 2) : 1 };
};
var w = function(e2) {
  return K(I(e2));
};
var y = function(e2) {
  var { s: r3, v: t2, a: n2 } = e2, o3 = (200 - r3) * t2 / 100;
  return { h: b2(e2.h), s: b2(o3 > 0 && o3 < 200 ? r3 * t2 / 100 / (o3 <= 100 ? o3 : 200 - o3) * 100 : 0), l: b2(o3 / 2), a: b2(n2, 2) };
};
var q = function(e2) {
  var r3 = y(e2);
  return "hsl(" + r3.h + ", " + r3.s + "%, " + r3.l + "%)";
};
var k = function(e2) {
  var r3 = y(e2);
  return "hsla(" + r3.h + ", " + r3.s + "%, " + r3.l + "%, " + r3.a + ")";
};
var I = function(e2) {
  var { h: r3, s: t2, v: n2, a: o3 } = e2;
  r3 = r3 / 360 * 6, t2 /= 100, n2 /= 100;
  var a3 = Math.floor(r3), l3 = n2 * (1 - t2), u2 = n2 * (1 - (r3 - a3) * t2), c3 = n2 * (1 - (1 - r3 + a3) * t2), i3 = a3 % 6;
  return { r: b2(255 * [n2, u2, l3, l3, c3, n2][i3]), g: b2(255 * [c3, n2, n2, u2, l3, l3][i3]), b: b2(255 * [l3, l3, c3, n2, n2, u2][i3]), a: b2(o3, 2) };
};
var D = function(e2) {
  var r3 = e2.toString(16);
  return r3.length < 2 ? "0" + r3 : r3;
};
var K = function(e2) {
  var { r: r3, g: t2, b: n2, a: o3 } = e2, a3 = o3 < 1 ? D(b2(255 * o3)) : "";
  return "#" + D(r3) + D(t2) + D(n2) + a3;
};
var L = function(e2) {
  var { r: r3, g: t2, b: n2, a: o3 } = e2, a3 = Math.max(r3, t2, n2), l3 = a3 - Math.min(r3, t2, n2), u2 = l3 ? a3 === r3 ? (t2 - n2) / l3 : a3 === t2 ? 2 + (n2 - r3) / l3 : 4 + (r3 - t2) / l3 : 0;
  return { h: b2(60 * (u2 < 0 ? u2 + 6 : u2)), s: b2(a3 ? l3 / a3 * 100 : 0), v: b2(a3 / 255 * 100), a: o3 };
};
var S = import_react18.default.memo(function(r3) {
  var { hue: t2, onChange: n2 } = r3, o3 = g(["react-colorful__hue", r3.className]);
  return import_react18.default.createElement("div", { className: o3 }, import_react18.default.createElement(m2, { onMove: function(e2) {
    n2({ h: 360 * e2.left });
  }, onKey: function(e2) {
    n2({ h: s(t2 + 360 * e2.left, 0, 360) });
  }, "aria-label": "Hue", "aria-valuenow": b2(t2), "aria-valuemax": "360", "aria-valuemin": "0" }, import_react18.default.createElement(p2, { className: "react-colorful__hue-pointer", left: t2 / 360, color: q({ h: t2, s: 100, v: 100, a: 1 }) })));
});
var T = import_react18.default.memo(function(r3) {
  var { hsva: t2, onChange: n2 } = r3, o3 = { backgroundColor: q({ h: t2.h, s: 100, v: 100, a: 1 }) };
  return import_react18.default.createElement("div", { className: "react-colorful__saturation", style: o3 }, import_react18.default.createElement(m2, { onMove: function(e2) {
    n2({ s: 100 * e2.left, v: 100 - 100 * e2.top });
  }, onKey: function(e2) {
    n2({ s: s(t2.s + 100 * e2.left, 0, 100), v: s(t2.v - 100 * e2.top, 0, 100) });
  }, "aria-label": "Color", "aria-valuetext": "Saturation " + b2(t2.s) + "%, Brightness " + b2(t2.v) + "%" }, import_react18.default.createElement(p2, { className: "react-colorful__saturation-pointer", top: 1 - t2.v / 100, left: t2.s / 100, color: q(t2) })));
});
var F = function(e2, r3) {
  if (e2 === r3)
    return true;
  for (var t2 in e2)
    if (e2[t2] !== r3[t2])
      return false;
  return true;
};
var X2 = function(e2, r3) {
  return e2.toLowerCase() === r3.toLowerCase() || F(C(e2), C(r3));
};
function Y(e2, t2, l3) {
  var u2 = i2(l3), c3 = import_react18.useState(function() {
    return e2.toHsva(t2);
  }), s2 = c3[0], f2 = c3[1], v2 = import_react18.useRef({ color: t2, hsva: s2 });
  import_react18.useEffect(function() {
    if (!e2.equal(t2, v2.current.color)) {
      var r3 = e2.toHsva(t2);
      v2.current = { hsva: r3, color: t2 }, f2(r3);
    }
  }, [t2, e2]), import_react18.useEffect(function() {
    var r3;
    F(s2, v2.current.hsva) || e2.equal(r3 = e2.fromHsva(s2), v2.current.color) || (v2.current = { hsva: s2, color: r3 }, u2(r3));
  }, [s2, e2, u2]);
  var d2 = import_react18.useCallback(function(e3) {
    f2(function(r3) {
      return Object.assign({}, r3, e3);
    });
  }, []);
  return [s2, d2];
}
var R;
var V = typeof window != "undefined" ? import_react18.useLayoutEffect : import_react18.useEffect;
var $ = function() {
  return R || (typeof __webpack_nonce__ != "undefined" ? __webpack_nonce__ : undefined);
};
var J = new Map;
var Q = function(e2) {
  V(function() {
    var r3 = e2.current ? e2.current.ownerDocument : document;
    if (r3 !== undefined && !J.has(r3)) {
      var t2 = r3.createElement("style");
      t2.innerHTML = '.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url(\'data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>\')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}', J.set(r3, t2);
      var n2 = $();
      n2 && t2.setAttribute("nonce", n2), r3.head.appendChild(t2);
    }
  }, []);
};
var ee = function(r3) {
  var { className: t2, hsva: n2, onChange: o3 } = r3, a3 = { backgroundImage: "linear-gradient(90deg, " + k(Object.assign({}, n2, { a: 0 })) + ", " + k(Object.assign({}, n2, { a: 1 })) + ")" }, l3 = g(["react-colorful__alpha", t2]), u2 = b2(100 * n2.a);
  return import_react18.default.createElement("div", { className: l3 }, import_react18.default.createElement("div", { className: "react-colorful__alpha-gradient", style: a3 }), import_react18.default.createElement(m2, { onMove: function(e2) {
    o3({ a: e2.left });
  }, onKey: function(e2) {
    o3({ a: s(n2.a + e2.left) });
  }, "aria-label": "Alpha", "aria-valuetext": u2 + "%", "aria-valuenow": u2, "aria-valuemin": "0", "aria-valuemax": "100" }, import_react18.default.createElement(p2, { className: "react-colorful__alpha-pointer", left: n2.a, color: k(n2) })));
};
var re = function(t2) {
  var { className: n2, colorModel: o3, color: a3 } = t2, l3 = a3 === undefined ? o3.defaultColor : a3, i3 = t2.onChange, s2 = c2(t2, ["className", "colorModel", "color", "onChange"]), f2 = import_react18.useRef(null);
  Q(f2);
  var v2 = Y(o3, l3, i3), d2 = v2[0], h3 = v2[1], m3 = g(["react-colorful", n2]);
  return import_react18.default.createElement("div", u({}, s2, { ref: f2, className: m3 }), import_react18.default.createElement(T, { hsva: d2, onChange: h3 }), import_react18.default.createElement(S, { hue: d2.h, onChange: h3 }), import_react18.default.createElement(ee, { hsva: d2, onChange: h3, className: "react-colorful__last-control" }));
};
var te = { defaultColor: "0001", toHsva: x2, fromHsva: w, equal: X2 };
var ne = function(r3) {
  return import_react18.default.createElement(re, u({}, r3, { colorModel: te }));
};

// ../../src/components/ui/popover.tsx
var React36 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/@radix-ui+react-popover@1.1.15_@types+react-dom@19.2.3_@types+react@19.2.7__@types+reac_aba36e289011c7efa5498b0a55e1bb01/node_modules/@radix-ui/react-popover/dist/index.mjs
var React35 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/@radix-ui+primitive@1.1.3/node_modules/@radix-ui/primitive/dist/index.mjs
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler?.(event);
    }
  };
}

// ../../node_modules/.pnpm/@radix-ui+react-context@1.1.2_@types+react@19.2.7_react@19.2.3/node_modules/@radix-ui/react-context/dist/index.mjs
var React9 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function createContext22(rootComponentName, defaultContext) {
  const Context2 = React9.createContext(defaultContext);
  const Provider = (props) => {
    const { children, ...context } = props;
    const value = React9.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ import_jsx_runtime2.jsx(Context2.Provider, { value, children });
  };
  Provider.displayName = rootComponentName + "Provider";
  function useContext22(consumerName) {
    const context = React9.useContext(Context2);
    if (context)
      return context;
    if (defaultContext !== undefined)
      return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider, useContext22];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = React9.createContext(defaultContext);
    const index = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider = (props) => {
      const { scope, children, ...context } = props;
      const Context2 = scope?.[scopeName]?.[index] || BaseContext;
      const value = React9.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ import_jsx_runtime2.jsx(Context2.Provider, { value, children });
    };
    Provider.displayName = rootComponentName + "Provider";
    function useContext22(consumerName, scope) {
      const Context2 = scope?.[scopeName]?.[index] || BaseContext;
      const context = React9.useContext(Context2);
      if (context)
        return context;
      if (defaultContext !== undefined)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React9.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = scope?.[scopeName] || scopeContexts;
      return React9.useMemo(() => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }), [scope, contexts]);
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React9.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}

// ../../node_modules/.pnpm/@radix-ui+react-dismissable-layer@1.1.11_@types+react-dom@19.2.3_@types+react@19.2.7__@_d3b8d348a25db9227f3697eddbb26378/node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var React14 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/@radix-ui+react-primitive@2.1.3_@types+react-dom@19.2.3_@types+react@19.2.7__@types+rea_5f3d28fea11cf58eed3830d0189b6e2d/node_modules/@radix-ui/react-primitive/dist/index.mjs
var React11 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);

// ../../node_modules/.pnpm/@radix-ui+react-slot@1.2.3_@types+react@19.2.7_react@19.2.3/node_modules/@radix-ui/react-slot/dist/index.mjs
var React10 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
function createSlot2(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone2(ownerName);
  const Slot2 = React10.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React10.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable2);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React10.Children.count(newElement) > 1)
            return React10.Children.only(null);
          return React10.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ import_jsx_runtime3.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: React10.isValidElement(newElement) ? React10.cloneElement(newElement, undefined, newChildren) : null });
    }
    return /* @__PURE__ */ import_jsx_runtime3.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
function createSlotClone2(ownerName) {
  const SlotClone = React10.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React10.isValidElement(children)) {
      const childrenRef = getElementRef2(children);
      const props2 = mergeProps2(slotProps, children.props);
      if (children.type !== React10.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React10.cloneElement(children, props2);
    }
    return React10.Children.count(children) > 1 ? React10.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER2 = Symbol("radix.slottable");
function createSlottable(ownerName) {
  const Slottable2 = ({ children }) => {
    return /* @__PURE__ */ import_jsx_runtime3.jsx(import_jsx_runtime3.Fragment, { children });
  };
  Slottable2.displayName = `${ownerName}.Slottable`;
  Slottable2.__radixId = SLOTTABLE_IDENTIFIER2;
  return Slottable2;
}
function isSlottable2(child) {
  return React10.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER2;
}
function mergeProps2(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef2(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// ../../node_modules/.pnpm/@radix-ui+react-primitive@2.1.3_@types+react-dom@19.2.3_@types+react@19.2.7__@types+rea_5f3d28fea11cf58eed3830d0189b6e2d/node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot2 = createSlot2(`Primitive.${node}`);
  const Node3 = React11.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ import_jsx_runtime4.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node3.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node3 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target)
    ReactDOM.flushSync(() => target.dispatchEvent(event));
}

// ../../node_modules/.pnpm/@radix-ui+react-use-callback-ref@1.1.1_@types+react@19.2.7_react@19.2.3/node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var React12 = __toESM(require_react(), 1);
function useCallbackRef(callback) {
  const callbackRef = React12.useRef(callback);
  React12.useEffect(() => {
    callbackRef.current = callback;
  });
  return React12.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}

// ../../node_modules/.pnpm/@radix-ui+react-use-escape-keydown@1.1.1_@types+react@19.2.7_react@19.2.3/node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
var React13 = __toESM(require_react(), 1);
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
  React13.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}

// ../../node_modules/.pnpm/@radix-ui+react-dismissable-layer@1.1.11_@types+react-dom@19.2.3_@types+react@19.2.7__@_d3b8d348a25db9227f3697eddbb26378/node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
"use client";
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React14.createContext({
  layers: /* @__PURE__ */ new Set,
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set,
  branches: /* @__PURE__ */ new Set
});
var DismissableLayer = React14.forwardRef((props, forwardedRef) => {
  const {
    disableOutsidePointerEvents = false,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    onDismiss,
    ...layerProps
  } = props;
  const context = React14.useContext(DismissableLayerContext);
  const [node, setNode] = React14.useState(null);
  const ownerDocument = node?.ownerDocument ?? globalThis?.document;
  const [, force] = React14.useState({});
  const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
  const layers = Array.from(context.layers);
  const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
  const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
  const index = node ? layers.indexOf(node) : -1;
  const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
  const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;
  const pointerDownOutside = usePointerDownOutside((event) => {
    const target = event.target;
    const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
    if (!isPointerEventsEnabled || isPointerDownOnBranch)
      return;
    onPointerDownOutside?.(event);
    onInteractOutside?.(event);
    if (!event.defaultPrevented)
      onDismiss?.();
  }, ownerDocument);
  const focusOutside = useFocusOutside((event) => {
    const target = event.target;
    const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
    if (isFocusInBranch)
      return;
    onFocusOutside?.(event);
    onInteractOutside?.(event);
    if (!event.defaultPrevented)
      onDismiss?.();
  }, ownerDocument);
  useEscapeKeydown((event) => {
    const isHighestLayer = index === context.layers.size - 1;
    if (!isHighestLayer)
      return;
    onEscapeKeyDown?.(event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }, ownerDocument);
  React14.useEffect(() => {
    if (!node)
      return;
    if (disableOutsidePointerEvents) {
      if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
        originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
        ownerDocument.body.style.pointerEvents = "none";
      }
      context.layersWithOutsidePointerEventsDisabled.add(node);
    }
    context.layers.add(node);
    dispatchUpdate();
    return () => {
      if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
        ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
      }
    };
  }, [node, ownerDocument, disableOutsidePointerEvents, context]);
  React14.useEffect(() => {
    return () => {
      if (!node)
        return;
      context.layers.delete(node);
      context.layersWithOutsidePointerEventsDisabled.delete(node);
      dispatchUpdate();
    };
  }, [node, context]);
  React14.useEffect(() => {
    const handleUpdate = () => force({});
    document.addEventListener(CONTEXT_UPDATE, handleUpdate);
    return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
  }, []);
  return /* @__PURE__ */ import_jsx_runtime5.jsx(Primitive.div, {
    ...layerProps,
    ref: composedRefs,
    style: {
      pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : undefined,
      ...props.style
    },
    onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
    onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
    onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
  });
});
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React14.forwardRef((props, forwardedRef) => {
  const context = React14.useContext(DismissableLayerContext);
  const ref = React14.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React14.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ import_jsx_runtime5.jsx(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React14.useRef(false);
  const handleClickRef = React14.useRef(() => {});
  React14.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, { discrete: true });
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
  const handleFocusOutside = useCallbackRef(onFocusOutside);
  const isFocusInsideReactTreeRef = React14.useRef(false);
  React14.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler)
    target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}

// ../../node_modules/.pnpm/@radix-ui+react-focus-guards@1.1.3_@types+react@19.2.7_react@19.2.3/node_modules/@radix-ui/react-focus-guards/dist/index.mjs
var React15 = __toESM(require_react(), 1);
"use client";
var count = 0;
function useFocusGuards() {
  React15.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count++;
    return () => {
      if (count === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}

// ../../node_modules/.pnpm/@radix-ui+react-focus-scope@1.1.7_@types+react-dom@19.2.3_@types+react@19.2.7__@types+r_4bc0a4f7a0f317379d2e6b46c577ea20/node_modules/@radix-ui/react-focus-scope/dist/index.mjs
var React16 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
"use client";
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React16.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React16.useState(null);
  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React16.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React16.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React16.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body)
          return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0)
            focus(container);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container)
        mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React16.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React16.useCallback((event) => {
    if (!loop && !trapped)
      return;
    if (focusScope.paused)
      return;
    const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
    const focusedElement = document.activeElement;
    if (isTabKey && focusedElement) {
      const container2 = event.currentTarget;
      const [first, last] = getTabbableEdges(container2);
      const hasTabbableElementsInside = first && last;
      if (!hasTabbableElementsInside) {
        if (focusedElement === container2)
          event.preventDefault();
      } else {
        if (!event.shiftKey && focusedElement === last) {
          event.preventDefault();
          if (loop)
            focus(first, { select: true });
        } else if (event.shiftKey && focusedElement === first) {
          event.preventDefault();
          if (loop)
            focus(last, { select: true });
        }
      }
    }
  }, [loop, trapped, focusScope.paused]);
  return /* @__PURE__ */ import_jsx_runtime6.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container }))
      return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== undefined && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      stack = arrayRemove(stack, focusScope);
      stack[0]?.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index = updatedArray.indexOf(item);
  if (index !== -1) {
    updatedArray.splice(index, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

// ../../node_modules/.pnpm/@radix-ui+react-id@1.1.1_@types+react@19.2.7_react@19.2.3/node_modules/@radix-ui/react-id/dist/index.mjs
var React18 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/@radix-ui+react-use-layout-effect@1.1.1_@types+react@19.2.7_react@19.2.3/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var React17 = __toESM(require_react(), 1);
var useLayoutEffect22 = globalThis?.document ? React17.useLayoutEffect : () => {};

// ../../node_modules/.pnpm/@radix-ui+react-id@1.1.1_@types+react@19.2.7_react@19.2.3/node_modules/@radix-ui/react-id/dist/index.mjs
var useReactId = React18[" useId ".trim().toString()] || (() => {
  return;
});
var count2 = 0;
function useId2(deterministicId) {
  const [id, setId] = React18.useState(useReactId());
  useLayoutEffect22(() => {
    if (!deterministicId)
      setId((reactId) => reactId ?? String(count2++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// ../../node_modules/.pnpm/@radix-ui+react-popper@1.2.8_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@_4468d6b8a14aa8e01a5fa6b59b3b35ec/node_modules/@radix-ui/react-popper/dist/index.mjs
var React22 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/@floating-ui+utils@0.2.10/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v2) => ({
  x: v2,
  y: v2
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp2(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === undefined) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x3,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x3,
    right: x3 + width,
    bottom: y2 + height,
    x: x3,
    y: y2
  };
}

// ../../node_modules/.pnpm/@floating-ui+core@1.7.3/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? undefined : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x3,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i3 = 0;i3 < validMiddleware.length; i3++) {
    const {
      name,
      fn
    } = validMiddleware[i3];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x3,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x3 = nextX != null ? nextX : x3;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x3,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i3 = -1;
    }
  }
  return {
    x: x3,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === undefined) {
    options = {};
  }
  const {
    x: x3,
    y: y2,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? undefined : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? undefined : platform.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x3,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? undefined : platform.getOffsetParent(elements.floating));
  const offsetScale = await (platform.isElement == null ? undefined : platform.isElement(offsetParent)) ? await (platform.getScale == null ? undefined : platform.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x3,
      y: y2,
      placement,
      rects,
      platform,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x3,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? undefined : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform.isElement == null ? undefined : platform.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = clamp2(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === undefined) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? undefined : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? undefined : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? undefined : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || overflowsData.every((d2) => getSideAxis(d2.placement) === initialSideAxis ? d2.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a3, b3) => a3.overflows[1] - b3.overflows[1])[0]) == null ? undefined : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a3, b3) => a3[1] - b3[1])[0]) == null ? undefined : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === undefined) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform,
    elements
  } = state;
  const rtl = await (platform.isRTL == null ? undefined : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === undefined) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x3,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? undefined : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x3 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === undefined) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x3,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x4,
              y: y3
            } = _ref;
            return {
              x: x4,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x3,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp2(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp2(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x3,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === undefined) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x3,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x3,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? undefined : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? undefined : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === undefined) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform,
        elements
      } = state;
      const {
        apply = () => {},
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform.isRTL == null ? undefined : platform.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// ../../node_modules/.pnpm/@floating-ui+utils@0.2.10/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? undefined : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? undefined : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === undefined) {
    list = [];
  }
  if (traverseIframes === undefined) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? undefined : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// ../../node_modules/.pnpm/@floating-ui+dom@1.7.4/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x3 = ($2 ? round(rect.width) : rect.width) / width;
  let y2 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x3 || !Number.isFinite(x3)) {
    x3 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x3,
    y: y2
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === undefined) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === undefined) {
    includeScale = false;
  }
  if (isFixedStrategy === undefined) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x3 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x3 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x3 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x3,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x3 = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x3,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x3 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x3 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x3,
    y: y2
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x3 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x3 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x: x3,
    y: y2
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x3 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x3,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x3 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x3,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a3, b3) {
  return a3.x === b3.x && a3.y === b3.y && a3.width === b3.width && a3.height === b3.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === undefined) {
      skip = false;
    }
    if (threshold === undefined) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 0.0000001);
          }, 1000);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === undefined) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache = new Map;
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// ../../node_modules/.pnpm/@floating-ui+react-dom@2.1.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React19 = __toESM(require_react(), 1);
var import_react19 = __toESM(require_react(), 1);
var ReactDOM2 = __toESM(require_react_dom(), 1);
var isClient = typeof document !== "undefined";
var noop = function noop2() {};
var index = isClient ? import_react19.useLayoutEffect : noop;
function deepEqual(a3, b3) {
  if (a3 === b3) {
    return true;
  }
  if (typeof a3 !== typeof b3) {
    return false;
  }
  if (typeof a3 === "function" && a3.toString() === b3.toString()) {
    return true;
  }
  let length;
  let i3;
  let keys;
  if (a3 && b3 && typeof a3 === "object") {
    if (Array.isArray(a3)) {
      length = a3.length;
      if (length !== b3.length)
        return false;
      for (i3 = length;i3-- !== 0; ) {
        if (!deepEqual(a3[i3], b3[i3])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a3);
    length = keys.length;
    if (length !== Object.keys(b3).length) {
      return false;
    }
    for (i3 = length;i3-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b3, keys[i3])) {
        return false;
      }
    }
    for (i3 = length;i3-- !== 0; ) {
      const key = keys[i3];
      if (key === "_owner" && a3.$$typeof) {
        continue;
      }
      if (!deepEqual(a3[key], b3[key])) {
        return false;
      }
    }
    return true;
  }
  return a3 !== a3 && b3 !== b3;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React19.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === undefined) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React19.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React19.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React19.useState(null);
  const [_floating, _setFloating] = React19.useState(null);
  const setReference = React19.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React19.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React19.useRef(null);
  const floatingRef = React19.useRef(null);
  const dataRef = React19.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React19.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM2.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React19.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React19.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React19.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React19.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x3 = roundByDPR(elements.floating, data.x);
    const y2 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x3 + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x3,
      top: y2
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React19.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var limitShift3 = (options, deps) => ({
  ...limitShift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var hide3 = (options, deps) => ({
  ...hide2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});

// ../../node_modules/.pnpm/@radix-ui+react-arrow@1.1.7_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@1_2aa610ae3ce517c8615cebea9e24dc5b/node_modules/@radix-ui/react-arrow/dist/index.mjs
var React20 = __toESM(require_react(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var NAME = "Arrow";
var Arrow2 = React20.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ import_jsx_runtime7.jsx(Primitive.svg, {
    ...arrowProps,
    ref: forwardedRef,
    width,
    height,
    viewBox: "0 0 30 10",
    preserveAspectRatio: "none",
    children: props.asChild ? children : /* @__PURE__ */ import_jsx_runtime7.jsx("polygon", { points: "0,0 30,0 15,10" })
  });
});
Arrow2.displayName = NAME;
var Root = Arrow2;

// ../../node_modules/.pnpm/@radix-ui+react-use-size@1.1.1_@types+react@19.2.7_react@19.2.3/node_modules/@radix-ui/react-use-size/dist/index.mjs
var React21 = __toESM(require_react(), 1);
function useSize(element) {
  const [size4, setSize] = React21.useState(undefined);
  useLayoutEffect22(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(undefined);
    }
  }, [element]);
  return size4;
}

// ../../node_modules/.pnpm/@radix-ui+react-popper@1.2.8_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@_4468d6b8a14aa8e01a5fa6b59b3b35ec/node_modules/@radix-ui/react-popper/dist/index.mjs
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
"use client";
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React22.useState(null);
  return /* @__PURE__ */ import_jsx_runtime8.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React22.forwardRef((props, forwardedRef) => {
  const { __scopePopper, virtualRef, ...anchorProps } = props;
  const context = usePopperContext(ANCHOR_NAME, __scopePopper);
  const ref = React22.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const anchorRef = React22.useRef(null);
  React22.useEffect(() => {
    const previousAnchor = anchorRef.current;
    anchorRef.current = virtualRef?.current || ref.current;
    if (previousAnchor !== anchorRef.current) {
      context.onAnchorChange(anchorRef.current);
    }
  });
  return virtualRef ? null : /* @__PURE__ */ import_jsx_runtime8.jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
});
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);
var PopperContent = React22.forwardRef((props, forwardedRef) => {
  const {
    __scopePopper,
    side = "bottom",
    sideOffset = 0,
    align = "center",
    alignOffset = 0,
    arrowPadding = 0,
    avoidCollisions = true,
    collisionBoundary = [],
    collisionPadding: collisionPaddingProp = 0,
    sticky = "partial",
    hideWhenDetached = false,
    updatePositionStrategy = "optimized",
    onPlaced,
    ...contentProps
  } = props;
  const context = usePopperContext(CONTENT_NAME, __scopePopper);
  const [content, setContent] = React22.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
  const [arrow4, setArrow] = React22.useState(null);
  const arrowSize = useSize(arrow4);
  const arrowWidth = arrowSize?.width ?? 0;
  const arrowHeight = arrowSize?.height ?? 0;
  const desiredPlacement = side + (align !== "center" ? "-" + align : "");
  const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
  const hasExplicitBoundaries = boundary.length > 0;
  const detectOverflowOptions = {
    padding: collisionPadding,
    boundary: boundary.filter(isNotNull),
    altBoundary: hasExplicitBoundaries
  };
  const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
    strategy: "fixed",
    placement: desiredPlacement,
    whileElementsMounted: (...args) => {
      const cleanup = autoUpdate(...args, {
        animationFrame: updatePositionStrategy === "always"
      });
      return cleanup;
    },
    elements: {
      reference: context.anchor
    },
    middleware: [
      offset3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
      avoidCollisions && shift3({
        mainAxis: true,
        crossAxis: false,
        limiter: sticky === "partial" ? limitShift3() : undefined,
        ...detectOverflowOptions
      }),
      avoidCollisions && flip3({ ...detectOverflowOptions }),
      size3({
        ...detectOverflowOptions,
        apply: ({ elements, rects, availableWidth, availableHeight }) => {
          const { width: anchorWidth, height: anchorHeight } = rects.reference;
          const contentStyle = elements.floating.style;
          contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
          contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
          contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
          contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
        }
      }),
      arrow4 && arrow3({ element: arrow4, padding: arrowPadding }),
      transformOrigin({ arrowWidth, arrowHeight }),
      hideWhenDetached && hide3({ strategy: "referenceHidden", ...detectOverflowOptions })
    ]
  });
  const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
  const handlePlaced = useCallbackRef(onPlaced);
  useLayoutEffect22(() => {
    if (isPositioned) {
      handlePlaced?.();
    }
  }, [isPositioned, handlePlaced]);
  const arrowX = middlewareData.arrow?.x;
  const arrowY = middlewareData.arrow?.y;
  const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
  const [contentZIndex, setContentZIndex] = React22.useState();
  useLayoutEffect22(() => {
    if (content)
      setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  return /* @__PURE__ */ import_jsx_runtime8.jsx("div", {
    ref: refs.setFloating,
    "data-radix-popper-content-wrapper": "",
    style: {
      ...floatingStyles,
      transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
      minWidth: "max-content",
      zIndex: contentZIndex,
      ["--radix-popper-transform-origin"]: [
        middlewareData.transformOrigin?.x,
        middlewareData.transformOrigin?.y
      ].join(" "),
      ...middlewareData.hide?.referenceHidden && {
        visibility: "hidden",
        pointerEvents: "none"
      }
    },
    dir: props.dir,
    children: /* @__PURE__ */ import_jsx_runtime8.jsx(PopperContentProvider, {
      scope: __scopePopper,
      placedSide,
      onArrowChange: setArrow,
      arrowX,
      arrowY,
      shouldHideArrow: cannotCenterArrow,
      children: /* @__PURE__ */ import_jsx_runtime8.jsx(Primitive.div, {
        "data-side": placedSide,
        "data-align": placedAlign,
        ...contentProps,
        ref: composedRefs,
        style: {
          ...contentProps.style,
          animation: !isPositioned ? "none" : undefined
        }
      })
    })
  });
});
PopperContent.displayName = CONTENT_NAME;
var ARROW_NAME = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React22.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return /* @__PURE__ */ import_jsx_runtime8.jsx("span", {
    ref: contentContext.onArrowChange,
    style: {
      position: "absolute",
      left: contentContext.arrowX,
      top: contentContext.arrowY,
      [baseSide]: 0,
      transformOrigin: {
        top: "",
        right: "0 0",
        bottom: "center 0",
        left: "100% 0"
      }[contentContext.placedSide],
      transform: {
        top: "translateY(100%)",
        right: "translateY(50%) rotate(90deg) translateX(-50%)",
        bottom: `rotate(180deg)`,
        left: "translateY(50%) rotate(-90deg) translateX(50%)"
      }[contentContext.placedSide],
      visibility: contentContext.shouldHideArrow ? "hidden" : undefined
    },
    children: /* @__PURE__ */ import_jsx_runtime8.jsx(Root, {
      ...arrowProps,
      ref: forwardedRef,
      style: {
        ...arrowProps.style,
        display: "block"
      }
    })
  });
});
PopperArrow.displayName = ARROW_NAME;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
    let x3 = "";
    let y2 = "";
    if (placedSide === "bottom") {
      x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x3 = `${-arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x3 = `${rects.floating.width + arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x: x3, y: y2 } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow3 = PopperArrow;

// ../../node_modules/.pnpm/@radix-ui+react-portal@1.1.9_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@_7645cc20debbdc3166db2ed8e9fd2af5/node_modules/@radix-ui/react-portal/dist/index.mjs
var React23 = __toESM(require_react(), 1);
var import_react_dom3 = __toESM(require_react_dom(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
"use client";
var PORTAL_NAME = "Portal";
var Portal = React23.forwardRef((props, forwardedRef) => {
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React23.useState(false);
  useLayoutEffect22(() => setMounted(true), []);
  const container = containerProp || mounted && globalThis?.document?.body;
  return container ? import_react_dom3.default.createPortal(/* @__PURE__ */ import_jsx_runtime9.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal.displayName = PORTAL_NAME;

// ../../node_modules/.pnpm/@radix-ui+react-presence@1.1.5_@types+react-dom@19.2.3_@types+react@19.2.7__@types+reac_90b29b5754215655309320557426a63a/node_modules/@radix-ui/react-presence/dist/index.mjs
var React24 = __toESM(require_react(), 1);
var React25 = __toESM(require_react(), 1);
"use client";
function useStateMachine(initialState, machine) {
  return React25.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React24.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef3(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React24.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = React24.useState();
  const stylesRef = React24.useRef(null);
  const prevPresentRef = React24.useRef(present);
  const prevAnimationNameRef = React24.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React24.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect22(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || styles?.display === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect22(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(CSS.escape(event.animationName));
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React24.useCallback((node2) => {
      stylesRef.current = node2 ? getComputedStyle(node2) : null;
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
function getElementRef3(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// ../../node_modules/.pnpm/@radix-ui+react-use-controllable-state@1.2.2_@types+react@19.2.7_react@19.2.3/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React27 = __toESM(require_react(), 1);
var React26 = __toESM(require_react(), 1);
var useInsertionEffect = React27[" useInsertionEffect ".trim().toString()] || useLayoutEffect22;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {},
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== undefined;
  const value = isControlled ? prop : uncontrolledProp;
  if (true) {
    const isControlledRef = React27.useRef(prop !== undefined);
    React27.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(`${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`);
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = React27.useCallback((nextValue) => {
    if (isControlled) {
      const value2 = isFunction(nextValue) ? nextValue(prop) : nextValue;
      if (value2 !== prop) {
        onChangeRef.current?.(value2);
      }
    } else {
      setUncontrolledProp(nextValue);
    }
  }, [isControlled, prop, setUncontrolledProp, onChangeRef]);
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value, setValue] = React27.useState(defaultProp);
  const prevValueRef = React27.useRef(value);
  const onChangeRef = React27.useRef(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  React27.useEffect(() => {
    if (prevValueRef.current !== value) {
      onChangeRef.current?.(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction(value) {
  return typeof value === "function";
}
var SYNC_STATE = Symbol("RADIX:SYNC_STATE");

// ../../node_modules/.pnpm/aria-hidden@1.2.6/node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = new WeakMap;
var uncontrolledNodes = new WeakMap;
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x3) {
    return Boolean(x3);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = new WeakMap;
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = new Set;
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e2) {
          console.error("aria-hidden: cannot operate on ", node, e2);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = new WeakMap;
      counterMap = new WeakMap;
      uncontrolledNodes = new WeakMap;
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === undefined) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// ../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign(t2) {
    for (var s2, i3 = 1, n2 = arguments.length;i3 < n2; i3++) {
      s2 = arguments[i3];
      for (var p3 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p3))
          t2[p3] = s2[p3];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p3 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
      t2[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s2);i3 < p3.length; i3++) {
      if (e2.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i3]))
        t2[p3[i3]] = s2[p3[i3]];
    }
  return t2;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i3 = 0, l3 = from.length, ar;i3 < l3; i3++) {
      if (ar || !(i3 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i3);
        ar[i3] = from[i3];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// ../../node_modules/.pnpm/react-remove-scroll@2.7.2_@types+react@19.2.7_react@19.2.3/node_modules/react-remove-scroll/dist/es2015/Combination.js
var React34 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/react-remove-scroll@2.7.2_@types+react@19.2.7_react@19.2.3/node_modules/react-remove-scroll/dist/es2015/UI.js
var React30 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/react-remove-scroll-bar@2.3.8_@types+react@19.2.7_react@19.2.3/node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// ../../node_modules/.pnpm/use-callback-ref@1.3.3_@types+react@19.2.7_react@19.2.3/node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// ../../node_modules/.pnpm/use-callback-ref@1.3.3_@types+react@19.2.7_react@19.2.3/node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react20 = __toESM(require_react(), 1);
function useCallbackRef2(initialValue, callback) {
  var ref = import_react20.useState(function() {
    return {
      value: initialValue,
      callback,
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// ../../node_modules/.pnpm/use-callback-ref@1.3.3_@types+react@19.2.7_react@19.2.3/node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var React28 = __toESM(require_react(), 1);
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React28.useLayoutEffect : React28.useEffect;
var currentValues = new WeakMap;
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
// ../../node_modules/.pnpm/use-sidecar@1.1.3_@types+react@19.2.7_react@19.2.3/node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a3) {
  return a3;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === undefined) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x3) {
          return x3 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x3) {
          return cb(x3);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x3) {
          pendingQueue.push(x3);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === undefined) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
// ../../node_modules/.pnpm/use-sidecar@1.1.3_@types+react@19.2.7_react@19.2.3/node_modules/use-sidecar/dist/es2015/exports.js
var React29 = __toESM(require_react(), 1);
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React29.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}
// ../../node_modules/.pnpm/react-remove-scroll@2.7.2_@types+react@19.2.7_react@19.2.3/node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// ../../node_modules/.pnpm/react-remove-scroll@2.7.2_@types+react@19.2.7_react@19.2.3/node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React30.forwardRef(function(props, parentRef) {
  var ref = React30.useRef(null);
  var _a = React30.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var { forwardProps, children, className, removeScrollBar, enabled, shards, sideCar, noRelative, noIsolation, inert, allowPinchZoom, as: _b } = props, Container2 = _b === undefined ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React30.createElement(React30.Fragment, null, enabled && React30.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }), forwardProps ? React30.cloneElement(React30.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React30.createElement(Container2, __assign({}, containerProps, { className, ref: containerRef }), children));
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// ../../node_modules/.pnpm/react-remove-scroll@2.7.2_@types+react@19.2.7_react@19.2.3/node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React33 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/react-remove-scroll-bar@2.3.8_@types+react@19.2.7_react@19.2.3/node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React32 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/react-style-singleton@2.2.3_@types+react@19.2.7_react@19.2.3/node_modules/react-style-singleton/dist/es2015/hook.js
var React31 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/get-nonce@1.0.1/node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return;
};

// ../../node_modules/.pnpm/react-style-singleton@2.2.3_@types+react@19.2.7_react@19.2.3/node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// ../../node_modules/.pnpm/react-style-singleton@2.2.3_@types+react@19.2.7_react@19.2.3/node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React31.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// ../../node_modules/.pnpm/react-style-singleton@2.2.3_@types+react@19.2.7_react@19.2.3/node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var { styles, dynamic } = _a;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
// ../../node_modules/.pnpm/react-remove-scroll-bar@2.3.8_@types+react@19.2.7_react@19.2.3/node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x3) {
  return parseInt(x3 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === undefined) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// ../../node_modules/.pnpm/react-remove-scroll-bar@2.3.8_@types+react@19.2.7_react@19.2.3/node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var { left, top, right, gap } = _a;
  if (gapMode === undefined) {
    gapMode = "margin";
  }
  return `
  .`.concat(noScrollbarsClassName, ` {
   overflow: hidden `).concat(important, `;
   padding-right: `).concat(gap, "px ").concat(important, `;
  }
  body[`).concat(lockAttribute, `] {
    overflow: hidden `).concat(important, `;
    overscroll-behavior: contain;
    `).concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && `
    padding-left: `.concat(left, `px;
    padding-top: `).concat(top, `px;
    padding-right: `).concat(right, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(gap, "px ").concat(important, `;
    `),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(zeroRightClassName, ` {
    right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(fullWidthClassName, ` {
    margin-right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(zeroRightClassName, " .").concat(zeroRightClassName, ` {
    right: 0 `).concat(important, `;
  }
  
  .`).concat(fullWidthClassName, " .").concat(fullWidthClassName, ` {
    margin-right: 0 `).concat(important, `;
  }
  
  body[`).concat(lockAttribute, `] {
    `).concat(removedBarSizeVariable, ": ").concat(gap, `px;
  }
`);
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React32.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var { noRelative, noImportant, gapMode: _b } = _a, gapMode = _b === undefined ? "margin" : _b;
  useLockAttribute();
  var gap = React32.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React32.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// ../../node_modules/.pnpm/react-remove-scroll@2.7.2_@types+react@19.2.7_react@19.2.3/node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// ../../node_modules/.pnpm/react-remove-scroll@2.7.2_@types+react@19.2.7_react@19.2.3/node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return styles[overflow] !== "hidden" && !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible");
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var { scrollTop, scrollHeight, clientHeight } = _a;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var { scrollLeft, scrollWidth, clientWidth } = _a;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    if (!target) {
      break;
    }
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    var parent_1 = target.parentNode;
    target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
  } while (!targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target));
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// ../../node_modules/.pnpm/react-remove-scroll@2.7.2_@types+react@19.2.7_react@19.2.3/node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x3, y2) {
  return x3[0] === y2[0] && x3[1] === y2[1];
};
var generateStyle = function(id) {
  return `
  .block-interactivity-`.concat(id, ` {pointer-events: none;}
  .allow-interactivity-`).concat(id, ` {pointer-events: all;}
`);
};
var idCounter3 = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React33.useRef([]);
  var touchStartRef = React33.useRef([0, 0]);
  var activeAxis = React33.useRef();
  var id = React33.useState(idCounter3++)[0];
  var Style2 = React33.useState(styleSingleton)[0];
  var lastProps = React33.useRef(props);
  React33.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React33.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React33.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var selection = window.getSelection();
    var anchorNode = selection && selection.anchorNode;
    var isTouchingSelection = anchorNode ? anchorNode === target || anchorNode.contains(target) : false;
    if (isTouchingSelection) {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React33.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React33.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React33.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = undefined;
  }, []);
  var scrollWheel = React33.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React33.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React33.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var { removeScrollBar, inert } = props;
  return React33.createElement(React33.Fragment, null, inert ? React33.createElement(Style2, { styles: generateStyle(id) }) : null, removeScrollBar ? React33.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null);
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}

// ../../node_modules/.pnpm/react-remove-scroll@2.7.2_@types+react@19.2.7_react@19.2.3/node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// ../../node_modules/.pnpm/react-remove-scroll@2.7.2_@types+react@19.2.7_react@19.2.3/node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React34.forwardRef(function(props, ref) {
  return React34.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// ../../node_modules/.pnpm/@radix-ui+react-popover@1.1.15_@types+react-dom@19.2.3_@types+react@19.2.7__@types+reac_aba36e289011c7efa5498b0a55e1bb01/node_modules/@radix-ui/react-popover/dist/index.mjs
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
"use client";
var POPOVER_NAME = "Popover";
var [createPopoverContext, createPopoverScope] = createContextScope(POPOVER_NAME, [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME);
var Popover = (props) => {
  const {
    __scopePopover,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = false
  } = props;
  const popperScope = usePopperScope(__scopePopover);
  const triggerRef = React35.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = React35.useState(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: POPOVER_NAME
  });
  return /* @__PURE__ */ import_jsx_runtime10.jsx(Root2, { ...popperScope, children: /* @__PURE__ */ import_jsx_runtime10.jsx(PopoverProvider, {
    scope: __scopePopover,
    contentId: useId2(),
    triggerRef,
    open,
    onOpenChange: setOpen,
    onOpenToggle: React35.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
    hasCustomAnchor,
    onCustomAnchorAdd: React35.useCallback(() => setHasCustomAnchor(true), []),
    onCustomAnchorRemove: React35.useCallback(() => setHasCustomAnchor(false), []),
    modal,
    children
  }) });
};
Popover.displayName = POPOVER_NAME;
var ANCHOR_NAME2 = "PopoverAnchor";
var PopoverAnchor = React35.forwardRef((props, forwardedRef) => {
  const { __scopePopover, ...anchorProps } = props;
  const context = usePopoverContext(ANCHOR_NAME2, __scopePopover);
  const popperScope = usePopperScope(__scopePopover);
  const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
  React35.useEffect(() => {
    onCustomAnchorAdd();
    return () => onCustomAnchorRemove();
  }, [onCustomAnchorAdd, onCustomAnchorRemove]);
  return /* @__PURE__ */ import_jsx_runtime10.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
});
PopoverAnchor.displayName = ANCHOR_NAME2;
var TRIGGER_NAME = "PopoverTrigger";
var PopoverTrigger = React35.forwardRef((props, forwardedRef) => {
  const { __scopePopover, ...triggerProps } = props;
  const context = usePopoverContext(TRIGGER_NAME, __scopePopover);
  const popperScope = usePopperScope(__scopePopover);
  const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
  const trigger = /* @__PURE__ */ import_jsx_runtime10.jsx(Primitive.button, {
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": context.open,
    "aria-controls": context.contentId,
    "data-state": getState(context.open),
    ...triggerProps,
    ref: composedTriggerRef,
    onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
  });
  return context.hasCustomAnchor ? trigger : /* @__PURE__ */ import_jsx_runtime10.jsx(Anchor, { asChild: true, ...popperScope, children: trigger });
});
PopoverTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME2 = "PopoverPortal";
var [PortalProvider, usePortalContext] = createPopoverContext(PORTAL_NAME2, {
  forceMount: undefined
});
var PopoverPortal = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = usePopoverContext(PORTAL_NAME2, __scopePopover);
  return /* @__PURE__ */ import_jsx_runtime10.jsx(PortalProvider, { scope: __scopePopover, forceMount, children: /* @__PURE__ */ import_jsx_runtime10.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ import_jsx_runtime10.jsx(Portal, { asChild: true, container, children }) }) });
};
PopoverPortal.displayName = PORTAL_NAME2;
var CONTENT_NAME2 = "PopoverContent";
var PopoverContent = React35.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext(CONTENT_NAME2, props.__scopePopover);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = usePopoverContext(CONTENT_NAME2, props.__scopePopover);
  return /* @__PURE__ */ import_jsx_runtime10.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ import_jsx_runtime10.jsx(PopoverContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ import_jsx_runtime10.jsx(PopoverContentNonModal, { ...contentProps, ref: forwardedRef }) });
});
PopoverContent.displayName = CONTENT_NAME2;
var Slot2 = createSlot2("PopoverContent.RemoveScroll");
var PopoverContentModal = React35.forwardRef((props, forwardedRef) => {
  const context = usePopoverContext(CONTENT_NAME2, props.__scopePopover);
  const contentRef = React35.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, contentRef);
  const isRightClickOutsideRef = React35.useRef(false);
  React35.useEffect(() => {
    const content = contentRef.current;
    if (content)
      return hideOthers(content);
  }, []);
  return /* @__PURE__ */ import_jsx_runtime10.jsx(Combination_default, { as: Slot2, allowPinchZoom: true, children: /* @__PURE__ */ import_jsx_runtime10.jsx(PopoverContentImpl, {
    ...props,
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
      event.preventDefault();
      if (!isRightClickOutsideRef.current)
        context.triggerRef.current?.focus();
    }),
    onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      isRightClickOutsideRef.current = isRightClick;
    }, { checkForDefaultPrevented: false }),
    onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => event.preventDefault(), { checkForDefaultPrevented: false })
  }) });
});
var PopoverContentNonModal = React35.forwardRef((props, forwardedRef) => {
  const context = usePopoverContext(CONTENT_NAME2, props.__scopePopover);
  const hasInteractedOutsideRef = React35.useRef(false);
  const hasPointerDownOutsideRef = React35.useRef(false);
  return /* @__PURE__ */ import_jsx_runtime10.jsx(PopoverContentImpl, {
    ...props,
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (event) => {
      props.onCloseAutoFocus?.(event);
      if (!event.defaultPrevented) {
        if (!hasInteractedOutsideRef.current)
          context.triggerRef.current?.focus();
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
      hasPointerDownOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      props.onInteractOutside?.(event);
      if (!event.defaultPrevented) {
        hasInteractedOutsideRef.current = true;
        if (event.detail.originalEvent.type === "pointerdown") {
          hasPointerDownOutsideRef.current = true;
        }
      }
      const target = event.target;
      const targetIsTrigger = context.triggerRef.current?.contains(target);
      if (targetIsTrigger)
        event.preventDefault();
      if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
        event.preventDefault();
      }
    }
  });
});
var PopoverContentImpl = React35.forwardRef((props, forwardedRef) => {
  const {
    __scopePopover,
    trapFocus,
    onOpenAutoFocus,
    onCloseAutoFocus,
    disableOutsidePointerEvents,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    ...contentProps
  } = props;
  const context = usePopoverContext(CONTENT_NAME2, __scopePopover);
  const popperScope = usePopperScope(__scopePopover);
  useFocusGuards();
  return /* @__PURE__ */ import_jsx_runtime10.jsx(FocusScope, {
    asChild: true,
    loop: true,
    trapped: trapFocus,
    onMountAutoFocus: onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus,
    children: /* @__PURE__ */ import_jsx_runtime10.jsx(DismissableLayer, {
      asChild: true,
      disableOutsidePointerEvents,
      onInteractOutside,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onDismiss: () => context.onOpenChange(false),
      children: /* @__PURE__ */ import_jsx_runtime10.jsx(Content, {
        "data-state": getState(context.open),
        role: "dialog",
        id: context.contentId,
        ...popperScope,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ...contentProps.style,
          ...{
            "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
            "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
            "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      })
    })
  });
});
var CLOSE_NAME = "PopoverClose";
var PopoverClose = React35.forwardRef((props, forwardedRef) => {
  const { __scopePopover, ...closeProps } = props;
  const context = usePopoverContext(CLOSE_NAME, __scopePopover);
  return /* @__PURE__ */ import_jsx_runtime10.jsx(Primitive.button, {
    type: "button",
    ...closeProps,
    ref: forwardedRef,
    onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
  });
});
PopoverClose.displayName = CLOSE_NAME;
var ARROW_NAME2 = "PopoverArrow";
var PopoverArrow = React35.forwardRef((props, forwardedRef) => {
  const { __scopePopover, ...arrowProps } = props;
  const popperScope = usePopperScope(__scopePopover);
  return /* @__PURE__ */ import_jsx_runtime10.jsx(Arrow3, { ...popperScope, ...arrowProps, ref: forwardedRef });
});
PopoverArrow.displayName = ARROW_NAME2;
function getState(open) {
  return open ? "open" : "closed";
}
var Root22 = Popover;
var Trigger = PopoverTrigger;
var Portal2 = PopoverPortal;
var Content2 = PopoverContent;

// ../../src/components/ui/popover.tsx
var jsx_dev_runtime25 = __toESM(require_jsx_dev_runtime(), 1);
var Popover2 = Root22;
var PopoverTrigger2 = Trigger;
var PopoverContent2 = React36.forwardRef(({ className, align = "center", sideOffset = 4, ...props }, ref) => /* @__PURE__ */ jsx_dev_runtime25.jsxDEV(Portal2, {
  children: /* @__PURE__ */ jsx_dev_runtime25.jsxDEV(Content2, {
    ref,
    align,
    sideOffset,
    className: cn("z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]", className),
    ...props
  }, undefined, false, undefined, this)
}, undefined, false, undefined, this));
PopoverContent2.displayName = Content2.displayName;

// ../../src/features/konva-editor/components/PropertyPanel/ColorInput.tsx
var import_react21 = __toESM(require_react(), 1);
var jsx_dev_runtime26 = __toESM(require_jsx_dev_runtime(), 1);
var ColorInput = ({ value, onChange, disabled, className }) => {
  const [isOpen, setIsOpen] = import_react21.useState(false);
  const popoverRef = import_react21.useRef(null);
  const [localColor, setLocalColor] = import_react21.useState(value);
  import_react21.useEffect(() => {
    setLocalColor(value);
  }, [value]);
  const handleColorDrag = (newColor) => {
    setLocalColor(newColor);
  };
  const handleInteractionEnd = () => {
    onChange(localColor, { saveToHistory: true });
  };
  return /* @__PURE__ */ jsx_dev_runtime26.jsxDEV("div", {
    className: cn2("relative", className),
    ref: popoverRef,
    children: /* @__PURE__ */ jsx_dev_runtime26.jsxDEV(Popover2, {
      open: isOpen,
      onOpenChange: setIsOpen,
      children: [
        /* @__PURE__ */ jsx_dev_runtime26.jsxDEV(PopoverTrigger2, {
          asChild: true,
          children: /* @__PURE__ */ jsx_dev_runtime26.jsxDEV("div", {
            className: cn2("w-full h-8 px-2 border border-border rounded flex items-center gap-2 cursor-pointer bg-background hover:bg-accent hover:text-accent-foreground", disabled && "opacity-50 cursor-not-allowed"),
            children: [
              /* @__PURE__ */ jsx_dev_runtime26.jsxDEV("div", {
                className: "w-4 h-4 rounded-sm border border-gray-200 shadow-sm",
                style: { backgroundColor: value }
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime26.jsxDEV("span", {
                className: "text-[12px] truncate flex-1",
                children: value
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime26.jsxDEV(PopoverContent2, {
          className: "w-auto p-3",
          align: "start",
          onOpenAutoFocus: (e2) => e2.preventDefault(),
          children: [
            /* @__PURE__ */ jsx_dev_runtime26.jsxDEV("div", {
              onPointerUp: handleInteractionEnd,
              children: /* @__PURE__ */ jsx_dev_runtime26.jsxDEV(ne, {
                color: localColor === "transparent" ? "#00000000" : localColor,
                onChange: handleColorDrag
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime26.jsxDEV("div", {
              className: "mt-3 flex items-center",
              children: [
                /* @__PURE__ */ jsx_dev_runtime26.jsxDEV(WidgetInput, {
                  value: localColor,
                  onChange: (e2) => {
                    setLocalColor(e2.target.value);
                    onChange(e2.target.value, { saveToHistory: true });
                  },
                  className: "uppercase flex-1"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx_dev_runtime26.jsxDEV("button", {
                  type: "button",
                  className: "w-10 h-10 border border-border rounded ml-2 flex items-center justify-center bg-muted hover:bg-muted/80 relative overflow-hidden",
                  onClick: () => {
                    setLocalColor("transparent");
                    onChange("transparent", { saveToHistory: true });
                  },
                  title: "Transparent",
                  children: [
                    /* @__PURE__ */ jsx_dev_runtime26.jsxDEV("div", {
                      className: "absolute inset-0",
                      style: {
                        background: "conic-gradient(#eee 0 25%, white 0 50%, #eee 0 75%, white 0)",
                        backgroundSize: "8px 8px",
                        opacity: 0.5
                      }
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx_dev_runtime26.jsxDEV("div", {
                      className: "absolute inset-0 border-t border-red-500 transform rotate-45"
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this)
              ]
            }, undefined, true, undefined, this)
          ]
        }, undefined, true, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/FontWidget.tsx
var jsx_dev_runtime27 = __toESM(require_jsx_dev_runtime(), 1);
var FontWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  if (node.t !== "text")
    return null;
  const textNode = node;
  const props = config.props ?? {};
  const families = props.fontFamilies ?? DEFAULT_FONT_FAMILIES;
  const sizes = props.fontSizes ?? DEFAULT_FONT_SIZES;
  const toggleStyle = (key, currentValue, onValue, offValue) => {
    onChange({ [key]: currentValue === onValue ? offValue : onValue });
  };
  return /* @__PURE__ */ jsx_dev_runtime27.jsxDEV("div", {
    className: "space-y-2",
    children: [
      /* @__PURE__ */ jsx_dev_runtime27.jsxDEV(GridContainer, {
        grid: config.grid,
        children: [
          props.showFamily !== false && /* @__PURE__ */ jsx_dev_runtime27.jsxDEV("div", {
            children: [
              /* @__PURE__ */ jsx_dev_runtime27.jsxDEV(WidgetLabel, {
                children: resolveText("properties_font", "Font")
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime27.jsxDEV(WidgetSelect, {
                value: textNode.font ?? "Meiryo",
                onChange: (e2) => onChange({ font: e2.target.value }),
                children: families.map((f2) => /* @__PURE__ */ jsx_dev_runtime27.jsxDEV("option", {
                  value: f2,
                  children: f2
                }, f2, false, undefined, this))
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          props.showSize !== false && /* @__PURE__ */ jsx_dev_runtime27.jsxDEV("div", {
            children: [
              /* @__PURE__ */ jsx_dev_runtime27.jsxDEV(WidgetLabel, {
                children: [
                  resolveText("properties_font_size", "Size"),
                  "(pt)"
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime27.jsxDEV(WidgetSelect, {
                value: String(roundTo(mmToPt(textNode.fontSize ?? ptToMm(12)), 1)),
                onChange: (e2) => onChange({ fontSize: ptToMm(Number(e2.target.value)) }),
                children: sizes.map((s2) => /* @__PURE__ */ jsx_dev_runtime27.jsxDEV("option", {
                  value: s2,
                  children: s2
                }, s2, false, undefined, this))
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime27.jsxDEV("div", {
        className: "flex gap-2 items-end",
        children: [
          /* @__PURE__ */ jsx_dev_runtime27.jsxDEV("div", {
            className: "flex gap-1",
            children: [
              props.showBold !== false && /* @__PURE__ */ jsx_dev_runtime27.jsxDEV("button", {
                type: "button",
                onClick: () => toggleStyle("fontWeight", textNode.fontWeight, 700, 400),
                className: cn2("p-1.5 rounded border h-8 w-8 flex items-center justify-center", textNode.fontWeight === 700 ? "bg-accent text-accent-foreground border-border" : "bg-background text-muted-foreground border-border hover:bg-muted"),
                children: /* @__PURE__ */ jsx_dev_runtime27.jsxDEV(Bold, {
                  size: 14
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              props.showItalic !== false && /* @__PURE__ */ jsx_dev_runtime27.jsxDEV("button", {
                type: "button",
                onClick: () => toggleStyle("italic", textNode.italic, true, false),
                className: cn2("p-1.5 rounded border h-8 w-8 flex items-center justify-center", textNode.italic ? "bg-accent text-accent-foreground border-border" : "bg-background text-muted-foreground border-border hover:bg-muted"),
                children: /* @__PURE__ */ jsx_dev_runtime27.jsxDEV(Italic, {
                  size: 14
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              props.showUnderline !== false && /* @__PURE__ */ jsx_dev_runtime27.jsxDEV("button", {
                type: "button",
                onClick: () => toggleStyle("underline", textNode.underline, true, false),
                className: cn2("p-1.5 rounded border h-8 w-8 flex items-center justify-center", textNode.underline ? "bg-accent text-accent-foreground border-border" : "bg-background text-muted-foreground border-border hover:bg-muted"),
                children: /* @__PURE__ */ jsx_dev_runtime27.jsxDEV(Underline, {
                  size: 14
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              props.showStrikethrough && /* @__PURE__ */ jsx_dev_runtime27.jsxDEV("button", {
                type: "button",
                onClick: () => toggleStyle("lineThrough", textNode.lineThrough, true, false),
                className: cn2("p-1.5 rounded border h-8 w-8 flex items-center justify-center", textNode.lineThrough ? "bg-accent text-accent-foreground border-border" : "bg-background text-muted-foreground border-border hover:bg-muted"),
                children: /* @__PURE__ */ jsx_dev_runtime27.jsxDEV(Strikethrough, {
                  size: 14
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          props.showColor !== false && /* @__PURE__ */ jsx_dev_runtime27.jsxDEV("div", {
            className: "flex-1",
            children: /* @__PURE__ */ jsx_dev_runtime27.jsxDEV(ColorInput, {
              value: textNode.fill ?? "#000000",
              onChange: (e2, options2) => onChange({ fill: e2 }, options2),
              className: "h-8 w-full p-0.5 cursor-pointer"
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/AlignmentWidget.tsx
var jsx_dev_runtime28 = __toESM(require_jsx_dev_runtime(), 1);
var alignIcons = {
  l: AlignLeft,
  c: AlignCenter,
  r: AlignRight,
  j: AlignJustify
};
var AlignmentWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  if (node.t !== "text")
    return null;
  const textNode = node;
  const options2 = config.props?.options ?? ["l", "c", "r"];
  return /* @__PURE__ */ jsx_dev_runtime28.jsxDEV("div", {
    children: [
      config.labelKey && /* @__PURE__ */ jsx_dev_runtime28.jsxDEV(WidgetLabel, {
        children: resolveText(config.labelKey, "Align")
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime28.jsxDEV("div", {
        className: "flex bg-background rounded border border-border p-0.5",
        children: options2.map((opt) => {
          const Icon2 = alignIcons[opt];
          const isActive = textNode.align === opt;
          return /* @__PURE__ */ jsx_dev_runtime28.jsxDEV("button", {
            type: "button",
            onClick: () => onChange({ align: opt }),
            className: cn2("flex-1 py-1 flex justify-center rounded transition-colors", isActive ? "bg-primary text-primary-foreground" : "hover:bg-accent text-muted-foreground"),
            children: /* @__PURE__ */ jsx_dev_runtime28.jsxDEV(Icon2, {
              size: 14
            }, undefined, false, undefined, this)
          }, opt, false, undefined, this);
        })
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/VAlignmentWidget.tsx
var jsx_dev_runtime29 = __toESM(require_jsx_dev_runtime(), 1);
var vAlignIcons = {
  t: ArrowUpToLine,
  m: AlignVerticalJustifyCenter,
  b: ArrowDownToLine
};
var VAlignmentWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  if (node.t !== "text")
    return null;
  const textNode = node;
  const options2 = config.props?.options ?? ["t", "m", "b"];
  return /* @__PURE__ */ jsx_dev_runtime29.jsxDEV("div", {
    children: [
      config.labelKey && /* @__PURE__ */ jsx_dev_runtime29.jsxDEV(WidgetLabel, {
        children: resolveText(config.labelKey, "V-Align")
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime29.jsxDEV("div", {
        className: "flex bg-background rounded border border-border p-0.5",
        children: options2.map((opt) => {
          const Icon2 = vAlignIcons[opt];
          const isActive = (textNode.vAlign || "t") === opt;
          return /* @__PURE__ */ jsx_dev_runtime29.jsxDEV("button", {
            type: "button",
            onClick: () => onChange({ vAlign: opt }),
            className: cn2("flex-1 py-1 flex justify-center rounded transition-colors", isActive ? "bg-primary text-primary-foreground" : "hover:bg-accent text-muted-foreground"),
            children: /* @__PURE__ */ jsx_dev_runtime29.jsxDEV(Icon2, {
              size: 14
            }, undefined, false, undefined, this)
          }, opt, false, undefined, this);
        })
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/StrokeWidget.tsx
var jsx_dev_runtime30 = __toESM(require_jsx_dev_runtime(), 1);
var StrokeWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  const props = config.props ?? { showColor: true, showWidth: true };
  const strokeNode = node;
  return /* @__PURE__ */ jsx_dev_runtime30.jsxDEV("div", {
    className: "space-y-2",
    children: [
      props.showColor && /* @__PURE__ */ jsx_dev_runtime30.jsxDEV("div", {
        children: [
          /* @__PURE__ */ jsx_dev_runtime30.jsxDEV(WidgetLabel, {
            children: resolveText("properties_stroke_color", "Stroke Color")
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime30.jsxDEV(ColorInput, {
            value: strokeNode.stroke ?? "#000000",
            onChange: (color, options2) => onChange({ stroke: color }, options2)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      props.showWidth && /* @__PURE__ */ jsx_dev_runtime30.jsxDEV("div", {
        children: [
          /* @__PURE__ */ jsx_dev_runtime30.jsxDEV(WidgetLabel, {
            children: resolveText(config.labelKey ?? "properties_line_width", "Line Width")
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime30.jsxDEV(WidgetInput, {
            type: "number",
            min: 0,
            max: props.maxWidth ?? 20,
            step: props.step ?? 0.2,
            value: strokeNode.strokeW ?? 0.2,
            onChange: (e2) => onChange({ strokeW: Math.max(0, Number(e2.target.value)) })
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/FillWidget.tsx
var jsx_dev_runtime31 = __toESM(require_jsx_dev_runtime(), 1);
var FillWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  const fillNode = node;
  return /* @__PURE__ */ jsx_dev_runtime31.jsxDEV("div", {
    children: [
      /* @__PURE__ */ jsx_dev_runtime31.jsxDEV(WidgetLabel, {
        children: resolveText(config.labelKey ?? "properties_fill_color", "Fill")
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime31.jsxDEV(ColorInput, {
        value: fillNode.fill ?? "#000000",
        onChange: (color, options2) => onChange({ fill: color }, options2)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/BorderWidget.tsx
var jsx_dev_runtime32 = __toESM(require_jsx_dev_runtime(), 1);
var BorderWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  const props = config.props ?? { showColor: true, showWidth: false };
  const shapeNode = node;
  return /* @__PURE__ */ jsx_dev_runtime32.jsxDEV("div", {
    className: "space-y-2",
    children: [
      props.showColor && /* @__PURE__ */ jsx_dev_runtime32.jsxDEV("div", {
        children: [
          /* @__PURE__ */ jsx_dev_runtime32.jsxDEV(WidgetLabel, {
            children: resolveText(config.labelKey ?? "properties_border_color", "BorderColor")
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime32.jsxDEV(ColorInput, {
            value: shapeNode.stroke ?? "#000000",
            onChange: (color, options2) => onChange({ stroke: color }, options2)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      props.showWidth && /* @__PURE__ */ jsx_dev_runtime32.jsxDEV("div", {
        children: [
          /* @__PURE__ */ jsx_dev_runtime32.jsxDEV(WidgetLabel, {
            children: resolveText("properties_border_width", "Border Width")
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime32.jsxDEV(WidgetInput, {
            type: "number",
            min: 0,
            step: props.step ?? 0.2,
            value: shapeNode.strokeW ?? 0.2,
            onChange: (e2) => onChange({ strokeW: Math.max(0, Number(e2.target.value)) })
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/ColorPickerWidget.tsx
var jsx_dev_runtime33 = __toESM(require_jsx_dev_runtime(), 1);
var ColorPickerWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  const fieldKey = config.props.fieldKey;
  const value = node[fieldKey] ?? "#000000";
  const labelKey = config.labelKey ?? "color";
  const fallbackLabel = labelKey === "properties_font_color" ? "FontColor" : labelKey === "properties_border_color" || labelKey === "properties_border_color_box" ? "BorderColor" : labelKey === "properties_line_color" ? "LineColor" : labelKey === "properties_fill_color" ? "FillColor" : "Color";
  return /* @__PURE__ */ jsx_dev_runtime33.jsxDEV("div", {
    children: [
      /* @__PURE__ */ jsx_dev_runtime33.jsxDEV(WidgetLabel, {
        children: resolveText(labelKey, fallbackLabel)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime33.jsxDEV(ColorInput, {
        value,
        onChange: (newColor) => {
          const updates = {
            [fieldKey]: newColor
          };
          if (fieldKey === "borderColor") {
            const currentWidth = node.borderWidth;
            if (!currentWidth || currentWidth === 0) {
              updates.borderWidth = 0.1;
            }
          }
          onChange(updates, undefined);
        }
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/SliderWidget.tsx
var jsx_dev_runtime34 = __toESM(require_jsx_dev_runtime(), 1);
var SliderWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  const { fieldKey, min: min2, max: max2, step = 1, showValue } = config.props;
  const value = node[fieldKey] ?? min2;
  return /* @__PURE__ */ jsx_dev_runtime34.jsxDEV("div", {
    children: [
      /* @__PURE__ */ jsx_dev_runtime34.jsxDEV(WidgetLabel, {
        children: [
          resolveText(config.labelKey ?? fieldKey, fieldKey),
          showValue && `: ${value}`
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime34.jsxDEV("input", {
        type: "range",
        min: min2,
        max: max2,
        step,
        value,
        onChange: (e2) => onChange({ [fieldKey]: parseFloat(e2.target.value) }),
        className: "w-full accent-accent"
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/TextContentWidget.tsx
var jsx_dev_runtime35 = __toESM(require_jsx_dev_runtime(), 1);
var TextContentWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  if (node.t !== "text")
    return null;
  const textNode = node;
  const rows = config.props?.rows ?? 3;
  return /* @__PURE__ */ jsx_dev_runtime35.jsxDEV("div", {
    children: [
      /* @__PURE__ */ jsx_dev_runtime35.jsxDEV(WidgetLabel, {
        children: resolveText(config.labelKey ?? "properties_text_content", "Content")
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime35.jsxDEV("textarea", {
        value: textNode.text ?? "",
        onChange: (e2) => onChange({ text: e2.target.value }),
        rows,
        className: cn2("w-full px-1.5 py-1 border border-border rounded text-[11px]", "bg-background text-foreground resize-y", "focus:outline-none focus:ring-1 focus:ring-ring")
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/LineStyleWidget.tsx
var jsx_dev_runtime36 = __toESM(require_jsx_dev_runtime(), 1);
var LineStyleWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  const lineNode = node;
  const options2 = config.props?.options ?? ["solid", "dashed", "dotted"];
  const getStyleFromDash = (dash) => {
    if (!dash || dash.length === 0)
      return "solid";
    if (dash[0] !== undefined && dash[0] < 1)
      return "dotted";
    return "dashed";
  };
  const getDashFromStyle = (style) => {
    if (style === "dashed")
      return [3, 3];
    if (style === "dotted")
      return [0.001, 2];
    return;
  };
  const currentStyle = getStyleFromDash(lineNode.dash);
  return /* @__PURE__ */ jsx_dev_runtime36.jsxDEV("div", {
    children: [
      /* @__PURE__ */ jsx_dev_runtime36.jsxDEV(WidgetLabel, {
        children: resolveText(config.labelKey ?? "properties_line_style", "Style")
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime36.jsxDEV("div", {
        className: "flex gap-1",
        children: options2.map((style) => /* @__PURE__ */ jsx_dev_runtime36.jsxDEV("button", {
          type: "button",
          onClick: () => onChange({ dash: getDashFromStyle(style) }),
          className: cn2("flex-1 py-1.5 px-2 rounded border text-[10px]", currentStyle === style ? "bg-accent text-accent-foreground border-border" : "bg-background text-muted-foreground border-border hover:bg-muted"),
          children: [
            style === "solid" && /* @__PURE__ */ jsx_dev_runtime36.jsxDEV("div", {
              className: "w-full h-0.5 bg-current"
            }, undefined, false, undefined, this),
            style === "dashed" && /* @__PURE__ */ jsx_dev_runtime36.jsxDEV("div", {
              className: "w-full h-0.5 border-b-2 border-dashed border-current"
            }, undefined, false, undefined, this),
            style === "dotted" && /* @__PURE__ */ jsx_dev_runtime36.jsxDEV("div", {
              className: "w-full h-0.5 border-b-2 border-dotted border-current"
            }, undefined, false, undefined, this)
          ]
        }, style, true, undefined, this))
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/ListWidget.tsx
var jsx_dev_runtime37 = __toESM(require_jsx_dev_runtime(), 1);
var BulletIcon = () => /* @__PURE__ */ jsx_dev_runtime37.jsxDEV("svg", {
  viewBox: "0 0 64 64",
  width: "20",
  height: "20",
  "aria-hidden": "true",
  children: [
    /* @__PURE__ */ jsx_dev_runtime37.jsxDEV("circle", {
      cx: "12",
      cy: "16",
      r: "4"
    }, undefined, false, undefined, this),
    /* @__PURE__ */ jsx_dev_runtime37.jsxDEV("rect", {
      x: "22",
      y: "14",
      width: "32",
      height: "4",
      rx: "2"
    }, undefined, false, undefined, this),
    /* @__PURE__ */ jsx_dev_runtime37.jsxDEV("circle", {
      cx: "12",
      cy: "32",
      r: "4"
    }, undefined, false, undefined, this),
    /* @__PURE__ */ jsx_dev_runtime37.jsxDEV("rect", {
      x: "22",
      y: "30",
      width: "32",
      height: "4",
      rx: "2"
    }, undefined, false, undefined, this),
    /* @__PURE__ */ jsx_dev_runtime37.jsxDEV("circle", {
      cx: "12",
      cy: "48",
      r: "4"
    }, undefined, false, undefined, this),
    /* @__PURE__ */ jsx_dev_runtime37.jsxDEV("rect", {
      x: "22",
      y: "46",
      width: "32",
      height: "4",
      rx: "2"
    }, undefined, false, undefined, this)
  ]
}, undefined, true, undefined, this);
var NumberIcon = () => /* @__PURE__ */ jsx_dev_runtime37.jsxDEV("svg", {
  viewBox: "0 0 64 64",
  width: "20",
  height: "20",
  "aria-hidden": "true",
  children: [
    /* @__PURE__ */ jsx_dev_runtime37.jsxDEV("text", {
      x: "4",
      y: "20",
      fontSize: "14",
      fontFamily: "system-ui, sans-serif",
      children: "1."
    }, undefined, false, undefined, this),
    /* @__PURE__ */ jsx_dev_runtime37.jsxDEV("rect", {
      x: "22",
      y: "14",
      width: "32",
      height: "4",
      rx: "2"
    }, undefined, false, undefined, this),
    /* @__PURE__ */ jsx_dev_runtime37.jsxDEV("text", {
      x: "4",
      y: "36",
      fontSize: "14",
      fontFamily: "system-ui, sans-serif",
      children: "2."
    }, undefined, false, undefined, this),
    /* @__PURE__ */ jsx_dev_runtime37.jsxDEV("rect", {
      x: "22",
      y: "30",
      width: "32",
      height: "4",
      rx: "2"
    }, undefined, false, undefined, this),
    /* @__PURE__ */ jsx_dev_runtime37.jsxDEV("text", {
      x: "4",
      y: "52",
      fontSize: "14",
      fontFamily: "system-ui, sans-serif",
      children: "3."
    }, undefined, false, undefined, this),
    /* @__PURE__ */ jsx_dev_runtime37.jsxDEV("rect", {
      x: "22",
      y: "46",
      width: "32",
      height: "4",
      rx: "2"
    }, undefined, false, undefined, this)
  ]
}, undefined, true, undefined, this);
var ListWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  if (node.t !== "text")
    return null;
  const textNode = node;
  const text = textNode.text ?? "";
  const isVertical = !!textNode.vertical;
  const activeType = getListTypeFromText(text, { vertical: isVertical });
  const handleClick = (type) => {
    const nextText = activeType === type ? removeListFormatting(text, { vertical: isVertical }) : applyListFormatting(text, type, { vertical: isVertical });
    onChange({ text: nextText });
  };
  return /* @__PURE__ */ jsx_dev_runtime37.jsxDEV("div", {
    children: [
      /* @__PURE__ */ jsx_dev_runtime37.jsxDEV(WidgetLabel, {
        children: resolveText(config.labelKey ?? "properties_list", "List")
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime37.jsxDEV("div", {
        className: "flex bg-background rounded border border-border p-1 gap-1",
        children: [
          /* @__PURE__ */ jsx_dev_runtime37.jsxDEV("button", {
            type: "button",
            onClick: () => handleClick("bullet"),
            className: cn2("flex-1 py-2 flex items-center justify-center gap-1 rounded text-xs transition-colors", activeType === "bullet" ? "bg-primary text-primary-foreground" : "hover:bg-accent text-muted-foreground"),
            title: resolveText("properties_list_bullet", "Bulleted list"),
            children: /* @__PURE__ */ jsx_dev_runtime37.jsxDEV(BulletIcon, {}, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime37.jsxDEV("button", {
            type: "button",
            onClick: () => handleClick("number"),
            className: cn2("flex-1 py-2 flex items-center justify-center gap-1 rounded text-xs transition-colors", activeType === "number" ? "bg-primary text-primary-foreground" : "hover:bg-accent text-muted-foreground"),
            title: resolveText("properties_list_numbered", "Numbered list"),
            children: /* @__PURE__ */ jsx_dev_runtime37.jsxDEV(NumberIcon, {}, undefined, false, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/LabelFieldWidget.tsx
var jsx_dev_runtime38 = __toESM(require_jsx_dev_runtime(), 1);
var LabelFieldWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  const fieldKey = config.props?.fieldKey ?? "name";
  return /* @__PURE__ */ jsx_dev_runtime38.jsxDEV("div", {
    children: [
      /* @__PURE__ */ jsx_dev_runtime38.jsxDEV(WidgetLabel, {
        children: resolveText(config.labelKey ?? "label", "Label")
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime38.jsxDEV(WidgetInput, {
        type: "text",
        value: node[fieldKey] ?? "",
        onChange: (e2) => onChange({ [fieldKey]: e2.target.value }),
        placeholder: config.props?.placeholder
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/ImageWidget.tsx
var import_react22 = __toESM(require_react(), 1);
var jsx_dev_runtime39 = __toESM(require_jsx_dev_runtime(), 1);
var ImageWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  const [imageSrc, setImageSrc] = import_react22.useState(null);
  const [status, setStatus] = import_react22.useState("loading");
  import_react22.useEffect(() => {
    if (node.t !== "image")
      return;
    const imageNode = node;
    const src = imageNode.src;
    if (!src) {
      setStatus("error");
      return;
    }
    if (src.startsWith("data:") || src.startsWith("http")) {
      setImageSrc(src);
      setStatus("loaded");
    } else {
      setImageSrc(src);
      setStatus("loaded");
    }
  }, [node]);
  if (node.t !== "image")
    return null;
  const maxHeight = config.props?.maxPreviewHeight ?? 120;
  return /* @__PURE__ */ jsx_dev_runtime39.jsxDEV("div", {
    children: [
      config.props?.showPreview !== false && /* @__PURE__ */ jsx_dev_runtime39.jsxDEV("div", {
        className: "mb-2",
        children: [
          status === "loading" && /* @__PURE__ */ jsx_dev_runtime39.jsxDEV("div", {
            className: "w-full h-20 bg-muted border border-border rounded flex items-center justify-center text-xs text-muted-foreground",
            children: resolveText("loading", "Loading...")
          }, undefined, false, undefined, this),
          status === "error" && /* @__PURE__ */ jsx_dev_runtime39.jsxDEV("div", {
            className: "w-full h-20 bg-muted border border-border rounded flex items-center justify-center text-xs text-red-500",
            children: resolveText("no_image", "No Image")
          }, undefined, false, undefined, this),
          status === "loaded" && imageSrc && /* @__PURE__ */ jsx_dev_runtime39.jsxDEV("div", {
            className: "w-full bg-muted border border-border rounded flex items-center justify-center p-2 mb-2",
            style: { maxHeight },
            children: /* @__PURE__ */ jsx_dev_runtime39.jsxDEV("img", {
              src: imageSrc,
              alt: resolveText("properties_preview", "Preview"),
              className: "max-w-full max-h-full object-contain",
              style: { maxHeight: maxHeight - 16 }
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime39.jsxDEV("div", {
        className: "flex gap-1",
        children: [
          /* @__PURE__ */ jsx_dev_runtime39.jsxDEV("label", {
            className: "flex flex-col items-center justify-center flex-1 h-8 border border-border border-dashed rounded cursor-pointer hover:bg-muted transition-colors",
            children: [
              /* @__PURE__ */ jsx_dev_runtime39.jsxDEV("span", {
                className: "text-xs text-muted-foreground",
                children: resolveText("browse", "Browse...")
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime39.jsxDEV("input", {
                type: "file",
                accept: "image/*",
                className: "hidden",
                onChange: (e2) => {
                  const file = e2.target.files?.[0];
                  if (file) {
                    const reader = new FileReader;
                    reader.onload = (ev) => {
                      const result = ev.target?.result;
                      if (result) {
                        const img = new Image;
                        img.onload = () => {
                          const dpi2 = 96;
                          const naturalW = pxToMm(img.width, { dpi: dpi2 });
                          const naturalH = pxToMm(img.height, { dpi: dpi2 });
                          onChange({
                            src: result,
                            w: naturalW,
                            h: naturalH
                          });
                        };
                        img.src = result;
                      }
                    };
                    reader.readAsDataURL(file);
                  }
                }
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          node.t === "image" && node.src && /* @__PURE__ */ jsx_dev_runtime39.jsxDEV("button", {
            onClick: () => onChange({ src: "" }),
            className: "px-2 py-1 text-xs bg-destructive text-destructive-foreground rounded hover:bg-destructive/90 transition-colors",
            title: resolveText("remove", "Remove"),
            children: ""
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/SelectWidget.tsx
var jsx_dev_runtime40 = __toESM(require_jsx_dev_runtime(), 1);
var SelectWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  const { fieldKey, options: options2 } = config.props;
  const labelKey = config.labelKey ?? (fieldKey === "strokeW" ? "properties_stroke_width" : fieldKey);
  const fallbackLabel = fieldKey === "strokeW" ? "StrokeWidth" : fieldKey;
  const getValue = () => {
    const keys = fieldKey.split(".");
    let value = node;
    for (const key of keys) {
      value = value?.[key];
    }
    return value ?? options2[0]?.value ?? "";
  };
  const setValue = (newValue) => {
    const keys = fieldKey.split(".");
    if (keys.length === 1) {
      onChange({ [fieldKey]: newValue });
    } else {
      const rootKey = keys[0];
      const existingData = node[rootKey] ?? {};
      const nestedKey = keys.slice(1).join(".");
      onChange({
        [rootKey]: { ...existingData, [nestedKey]: newValue }
      });
    }
  };
  return /* @__PURE__ */ jsx_dev_runtime40.jsxDEV("div", {
    children: [
      /* @__PURE__ */ jsx_dev_runtime40.jsxDEV(WidgetLabel, {
        children: resolveText(labelKey, fallbackLabel)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime40.jsxDEV(WidgetSelect, {
        value: getValue(),
        onChange: (e2) => setValue(e2.target.value),
        children: options2.map((opt) => /* @__PURE__ */ jsx_dev_runtime40.jsxDEV("option", {
          value: opt.value,
          children: resolveText(opt.labelKey, opt.value)
        }, opt.value, false, undefined, this))
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/PolygonWidget.tsx
var jsx_dev_runtime41 = __toESM(require_jsx_dev_runtime(), 1);
var PolygonWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  if (node.t !== "shape")
    return null;
  const shapeNode = node;
  const points = shapeNode.sides ?? 5;
  const { min: min2 = 3, max: max2 = 12, step = 1 } = config.props || {};
  return /* @__PURE__ */ jsx_dev_runtime41.jsxDEV("div", {
    children: [
      /* @__PURE__ */ jsx_dev_runtime41.jsxDEV(WidgetLabel, {
        children: [
          resolveText(config.labelKey ?? "properties_sides", "Sides"),
          ": ",
          points
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime41.jsxDEV("input", {
        type: "range",
        min: min2,
        max: max2,
        step,
        value: points,
        onChange: (e2) => onChange({ sides: parseInt(e2.target.value, 10) }),
        className: "w-full accent-accent"
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/DataBindingWidget.tsx
var jsx_dev_runtime42 = __toESM(require_jsx_dev_runtime(), 1);
var DataBindingWidget = ({
  config,
  resolveText
}) => {
  return /* @__PURE__ */ jsx_dev_runtime42.jsxDEV("div", {
    className: "text-xs text-muted-foreground italic",
    children: [
      config.props?.mode === "repeater" ? resolveText("data_binding_repeater", "Repeater Binding") : resolveText("data_binding_field", "Field Binding"),
      " ",
      resolveText("wip", "(WIP)")
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/ArrowheadWidget.tsx
var jsx_dev_runtime43 = __toESM(require_jsx_dev_runtime(), 1);
var ArrowheadWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  if (node.t !== "line")
    return null;
  const lineNode = node;
  const position = config.props?.position ?? "end";
  const index2 = position === "start" ? 0 : 1;
  const currentArrow = lineNode.arrows?.[index2] ?? "none";
  const options2 = ["none", "arrow", "circle", "diamond"];
  const handleSelect = (arrowType) => {
    const currentArrows = lineNode.arrows ?? ["none", "none"];
    const newArrows = [...currentArrows];
    newArrows[index2] = arrowType;
    onChange({ arrows: newArrows });
  };
  return /* @__PURE__ */ jsx_dev_runtime43.jsxDEV("div", {
    children: [
      /* @__PURE__ */ jsx_dev_runtime43.jsxDEV(WidgetLabel, {
        children: resolveText(config.labelKey ?? `arrow_${position}`, position === "start" ? "Start Arrow" : "End Arrow")
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime43.jsxDEV("div", {
        className: "flex bg-muted rounded p-0.5 border border-border",
        children: options2.map((opt) => /* @__PURE__ */ jsx_dev_runtime43.jsxDEV("button", {
          onClick: () => handleSelect(opt),
          className: cn2("flex-1 py-1.5 flex items-center justify-center rounded transition-colors", currentArrow === opt ? "bg-primary text-primary-foreground shadow-sm" : "hover:bg-accent text-muted-foreground"),
          title: opt === "none" ? resolveText("none", "None") : opt === "arrow" ? resolveText("properties_arrow_standard", "Standard") : opt === "circle" ? resolveText("properties_arrow_circle", "Circle") : resolveText("properties_arrow_diamond", "Diamond"),
          children: [
            opt === "none" && /* @__PURE__ */ jsx_dev_runtime43.jsxDEV(Minus, {
              size: 14
            }, undefined, false, undefined, this),
            opt === "arrow" && (position === "start" ? /* @__PURE__ */ jsx_dev_runtime43.jsxDEV(ArrowLeft, {
              size: 14
            }, undefined, false, undefined, this) : /* @__PURE__ */ jsx_dev_runtime43.jsxDEV(ArrowRight, {
              size: 14
            }, undefined, false, undefined, this)),
            opt === "circle" && /* @__PURE__ */ jsx_dev_runtime43.jsxDEV(Circle3, {
              size: 12
            }, undefined, false, undefined, this),
            opt === "diamond" && /* @__PURE__ */ jsx_dev_runtime43.jsxDEV(Diamond, {
              size: 12
            }, undefined, false, undefined, this)
          ]
        }, opt, true, undefined, this))
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/NumberInputWidget.tsx
var jsx_dev_runtime44 = __toESM(require_jsx_dev_runtime(), 1);
var NumberInputWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  const { fieldKey, min: min2, max: max2, step = 1, unit } = config.props;
  const value = node[fieldKey] ?? 0;
  return /* @__PURE__ */ jsx_dev_runtime44.jsxDEV("div", {
    children: [
      /* @__PURE__ */ jsx_dev_runtime44.jsxDEV(WidgetLabel, {
        children: resolveText(config.labelKey ?? fieldKey, fieldKey)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime44.jsxDEV("div", {
        className: "flex items-center gap-1",
        children: [
          /* @__PURE__ */ jsx_dev_runtime44.jsxDEV(WidgetInput, {
            type: "number",
            min: min2,
            max: max2,
            step,
            value,
            onChange: (e2) => onChange({ [fieldKey]: parseFloat(e2.target.value) })
          }, undefined, false, undefined, this),
          unit && /* @__PURE__ */ jsx_dev_runtime44.jsxDEV("span", {
            className: "text-[12px] text-muted-foreground",
            children: unit
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/CheckboxWidget.tsx
var jsx_dev_runtime45 = __toESM(require_jsx_dev_runtime(), 1);
var CheckboxWidget = ({
  config,
  node,
  onChange,
  resolveText
}) => {
  const { fieldKey } = config.props;
  const isRouting = fieldKey === "routing";
  const value = isRouting ? node[fieldKey] === "orthogonal" : !!node[fieldKey];
  const handleChange = (checked) => {
    if (isRouting) {
      if (checked) {
        const updates = { routing: "orthogonal" };
        onChange(updates);
      } else {
        const lineNode = node;
        const pts = lineNode.pts || [];
        if (pts.length >= 4) {
          const newPts = [pts[0], pts[1], pts[pts.length - 2], pts[pts.length - 1]];
          const updates = { routing: "straight", pts: newPts };
          onChange(updates);
        } else {
          const updates = { routing: "straight" };
          onChange(updates);
        }
      }
    } else if (fieldKey === "vertical") {
      onChange({ vertical: checked });
    } else if (fieldKey === "hasFrame" && checked) {
      const textNode = node;
      const updates = { hasFrame: true };
      if (!textNode.borderWidth || textNode.borderWidth === 0) {
        updates.borderWidth = 0.2;
      }
      if (!textNode.borderColor) {
        updates.borderColor = "#000000";
      }
      if (!textNode.backgroundColor) {
        updates.backgroundColor = "#FFFFFF";
      }
      if (textNode.padding === undefined) {
        updates.padding = 0.5;
      }
      onChange(updates);
    } else {
      onChange({ [fieldKey]: checked });
    }
  };
  return /* @__PURE__ */ jsx_dev_runtime45.jsxDEV("div", {
    children: [
      /* @__PURE__ */ jsx_dev_runtime45.jsxDEV(WidgetLabel, {
        className: "opacity-0 select-none",
        children: ""
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime45.jsxDEV("div", {
        className: "flex items-center gap-2 h-8",
        children: [
          /* @__PURE__ */ jsx_dev_runtime45.jsxDEV("input", {
            type: "checkbox",
            id: `checkbox-${fieldKey}`,
            checked: value,
            onChange: (e2) => handleChange(e2.target.checked),
            className: "w-4 h-4 rounded border-gray-300 text-primary focus:ring-primary"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime45.jsxDEV("label", {
            htmlFor: `checkbox-${fieldKey}`,
            className: "text-xs text-muted-foreground cursor-pointer select-none",
            children: resolveText(config.labelKey ?? fieldKey, fieldKey)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/konva-editor/components/PropertyPanel/widgets/renderWidget.tsx
var jsx_dev_runtime46 = __toESM(require_jsx_dev_runtime(), 1);
var renderWidget = (config, node, onChange, resolveText, customRenderers) => {
  const commonProps = { node, onChange, resolveText };
  switch (config.type) {
    case "posSize":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(PosSizeWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "font":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(FontWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "alignment":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(AlignmentWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "vAlignment":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(VAlignmentWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "stroke":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(StrokeWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "fill":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(FillWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "border":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(BorderWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "polygon":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(PolygonWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "image":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(ImageWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "select":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(SelectWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "colorPicker":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(ColorPickerWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "slider":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(SliderWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "textContent":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(TextContentWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "lineStyle":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(LineStyleWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "arrowhead":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(ArrowheadWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "labelField":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(LabelFieldWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "hiddenField":
      return null;
    case "dataBinding":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(DataBindingWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "numberInput":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(NumberInputWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "checkbox":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(CheckboxWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "list":
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(ListWidget, {
        ...commonProps,
        config
      }, undefined, false, undefined, this);
    case "custom":
      if (customRenderers?.[config.props.renderKey]) {
        const CustomComponent = customRenderers[config.props.renderKey];
        return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV(CustomComponent, {
          ...commonProps,
          config
        }, undefined, false, undefined, this);
      }
      return null;
    default:
      return /* @__PURE__ */ jsx_dev_runtime46.jsxDEV("div", {
        className: "text-xs text-red-500",
        children: [
          "Unknown widget type: ",
          config.type
        ]
      }, undefined, true, undefined, this);
  }
};

// ../../src/features/konva-editor/components/PropertyPanel/UnifiedPropertyPanel.tsx
var jsx_dev_runtime47 = __toESM(require_jsx_dev_runtime(), 1);
var SectionHeader = ({ labelKey, resolveText, collapsible, collapsed, onToggle }) => {
  if (!labelKey)
    return null;
  return /* @__PURE__ */ jsx_dev_runtime47.jsxDEV("h4", {
    className: cn2("text-[11px] font-medium text-muted-foreground mb-1", collapsible && "cursor-pointer flex items-center justify-between"),
    onClick: collapsible ? onToggle : undefined,
    children: [
      resolveText(labelKey, labelKey),
      collapsible && /* @__PURE__ */ jsx_dev_runtime47.jsxDEV(ChevronDown, {
        size: 14,
        className: cn2("transition-transform", collapsed && "-rotate-90")
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
var SectionCard = ({ section, node, onChange, resolveText, customRenderers }) => {
  const [collapsed, setCollapsed] = import_react23.default.useState(section.defaultCollapsed ?? false);
  const widgets = section.widgets.map((ref) => {
    if (typeof ref === "string") {
      return WIDGET_PRESETS[ref];
    }
    return ref;
  }).filter(Boolean);
  const visibleWidgets = widgets.filter((w2) => !w2.condition || w2.condition(node));
  if (visibleWidgets.length === 0)
    return null;
  return /* @__PURE__ */ jsx_dev_runtime47.jsxDEV("div", {
    className: "mb-2",
    children: [
      /* @__PURE__ */ jsx_dev_runtime47.jsxDEV(SectionHeader, {
        labelKey: section.labelKey,
        resolveText,
        collapsible: section.collapsible,
        collapsed,
        onToggle: () => setCollapsed(!collapsed)
      }, undefined, false, undefined, this),
      !collapsed && /* @__PURE__ */ jsx_dev_runtime47.jsxDEV("div", {
        className: cn2("w-full", section.grid && "grid", section.grid && `gap-${section.grid.gap ?? 2}`),
        style: section.grid ? { gridTemplateColumns: `repeat(${section.grid.cols}, 1fr)` } : undefined,
        children: visibleWidgets.map((widget, i3) => /* @__PURE__ */ jsx_dev_runtime47.jsxDEV("div", {
          className: "w-full",
          style: widget.colSpan ? { gridColumn: `span ${widget.colSpan}` } : undefined,
          children: renderWidget(widget, node, onChange, resolveText, customRenderers)
        }, `${section.id}-widget-${i3}`, false, undefined, this))
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
var PanelHeader = ({ labelKey, resolveText }) => {
  return /* @__PURE__ */ jsx_dev_runtime47.jsxDEV("div", {
    className: "flex justify-end mb-1",
    children: /* @__PURE__ */ jsx_dev_runtime47.jsxDEV("span", {
      className: "px-2 py-0.5 text-xs bg-accent text-accent-foreground rounded-full",
      children: resolveText(labelKey, labelKey)
    }, undefined, false, undefined, this)
  }, undefined, false, undefined, this);
};
var DeleteButton = ({ onClick, resolveText }) => /* @__PURE__ */ jsx_dev_runtime47.jsxDEV("div", {
  className: "mt-4 pt-4 border-t border-border",
  children: /* @__PURE__ */ jsx_dev_runtime47.jsxDEV("button", {
    onClick,
    className: "w-full py-1 text-xs text-red-500 hover:text-red-700 border border-red-200 hover:bg-red-50 rounded",
    children: resolveText("delete", "Delete")
  }, undefined, false, undefined, this)
}, undefined, false, undefined, this);
var UnifiedPropertyPanel = ({
  config,
  selectedNode,
  onChange,
  onDelete,
  i18nOverrides,
  customRenderers: externalCustomRenderers,
  emptyStateContent,
  className
}) => {
  const { t: t2 } = useI18n();
  const resolveText = (key, fallback) => {
    if (i18nOverrides?.[key])
      return i18nOverrides[key];
    return t2(key, fallback ?? key);
  };
  const builtInCustomRenderers = {
    deleteButton: ({ node }) => onDelete ? /* @__PURE__ */ jsx_dev_runtime47.jsxDEV(DeleteButton, {
      onClick: () => onDelete(node.id),
      resolveText
    }, undefined, false, undefined, this) : null
  };
  const customRenderers = { ...builtInCustomRenderers, ...externalCustomRenderers };
  const handleChange = (updates, options2) => {
    if (selectedNode) {
      const finalUpdates = selectedNode.t === "text" ? applyTextLayoutUpdates(selectedNode, updates) : updates;
      onChange(selectedNode.id, finalUpdates, options2);
    }
  };
  if (!selectedNode) {
    return emptyStateContent ? /* @__PURE__ */ jsx_dev_runtime47.jsxDEV("div", {
      className: cn2("bg-secondary border-l border-border p-4 overflow-y-auto", className),
      style: { width: config.layout.width },
      children: emptyStateContent
    }, undefined, false, undefined, this) : null;
  }
  const objectConfig = getObjectConfig(config, selectedNode);
  const objectSections = (objectConfig?.sections ?? []).map((ref) => {
    if (typeof ref === "string") {
      return SECTION_PRESETS[ref];
    }
    return ref;
  }).filter(Boolean);
  const defaultSections = config.defaultSections.map((ref) => {
    if (typeof ref === "string") {
      return SECTION_PRESETS[ref];
    }
    return ref;
  }).filter(Boolean);
  const visibleObjectSections = objectSections.filter((s2) => !s2.condition || s2.condition(selectedNode));
  const visibleDefaultSections = defaultSections.filter((s2) => !s2.condition || s2.condition(selectedNode));
  const deleteSections = visibleDefaultSections.filter((s2) => s2.id === "common-delete");
  const nonDeleteDefaultSections = visibleDefaultSections.filter((s2) => s2.id !== "common-delete");
  return /* @__PURE__ */ jsx_dev_runtime47.jsxDEV("div", {
    className: cn2("w-full bg-secondary overflow-x-hidden overflow-y-auto text-foreground px-2 py-1", className),
    children: [
      objectConfig?.header && /* @__PURE__ */ jsx_dev_runtime47.jsxDEV(PanelHeader, {
        iconName: objectConfig.header.iconName,
        labelKey: objectConfig.header.labelKey,
        resolveText
      }, undefined, false, undefined, this),
      visibleObjectSections.map((section) => /* @__PURE__ */ jsx_dev_runtime47.jsxDEV(SectionCard, {
        section,
        node: selectedNode,
        onChange: handleChange,
        resolveText,
        customRenderers
      }, section.id, false, undefined, this)),
      nonDeleteDefaultSections.map((section) => /* @__PURE__ */ jsx_dev_runtime47.jsxDEV(SectionCard, {
        section,
        node: selectedNode,
        onChange: handleChange,
        resolveText,
        customRenderers
      }, section.id, false, undefined, this)),
      deleteSections.map((section) => /* @__PURE__ */ jsx_dev_runtime47.jsxDEV(SectionCard, {
        section,
        node: selectedNode,
        onChange: handleChange,
        resolveText,
        customRenderers
      }, section.id, false, undefined, this))
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/bed-layout-editor/components/PropertyPanel/PropertyPanel.tsx
var jsx_dev_runtime48 = __toESM(require_jsx_dev_runtime(), 1);
var FIBONACCI_GRID_SIZES = [2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377];
var labelClass = "block text-[13px] text-muted-foreground mb-0.5";
var inputClass = "w-full px-1.5 py-1 border border-border rounded text-[13px] bg-background text-foreground focus:outline-none focus:ring-1 focus:ring-ring";
var CanvasSettingsPanel = ({
  document: document2,
  onDocumentChange,
  surfaceId,
  showGrid,
  onShowGridChange,
  gridSize,
  onGridSizeChange,
  snapStrength,
  onSnapStrengthChange,
  resolveText
}) => {
  const { t: t2 } = useI18n();
  const resolvedSurfaceId = surfaceId || document2?.surfaces.find((s2) => s2.type === "canvas")?.id || document2?.surfaces[0]?.id || "layout";
  const surface = document2?.surfaces.find((s2) => s2.id === resolvedSurfaceId) || document2?.surfaces[0];
  const updateSurface = (patch) => {
    if (!document2 || !onDocumentChange || !surface)
      return;
    onDocumentChange({
      ...document2,
      surfaces: document2.surfaces.map((s2) => s2.id === surface.id ? { ...s2, ...patch } : s2)
    });
  };
  return /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("div", {
    className: "w-64 bg-secondary px-2 py-1 overflow-x-hidden overflow-y-auto text-foreground",
    children: [
      document2 && onDocumentChange && surface && /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("div", {
        className: "mb-3",
        children: [
          /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("h4", {
            className: "text-[13px] font-medium text-muted-foreground mb-1",
            children: resolveText("properties_layout", "Canvas")
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("div", {
            className: "grid grid-cols-2 gap-1",
            children: [
              /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("div", {
                children: [
                  /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("label", {
                    className: labelClass,
                    children: resolveText("properties_width", "W")
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("input", {
                    type: "number",
                    value: surface.w,
                    onChange: (e2) => updateSurface({ w: Number(e2.target.value) }),
                    className: inputClass
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("div", {
                children: [
                  /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("label", {
                    className: labelClass,
                    children: resolveText("properties_height", "H")
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("input", {
                    type: "number",
                    value: surface.h,
                    onChange: (e2) => updateSurface({ h: Number(e2.target.value) }),
                    className: inputClass
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      onShowGridChange && /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("div", {
        className: "mb-3",
        children: [
          /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("div", {
            className: "flex items-center justify-between mb-1",
            children: [
              /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("label", {
                className: "text-[13px] text-muted-foreground",
                children: t2("settings_show_grid", "Grid")
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("input", {
                type: "checkbox",
                checked: showGrid ?? false,
                onChange: (e2) => onShowGridChange(e2.target.checked),
                className: "h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          showGrid && onGridSizeChange && /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("div", {
            children: [
              /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("label", {
                className: labelClass,
                children: t2("settings_grid_size", "Size")
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("select", {
                value: gridSize ?? 13,
                onChange: (e2) => onGridSizeChange(Number(e2.target.value)),
                className: inputClass,
                children: FIBONACCI_GRID_SIZES.map((size4) => /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("option", {
                  value: size4,
                  children: [
                    size4,
                    "pt"
                  ]
                }, size4, true, undefined, this))
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      onSnapStrengthChange && /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("div", {
        className: "mb-3",
        children: /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("div", {
          className: "flex items-center justify-between",
          children: [
            /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("label", {
              className: "text-[13px] text-muted-foreground",
              children: t2("settings_snap_to_grid", "Snap to Grid")
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("input", {
              type: "checkbox",
              checked: (snapStrength ?? 0) > 0,
              onChange: (e2) => onSnapStrengthChange(e2.target.checked ? gridSize ?? 15 : 0),
              className: "h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
var PropertyPanel = ({
  selectedElement,
  onChange,
  onDelete,
  document: document2,
  onDocumentChange,
  surfaceId,
  i18nOverrides,
  showGrid,
  onShowGridChange,
  gridSize,
  onGridSizeChange,
  snapStrength,
  onSnapStrengthChange
}) => {
  const resolveText = (key, fallback) => {
    if (i18nOverrides?.[key])
      return i18nOverrides[key];
    return fallback ?? key;
  };
  if (!selectedElement) {
    return /* @__PURE__ */ jsx_dev_runtime48.jsxDEV(CanvasSettingsPanel, {
      document: document2,
      onDocumentChange,
      surfaceId,
      showGrid,
      onShowGridChange,
      gridSize,
      onGridSizeChange,
      snapStrength,
      onSnapStrengthChange,
      resolveText
    }, undefined, false, undefined, this);
  }
  const customRenderers = {
    deleteButton: ({ node }) => /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("div", {
      className: "mt-2 pt-2 border-t border-border",
      children: /* @__PURE__ */ jsx_dev_runtime48.jsxDEV("button", {
        onClick: () => onDelete(node.id),
        className: "w-full py-1 text-xs text-red-500 hover:text-red-700 border border-red-200 hover:bg-red-50 rounded",
        children: resolveText("delete", "Delete")
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this)
  };
  return /* @__PURE__ */ jsx_dev_runtime48.jsxDEV(UnifiedPropertyPanel, {
    config: BED_LAYOUT_PANEL_CONFIG,
    selectedNode: selectedElement,
    onChange,
    onDelete,
    i18nOverrides,
    customRenderers
  }, undefined, false, undefined, this);
};
// ../../node_modules/.pnpm/@radix-ui+react-dropdown-menu@2.1.16_@types+react-dom@19.2.3_@types+react@19.2.7__@type_9ae99dbb567afdb87068bf276cfbb7a7/node_modules/@radix-ui/react-dropdown-menu/dist/index.mjs
var React42 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/@radix-ui+react-menu@2.1.16_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@1_29de2434e7d88997dbc2ca0d34462146/node_modules/@radix-ui/react-menu/dist/index.mjs
var React41 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/@radix-ui+react-collection@1.1.7_@types+react-dom@19.2.3_@types+react@19.2.7__@types+re_51f38897cc3aa0a11933866657bdcfb1/node_modules/@radix-ui/react-collection/dist/index.mjs
var import_react24 = __toESM(require_react(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react25 = __toESM(require_react(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
"use client";
function createCollection(name) {
  const PROVIDER_NAME = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map });
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = import_react24.default.useRef(null);
    const itemMap = import_react24.default.useRef(/* @__PURE__ */ new Map).current;
    return /* @__PURE__ */ import_jsx_runtime11.jsx(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = createSlot2(COLLECTION_SLOT_NAME);
  const CollectionSlot = import_react24.default.forwardRef((props, forwardedRef) => {
    const { scope, children } = props;
    const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
    const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
    return /* @__PURE__ */ import_jsx_runtime11.jsx(CollectionSlotImpl, { ref: composedRefs, children });
  });
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = createSlot2(ITEM_SLOT_NAME);
  const CollectionItemSlot = import_react24.default.forwardRef((props, forwardedRef) => {
    const { scope, children, ...itemData } = props;
    const ref = import_react24.default.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const context = useCollectionContext(ITEM_SLOT_NAME, scope);
    import_react24.default.useEffect(() => {
      context.itemMap.set(ref, { ref, ...itemData });
      return () => void context.itemMap.delete(ref);
    });
    return /* @__PURE__ */ import_jsx_runtime11.jsx(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
  });
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = import_react24.default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode)
        return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort((a3, b3) => orderedNodes.indexOf(a3.ref.current) - orderedNodes.indexOf(b3.ref.current));
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection,
    createCollectionScope
  ];
}
var __instanciated = /* @__PURE__ */ new WeakMap;
var OrderedDict = class _OrderedDict extends Map {
  #keys;
  constructor(entries) {
    super(entries);
    this.#keys = [...super.keys()];
    __instanciated.set(this, true);
  }
  set(key, value) {
    if (__instanciated.get(this)) {
      if (this.has(key)) {
        this.#keys[this.#keys.indexOf(key)] = key;
      } else {
        this.#keys.push(key);
      }
    }
    super.set(key, value);
    return this;
  }
  insert(index2, key, value) {
    const has = this.has(key);
    const length = this.#keys.length;
    const relativeIndex = toSafeInteger(index2);
    let actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
    const safeIndex = actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;
    if (safeIndex === this.size || has && safeIndex === this.size - 1 || safeIndex === -1) {
      this.set(key, value);
      return this;
    }
    const size4 = this.size + (has ? 0 : 1);
    if (relativeIndex < 0) {
      actualIndex++;
    }
    const keys = [...this.#keys];
    let nextValue;
    let shouldSkip = false;
    for (let i3 = actualIndex;i3 < size4; i3++) {
      if (actualIndex === i3) {
        let nextKey = keys[i3];
        if (keys[i3] === key) {
          nextKey = keys[i3 + 1];
        }
        if (has) {
          this.delete(key);
        }
        nextValue = this.get(nextKey);
        this.set(key, value);
      } else {
        if (!shouldSkip && keys[i3 - 1] === key) {
          shouldSkip = true;
        }
        const currentKey = keys[shouldSkip ? i3 : i3 - 1];
        const currentValue = nextValue;
        nextValue = this.get(currentKey);
        this.delete(currentKey);
        this.set(currentKey, currentValue);
      }
    }
    return this;
  }
  with(index2, key, value) {
    const copy = new _OrderedDict(this);
    copy.insert(index2, key, value);
    return copy;
  }
  before(key) {
    const index2 = this.#keys.indexOf(key) - 1;
    if (index2 < 0) {
      return;
    }
    return this.entryAt(index2);
  }
  setBefore(key, newKey, value) {
    const index2 = this.#keys.indexOf(key);
    if (index2 === -1) {
      return this;
    }
    return this.insert(index2, newKey, value);
  }
  after(key) {
    let index2 = this.#keys.indexOf(key);
    index2 = index2 === -1 || index2 === this.size - 1 ? -1 : index2 + 1;
    if (index2 === -1) {
      return;
    }
    return this.entryAt(index2);
  }
  setAfter(key, newKey, value) {
    const index2 = this.#keys.indexOf(key);
    if (index2 === -1) {
      return this;
    }
    return this.insert(index2 + 1, newKey, value);
  }
  first() {
    return this.entryAt(0);
  }
  last() {
    return this.entryAt(-1);
  }
  clear() {
    this.#keys = [];
    return super.clear();
  }
  delete(key) {
    const deleted = super.delete(key);
    if (deleted) {
      this.#keys.splice(this.#keys.indexOf(key), 1);
    }
    return deleted;
  }
  deleteAt(index2) {
    const key = this.keyAt(index2);
    if (key !== undefined) {
      return this.delete(key);
    }
    return false;
  }
  at(index2) {
    const key = at(this.#keys, index2);
    if (key !== undefined) {
      return this.get(key);
    }
  }
  entryAt(index2) {
    const key = at(this.#keys, index2);
    if (key !== undefined) {
      return [key, this.get(key)];
    }
  }
  indexOf(key) {
    return this.#keys.indexOf(key);
  }
  keyAt(index2) {
    return at(this.#keys, index2);
  }
  from(key, offset4) {
    const index2 = this.indexOf(key);
    if (index2 === -1) {
      return;
    }
    let dest = index2 + offset4;
    if (dest < 0)
      dest = 0;
    if (dest >= this.size)
      dest = this.size - 1;
    return this.at(dest);
  }
  keyFrom(key, offset4) {
    const index2 = this.indexOf(key);
    if (index2 === -1) {
      return;
    }
    let dest = index2 + offset4;
    if (dest < 0)
      dest = 0;
    if (dest >= this.size)
      dest = this.size - 1;
    return this.keyAt(dest);
  }
  find(predicate, thisArg) {
    let index2 = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        return entry;
      }
      index2++;
    }
    return;
  }
  findIndex(predicate, thisArg) {
    let index2 = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        return index2;
      }
      index2++;
    }
    return -1;
  }
  filter(predicate, thisArg) {
    const entries = [];
    let index2 = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        entries.push(entry);
      }
      index2++;
    }
    return new _OrderedDict(entries);
  }
  map(callbackfn, thisArg) {
    const entries = [];
    let index2 = 0;
    for (const entry of this) {
      entries.push([entry[0], Reflect.apply(callbackfn, thisArg, [entry, index2, this])]);
      index2++;
    }
    return new _OrderedDict(entries);
  }
  reduce(...args) {
    const [callbackfn, initialValue] = args;
    let index2 = 0;
    let accumulator = initialValue ?? this.at(0);
    for (const entry of this) {
      if (index2 === 0 && args.length === 1) {
        accumulator = entry;
      } else {
        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index2, this]);
      }
      index2++;
    }
    return accumulator;
  }
  reduceRight(...args) {
    const [callbackfn, initialValue] = args;
    let accumulator = initialValue ?? this.at(-1);
    for (let index2 = this.size - 1;index2 >= 0; index2--) {
      const entry = this.at(index2);
      if (index2 === this.size - 1 && args.length === 1) {
        accumulator = entry;
      } else {
        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index2, this]);
      }
    }
    return accumulator;
  }
  toSorted(compareFn) {
    const entries = [...this.entries()].sort(compareFn);
    return new _OrderedDict(entries);
  }
  toReversed() {
    const reversed = new _OrderedDict;
    for (let index2 = this.size - 1;index2 >= 0; index2--) {
      const key = this.keyAt(index2);
      const element = this.get(key);
      reversed.set(key, element);
    }
    return reversed;
  }
  toSpliced(...args) {
    const entries = [...this.entries()];
    entries.splice(...args);
    return new _OrderedDict(entries);
  }
  slice(start, end) {
    const result = new _OrderedDict;
    let stop = this.size - 1;
    if (start === undefined) {
      return result;
    }
    if (start < 0) {
      start = start + this.size;
    }
    if (end !== undefined && end > 0) {
      stop = end - 1;
    }
    for (let index2 = start;index2 <= stop; index2++) {
      const key = this.keyAt(index2);
      const element = this.get(key);
      result.set(key, element);
    }
    return result;
  }
  every(predicate, thisArg) {
    let index2 = 0;
    for (const entry of this) {
      if (!Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        return false;
      }
      index2++;
    }
    return true;
  }
  some(predicate, thisArg) {
    let index2 = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        return true;
      }
      index2++;
    }
    return false;
  }
};
function at(array, index2) {
  if ("at" in Array.prototype) {
    return Array.prototype.at.call(array, index2);
  }
  const actualIndex = toSafeIndex(array, index2);
  return actualIndex === -1 ? undefined : array[actualIndex];
}
function toSafeIndex(array, index2) {
  const length = array.length;
  const relativeIndex = toSafeInteger(index2);
  const actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
  return actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;
}
function toSafeInteger(number) {
  return number !== number || number === 0 ? 0 : Math.trunc(number);
}

// ../../node_modules/.pnpm/@radix-ui+react-direction@1.1.1_@types+react@19.2.7_react@19.2.3/node_modules/@radix-ui/react-direction/dist/index.mjs
var React39 = __toESM(require_react(), 1);
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var DirectionContext = React39.createContext(undefined);
function useDirection(localDir) {
  const globalDir = React39.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}

// ../../node_modules/.pnpm/@radix-ui+react-roving-focus@1.1.11_@types+react-dom@19.2.3_@types+react@19.2.7__@types_15baa560c953bc49315682e94c801f68/node_modules/@radix-ui/react-roving-focus/dist/index.mjs
var React40 = __toESM(require_react(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
"use client";
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS2 = { bubbles: false, cancelable: true };
var GROUP_NAME = "RovingFocusGroup";
var [Collection, useCollection, createCollectionScope] = createCollection(GROUP_NAME);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(GROUP_NAME, [createCollectionScope]);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);
var RovingFocusGroup = React40.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ import_jsx_runtime14.jsx(Collection.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ import_jsx_runtime14.jsx(Collection.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ import_jsx_runtime14.jsx(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
});
RovingFocusGroup.displayName = GROUP_NAME;
var RovingFocusGroupImpl = React40.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = React40.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId ?? null,
    onChange: onCurrentTabStopIdChange,
    caller: GROUP_NAME
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React40.useState(false);
  const handleEntryFocus = useCallbackRef(onEntryFocus);
  const getItems = useCollection(__scopeRovingFocusGroup);
  const isClickFocusRef = React40.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React40.useState(0);
  React40.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ import_jsx_runtime14.jsx(RovingFocusProvider, {
    scope: __scopeRovingFocusGroup,
    orientation,
    dir: direction,
    loop,
    currentTabStopId,
    onItemFocus: React40.useCallback((tabStopId) => setCurrentTabStopId(tabStopId), [setCurrentTabStopId]),
    onItemShiftTab: React40.useCallback(() => setIsTabbingBackOut(true), []),
    onFocusableItemAdd: React40.useCallback(() => setFocusableItemsCount((prevCount) => prevCount + 1), []),
    onFocusableItemRemove: React40.useCallback(() => setFocusableItemsCount((prevCount) => prevCount - 1), []),
    children: /* @__PURE__ */ import_jsx_runtime14.jsx(Primitive.div, {
      tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
      "data-orientation": orientation,
      ...groupProps,
      ref: composedRefs,
      style: { outline: "none", ...props.style },
      onMouseDown: composeEventHandlers(props.onMouseDown, () => {
        isClickFocusRef.current = true;
      }),
      onFocus: composeEventHandlers(props.onFocus, (event) => {
        const isKeyboardFocus = !isClickFocusRef.current;
        if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
          const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS2);
          event.currentTarget.dispatchEvent(entryFocusEvent);
          if (!entryFocusEvent.defaultPrevented) {
            const items = getItems().filter((item) => item.focusable);
            const activeItem = items.find((item) => item.active);
            const currentItem = items.find((item) => item.id === currentTabStopId);
            const candidateItems = [activeItem, currentItem, ...items].filter(Boolean);
            const candidateNodes = candidateItems.map((item) => item.ref.current);
            focusFirst2(candidateNodes, preventScrollOnEntryFocus);
          }
        }
        isClickFocusRef.current = false;
      }),
      onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
    })
  });
});
var ITEM_NAME = "RovingFocusGroupItem";
var RovingFocusGroupItem = React40.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    focusable = true,
    active = false,
    tabStopId,
    children,
    ...itemProps
  } = props;
  const autoId = useId2();
  const id = tabStopId || autoId;
  const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);
  const isCurrentTabStop = context.currentTabStopId === id;
  const getItems = useCollection(__scopeRovingFocusGroup);
  const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;
  React40.useEffect(() => {
    if (focusable) {
      onFocusableItemAdd();
      return () => onFocusableItemRemove();
    }
  }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
  return /* @__PURE__ */ import_jsx_runtime14.jsx(Collection.ItemSlot, {
    scope: __scopeRovingFocusGroup,
    id,
    focusable,
    active,
    children: /* @__PURE__ */ import_jsx_runtime14.jsx(Primitive.span, {
      tabIndex: isCurrentTabStop ? 0 : -1,
      "data-orientation": context.orientation,
      ...itemProps,
      ref: forwardedRef,
      onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
        if (!focusable)
          event.preventDefault();
        else
          context.onItemFocus(id);
      }),
      onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id)),
      onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
        if (event.key === "Tab" && event.shiftKey) {
          context.onItemShiftTab();
          return;
        }
        if (event.target !== event.currentTarget)
          return;
        const focusIntent = getFocusIntent(event, context.orientation, context.dir);
        if (focusIntent !== undefined) {
          if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey)
            return;
          event.preventDefault();
          const items = getItems().filter((item) => item.focusable);
          let candidateNodes = items.map((item) => item.ref.current);
          if (focusIntent === "last")
            candidateNodes.reverse();
          else if (focusIntent === "prev" || focusIntent === "next") {
            if (focusIntent === "prev")
              candidateNodes.reverse();
            const currentIndex = candidateNodes.indexOf(event.currentTarget);
            candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
          }
          setTimeout(() => focusFirst2(candidateNodes));
        }
      }),
      children: typeof children === "function" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children
    })
  });
});
RovingFocusGroupItem.displayName = ITEM_NAME;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl")
    return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key))
    return;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key))
    return;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst2(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
var Root3 = RovingFocusGroup;
var Item = RovingFocusGroupItem;

// ../../node_modules/.pnpm/@radix-ui+react-menu@2.1.16_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@1_29de2434e7d88997dbc2ca0d34462146/node_modules/@radix-ui/react-menu/dist/index.mjs
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
"use client";
var SELECTION_KEYS = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME = "Menu";
var [Collection2, useCollection2, createCollectionScope2] = createCollection(MENU_NAME);
var [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [
  createCollectionScope2,
  createPopperScope,
  createRovingFocusGroupScope
]);
var usePopperScope2 = createPopperScope();
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);
var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);
var Menu = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = usePopperScope2(__scopeMenu);
  const [content, setContent] = React41.useState(null);
  const isUsingKeyboardRef = React41.useRef(false);
  const handleOpenChange = useCallbackRef(onOpenChange);
  const direction = useDirection(dir);
  React41.useEffect(() => {
    const handleKeyDown = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return /* @__PURE__ */ import_jsx_runtime15.jsx(Root2, { ...popperScope, children: /* @__PURE__ */ import_jsx_runtime15.jsx(MenuProvider, {
    scope: __scopeMenu,
    open,
    onOpenChange: handleOpenChange,
    content,
    onContentChange: setContent,
    children: /* @__PURE__ */ import_jsx_runtime15.jsx(MenuRootProvider, {
      scope: __scopeMenu,
      onClose: React41.useCallback(() => handleOpenChange(false), [handleOpenChange]),
      isUsingKeyboardRef,
      dir: direction,
      modal,
      children
    })
  }) });
};
Menu.displayName = MENU_NAME;
var ANCHOR_NAME3 = "MenuAnchor";
var MenuAnchor = React41.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...anchorProps } = props;
  const popperScope = usePopperScope2(__scopeMenu);
  return /* @__PURE__ */ import_jsx_runtime15.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
});
MenuAnchor.displayName = ANCHOR_NAME3;
var PORTAL_NAME3 = "MenuPortal";
var [PortalProvider2, usePortalContext2] = createMenuContext(PORTAL_NAME3, {
  forceMount: undefined
});
var MenuPortal = (props) => {
  const { __scopeMenu, forceMount, children, container } = props;
  const context = useMenuContext(PORTAL_NAME3, __scopeMenu);
  return /* @__PURE__ */ import_jsx_runtime15.jsx(PortalProvider2, { scope: __scopeMenu, forceMount, children: /* @__PURE__ */ import_jsx_runtime15.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ import_jsx_runtime15.jsx(Portal, { asChild: true, container, children }) }) });
};
MenuPortal.displayName = PORTAL_NAME3;
var CONTENT_NAME3 = "MenuContent";
var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME3);
var MenuContent = React41.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext2(CONTENT_NAME3, props.__scopeMenu);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = useMenuContext(CONTENT_NAME3, props.__scopeMenu);
  const rootContext = useMenuRootContext(CONTENT_NAME3, props.__scopeMenu);
  return /* @__PURE__ */ import_jsx_runtime15.jsx(Collection2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ import_jsx_runtime15.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ import_jsx_runtime15.jsx(Collection2.Slot, { scope: props.__scopeMenu, children: rootContext.modal ? /* @__PURE__ */ import_jsx_runtime15.jsx(MenuRootContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ import_jsx_runtime15.jsx(MenuRootContentNonModal, { ...contentProps, ref: forwardedRef }) }) }) });
});
var MenuRootContentModal = React41.forwardRef((props, forwardedRef) => {
  const context = useMenuContext(CONTENT_NAME3, props.__scopeMenu);
  const ref = React41.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React41.useEffect(() => {
    const content = ref.current;
    if (content)
      return hideOthers(content);
  }, []);
  return /* @__PURE__ */ import_jsx_runtime15.jsx(MenuContentImpl, {
    ...props,
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: context.open,
    disableOutsideScroll: true,
    onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => event.preventDefault(), { checkForDefaultPrevented: false }),
    onDismiss: () => context.onOpenChange(false)
  });
});
var MenuRootContentNonModal = React41.forwardRef((props, forwardedRef) => {
  const context = useMenuContext(CONTENT_NAME3, props.__scopeMenu);
  return /* @__PURE__ */ import_jsx_runtime15.jsx(MenuContentImpl, {
    ...props,
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    disableOutsideScroll: false,
    onDismiss: () => context.onOpenChange(false)
  });
});
var Slot3 = createSlot2("MenuContent.ScrollLock");
var MenuContentImpl = React41.forwardRef((props, forwardedRef) => {
  const {
    __scopeMenu,
    loop = false,
    trapFocus,
    onOpenAutoFocus,
    onCloseAutoFocus,
    disableOutsidePointerEvents,
    onEntryFocus,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    onDismiss,
    disableOutsideScroll,
    ...contentProps
  } = props;
  const context = useMenuContext(CONTENT_NAME3, __scopeMenu);
  const rootContext = useMenuRootContext(CONTENT_NAME3, __scopeMenu);
  const popperScope = usePopperScope2(__scopeMenu);
  const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);
  const getItems = useCollection2(__scopeMenu);
  const [currentItemId, setCurrentItemId] = React41.useState(null);
  const contentRef = React41.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);
  const timerRef = React41.useRef(0);
  const searchRef = React41.useRef("");
  const pointerGraceTimerRef = React41.useRef(0);
  const pointerGraceIntentRef = React41.useRef(null);
  const pointerDirRef = React41.useRef("right");
  const lastPointerXRef = React41.useRef(0);
  const ScrollLockWrapper = disableOutsideScroll ? Combination_default : React41.Fragment;
  const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot3, allowPinchZoom: true } : undefined;
  const handleTypeaheadSearch = (key) => {
    const search = searchRef.current + key;
    const items = getItems().filter((item) => !item.disabled);
    const currentItem = document.activeElement;
    const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;
    const values = items.map((item) => item.textValue);
    const nextMatch = getNextMatch(values, search, currentMatch);
    const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;
    (function updateSearch(value) {
      searchRef.current = value;
      window.clearTimeout(timerRef.current);
      if (value !== "")
        timerRef.current = window.setTimeout(() => updateSearch(""), 1000);
    })(search);
    if (newItem) {
      setTimeout(() => newItem.focus());
    }
  };
  React41.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  useFocusGuards();
  const isPointerMovingToSubmenu = React41.useCallback((event) => {
    const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;
    return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);
  }, []);
  return /* @__PURE__ */ import_jsx_runtime15.jsx(MenuContentProvider, {
    scope: __scopeMenu,
    searchRef,
    onItemEnter: React41.useCallback((event) => {
      if (isPointerMovingToSubmenu(event))
        event.preventDefault();
    }, [isPointerMovingToSubmenu]),
    onItemLeave: React41.useCallback((event) => {
      if (isPointerMovingToSubmenu(event))
        return;
      contentRef.current?.focus();
      setCurrentItemId(null);
    }, [isPointerMovingToSubmenu]),
    onTriggerLeave: React41.useCallback((event) => {
      if (isPointerMovingToSubmenu(event))
        event.preventDefault();
    }, [isPointerMovingToSubmenu]),
    pointerGraceTimerRef,
    onPointerGraceIntentChange: React41.useCallback((intent) => {
      pointerGraceIntentRef.current = intent;
    }, []),
    children: /* @__PURE__ */ import_jsx_runtime15.jsx(ScrollLockWrapper, { ...scrollLockWrapperProps, children: /* @__PURE__ */ import_jsx_runtime15.jsx(FocusScope, {
      asChild: true,
      trapped: trapFocus,
      onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, (event) => {
        event.preventDefault();
        contentRef.current?.focus({ preventScroll: true });
      }),
      onUnmountAutoFocus: onCloseAutoFocus,
      children: /* @__PURE__ */ import_jsx_runtime15.jsx(DismissableLayer, {
        asChild: true,
        disableOutsidePointerEvents,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside,
        onInteractOutside,
        onDismiss,
        children: /* @__PURE__ */ import_jsx_runtime15.jsx(Root3, {
          asChild: true,
          ...rovingFocusGroupScope,
          dir: rootContext.dir,
          orientation: "vertical",
          loop,
          currentTabStopId: currentItemId,
          onCurrentTabStopIdChange: setCurrentItemId,
          onEntryFocus: composeEventHandlers(onEntryFocus, (event) => {
            if (!rootContext.isUsingKeyboardRef.current)
              event.preventDefault();
          }),
          preventScrollOnEntryFocus: true,
          children: /* @__PURE__ */ import_jsx_runtime15.jsx(Content, {
            role: "menu",
            "aria-orientation": "vertical",
            "data-state": getOpenState(context.open),
            "data-radix-menu-content": "",
            dir: rootContext.dir,
            ...popperScope,
            ...contentProps,
            ref: composedRefs,
            style: { outline: "none", ...contentProps.style },
            onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
              const target = event.target;
              const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
              const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
              const isCharacterKey = event.key.length === 1;
              if (isKeyDownInside) {
                if (event.key === "Tab")
                  event.preventDefault();
                if (!isModifierKey && isCharacterKey)
                  handleTypeaheadSearch(event.key);
              }
              const content = contentRef.current;
              if (event.target !== content)
                return;
              if (!FIRST_LAST_KEYS.includes(event.key))
                return;
              event.preventDefault();
              const items = getItems().filter((item) => !item.disabled);
              const candidateNodes = items.map((item) => item.ref.current);
              if (LAST_KEYS.includes(event.key))
                candidateNodes.reverse();
              focusFirst3(candidateNodes);
            }),
            onBlur: composeEventHandlers(props.onBlur, (event) => {
              if (!event.currentTarget.contains(event.target)) {
                window.clearTimeout(timerRef.current);
                searchRef.current = "";
              }
            }),
            onPointerMove: composeEventHandlers(props.onPointerMove, whenMouse((event) => {
              const target = event.target;
              const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
              if (event.currentTarget.contains(target) && pointerXHasChanged) {
                const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                pointerDirRef.current = newDir;
                lastPointerXRef.current = event.clientX;
              }
            }))
          })
        })
      })
    }) })
  });
});
MenuContent.displayName = CONTENT_NAME3;
var GROUP_NAME2 = "MenuGroup";
var MenuGroup = React41.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...groupProps } = props;
  return /* @__PURE__ */ import_jsx_runtime15.jsx(Primitive.div, { role: "group", ...groupProps, ref: forwardedRef });
});
MenuGroup.displayName = GROUP_NAME2;
var LABEL_NAME = "MenuLabel";
var MenuLabel = React41.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...labelProps } = props;
  return /* @__PURE__ */ import_jsx_runtime15.jsx(Primitive.div, { ...labelProps, ref: forwardedRef });
});
MenuLabel.displayName = LABEL_NAME;
var ITEM_NAME2 = "MenuItem";
var ITEM_SELECT = "menu.itemSelect";
var MenuItem = React41.forwardRef((props, forwardedRef) => {
  const { disabled = false, onSelect, ...itemProps } = props;
  const ref = React41.useRef(null);
  const rootContext = useMenuRootContext(ITEM_NAME2, props.__scopeMenu);
  const contentContext = useMenuContentContext(ITEM_NAME2, props.__scopeMenu);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const isPointerDownRef = React41.useRef(false);
  const handleSelect = () => {
    const menuItem = ref.current;
    if (!disabled && menuItem) {
      const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
      menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });
      dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);
      if (itemSelectEvent.defaultPrevented) {
        isPointerDownRef.current = false;
      } else {
        rootContext.onClose();
      }
    }
  };
  return /* @__PURE__ */ import_jsx_runtime15.jsx(MenuItemImpl, {
    ...itemProps,
    ref: composedRefs,
    disabled,
    onClick: composeEventHandlers(props.onClick, handleSelect),
    onPointerDown: (event) => {
      props.onPointerDown?.(event);
      isPointerDownRef.current = true;
    },
    onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
      if (!isPointerDownRef.current)
        event.currentTarget?.click();
    }),
    onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
      const isTypingAhead = contentContext.searchRef.current !== "";
      if (disabled || isTypingAhead && event.key === " ")
        return;
      if (SELECTION_KEYS.includes(event.key)) {
        event.currentTarget.click();
        event.preventDefault();
      }
    })
  });
});
MenuItem.displayName = ITEM_NAME2;
var MenuItemImpl = React41.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
  const contentContext = useMenuContentContext(ITEM_NAME2, __scopeMenu);
  const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);
  const ref = React41.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [isFocused, setIsFocused] = React41.useState(false);
  const [textContent, setTextContent] = React41.useState("");
  React41.useEffect(() => {
    const menuItem = ref.current;
    if (menuItem) {
      setTextContent((menuItem.textContent ?? "").trim());
    }
  }, [itemProps.children]);
  return /* @__PURE__ */ import_jsx_runtime15.jsx(Collection2.ItemSlot, {
    scope: __scopeMenu,
    disabled,
    textValue: textValue ?? textContent,
    children: /* @__PURE__ */ import_jsx_runtime15.jsx(Item, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: /* @__PURE__ */ import_jsx_runtime15.jsx(Primitive.div, {
      role: "menuitem",
      "data-highlighted": isFocused ? "" : undefined,
      "aria-disabled": disabled || undefined,
      "data-disabled": disabled ? "" : undefined,
      ...itemProps,
      ref: composedRefs,
      onPointerMove: composeEventHandlers(props.onPointerMove, whenMouse((event) => {
        if (disabled) {
          contentContext.onItemLeave(event);
        } else {
          contentContext.onItemEnter(event);
          if (!event.defaultPrevented) {
            const item = event.currentTarget;
            item.focus({ preventScroll: true });
          }
        }
      })),
      onPointerLeave: composeEventHandlers(props.onPointerLeave, whenMouse((event) => contentContext.onItemLeave(event))),
      onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),
      onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))
    }) })
  });
});
var CHECKBOX_ITEM_NAME = "MenuCheckboxItem";
var MenuCheckboxItem = React41.forwardRef((props, forwardedRef) => {
  const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
  return /* @__PURE__ */ import_jsx_runtime15.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ import_jsx_runtime15.jsx(MenuItem, {
    role: "menuitemcheckbox",
    "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
    ...checkboxItemProps,
    ref: forwardedRef,
    "data-state": getCheckedState(checked),
    onSelect: composeEventHandlers(checkboxItemProps.onSelect, () => onCheckedChange?.(isIndeterminate(checked) ? true : !checked), { checkForDefaultPrevented: false })
  }) });
});
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME = "MenuRadioGroup";
var [RadioGroupProvider, useRadioGroupContext] = createMenuContext(RADIO_GROUP_NAME, { value: undefined, onValueChange: () => {} });
var MenuRadioGroup = React41.forwardRef((props, forwardedRef) => {
  const { value, onValueChange, ...groupProps } = props;
  const handleValueChange = useCallbackRef(onValueChange);
  return /* @__PURE__ */ import_jsx_runtime15.jsx(RadioGroupProvider, { scope: props.__scopeMenu, value, onValueChange: handleValueChange, children: /* @__PURE__ */ import_jsx_runtime15.jsx(MenuGroup, { ...groupProps, ref: forwardedRef }) });
});
MenuRadioGroup.displayName = RADIO_GROUP_NAME;
var RADIO_ITEM_NAME = "MenuRadioItem";
var MenuRadioItem = React41.forwardRef((props, forwardedRef) => {
  const { value, ...radioItemProps } = props;
  const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);
  const checked = value === context.value;
  return /* @__PURE__ */ import_jsx_runtime15.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ import_jsx_runtime15.jsx(MenuItem, {
    role: "menuitemradio",
    "aria-checked": checked,
    ...radioItemProps,
    ref: forwardedRef,
    "data-state": getCheckedState(checked),
    onSelect: composeEventHandlers(radioItemProps.onSelect, () => context.onValueChange?.(value), { checkForDefaultPrevented: false })
  }) });
});
MenuRadioItem.displayName = RADIO_ITEM_NAME;
var ITEM_INDICATOR_NAME = "MenuItemIndicator";
var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(ITEM_INDICATOR_NAME, { checked: false });
var MenuItemIndicator = React41.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
  const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);
  return /* @__PURE__ */ import_jsx_runtime15.jsx(Presence, {
    present: forceMount || isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true,
    children: /* @__PURE__ */ import_jsx_runtime15.jsx(Primitive.span, {
      ...itemIndicatorProps,
      ref: forwardedRef,
      "data-state": getCheckedState(indicatorContext.checked)
    })
  });
});
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SEPARATOR_NAME = "MenuSeparator";
var MenuSeparator = React41.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...separatorProps } = props;
  return /* @__PURE__ */ import_jsx_runtime15.jsx(Primitive.div, {
    role: "separator",
    "aria-orientation": "horizontal",
    ...separatorProps,
    ref: forwardedRef
  });
});
MenuSeparator.displayName = SEPARATOR_NAME;
var ARROW_NAME3 = "MenuArrow";
var MenuArrow = React41.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...arrowProps } = props;
  const popperScope = usePopperScope2(__scopeMenu);
  return /* @__PURE__ */ import_jsx_runtime15.jsx(Arrow3, { ...popperScope, ...arrowProps, ref: forwardedRef });
});
MenuArrow.displayName = ARROW_NAME3;
var SUB_NAME = "MenuSub";
var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME);
var MenuSub = (props) => {
  const { __scopeMenu, children, open = false, onOpenChange } = props;
  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);
  const popperScope = usePopperScope2(__scopeMenu);
  const [trigger, setTrigger] = React41.useState(null);
  const [content, setContent] = React41.useState(null);
  const handleOpenChange = useCallbackRef(onOpenChange);
  React41.useEffect(() => {
    if (parentMenuContext.open === false)
      handleOpenChange(false);
    return () => handleOpenChange(false);
  }, [parentMenuContext.open, handleOpenChange]);
  return /* @__PURE__ */ import_jsx_runtime15.jsx(Root2, { ...popperScope, children: /* @__PURE__ */ import_jsx_runtime15.jsx(MenuProvider, {
    scope: __scopeMenu,
    open,
    onOpenChange: handleOpenChange,
    content,
    onContentChange: setContent,
    children: /* @__PURE__ */ import_jsx_runtime15.jsx(MenuSubProvider, {
      scope: __scopeMenu,
      contentId: useId2(),
      triggerId: useId2(),
      trigger,
      onTriggerChange: setTrigger,
      children
    })
  }) });
};
MenuSub.displayName = SUB_NAME;
var SUB_TRIGGER_NAME = "MenuSubTrigger";
var MenuSubTrigger = React41.forwardRef((props, forwardedRef) => {
  const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);
  const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props.__scopeMenu);
  const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props.__scopeMenu);
  const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);
  const openTimerRef = React41.useRef(null);
  const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
  const scope = { __scopeMenu: props.__scopeMenu };
  const clearOpenTimer = React41.useCallback(() => {
    if (openTimerRef.current)
      window.clearTimeout(openTimerRef.current);
    openTimerRef.current = null;
  }, []);
  React41.useEffect(() => clearOpenTimer, [clearOpenTimer]);
  React41.useEffect(() => {
    const pointerGraceTimer = pointerGraceTimerRef.current;
    return () => {
      window.clearTimeout(pointerGraceTimer);
      onPointerGraceIntentChange(null);
    };
  }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
  return /* @__PURE__ */ import_jsx_runtime15.jsx(MenuAnchor, { asChild: true, ...scope, children: /* @__PURE__ */ import_jsx_runtime15.jsx(MenuItemImpl, {
    id: subContext.triggerId,
    "aria-haspopup": "menu",
    "aria-expanded": context.open,
    "aria-controls": subContext.contentId,
    "data-state": getOpenState(context.open),
    ...props,
    ref: composeRefs(forwardedRef, subContext.onTriggerChange),
    onClick: (event) => {
      props.onClick?.(event);
      if (props.disabled || event.defaultPrevented)
        return;
      event.currentTarget.focus();
      if (!context.open)
        context.onOpenChange(true);
    },
    onPointerMove: composeEventHandlers(props.onPointerMove, whenMouse((event) => {
      contentContext.onItemEnter(event);
      if (event.defaultPrevented)
        return;
      if (!props.disabled && !context.open && !openTimerRef.current) {
        contentContext.onPointerGraceIntentChange(null);
        openTimerRef.current = window.setTimeout(() => {
          context.onOpenChange(true);
          clearOpenTimer();
        }, 100);
      }
    })),
    onPointerLeave: composeEventHandlers(props.onPointerLeave, whenMouse((event) => {
      clearOpenTimer();
      const contentRect = context.content?.getBoundingClientRect();
      if (contentRect) {
        const side = context.content?.dataset.side;
        const rightSide = side === "right";
        const bleed = rightSide ? -5 : 5;
        const contentNearEdge = contentRect[rightSide ? "left" : "right"];
        const contentFarEdge = contentRect[rightSide ? "right" : "left"];
        contentContext.onPointerGraceIntentChange({
          area: [
            { x: event.clientX + bleed, y: event.clientY },
            { x: contentNearEdge, y: contentRect.top },
            { x: contentFarEdge, y: contentRect.top },
            { x: contentFarEdge, y: contentRect.bottom },
            { x: contentNearEdge, y: contentRect.bottom }
          ],
          side
        });
        window.clearTimeout(pointerGraceTimerRef.current);
        pointerGraceTimerRef.current = window.setTimeout(() => contentContext.onPointerGraceIntentChange(null), 300);
      } else {
        contentContext.onTriggerLeave(event);
        if (event.defaultPrevented)
          return;
        contentContext.onPointerGraceIntentChange(null);
      }
    })),
    onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
      const isTypingAhead = contentContext.searchRef.current !== "";
      if (props.disabled || isTypingAhead && event.key === " ")
        return;
      if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
        context.onOpenChange(true);
        context.content?.focus();
        event.preventDefault();
      }
    })
  }) });
});
MenuSubTrigger.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "MenuSubContent";
var MenuSubContent = React41.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext2(CONTENT_NAME3, props.__scopeMenu);
  const { forceMount = portalContext.forceMount, ...subContentProps } = props;
  const context = useMenuContext(CONTENT_NAME3, props.__scopeMenu);
  const rootContext = useMenuRootContext(CONTENT_NAME3, props.__scopeMenu);
  const subContext = useMenuSubContext(SUB_CONTENT_NAME, props.__scopeMenu);
  const ref = React41.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  return /* @__PURE__ */ import_jsx_runtime15.jsx(Collection2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ import_jsx_runtime15.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ import_jsx_runtime15.jsx(Collection2.Slot, { scope: props.__scopeMenu, children: /* @__PURE__ */ import_jsx_runtime15.jsx(MenuContentImpl, {
    id: subContext.contentId,
    "aria-labelledby": subContext.triggerId,
    ...subContentProps,
    ref: composedRefs,
    align: "start",
    side: rootContext.dir === "rtl" ? "left" : "right",
    disableOutsidePointerEvents: false,
    disableOutsideScroll: false,
    trapFocus: false,
    onOpenAutoFocus: (event) => {
      if (rootContext.isUsingKeyboardRef.current)
        ref.current?.focus();
      event.preventDefault();
    },
    onCloseAutoFocus: (event) => event.preventDefault(),
    onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
      if (event.target !== subContext.trigger)
        context.onOpenChange(false);
    }),
    onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, (event) => {
      rootContext.onClose();
      event.preventDefault();
    }),
    onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
      const isKeyDownInside = event.currentTarget.contains(event.target);
      const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
      if (isKeyDownInside && isCloseKey) {
        context.onOpenChange(false);
        subContext.trigger?.focus();
        event.preventDefault();
      }
    })
  }) }) }) });
});
MenuSubContent.displayName = SUB_CONTENT_NAME;
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst3(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray2(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray2(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch)
    wrappedValues = wrappedValues.filter((v2) => v2 !== currentMatch);
  const nextMatch = wrappedValues.find((value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase()));
  return nextMatch !== currentMatch ? nextMatch : undefined;
}
function isPointInPolygon(point, polygon) {
  const { x: x3, y: y2 } = point;
  let inside = false;
  for (let i3 = 0, j = polygon.length - 1;i3 < polygon.length; j = i3++) {
    const ii = polygon[i3];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y2 !== yj > y2 && x3 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area)
    return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon(cursorPos, area);
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : undefined;
}
var Root32 = Menu;
var Anchor2 = MenuAnchor;
var Portal3 = MenuPortal;
var Content22 = MenuContent;
var Group3 = MenuGroup;
var Label2 = MenuLabel;
var Item2 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator = MenuItemIndicator;
var Separator = MenuSeparator;
var Arrow22 = MenuArrow;
var SubTrigger = MenuSubTrigger;
var SubContent = MenuSubContent;

// ../../node_modules/.pnpm/@radix-ui+react-dropdown-menu@2.1.16_@types+react-dom@19.2.3_@types+react@19.2.7__@type_9ae99dbb567afdb87068bf276cfbb7a7/node_modules/@radix-ui/react-dropdown-menu/dist/index.mjs
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
"use client";
var DROPDOWN_MENU_NAME = "DropdownMenu";
var [createDropdownMenuContext, createDropdownMenuScope] = createContextScope(DROPDOWN_MENU_NAME, [createMenuScope]);
var useMenuScope = createMenuScope();
var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
var DropdownMenu = (props) => {
  const {
    __scopeDropdownMenu,
    children,
    dir,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const triggerRef = React42.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DROPDOWN_MENU_NAME
  });
  return /* @__PURE__ */ import_jsx_runtime16.jsx(DropdownMenuProvider, {
    scope: __scopeDropdownMenu,
    triggerId: useId2(),
    triggerRef,
    contentId: useId2(),
    open,
    onOpenChange: setOpen,
    onOpenToggle: React42.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
    modal,
    children: /* @__PURE__ */ import_jsx_runtime16.jsx(Root32, { ...menuScope, open, onOpenChange: setOpen, dir, modal, children })
  });
};
DropdownMenu.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME2 = "DropdownMenuTrigger";
var DropdownMenuTrigger = React42.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
  const context = useDropdownMenuContext(TRIGGER_NAME2, __scopeDropdownMenu);
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ import_jsx_runtime16.jsx(Anchor2, { asChild: true, ...menuScope, children: /* @__PURE__ */ import_jsx_runtime16.jsx(Primitive.button, {
    type: "button",
    id: context.triggerId,
    "aria-haspopup": "menu",
    "aria-expanded": context.open,
    "aria-controls": context.open ? context.contentId : undefined,
    "data-state": context.open ? "open" : "closed",
    "data-disabled": disabled ? "" : undefined,
    disabled,
    ...triggerProps,
    ref: composeRefs(forwardedRef, context.triggerRef),
    onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
      if (!disabled && event.button === 0 && event.ctrlKey === false) {
        context.onOpenToggle();
        if (!context.open)
          event.preventDefault();
      }
    }),
    onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
      if (disabled)
        return;
      if (["Enter", " "].includes(event.key))
        context.onOpenToggle();
      if (event.key === "ArrowDown")
        context.onOpenChange(true);
      if (["Enter", " ", "ArrowDown"].includes(event.key))
        event.preventDefault();
    })
  }) });
});
DropdownMenuTrigger.displayName = TRIGGER_NAME2;
var PORTAL_NAME4 = "DropdownMenuPortal";
var DropdownMenuPortal = (props) => {
  const { __scopeDropdownMenu, ...portalProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ import_jsx_runtime16.jsx(Portal3, { ...menuScope, ...portalProps });
};
DropdownMenuPortal.displayName = PORTAL_NAME4;
var CONTENT_NAME4 = "DropdownMenuContent";
var DropdownMenuContent = React42.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...contentProps } = props;
  const context = useDropdownMenuContext(CONTENT_NAME4, __scopeDropdownMenu);
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const hasInteractedOutsideRef = React42.useRef(false);
  return /* @__PURE__ */ import_jsx_runtime16.jsx(Content22, {
    id: context.contentId,
    "aria-labelledby": context.triggerId,
    ...menuScope,
    ...contentProps,
    ref: forwardedRef,
    onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
      if (!hasInteractedOutsideRef.current)
        context.triggerRef.current?.focus();
      hasInteractedOutsideRef.current = false;
      event.preventDefault();
    }),
    onInteractOutside: composeEventHandlers(props.onInteractOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      if (!context.modal || isRightClick)
        hasInteractedOutsideRef.current = true;
    }),
    style: {
      ...props.style,
      ...{
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  });
});
DropdownMenuContent.displayName = CONTENT_NAME4;
var GROUP_NAME3 = "DropdownMenuGroup";
var DropdownMenuGroup = React42.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...groupProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ import_jsx_runtime16.jsx(Group3, { ...menuScope, ...groupProps, ref: forwardedRef });
});
DropdownMenuGroup.displayName = GROUP_NAME3;
var LABEL_NAME2 = "DropdownMenuLabel";
var DropdownMenuLabel = React42.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...labelProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ import_jsx_runtime16.jsx(Label2, { ...menuScope, ...labelProps, ref: forwardedRef });
});
DropdownMenuLabel.displayName = LABEL_NAME2;
var ITEM_NAME3 = "DropdownMenuItem";
var DropdownMenuItem = React42.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ import_jsx_runtime16.jsx(Item2, { ...menuScope, ...itemProps, ref: forwardedRef });
});
DropdownMenuItem.displayName = ITEM_NAME3;
var CHECKBOX_ITEM_NAME2 = "DropdownMenuCheckboxItem";
var DropdownMenuCheckboxItem = React42.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ import_jsx_runtime16.jsx(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
DropdownMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME2;
var RADIO_GROUP_NAME2 = "DropdownMenuRadioGroup";
var DropdownMenuRadioGroup = React42.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ import_jsx_runtime16.jsx(RadioGroup, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
DropdownMenuRadioGroup.displayName = RADIO_GROUP_NAME2;
var RADIO_ITEM_NAME2 = "DropdownMenuRadioItem";
var DropdownMenuRadioItem = React42.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ import_jsx_runtime16.jsx(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
DropdownMenuRadioItem.displayName = RADIO_ITEM_NAME2;
var INDICATOR_NAME = "DropdownMenuItemIndicator";
var DropdownMenuItemIndicator = React42.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ import_jsx_runtime16.jsx(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
DropdownMenuItemIndicator.displayName = INDICATOR_NAME;
var SEPARATOR_NAME2 = "DropdownMenuSeparator";
var DropdownMenuSeparator = React42.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ import_jsx_runtime16.jsx(Separator, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
DropdownMenuSeparator.displayName = SEPARATOR_NAME2;
var ARROW_NAME4 = "DropdownMenuArrow";
var DropdownMenuArrow = React42.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...arrowProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ import_jsx_runtime16.jsx(Arrow22, { ...menuScope, ...arrowProps, ref: forwardedRef });
});
DropdownMenuArrow.displayName = ARROW_NAME4;
var SUB_TRIGGER_NAME2 = "DropdownMenuSubTrigger";
var DropdownMenuSubTrigger = React42.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ import_jsx_runtime16.jsx(SubTrigger, { ...menuScope, ...subTriggerProps, ref: forwardedRef });
});
DropdownMenuSubTrigger.displayName = SUB_TRIGGER_NAME2;
var SUB_CONTENT_NAME2 = "DropdownMenuSubContent";
var DropdownMenuSubContent = React42.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ import_jsx_runtime16.jsx(SubContent, {
    ...menuScope,
    ...subContentProps,
    ref: forwardedRef,
    style: {
      ...props.style,
      ...{
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  });
});
DropdownMenuSubContent.displayName = SUB_CONTENT_NAME2;
var Root23 = DropdownMenu;
var Trigger2 = DropdownMenuTrigger;
var Portal22 = DropdownMenuPortal;
var Content23 = DropdownMenuContent;
var Label22 = DropdownMenuLabel;
var Item22 = DropdownMenuItem;
var CheckboxItem2 = DropdownMenuCheckboxItem;
var RadioItem2 = DropdownMenuRadioItem;
var ItemIndicator2 = DropdownMenuItemIndicator;
var Separator2 = DropdownMenuSeparator;
var SubTrigger2 = DropdownMenuSubTrigger;
var SubContent2 = DropdownMenuSubContent;

// ../../src/components/ui/DropdownMenu.tsx
var React43 = __toESM(require_react(), 1);
var jsx_dev_runtime49 = __toESM(require_jsx_dev_runtime(), 1);
var DropdownMenu2 = Root23;
var DropdownMenuTrigger2 = Trigger2;
var DropdownMenuSubTrigger2 = React43.forwardRef(({ className, inset, children, ...props }, ref) => /* @__PURE__ */ jsx_dev_runtime49.jsxDEV(SubTrigger2, {
  ref,
  className: cn2("flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground text-foreground", inset && "pl-8", className),
  ...props,
  children: [
    children,
    /* @__PURE__ */ jsx_dev_runtime49.jsxDEV(ChevronRight, {
      className: "ml-auto h-4 w-4"
    }, undefined, false, undefined, this)
  ]
}, undefined, true, undefined, this));
DropdownMenuSubTrigger2.displayName = SubTrigger2.displayName;
var DropdownMenuSubContent2 = React43.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx_dev_runtime49.jsxDEV(SubContent2, {
  ref,
  className: cn2("z-50 min-w-[8rem] overflow-hidden rounded-md border border-border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", className),
  ...props
}, undefined, false, undefined, this));
DropdownMenuSubContent2.displayName = SubContent2.displayName;
var DropdownMenuContent2 = React43.forwardRef(({ className, sideOffset = 4, ...props }, ref) => /* @__PURE__ */ jsx_dev_runtime49.jsxDEV(Portal22, {
  children: /* @__PURE__ */ jsx_dev_runtime49.jsxDEV(Content23, {
    ref,
    sideOffset,
    style: {
      backgroundColor: "hsl(var(--popover))",
      color: "hsl(var(--popover-foreground))"
    },
    className: cn2("z-50 min-w-[8rem] overflow-hidden rounded-md border border-border p-1 shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", className),
    ...props
  }, undefined, false, undefined, this)
}, undefined, false, undefined, this));
DropdownMenuContent2.displayName = Content23.displayName;
var DropdownMenuItem2 = React43.forwardRef(({ className, inset, ...props }, ref) => /* @__PURE__ */ jsx_dev_runtime49.jsxDEV(Item22, {
  ref,
  className: cn2("relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 text-foreground", inset && "pl-8", className),
  ...props
}, undefined, false, undefined, this));
DropdownMenuItem2.displayName = Item22.displayName;
var DropdownMenuCheckboxItem2 = React43.forwardRef(({ className, children, checked, ...props }, ref) => /* @__PURE__ */ jsx_dev_runtime49.jsxDEV(CheckboxItem2, {
  ref,
  className: cn2("relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 text-foreground", className),
  checked,
  ...props,
  children: [
    /* @__PURE__ */ jsx_dev_runtime49.jsxDEV("span", {
      className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center",
      children: /* @__PURE__ */ jsx_dev_runtime49.jsxDEV(ItemIndicator2, {
        children: /* @__PURE__ */ jsx_dev_runtime49.jsxDEV(Check, {
          className: "h-4 w-4"
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this),
    children
  ]
}, undefined, true, undefined, this));
DropdownMenuCheckboxItem2.displayName = CheckboxItem2.displayName;
var DropdownMenuRadioItem2 = React43.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsx_dev_runtime49.jsxDEV(RadioItem2, {
  ref,
  className: cn2("relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 text-foreground", className),
  ...props,
  children: [
    /* @__PURE__ */ jsx_dev_runtime49.jsxDEV("span", {
      className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center",
      children: /* @__PURE__ */ jsx_dev_runtime49.jsxDEV(ItemIndicator2, {
        children: /* @__PURE__ */ jsx_dev_runtime49.jsxDEV(Circle3, {
          className: "h-2 w-2 fill-current"
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this),
    children
  ]
}, undefined, true, undefined, this));
DropdownMenuRadioItem2.displayName = RadioItem2.displayName;
var DropdownMenuLabel2 = React43.forwardRef(({ className, inset, ...props }, ref) => /* @__PURE__ */ jsx_dev_runtime49.jsxDEV(Label22, {
  ref,
  className: cn2("px-2 py-1.5 text-sm font-semibold text-foreground", inset && "pl-8", className),
  ...props
}, undefined, false, undefined, this));
DropdownMenuLabel2.displayName = Label22.displayName;
var DropdownMenuSeparator2 = React43.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx_dev_runtime49.jsxDEV(Separator2, {
  ref,
  className: cn2("-mx-1 my-1 h-px bg-border", className),
  ...props
}, undefined, false, undefined, this));
DropdownMenuSeparator2.displayName = Separator2.displayName;
var DropdownMenuShortcut = ({ className, ...props }) => {
  return /* @__PURE__ */ jsx_dev_runtime49.jsxDEV("span", {
    className: cn2("ml-auto text-xs tracking-widest opacity-60", className),
    ...props
  }, undefined, false, undefined, this);
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

// ../../node_modules/.pnpm/@radix-ui+react-tooltip@1.2.8_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react_61903d443f318e235810cb4023b9ffb4/node_modules/@radix-ui/react-tooltip/dist/index.mjs
var React45 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/@radix-ui+react-visually-hidden@1.2.3_@types+react-dom@19.2.3_@types+react@19.2.7__@typ_b08a54b8b8cc1e2fcb68c28280b66cb9/node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
var React44 = __toESM(require_react(), 1);
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var VISUALLY_HIDDEN_STYLES = Object.freeze({
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
});
var NAME2 = "VisuallyHidden";
var VisuallyHidden = React44.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ import_jsx_runtime17.jsx(Primitive.span, {
    ...props,
    ref: forwardedRef,
    style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }
  });
});
VisuallyHidden.displayName = NAME2;
var Root5 = VisuallyHidden;

// ../../node_modules/.pnpm/@radix-ui+react-tooltip@1.2.8_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react_61903d443f318e235810cb4023b9ffb4/node_modules/@radix-ui/react-tooltip/dist/index.mjs
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
"use client";
var [createTooltipContext, createTooltipScope] = createContextScope("Tooltip", [
  createPopperScope
]);
var usePopperScope3 = createPopperScope();
var PROVIDER_NAME = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
var TooltipProvider = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const isOpenDelayedRef = React45.useRef(true);
  const isPointerInTransitRef = React45.useRef(false);
  const skipDelayTimerRef = React45.useRef(0);
  React45.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return /* @__PURE__ */ import_jsx_runtime18.jsx(TooltipProviderContextProvider, {
    scope: __scopeTooltip,
    isOpenDelayedRef,
    delayDuration,
    onOpen: React45.useCallback(() => {
      window.clearTimeout(skipDelayTimerRef.current);
      isOpenDelayedRef.current = false;
    }, []),
    onClose: React45.useCallback(() => {
      window.clearTimeout(skipDelayTimerRef.current);
      skipDelayTimerRef.current = window.setTimeout(() => isOpenDelayedRef.current = true, skipDelayDuration);
    }, [skipDelayDuration]),
    isPointerInTransitRef,
    onPointerInTransitChange: React45.useCallback((inTransit) => {
      isPointerInTransitRef.current = inTransit;
    }, []),
    disableHoverableContent,
    children
  });
};
TooltipProvider.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope3(__scopeTooltip);
  const [trigger, setTrigger] = React45.useState(null);
  const contentId = useId2();
  const openTimerRef = React45.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = React45.useRef(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange?.(open2);
    },
    caller: TOOLTIP_NAME
  });
  const stateAttribute = React45.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = React45.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = React45.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = React45.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
      openTimerRef.current = 0;
    }, delayDuration);
  }, [delayDuration, setOpen]);
  React45.useEffect(() => {
    return () => {
      if (openTimerRef.current) {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    };
  }, []);
  return /* @__PURE__ */ import_jsx_runtime18.jsx(Root2, { ...popperScope, children: /* @__PURE__ */ import_jsx_runtime18.jsx(TooltipContextProvider, {
    scope: __scopeTooltip,
    contentId,
    open,
    stateAttribute,
    trigger,
    onTriggerChange: setTrigger,
    onTriggerEnter: React45.useCallback(() => {
      if (providerContext.isOpenDelayedRef.current)
        handleDelayedOpen();
      else
        handleOpen();
    }, [providerContext.isOpenDelayedRef, handleDelayedOpen, handleOpen]),
    onTriggerLeave: React45.useCallback(() => {
      if (disableHoverableContent) {
        handleClose();
      } else {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    }, [handleClose, disableHoverableContent]),
    onOpen: handleOpen,
    onClose: handleClose,
    disableHoverableContent,
    children
  }) });
};
Tooltip.displayName = TOOLTIP_NAME;
var TRIGGER_NAME3 = "TooltipTrigger";
var TooltipTrigger = React45.forwardRef((props, forwardedRef) => {
  const { __scopeTooltip, ...triggerProps } = props;
  const context = useTooltipContext(TRIGGER_NAME3, __scopeTooltip);
  const providerContext = useTooltipProviderContext(TRIGGER_NAME3, __scopeTooltip);
  const popperScope = usePopperScope3(__scopeTooltip);
  const ref = React45.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);
  const isPointerDownRef = React45.useRef(false);
  const hasPointerMoveOpenedRef = React45.useRef(false);
  const handlePointerUp = React45.useCallback(() => isPointerDownRef.current = false, []);
  React45.useEffect(() => {
    return () => document.removeEventListener("pointerup", handlePointerUp);
  }, [handlePointerUp]);
  return /* @__PURE__ */ import_jsx_runtime18.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ import_jsx_runtime18.jsx(Primitive.button, {
    "aria-describedby": context.open ? context.contentId : undefined,
    "data-state": context.stateAttribute,
    ...triggerProps,
    ref: composedRefs,
    onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
      if (event.pointerType === "touch")
        return;
      if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
        context.onTriggerEnter();
        hasPointerMoveOpenedRef.current = true;
      }
    }),
    onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
      context.onTriggerLeave();
      hasPointerMoveOpenedRef.current = false;
    }),
    onPointerDown: composeEventHandlers(props.onPointerDown, () => {
      if (context.open) {
        context.onClose();
      }
      isPointerDownRef.current = true;
      document.addEventListener("pointerup", handlePointerUp, { once: true });
    }),
    onFocus: composeEventHandlers(props.onFocus, () => {
      if (!isPointerDownRef.current)
        context.onOpen();
    }),
    onBlur: composeEventHandlers(props.onBlur, context.onClose),
    onClick: composeEventHandlers(props.onClick, context.onClose)
  }) });
});
TooltipTrigger.displayName = TRIGGER_NAME3;
var PORTAL_NAME5 = "TooltipPortal";
var [PortalProvider3, usePortalContext3] = createTooltipContext(PORTAL_NAME5, {
  forceMount: undefined
});
var TooltipPortal = (props) => {
  const { __scopeTooltip, forceMount, children, container } = props;
  const context = useTooltipContext(PORTAL_NAME5, __scopeTooltip);
  return /* @__PURE__ */ import_jsx_runtime18.jsx(PortalProvider3, { scope: __scopeTooltip, forceMount, children: /* @__PURE__ */ import_jsx_runtime18.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ import_jsx_runtime18.jsx(Portal, { asChild: true, container, children }) }) });
};
TooltipPortal.displayName = PORTAL_NAME5;
var CONTENT_NAME5 = "TooltipContent";
var TooltipContent = React45.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext3(CONTENT_NAME5, props.__scopeTooltip);
  const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
  const context = useTooltipContext(CONTENT_NAME5, props.__scopeTooltip);
  return /* @__PURE__ */ import_jsx_runtime18.jsx(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? /* @__PURE__ */ import_jsx_runtime18.jsx(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ import_jsx_runtime18.jsx(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
});
var TooltipContentHoverable = React45.forwardRef((props, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME5, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME5, props.__scopeTooltip);
  const ref = React45.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = React45.useState(null);
  const { trigger, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = React45.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = React45.useCallback((event, hoverTarget) => {
    const currentTarget = event.currentTarget;
    const exitPoint = { x: event.clientX, y: event.clientY };
    const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
    const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
    const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
    const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
    setPointerGraceArea(graceArea);
    onPointerInTransitChange(true);
  }, [onPointerInTransitChange]);
  React45.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  React45.useEffect(() => {
    if (trigger && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
      trigger.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);
  React45.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = trigger?.contains(target) || content?.contains(target);
        const isPointerOutsideGraceArea = !isPointInPolygon2(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return /* @__PURE__ */ import_jsx_runtime18.jsx(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var Slottable = createSlottable("TooltipContent");
var TooltipContentImpl = React45.forwardRef((props, forwardedRef) => {
  const {
    __scopeTooltip,
    children,
    "aria-label": ariaLabel,
    onEscapeKeyDown,
    onPointerDownOutside,
    ...contentProps
  } = props;
  const context = useTooltipContext(CONTENT_NAME5, __scopeTooltip);
  const popperScope = usePopperScope3(__scopeTooltip);
  const { onClose } = context;
  React45.useEffect(() => {
    document.addEventListener(TOOLTIP_OPEN, onClose);
    return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
  }, [onClose]);
  React45.useEffect(() => {
    if (context.trigger) {
      const handleScroll2 = (event) => {
        const target = event.target;
        if (target?.contains(context.trigger))
          onClose();
      };
      window.addEventListener("scroll", handleScroll2, { capture: true });
      return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
    }
  }, [context.trigger, onClose]);
  return /* @__PURE__ */ import_jsx_runtime18.jsx(DismissableLayer, {
    asChild: true,
    disableOutsidePointerEvents: false,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside: (event) => event.preventDefault(),
    onDismiss: onClose,
    children: /* @__PURE__ */ import_jsx_runtime18.jsxs(Content, {
      "data-state": context.stateAttribute,
      ...popperScope,
      ...contentProps,
      ref: forwardedRef,
      style: {
        ...contentProps.style,
        ...{
          "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
          "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
          "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
        }
      },
      children: [
        /* @__PURE__ */ import_jsx_runtime18.jsx(Slottable, { children }),
        /* @__PURE__ */ import_jsx_runtime18.jsx(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ import_jsx_runtime18.jsx(Root5, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
      ]
    })
  });
});
TooltipContent.displayName = CONTENT_NAME5;
var ARROW_NAME5 = "TooltipArrow";
var TooltipArrow = React45.forwardRef((props, forwardedRef) => {
  const { __scopeTooltip, ...arrowProps } = props;
  const popperScope = usePopperScope3(__scopeTooltip);
  const visuallyHiddenContentContext = useVisuallyHiddenContentContext(ARROW_NAME5, __scopeTooltip);
  return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ import_jsx_runtime18.jsx(Arrow3, { ...popperScope, ...arrowProps, ref: forwardedRef });
});
TooltipArrow.displayName = ARROW_NAME5;
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push({ x: exitPoint.x - padding, y: exitPoint.y + padding }, { x: exitPoint.x + padding, y: exitPoint.y + padding });
      break;
    case "bottom":
      paddedExitPoints.push({ x: exitPoint.x - padding, y: exitPoint.y - padding }, { x: exitPoint.x + padding, y: exitPoint.y - padding });
      break;
    case "left":
      paddedExitPoints.push({ x: exitPoint.x + padding, y: exitPoint.y - padding }, { x: exitPoint.x + padding, y: exitPoint.y + padding });
      break;
    case "right":
      paddedExitPoints.push({ x: exitPoint.x - padding, y: exitPoint.y - padding }, { x: exitPoint.x - padding, y: exitPoint.y + padding });
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon2(point, polygon) {
  const { x: x3, y: y2 } = point;
  let inside = false;
  for (let i3 = 0, j = polygon.length - 1;i3 < polygon.length; j = i3++) {
    const ii = polygon[i3];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y2 !== yj > y2 && x3 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a3, b3) => {
    if (a3.x < b3.x)
      return -1;
    else if (a3.x > b3.x)
      return 1;
    else if (a3.y < b3.y)
      return -1;
    else if (a3.y > b3.y)
      return 1;
    else
      return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i3 = 0;i3 < points.length; i3++) {
    const p3 = points[i3];
    while (upperHull.length >= 2) {
      const q2 = upperHull[upperHull.length - 1];
      const r3 = upperHull[upperHull.length - 2];
      if ((q2.x - r3.x) * (p3.y - r3.y) >= (q2.y - r3.y) * (p3.x - r3.x))
        upperHull.pop();
      else
        break;
    }
    upperHull.push(p3);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i3 = points.length - 1;i3 >= 0; i3--) {
    const p3 = points[i3];
    while (lowerHull.length >= 2) {
      const q2 = lowerHull[lowerHull.length - 1];
      const r3 = lowerHull[lowerHull.length - 2];
      if ((q2.x - r3.x) * (p3.y - r3.y) >= (q2.y - r3.y) * (p3.x - r3.x))
        lowerHull.pop();
      else
        break;
    }
    lowerHull.push(p3);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider = TooltipProvider;
var Root33 = Tooltip;
var Trigger3 = TooltipTrigger;
var Portal4 = TooltipPortal;
var Content24 = TooltipContent;

// ../../src/components/ui/Tooltip.tsx
var React46 = __toESM(require_react(), 1);
var jsx_dev_runtime50 = __toESM(require_jsx_dev_runtime(), 1);
var TooltipProvider2 = Provider;
var Tooltip2 = Root33;
var TooltipTrigger2 = Trigger3;
var TooltipContent2 = React46.memo(React46.forwardRef(({ className, sideOffset = 4, side = "bottom", ...props }, ref) => /* @__PURE__ */ jsx_dev_runtime50.jsxDEV(Portal4, {
  children: /* @__PURE__ */ jsx_dev_runtime50.jsxDEV(Content24, {
    ref,
    sideOffset,
    side,
    className: cn2("z-50 overflow-hidden rounded-md border border-white bg-black text-white px-3 py-1.5 text-xs shadow-md animate-in fade-in-0 zoom-in-95", className),
    ...props
  }, undefined, false, undefined, this)
}, undefined, false, undefined, this)));
TooltipContent2.displayName = Content24.displayName;

// ../../src/features/bed-layout-editor/components/Toolbar/Toolbar.tsx
var jsx_dev_runtime51 = __toESM(require_jsx_dev_runtime(), 1);
var TOOLBAR_BUTTON_CLASS = "w-10 h-10 flex items-center justify-center rounded border border-border bg-background text-muted-foreground hover:bg-accent transition-colors";
var ACTIVE_BUTTON_CLASS = "w-10 h-10 flex items-center justify-center rounded border-2 border-primary bg-primary/10 text-primary";
var TrapezoidIcon = ({ size: size4 = 20, className = "", title = "Trapezoid" }) => /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("svg", {
  width: size4,
  height: size4,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: "2",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  className,
  children: [
    /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("title", {
      children: title
    }, undefined, false, undefined, this),
    /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("path", {
      d: "M4 20h16l-4-16H8L4 20z"
    }, undefined, false, undefined, this)
  ]
}, undefined, true, undefined, this);
var Toolbar = ({
  activeTool,
  document: document2,
  onAddElement,
  onSelectElement,
  onToolSelect,
  zoom,
  onZoomIn,
  onZoomOut,
  surfaceId,
  i18nOverrides,
  onCopy,
  onPaste
}) => {
  const { t: t2 } = useI18n();
  const resolveText = (key, defaultValue) => {
    if (i18nOverrides?.[key])
      return i18nOverrides[key];
    return t2(key, defaultValue ?? key);
  };
  const shapes2 = [
    { type: "Rect", icon: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Square, {
      size: 20
    }, undefined, false, undefined, this) },
    { type: "Circle", icon: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Circle3, {
      size: 20
    }, undefined, false, undefined, this) },
    { type: "Triangle", icon: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Triangle, {
      size: 20
    }, undefined, false, undefined, this) },
    {
      type: "Trapezoid",
      icon: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(TrapezoidIcon, {
        size: 20,
        title: resolveText("shape_trapezoid", "Trapezoid")
      }, undefined, false, undefined, this)
    },
    { type: "Diamond", icon: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Diamond, {
      size: 20
    }, undefined, false, undefined, this) },
    { type: "Cylinder", icon: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Database, {
      size: 20
    }, undefined, false, undefined, this) },
    { type: "Heart", icon: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Heart, {
      size: 20
    }, undefined, false, undefined, this) },
    { type: "Star", icon: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Star3, {
      size: 20
    }, undefined, false, undefined, this) },
    { type: "Pentagon", icon: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Pentagon, {
      size: 20
    }, undefined, false, undefined, this) },
    { type: "Hexagon", icon: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Hexagon, {
      size: 20
    }, undefined, false, undefined, this) },
    { type: "ArrowUp", icon: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(ArrowUp, {
      size: 20
    }, undefined, false, undefined, this) },
    { type: "ArrowDown", icon: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(ArrowDown, {
      size: 20
    }, undefined, false, undefined, this) },
    { type: "ArrowLeft", icon: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(ArrowLeft, {
      size: 20
    }, undefined, false, undefined, this) },
    { type: "ArrowRight", icon: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(ArrowRight, {
      size: 20
    }, undefined, false, undefined, this) },
    {
      type: "Cone",
      icon: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("svg", {
        width: "20",
        height: "20",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("path", {
            d: "M12 2L4 18a4 2 0 0 0 8 2 4 2 0 0 0 8-2L12 2z"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("ellipse", {
            cx: "12",
            cy: "18",
            rx: "8",
            ry: "2"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    },
    { type: "House", icon: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(House, {
      size: 20
    }, undefined, false, undefined, this) }
  ];
  const getButtonClass = (tool) => {
    return activeTool === tool ? ACTIVE_BUTTON_CLASS : TOOLBAR_BUTTON_CLASS;
  };
  const getTargetSurfaceId = () => {
    if (surfaceId)
      return surfaceId;
    return document2.surfaces.find((s2) => s2.type === "canvas")?.id || document2.surfaces[0]?.id || "layout";
  };
  const calculateInitialPosition = (targetSurfaceId) => {
    const surface = document2.surfaces.find((s2) => s2.id === targetSurfaceId);
    const surfaceW = surface?.w ?? 800;
    const surfaceH = surface?.h ?? 600;
    const nodesOnSurface = document2.nodes.filter((n2) => n2.s === targetSurfaceId).length;
    const offset4 = nodesOnSurface * (surfaceW * 0.01);
    return {
      x: surfaceW * 0.15 + offset4,
      y: surfaceH * 0.15 + offset4
    };
  };
  const withNewElement = (element) => {
    onAddElement(element);
    onSelectElement(element.id);
    onToolSelect?.("select");
  };
  const addText = () => {
    const s2 = getTargetSurfaceId();
    const { x: x3, y: y2 } = calculateInitialPosition(s2);
    const id = `text-${crypto.randomUUID()}`;
    const textContent = resolveText("toolbar_default_text", "Text");
    const dpi2 = 96;
    const fontSizeMm = ptToMm(12);
    const font = {
      family: "Meiryo",
      sizeMm: fontSizeMm,
      weight: 400
    };
    const { w: w2, h: h3 } = calculateInitialTextBoxSize(textContent, font, { dpi: dpi2 });
    const text = {
      id,
      t: "text",
      s: s2,
      locked: false,
      r: 0,
      name: "Text",
      text: textContent,
      font: font.family,
      fontSize: fontSizeMm,
      fontWeight: font.weight,
      fill: "#000000",
      align: "l",
      x: x3,
      y: y2,
      w: w2,
      h: h3
    };
    withNewElement(text);
  };
  const addImage = () => {
    const s2 = getTargetSurfaceId();
    const { x: x3, y: y2 } = calculateInitialPosition(s2);
    const id = `image-${crypto.randomUUID()}`;
    const image = {
      id,
      t: "image",
      s: s2,
      locked: false,
      r: 0,
      name: "Image",
      x: x3,
      y: y2,
      w: 40,
      h: 30,
      src: ""
    };
    withNewElement(image);
  };
  const addWall = () => {
    const s2 = getTargetSurfaceId();
    const { x: x3, y: y2 } = calculateInitialPosition(s2);
    const id = `wall-${crypto.randomUUID()}`;
    const line = {
      id,
      t: "line",
      s: s2,
      locked: false,
      name: "Wall",
      pts: [x3, y2, x3 + 160, y2],
      stroke: "#000000",
      strokeW: 0.4,
      arrows: ["none", "none"]
    };
    withNewElement(line);
  };
  const addShape = (shapeType) => {
    const s2 = getTargetSurfaceId();
    const { x: x3, y: y2 } = calculateInitialPosition(s2);
    const id = `${shapeType.toLowerCase()}-${crypto.randomUUID()}`;
    let width = 80;
    let height = 80;
    if (shapeType === "trapezoid") {
      width = 100;
      height = 60;
    } else if (shapeType === "cylinder") {
      width = 60;
      height = 100;
    } else if (["arrow-u", "arrow-d"].includes(shapeType)) {
      width = 40;
      height = 80;
    } else if (["arrow-l", "arrow-r"].includes(shapeType)) {
      width = 80;
      height = 40;
    }
    const shape = {
      id,
      t: "shape",
      shape: shapeType.toLowerCase(),
      s: s2,
      locked: false,
      r: 0,
      name: shapeType,
      x: x3,
      y: y2,
      w: width,
      h: height,
      stroke: "#000000",
      strokeW: 0.2,
      fill: "#ffffff"
    };
    withNewElement(shape);
  };
  const addBed = () => {
    const s2 = getTargetSurfaceId();
    const { x: x3, y: y2 } = calculateInitialPosition(s2);
    const id = `bed-${crypto.randomUUID()}`;
    const bed = {
      id,
      t: "widget",
      widget: "bed",
      s: s2,
      locked: false,
      r: 0,
      name: "Bed",
      x: x3,
      y: y2,
      w: 15,
      h: 30,
      data: { bedType: "standard", borderW: 0.4 }
    };
    withNewElement(bed);
  };
  return /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("div", {
    className: "flex flex-col items-center gap-2 p-2 bg-secondary border-r border-border text-muted-foreground h-full",
    children: [
      /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(TooltipProvider2, {
        children: [
          /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Tooltip2, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(TooltipTrigger2, {
                asChild: true,
                children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("button", {
                  type: "button",
                  onClick: () => onToolSelect?.("select"),
                  className: getButtonClass("select"),
                  "aria-label": resolveText("toolbar_select", "Select"),
                  children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(MousePointer2, {
                    size: 20
                  }, undefined, false, undefined, this)
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(TooltipContent2, {
                side: "right",
                children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("p", {
                  children: resolveText("toolbar_select", "Select")
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Tooltip2, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(TooltipTrigger2, {
                asChild: true,
                children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("button", {
                  type: "button",
                  onClick: addText,
                  className: getButtonClass("text"),
                  "aria-label": resolveText("toolbar_text", "Text"),
                  children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Type, {
                    size: 20
                  }, undefined, false, undefined, this)
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(TooltipContent2, {
                side: "right",
                children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("p", {
                  children: resolveText("toolbar_text", "Text")
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Tooltip2, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(TooltipTrigger2, {
                asChild: true,
                children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("button", {
                  type: "button",
                  onClick: addImage,
                  className: getButtonClass("image"),
                  "aria-label": resolveText("toolbar_image", "Image"),
                  children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Image4, {
                    size: 20
                  }, undefined, false, undefined, this)
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(TooltipContent2, {
                side: "right",
                children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("p", {
                  children: resolveText("toolbar_image", "Image")
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Tooltip2, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(TooltipTrigger2, {
                asChild: true,
                children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("button", {
                  type: "button",
                  onClick: addBed,
                  className: getButtonClass("bed"),
                  "aria-label": resolveText("toolbar_bed", "Bed"),
                  children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(BedDouble, {
                    size: 20
                  }, undefined, false, undefined, this)
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(TooltipContent2, {
                side: "right",
                children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("p", {
                  children: resolveText("toolbar_bed", "Bed")
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Tooltip2, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(TooltipTrigger2, {
                asChild: true,
                children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("button", {
                  type: "button",
                  onClick: addWall,
                  className: getButtonClass("line"),
                  "aria-label": resolveText("toolbar_wall", "Wall"),
                  children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Minus, {
                    size: 20
                  }, undefined, false, undefined, this)
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(TooltipContent2, {
                side: "right",
                children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("p", {
                  children: resolveText("toolbar_wall", "Wall")
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(DropdownMenu2, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Tooltip2, {
                children: [
                  /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(TooltipTrigger2, {
                    asChild: true,
                    children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(DropdownMenuTrigger2, {
                      asChild: true,
                      children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("button", {
                        type: "button",
                        className: getButtonClass("shape"),
                        "aria-label": resolveText("toolbar_shape", "Shape"),
                        children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Shapes, {
                          size: 20
                        }, undefined, false, undefined, this)
                      }, undefined, false, undefined, this)
                    }, undefined, false, undefined, this)
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(TooltipContent2, {
                    side: "right",
                    children: resolveText("toolbar_shape", "Shape")
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(DropdownMenuContent2, {
                align: "start",
                className: "w-56 grid grid-cols-4 gap-1 p-2 bg-popover text-popover-foreground border border-border shadow-lg z-50",
                children: shapes2.map((shape) => /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(DropdownMenuItem2, {
                  onClick: () => addShape(shape.type.toLowerCase()),
                  className: "flex items-center justify-center p-2 rounded cursor-pointer hover:bg-accent text-foreground outline-none",
                  children: shape.icon
                }, shape.type, false, undefined, this))
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("div", {
        className: "flex-1"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("div", {
        className: "border-t border-border my-2 w-full"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("div", {
        className: "flex flex-col items-center gap-1",
        children: [
          /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Tooltip2, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(TooltipTrigger2, {
                asChild: true,
                children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("button", {
                  type: "button",
                  onClick: onCopy,
                  className: TOOLBAR_BUTTON_CLASS,
                  "aria-label": resolveText("toolbar_copy", "Copy"),
                  children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Copy, {
                    size: 20
                  }, undefined, false, undefined, this)
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(TooltipContent2, {
                side: "right",
                children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("p", {
                  children: resolveText("toolbar_copy", "Copy")
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(Tooltip2, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(TooltipTrigger2, {
                asChild: true,
                children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("button", {
                  type: "button",
                  onClick: onPaste,
                  className: TOOLBAR_BUTTON_CLASS,
                  "aria-label": resolveText("toolbar_paste", "Paste"),
                  children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(ClipboardPaste, {
                    size: 20
                  }, undefined, false, undefined, this)
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(TooltipContent2, {
                side: "right",
                children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("p", {
                  children: resolveText("toolbar_paste", "Paste")
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("div", {
        className: "border-t border-border my-3 w-full"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("div", {
        className: "flex flex-col items-center gap-1 pb-2",
        children: [
          /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("button", {
            type: "button",
            onClick: onZoomIn,
            className: `${TOOLBAR_BUTTON_CLASS} disabled:opacity-50`,
            "aria-label": resolveText("toolbar_zoom_in", "Zoom in"),
            disabled: zoom >= 2,
            children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(ZoomIn, {
              size: 18
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("span", {
            className: "text-muted-foreground text-xs font-medium",
            "aria-label": resolveText("toolbar_zoom_reset", "Reset zoom"),
            children: [
              Math.round(zoom * 100),
              "%"
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime51.jsxDEV("button", {
            type: "button",
            onClick: onZoomOut,
            className: `${TOOLBAR_BUTTON_CLASS} disabled:opacity-50`,
            "aria-label": resolveText("toolbar_zoom_out", "Zoom out"),
            disabled: zoom <= 0.25,
            children: /* @__PURE__ */ jsx_dev_runtime51.jsxDEV(ZoomOut, {
              size: 18
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
// ../../src/features/konva-editor/hooks/useEditorHistory.ts
var import_react26 = __toESM(require_react(), 1);
var MAX_HISTORY_SIZE = 50;
function useEditorHistoryDoc(document2, setDocument) {
  const [past, setPast] = import_react26.useState([]);
  const [future, setFuture] = import_react26.useState([]);
  const didNormalizeRef = import_react26.useRef(false);
  import_react26.useEffect(() => {
    if (didNormalizeRef.current)
      return;
    if (!document2 || document2.unit === "mm") {
      didNormalizeRef.current = true;
      return;
    }
    console.warn("[useEditorHistoryDoc] Doc.unit is not mm. Please convert the document before passing it in.");
    didNormalizeRef.current = true;
  }, [document2, setDocument]);
  const execute = import_react26.useCallback((operation, options2) => {
    setDocument((prevDoc) => {
      const nextDoc = applyOperationDoc(prevDoc, operation);
      return nextDoc;
    });
    if (options2?.saveToHistory !== false) {
      setPast((prevPast) => {
        const newPast = [...prevPast, operation];
        if (newPast.length > MAX_HISTORY_SIZE) {
          return newPast.slice(newPast.length - MAX_HISTORY_SIZE);
        }
        return newPast;
      });
      setFuture([]);
    }
  }, [setDocument]);
  const undo = import_react26.useCallback(() => {
    if (past.length === 0)
      return;
    const operation = past[past.length - 1];
    const newPast = past.slice(0, past.length - 1);
    const newDoc = revertOperationDoc(document2, operation);
    setDocument(newDoc);
    setPast(newPast);
    setFuture((prev) => [operation, ...prev]);
  }, [document2, past, setDocument]);
  const redo = import_react26.useCallback(() => {
    if (future.length === 0)
      return;
    const operation = future[0];
    const newFuture = future.slice(1);
    const newDoc = applyOperationDoc(document2, operation);
    setDocument(newDoc);
    setPast((prev) => [...prev, operation]);
    setFuture(newFuture);
  }, [document2, future, setDocument]);
  const clear = import_react26.useCallback(() => {
    setPast([]);
    setFuture([]);
  }, []);
  return {
    execute,
    undo,
    redo,
    canUndo: past.length > 0,
    canRedo: future.length > 0,
    clear
  };
}
function useEditorHistory(document2, setDocument) {
  return useEditorHistoryDoc(document2, setDocument);
}
function applyOperationDoc(doc, op) {
  switch (op.kind) {
    case "create-element":
      return {
        ...doc,
        nodes: [...doc.nodes, op.element]
      };
    case "update-element": {
      const { id, next } = op;
      const update = next;
      if ("x" in update || "y" in update) {
        const target = doc.nodes.find((n2) => n2.id === id);
        if (target && target.t === "widget" && target.widget === "bed") {
          console.log(`[applyOperationDoc] Updating bed ${id} position:`, {
            from: { x: target.x, y: target.y },
            to: { x: update.x ?? target.x, y: update.y ?? target.y }
          });
        }
      }
      return {
        ...doc,
        nodes: doc.nodes.map((n2) => n2.id === id ? { ...n2, ...update, id } : n2)
      };
    }
    case "delete-element":
      return {
        ...doc,
        nodes: doc.nodes.filter((n2) => n2.id !== op.id)
      };
    case "reorder-elements": {
      const byId = new Map(doc.nodes.map((n2) => [n2.id, n2]));
      const nextNodes = [];
      for (const id of op.nextOrder) {
        const n2 = byId.get(id);
        if (n2)
          nextNodes.push(n2);
      }
      for (const n2 of doc.nodes) {
        if (!op.nextOrder.includes(n2.id))
          nextNodes.push(n2);
      }
      return {
        ...doc,
        nodes: nextNodes
      };
    }
    default:
      return doc;
  }
}
function revertOperationDoc(doc, op) {
  switch (op.kind) {
    case "create-element":
      return {
        ...doc,
        nodes: doc.nodes.filter((n2) => n2.id !== op.element.id)
      };
    case "update-element": {
      return {
        ...doc,
        nodes: doc.nodes.map((n2) => n2.id === op.id ? { ...n2, ...op.prev, id: op.id } : n2)
      };
    }
    case "delete-element":
      return {
        ...doc,
        nodes: [...doc.nodes, op.prevElement]
      };
    case "reorder-elements": {
      const byId = new Map(doc.nodes.map((n2) => [n2.id, n2]));
      const prevNodes = [];
      for (const id of op.prevOrder) {
        const n2 = byId.get(id);
        if (n2)
          prevNodes.push(n2);
      }
      for (const n2 of doc.nodes) {
        if (!op.prevOrder.includes(n2.id))
          prevNodes.push(n2);
      }
      return {
        ...doc,
        nodes: prevNodes
      };
    }
    default:
      return doc;
  }
}
// ../../src/features/konva-editor/hooks/useEditorState.ts
var import_react27 = __toESM(require_react(), 1);
function useEditorState() {
  const [selection, setSelection] = import_react27.useState([]);
  const toggleSelection = import_react27.useCallback((id) => {
    setSelection((prev) => {
      if (prev.includes(id)) {
        return prev.filter((item) => item !== id);
      }
      return [...prev, id];
    });
  }, []);
  const clearSelection = import_react27.useCallback(() => {
    setSelection([]);
  }, []);
  const [zoom, setZoom] = import_react27.useState(1);
  const zoomIn = import_react27.useCallback(() => {
    setZoom((prev) => Math.min(prev + 0.25, 5));
  }, []);
  const zoomOut = import_react27.useCallback(() => {
    setZoom((prev) => Math.max(prev - 0.25, 0.25));
  }, []);
  const resetZoom = import_react27.useCallback(() => {
    setZoom(1);
  }, []);
  const [scroll, setScroll] = import_react27.useState({ x: 0, y: 0 });
  return {
    selection,
    setSelection,
    toggleSelection,
    clearSelection,
    zoom,
    setZoom,
    zoomIn,
    zoomOut,
    resetZoom,
    scroll,
    setScroll
  };
}
// ../../src/features/konva-editor/renderers/print/BedPrintLayout.tsx
var import_react29 = __toESM(require_react(), 1);

// ../../src/features/konva-editor/renderers/print/ReportPrintLayout.tsx
var import_react28 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/perfect-freehand@1.2.2/node_modules/perfect-freehand/dist/esm/index.mjs
function $2(e2, t2, u2, x3 = (h3) => h3) {
  return e2 * x3(0.5 - t2 * (0.5 - u2));
}
function se(e2) {
  return [-e2[0], -e2[1]];
}
function l3(e2, t2) {
  return [e2[0] + t2[0], e2[1] + t2[1]];
}
function a3(e2, t2) {
  return [e2[0] - t2[0], e2[1] - t2[1]];
}
function b3(e2, t2) {
  return [e2[0] * t2, e2[1] * t2];
}
function he(e2, t2) {
  return [e2[0] / t2, e2[1] / t2];
}
function R2(e2) {
  return [e2[1], -e2[0]];
}
function B(e2, t2) {
  return e2[0] * t2[0] + e2[1] * t2[1];
}
function ue(e2, t2) {
  return e2[0] === t2[0] && e2[1] === t2[1];
}
function ge(e2) {
  return Math.hypot(e2[0], e2[1]);
}
function de(e2) {
  return e2[0] * e2[0] + e2[1] * e2[1];
}
function A(e2, t2) {
  return de(a3(e2, t2));
}
function G(e2) {
  return he(e2, ge(e2));
}
function ie(e2, t2) {
  return Math.hypot(e2[1] - t2[1], e2[0] - t2[0]);
}
function L2(e2, t2, u2) {
  let x3 = Math.sin(u2), h3 = Math.cos(u2), y2 = e2[0] - t2[0], n2 = e2[1] - t2[1], f2 = y2 * h3 - n2 * x3, d2 = y2 * x3 + n2 * h3;
  return [f2 + t2[0], d2 + t2[1]];
}
function K2(e2, t2, u2) {
  return l3(e2, b3(a3(t2, e2), u2));
}
function ee2(e2, t2, u2) {
  return l3(e2, b3(t2, u2));
}
var { min: C2, PI: xe } = Math;
var pe = 0.275;
var V2 = xe + 0.0001;
function ce(e2, t2 = {}) {
  let { size: u2 = 16, smoothing: x3 = 0.5, thinning: h3 = 0.5, simulatePressure: y2 = true, easing: n2 = (r3) => r3, start: f2 = {}, end: d2 = {}, last: D2 = false } = t2, { cap: S2 = true, easing: j = (r3) => r3 * (2 - r3) } = f2, { cap: q2 = true, easing: c3 = (r3) => --r3 * r3 * r3 + 1 } = d2;
  if (e2.length === 0 || u2 <= 0)
    return [];
  let p3 = e2[e2.length - 1].runningLength, g2 = f2.taper === false ? 0 : f2.taper === true ? Math.max(u2, p3) : f2.taper, T2 = d2.taper === false ? 0 : d2.taper === true ? Math.max(u2, p3) : d2.taper, te2 = Math.pow(u2 * x3, 2), _2 = [], M = [], H = e2.slice(0, 10).reduce((r3, i3) => {
    let o3 = i3.pressure;
    if (y2) {
      let s2 = C2(1, i3.distance / u2), W = C2(1, 1 - s2);
      o3 = C2(1, r3 + (W - r3) * (s2 * pe));
    }
    return (r3 + o3) / 2;
  }, e2[0].pressure), m3 = $2(u2, h3, e2[e2.length - 1].pressure, n2), U, X3 = e2[0].vector, z = e2[0].point, F2 = z, O = z, E = F2, J2 = false;
  for (let r3 = 0;r3 < e2.length; r3++) {
    let { pressure: i3 } = e2[r3], { point: o3, vector: s2, distance: W, runningLength: I2 } = e2[r3];
    if (r3 < e2.length - 1 && p3 - I2 < 3)
      continue;
    if (h3) {
      if (y2) {
        let v2 = C2(1, W / u2), Z = C2(1, 1 - v2);
        i3 = C2(1, H + (Z - H) * (v2 * pe));
      }
      m3 = $2(u2, h3, i3, n2);
    } else
      m3 = u2 / 2;
    U === undefined && (U = m3);
    let le = I2 < g2 ? j(I2 / g2) : 1, fe = p3 - I2 < T2 ? c3((p3 - I2) / T2) : 1;
    m3 = Math.max(0.01, m3 * Math.min(le, fe));
    let re2 = (r3 < e2.length - 1 ? e2[r3 + 1] : e2[r3]).vector, Y2 = r3 < e2.length - 1 ? B(s2, re2) : 1, be = B(s2, X3) < 0 && !J2, ne2 = Y2 !== null && Y2 < 0;
    if (be || ne2) {
      let v2 = b3(R2(X3), m3);
      for (let Z = 1 / 13, w2 = 0;w2 <= 1; w2 += Z)
        O = L2(a3(o3, v2), o3, V2 * w2), _2.push(O), E = L2(l3(o3, v2), o3, V2 * -w2), M.push(E);
      z = O, F2 = E, ne2 && (J2 = true);
      continue;
    }
    if (J2 = false, r3 === e2.length - 1) {
      let v2 = b3(R2(s2), m3);
      _2.push(a3(o3, v2)), M.push(l3(o3, v2));
      continue;
    }
    let oe = b3(R2(K2(re2, s2, Y2)), m3);
    O = a3(o3, oe), (r3 <= 1 || A(z, O) > te2) && (_2.push(O), z = O), E = l3(o3, oe), (r3 <= 1 || A(F2, E) > te2) && (M.push(E), F2 = E), H = i3, X3 = s2;
  }
  let P = e2[0].point.slice(0, 2), k2 = e2.length > 1 ? e2[e2.length - 1].point.slice(0, 2) : l3(e2[0].point, [1, 1]), Q2 = [], N = [];
  if (e2.length === 1) {
    if (!(g2 || T2) || D2) {
      let r3 = ee2(P, G(R2(a3(P, k2))), -(U || m3)), i3 = [];
      for (let o3 = 1 / 13, s2 = o3;s2 <= 1; s2 += o3)
        i3.push(L2(r3, P, V2 * 2 * s2));
      return i3;
    }
  } else {
    if (!(g2 || T2 && e2.length === 1))
      if (S2)
        for (let i3 = 1 / 13, o3 = i3;o3 <= 1; o3 += i3) {
          let s2 = L2(M[0], P, V2 * o3);
          Q2.push(s2);
        }
      else {
        let i3 = a3(_2[0], M[0]), o3 = b3(i3, 0.5), s2 = b3(i3, 0.51);
        Q2.push(a3(P, o3), a3(P, s2), l3(P, s2), l3(P, o3));
      }
    let r3 = R2(se(e2[e2.length - 1].vector));
    if (T2 || g2 && e2.length === 1)
      N.push(k2);
    else if (q2) {
      let i3 = ee2(k2, r3, m3);
      for (let o3 = 1 / 29, s2 = o3;s2 < 1; s2 += o3)
        N.push(L2(i3, k2, V2 * 3 * s2));
    } else
      N.push(l3(k2, b3(r3, m3)), l3(k2, b3(r3, m3 * 0.99)), a3(k2, b3(r3, m3 * 0.99)), a3(k2, b3(r3, m3)));
  }
  return _2.concat(N, M.reverse(), Q2);
}
function me(e2, t2 = {}) {
  var q2;
  let { streamline: u2 = 0.5, size: x3 = 16, last: h3 = false } = t2;
  if (e2.length === 0)
    return [];
  let y2 = 0.15 + (1 - u2) * 0.85, n2 = Array.isArray(e2[0]) ? e2 : e2.map(({ x: c3, y: p3, pressure: g2 = 0.5 }) => [c3, p3, g2]);
  if (n2.length === 2) {
    let c3 = n2[1];
    n2 = n2.slice(0, -1);
    for (let p3 = 1;p3 < 5; p3++)
      n2.push(K2(n2[0], c3, p3 / 4));
  }
  n2.length === 1 && (n2 = [...n2, [...l3(n2[0], [1, 1]), ...n2[0].slice(2)]]);
  let f2 = [{ point: [n2[0][0], n2[0][1]], pressure: n2[0][2] >= 0 ? n2[0][2] : 0.25, vector: [1, 1], distance: 0, runningLength: 0 }], d2 = false, D2 = 0, S2 = f2[0], j = n2.length - 1;
  for (let c3 = 1;c3 < n2.length; c3++) {
    let p3 = h3 && c3 === j ? n2[c3].slice(0, 2) : K2(S2.point, n2[c3], y2);
    if (ue(S2.point, p3))
      continue;
    let g2 = ie(p3, S2.point);
    if (D2 += g2, c3 < j && !d2) {
      if (D2 < x3)
        continue;
      d2 = true;
    }
    S2 = { point: p3, pressure: n2[c3][2] >= 0 ? n2[c3][2] : 0.5, vector: G(a3(S2.point, p3)), distance: g2, runningLength: D2 }, f2.push(S2);
  }
  return f2[0].vector = ((q2 = f2[1]) == null ? undefined : q2.vector) || [0, 0], f2;
}
function ae(e2, t2 = {}) {
  return ce(me(e2, t2), t2);
}

// ../../src/utils/handwriting.ts
function buildStrokeConfig(width, usePressureSim) {
  return {
    size: width * 4.25,
    thinning: 0.6,
    smoothing: 0.5,
    streamline: 0.5,
    easing: (t2) => Math.sin(t2 * Math.PI / 2),
    simulatePressure: usePressureSim,
    last: true
  };
}
function buildPathData(points) {
  if (!points.length)
    return "";
  const max2 = points.length - 1;
  const midPoint = (a4, b4) => [(a4[0] + b4[0]) / 2, (a4[1] + b4[1]) / 2];
  let path = `M ${points[0][0].toFixed(2)} ${points[0][1].toFixed(2)} Q`;
  for (let i3 = 0;i3 < points.length; i3++) {
    const point = points[i3];
    if (i3 === max2) {
      const mid = midPoint(point, points[0]);
      path += ` ${point[0].toFixed(2)} ${point[1].toFixed(2)}`;
      path += ` ${mid[0].toFixed(2)} ${mid[1].toFixed(2)}`;
      path += ` L ${points[0][0].toFixed(2)} ${points[0][1].toFixed(2)} Z`;
    } else {
      const mid = midPoint(point, points[i3 + 1]);
      path += ` ${point[0].toFixed(2)} ${point[1].toFixed(2)}`;
      path += ` ${mid[0].toFixed(2)} ${mid[1].toFixed(2)}`;
    }
  }
  return path;
}
function toPointPairs(flat) {
  const points = [];
  for (let i3 = 0;i3 < flat.length; i3 += 2) {
    points.push([flat[i3], flat[i3 + 1]]);
  }
  return points;
}
function createHandwritingPath(flatPoints, width, pressure, usePressureSim = true) {
  if (flatPoints.length < 4)
    return "";
  const points = toPointPairs(flatPoints);
  const inputPoints = usePressureSim || !pressure ? points : points.map((p3, i3) => [...p3, pressure[i3] ?? 0.5]);
  const config = buildStrokeConfig(width, usePressureSim);
  const outlinePoints = ae(inputPoints, config);
  if (outlinePoints.length === 0)
    return "";
  return buildPathData(outlinePoints);
}

// ../../src/features/konva-editor/renderers/print/ReportPrintLayout.tsx
var jsx_dev_runtime52 = __toESM(require_jsx_dev_runtime(), 1);
var mmToPtValue = (mm) => mmToPt(mm ?? 0);
var mmPt = (mm) => `${mmToPtValue(mm)}pt`;
var RenderSignature = ({ element }) => {
  const { strokes, stroke, strokeW } = element;
  const pathDataList = import_react28.useMemo(() => {
    return strokes.map((strokePoints, i3) => createHandwritingPath(strokePoints.map((value) => mmToPt(value)), mmToPtValue(strokeW), element.pressureData?.[i3], (element.usePressureSim ?? true) || !(element.pressureData?.[i3]?.length ?? 0)));
  }, [strokes, strokeW, element.pressureData, element.usePressureSim]);
  return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("svg", {
    width: "100%",
    height: "100%",
    viewBox: `0 0 ${mmToPtValue(element.w)} ${mmToPtValue(element.h)}`,
    style: { overflow: "visible" },
    children: pathDataList.map((pathData, i3) => pathData && /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("path", {
      d: pathData,
      fill: stroke || "#000"
    }, i3, false, undefined, this))
  }, undefined, false, undefined, this);
};
var RenderShape = ({ element }) => {
  const { shape } = element;
  const width = mmToPtValue(element.w);
  const height = mmToPtValue(element.h);
  const fill = element.fill || "none";
  const stroke = element.stroke || "none";
  const strokeWidth = mmToPtValue(element.strokeW || 1);
  switch (shape) {
    case "rect":
      return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("rect", {
        x: 0,
        y: 0,
        width,
        height,
        fill,
        stroke,
        strokeWidth,
        rx: mmToPtValue(element.radius)
      }, undefined, false, undefined, this);
    case "circle":
      return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("ellipse", {
        cx: width / 2,
        cy: height / 2,
        rx: width / 2,
        ry: height / 2,
        fill,
        stroke,
        strokeWidth
      }, undefined, false, undefined, this);
    case "triangle": {
      const points = `${width / 2}, 0 ${width},${height} 0, ${height} `;
      return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("polygon", {
        points,
        fill,
        stroke,
        strokeWidth
      }, undefined, false, undefined, this);
    }
    case "diamond": {
      const points = `${width / 2}, 0 ${width},${height / 2} ${width / 2},${height} 0, ${height / 2} `;
      return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("polygon", {
        points,
        fill,
        stroke,
        strokeWidth
      }, undefined, false, undefined, this);
    }
    case "arrow-u":
      return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("path", {
        d: "M12 4l-8 8h6v8h4v-8h6z",
        fill,
        stroke,
        strokeWidth,
        transform: `scale(${width / 24}, ${height / 24})`,
        vectorEffect: "non-scaling-stroke"
      }, undefined, false, undefined, this);
    default:
      return null;
  }
};
var RenderLine = ({ element }) => {
  const { pts, stroke, strokeW } = element;
  if (!pts)
    return null;
  const ptsPt = [];
  for (let i3 = 0;i3 < pts.length; i3++) {
    ptsPt.push(mmToPt(pts[i3]));
  }
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (let i3 = 0;i3 < ptsPt.length; i3 += 2) {
    if (ptsPt[i3] < minX)
      minX = ptsPt[i3];
    if (ptsPt[i3] > maxX)
      maxX = ptsPt[i3];
    if (ptsPt[i3 + 1] < minY)
      minY = ptsPt[i3 + 1];
    if (ptsPt[i3 + 1] > maxY)
      maxY = ptsPt[i3 + 1];
  }
  const width = Math.abs(maxX - minX);
  const height = Math.abs(maxY - minY);
  const relativePts = [];
  for (let i3 = 0;i3 < ptsPt.length; i3 += 2) {
    relativePts.push(`${ptsPt[i3] - minX},${ptsPt[i3 + 1] - minY}`);
  }
  return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("svg", {
    width: `${width + 20}pt`,
    height: `${height + 20}pt`,
    viewBox: `0 0 ${width + 20} ${height + 20}`,
    style: { overflow: "visible", position: "absolute", left: `${minX}pt`, top: `${minY}pt` },
    children: /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("polyline", {
      points: relativePts.join(" "),
      stroke,
      strokeWidth: mmToPtValue(strokeW),
      fill: "none"
    }, undefined, false, undefined, this)
  }, undefined, false, undefined, this);
};
var RenderTable = ({ element }) => {
  const { table } = element;
  const { rows, cols, cells } = table;
  const rowCount = rows.length;
  const colCount = cols.length;
  const occupied = Array(rowCount).fill(null).map(() => Array(colCount).fill(false));
  return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("table", {
    style: {
      width: mmPt(element.w),
      height: mmPt(element.h),
      borderCollapse: "collapse",
      tableLayout: "fixed",
      position: "absolute",
      left: mmPt(element.x),
      top: mmPt(element.y)
    },
    children: [
      /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("colgroup", {
        children: cols.map((w2, i3) => /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("col", {
          style: { width: mmPt(w2) }
        }, i3, false, undefined, this))
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("tbody", {
        children: rows.map((h3, rowIndex) => /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("tr", {
          style: { height: mmPt(h3) },
          children: cols.map((_2, colIndex) => {
            if (occupied[rowIndex][colIndex])
              return null;
            const cell = cells.find((c3) => c3.r === rowIndex && c3.c === colIndex);
            const rowSpan = cell?.rs || 1;
            const colSpan = cell?.cs || 1;
            if (rowSpan > 1 || colSpan > 1) {
              for (let r3 = 0;r3 < rowSpan; r3++) {
                for (let c3 = 0;c3 < colSpan; c3++) {
                  if (rowIndex + r3 < rowCount && colIndex + c3 < colCount) {
                    occupied[rowIndex + r3][colIndex + c3] = true;
                  }
                }
              }
            }
            if (!cell)
              return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("td", {}, `${rowIndex}-${colIndex}`, false, undefined, this);
            const fontSize = cell.fontSize ?? ptToMm(12);
            const borderW = cell.borderW ?? (cell.border ? 0.2 : 0.2);
            const borderColor = cell.borderColor || cell.border || "#ccc";
            return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("td", {
              colSpan,
              rowSpan,
              style: {
                border: borderW > 0 ? `${mmToPtValue(borderW)}pt solid ${borderColor}` : "none",
                backgroundColor: cell.bg || "transparent",
                fontFamily: cell.font || "Helvetica",
                fontSize: `${mmToPtValue(fontSize)}pt`,
                textAlign: cell.align === "r" ? "right" : cell.align === "c" ? "center" : "left",
                verticalAlign: cell.vAlign === "b" ? "bottom" : cell.vAlign === "m" ? "middle" : "top",
                color: cell.color || "#000000",
                padding: "4pt",
                wordBreak: "break-word",
                whiteSpace: "pre-wrap"
              },
              children: cell.v
            }, `${rowIndex}-${colIndex}`, false, undefined, this);
          })
        }, rowIndex, false, undefined, this))
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
var PrintElement = ({ element }) => {
  const [imageSrc, setImageSrc] = import_react28.useState(null);
  import_react28.useEffect(() => {
    if (element.t === "image") {
      const imageEl = element;
      if (imageEl.src) {
        if (imageEl.src.startsWith("http") || imageEl.src.startsWith("data:")) {
          setImageSrc(imageEl.src);
        } else {
          findImageWithExtension(imageEl.src).then((res) => {
            if (res)
              setImageSrc(res.url);
          });
        }
      } else {
        setImageSrc(null);
      }
    }
  }, [element]);
  if (element.hidden)
    return null;
  if (element.t === "line")
    return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV(RenderLine, {
      element
    }, undefined, false, undefined, this);
  if (!("x" in element))
    return null;
  const style = {
    position: "absolute",
    left: mmPt(element.x),
    top: mmPt(element.y),
    width: mmPt(element.w),
    height: mmPt(element.h),
    transform: element.r ? `rotate(${element.r}deg)` : undefined
  };
  if (element.t === "text") {
    const textEl = element;
    const numberMarkerScale = 0.75;
    const fontSizeMm = textEl.fontSize ?? ptToMm(12);
    const lineHeight = 1.2;
    const textAlign = textEl.align === "r" ? "right" : textEl.align === "c" ? "center" : "left";
    const vAlign = textEl.vAlign === "b" ? "flex-end" : textEl.vAlign === "m" ? "center" : "flex-start";
    const shouldShowBox = textEl.hasFrame !== undefined ? textEl.hasFrame : textEl.borderColor || textEl.borderWidth && textEl.borderWidth > 0 || textEl.backgroundColor;
    const borderStyle = shouldShowBox && textEl.borderWidth && textEl.borderWidth > 0 ? `${mmToPtValue(textEl.borderWidth)}pt solid ${textEl.borderColor || "#000"}` : "none";
    const backgroundColor = shouldShowBox && textEl.backgroundColor ? textEl.backgroundColor : "transparent";
    const radiusRatio = Math.max(0, Math.min(1, Number(textEl.cornerRadius || 0)));
    const minDim = Math.min(textEl.w, textEl.h);
    const actualRadius = minDim * radiusRatio * 0.5;
    const borderRadius = shouldShowBox && actualRadius > 0 ? `${mmToPtValue(actualRadius)}pt` : undefined;
    const renderListText = () => {
      if (textEl.vertical)
        return textEl.text;
      const lines = (textEl.text || "").split(`
`);
      const hasList = lines.some((line) => parseListLine(line, { vertical: false }).isList);
      if (!hasList)
        return textEl.text;
      return lines.map((line, index2) => {
        const parsed = parseListLine(line, { vertical: false });
        if (!parsed.isList || !parsed.type || !parsed.markerText) {
          return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("div", {
            children: line === "" ? "" : line
          }, `line-${index2}`, false, undefined, this);
        }
        const indentSpaces = " ".repeat(parsed.indentLength);
        const gapSpaces = " ".repeat(parsed.gapLength);
        const markerStyle = parsed.type === "number" ? {
          fontSize: `${mmToPtValue(fontSizeMm * numberMarkerScale)}pt`,
          verticalAlign: "middle",
          display: "inline-block"
        } : undefined;
        return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("div", {
          children: [
            indentSpaces,
            /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("span", {
              style: markerStyle,
              children: parsed.markerText
            }, undefined, false, undefined, this),
            gapSpaces,
            parsed.content === "" ? "" : parsed.content
          ]
        }, `list-line-${index2}`, true, undefined, this);
      });
    };
    if (textEl.vertical) {
      const padding = textEl.padding ?? 10;
      const COLUMN_SPACING = 1.5;
      const startX = textEl.w - padding - fontSizeMm * (COLUMN_SPACING / 2 + 0.5);
      const charMetrics = calculateVerticalLayout(textEl.text || "", startX, padding, {
        fontSize: fontSizeMm,
        columnSpacing: COLUMN_SPACING,
        letterSpacing: 0
      });
      return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("div", {
        style,
        children: /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("div", {
          style: {
            position: "relative",
            width: "100%",
            height: "100%",
            border: borderStyle,
            backgroundColor,
            borderRadius,
            boxSizing: "border-box"
          },
          children: charMetrics.map((metric, index2) => /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("div", {
            style: {
              position: "absolute",
              left: `${mmToPtValue(metric.x + metric.offsetX)}pt`,
              top: `${mmToPtValue(metric.y + metric.offsetY)}pt`,
              fontSize: `${mmToPtValue(fontSizeMm)}pt`,
              fontFamily: textEl.font,
              color: textEl.fill,
              width: `${mmToPtValue(fontSizeMm)}pt`,
              height: `${mmToPtValue(fontSizeMm)}pt`,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              transform: metric.rotation ? `rotate(${metric.rotation}deg)` : undefined,
              lineHeight: 1,
              whiteSpace: "pre"
            },
            children: metric.char
          }, index2, false, undefined, this))
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this);
    }
    return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("div", {
      style: {
        ...style,
        fontSize: `${mmToPtValue(fontSizeMm)}pt`,
        fontWeight: textEl.fontWeight,
        fontStyle: textEl.italic ? "italic" : "normal",
        textDecoration: [
          textEl.underline ? "underline" : "",
          textEl.lineThrough ? "line-through" : ""
        ].filter(Boolean).join(" "),
        color: textEl.fill,
        fontFamily: textEl.font,
        display: "flex",
        flexDirection: "column",
        alignItems: "stretch",
        justifyContent: vAlign,
        whiteSpace: "pre",
        lineHeight,
        border: borderStyle,
        backgroundColor,
        borderRadius,
        padding: textEl.padding ? `${mmToPtValue(textEl.padding)}pt` : undefined,
        boxSizing: "border-box"
      },
      children: /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("div", {
        style: { width: "100%", textAlign },
        children: renderListText()
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this);
  }
  if (element.t === "shape") {
    return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("div", {
      style,
      children: /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("svg", {
        width: "100%",
        height: "100%",
        viewBox: `0 0 ${mmToPtValue(element.w)} ${mmToPtValue(element.h)}`,
        style: { overflow: "visible" },
        children: /* @__PURE__ */ jsx_dev_runtime52.jsxDEV(RenderShape, {
          element
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this);
  }
  if (element.t === "image") {
    return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("div", {
      style,
      children: imageSrc ? /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("img", {
        src: imageSrc,
        style: { width: "100%", height: "100%", objectFit: "fill" },
        alt: ""
      }, undefined, false, undefined, this) : /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("div", {}, undefined, false, undefined, this)
    }, undefined, false, undefined, this);
  }
  if (element.t === "table") {
    return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV(RenderTable, {
      element
    }, undefined, false, undefined, this);
  }
  if (element.t === "signature") {
    return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("div", {
      style,
      children: /* @__PURE__ */ jsx_dev_runtime52.jsxDEV(RenderSignature, {
        element
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this);
  }
  return null;
};
var PrintLayout = import_react28.default.forwardRef(({ doc, orientation = "portrait" }, ref) => {
  const isLandscape = orientation === "landscape";
  const width = isLandscape ? "297mm" : "210mm";
  const height = isLandscape ? "210mm" : "297mm";
  const pageSize = isLandscape ? "297mm 210mm" : "210mm 297mm";
  const PrintPage = ({ surface, pageIndex }) => {
    const [bgImageSrc, setBgImageSrc] = import_react28.useState(null);
    import_react28.useEffect(() => {
      if (surface.bg && !surface.bg.startsWith("#")) {
        if (surface.bg.startsWith("http") || surface.bg.startsWith("data:")) {
          setBgImageSrc(surface.bg);
        } else {
          findImageWithExtension(surface.bg).then((res) => {
            if (res)
              setBgImageSrc(res.url);
          });
        }
      } else {
        setBgImageSrc(null);
      }
    }, [surface.bg]);
    return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("div", {
      className: "print-page",
      style: {
        backgroundColor: surface.bg?.startsWith("#") ? surface.bg : "white",
        width,
        height
      },
      children: [
        bgImageSrc && /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("img", {
          src: bgImageSrc,
          alt: "",
          style: {
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            objectFit: "fill",
            zIndex: 0
          }
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("div", {
          style: { position: "relative", zIndex: 1, width: "100%", height: "100%" },
          children: doc.nodes.filter((el) => el.s === surface.id).map((element) => /* @__PURE__ */ jsx_dev_runtime52.jsxDEV(PrintElement, {
            element
          }, element.id, false, undefined, this))
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("div", {
          style: {
            position: "absolute",
            bottom: "10mm",
            right: "10mm",
            fontSize: "10pt",
            color: "#666",
            zIndex: 2
          },
          children: [
            pageIndex + 1,
            " / ",
            doc.surfaces.length
          ]
        }, undefined, true, undefined, this)
      ]
    }, undefined, true, undefined, this);
  };
  return /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("div", {
    ref,
    className: "print-container",
    style: { width },
    children: [
      /* @__PURE__ */ jsx_dev_runtime52.jsxDEV("style", {
        children: `@media print { @page { size: ${pageSize}; margin: 0; } }`
      }, undefined, false, undefined, this),
      doc.surfaces.map((surface, index2) => /* @__PURE__ */ jsx_dev_runtime52.jsxDEV(PrintPage, {
        surface,
        pageIndex: index2
      }, surface.id, false, undefined, this))
    ]
  }, undefined, true, undefined, this);
});

// ../../src/features/konva-editor/renderers/print/BedPrintLayout.tsx
var jsx_dev_runtime53 = __toESM(require_jsx_dev_runtime(), 1);
var mmToPtValue2 = (mm) => mmToPt(mm ?? 0);
var mmPt2 = (mm) => `${mmToPtValue2(mm)}pt`;
var RenderBed = ({ element }) => {
  const { t: t2 } = useI18n();
  const data = element.data || {};
  const patientName = data.patientName || "";
  const bloodPressure = data.bloodPressure || "";
  const label = data.label || t2("toolbar_bed", "Bed");
  const strokeColor = "#3b82f6";
  const bgColor = "#ffffff";
  const rawBorderW = data.borderW;
  const strokeWidth = typeof rawBorderW === "number" && Number.isFinite(rawBorderW) ? Math.max(0, rawBorderW) : 0.4;
  const pillowStyle = {
    top: "10%",
    left: "5pt",
    width: "20pt",
    height: "80%"
  };
  const textHalo = "2px 0 0 white, -2px 0 0 white, 0 2px 0 white, 0 -2px 0 white, 1px 1px 0 white, -1px -1px 0 white, 1px -1px 0 white, -1px 1px 0 white";
  const cornerR = 1;
  const pillowR = 0.5;
  return /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("div", {
    style: {
      width: "100%",
      height: "100%",
      backgroundColor: bgColor,
      border: `${mmToPtValue2(strokeWidth)}pt solid ${strokeColor}`,
      borderRadius: mmPt2(cornerR),
      position: "relative",
      boxSizing: "border-box",
      overflow: "hidden",
      fontFamily: '"Meiryo", sans-serif'
    },
    children: [
      /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("div", {
        style: {
          position: "absolute",
          backgroundColor: "#e5e7eb",
          borderRadius: mmPt2(pillowR),
          opacity: 0.5,
          ...pillowStyle
        }
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("div", {
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          pointerEvents: "none"
        },
        children: [
          /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("div", {
            style: {
              fontSize: "18pt",
              fontWeight: "bold",
              color: "#374151",
              textShadow: textHalo,
              lineHeight: 1,
              textAlign: "center",
              marginBottom: patientName ? "0" : "0"
            },
            children: label
          }, undefined, false, undefined, this),
          patientName && /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("div", {
            style: {
              fontSize: "18pt",
              fontWeight: "bold",
              color: "#000000",
              textShadow: textHalo,
              lineHeight: 1,
              textAlign: "center",
              marginTop: "18pt"
            },
            children: patientName
          }, undefined, false, undefined, this),
          bloodPressure && /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("div", {
            style: {
              fontSize: "18pt",
              color: "#000000",
              textShadow: textHalo,
              lineHeight: 1,
              textAlign: "center",
              marginTop: "18pt"
            },
            children: bloodPressure
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
var BedPrintElement = ({ element, i18nOverrides }) => {
  const { t: t2 } = useI18n();
  const resolveText = (key, defaultValue) => {
    if (i18nOverrides?.[key])
      return i18nOverrides[key];
    return t2(key, defaultValue ?? key);
  };
  const [imageSrc, setImageSrc] = import_react29.useState(null);
  import_react29.useEffect(() => {
    if (element.t === "image") {
      const img = element;
      if (img.src) {
        if (img.src.startsWith("http") || img.src.startsWith("data:")) {
          setImageSrc(img.src);
        } else {
          findImageWithExtension(img.src).then((res) => {
            if (res)
              setImageSrc(res.url);
          });
        }
      }
    }
  }, [element]);
  if (element.hidden)
    return null;
  if (element.t === "line") {
    return /* @__PURE__ */ jsx_dev_runtime53.jsxDEV(RenderLine, {
      element
    }, undefined, false, undefined, this);
  }
  if (!("x" in element))
    return null;
  const style = {
    position: "absolute",
    left: mmPt2(element.x),
    top: mmPt2(element.y),
    width: mmPt2(element.w),
    height: mmPt2(element.h),
    transform: element.r ? `rotate(${element.r}deg)` : undefined
  };
  if (element.t === "widget" && element.widget === "bed") {
    return /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("div", {
      style,
      children: /* @__PURE__ */ jsx_dev_runtime53.jsxDEV(RenderBed, {
        element
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this);
  }
  if (element.t === "text") {
    const textEl = element;
    const numberMarkerScale = 0.75;
    const fontSizeMm = textEl.fontSize ?? ptToMm(12);
    const lineHeight = 1.2;
    const textAlign = textEl.align === "r" ? "right" : textEl.align === "c" ? "center" : "left";
    const renderListText = () => {
      if (textEl.vertical)
        return textEl.text;
      const lines = (textEl.text || "").split(`
`);
      const hasList = lines.some((line) => parseListLine(line, { vertical: false }).isList);
      if (!hasList)
        return textEl.text;
      return lines.map((line, index2) => {
        const parsed = parseListLine(line, { vertical: false });
        if (!parsed.isList || !parsed.type || !parsed.markerText) {
          return /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("div", {
            children: line === "" ? "" : line
          }, `line-${index2}`, false, undefined, this);
        }
        const indentSpaces = " ".repeat(parsed.indentLength);
        const gapSpaces = " ".repeat(parsed.gapLength);
        const markerStyle = parsed.type === "number" ? {
          fontSize: `${mmToPtValue2(fontSizeMm * numberMarkerScale)}pt`,
          verticalAlign: "middle",
          display: "inline-block"
        } : undefined;
        return /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("div", {
          children: [
            indentSpaces,
            /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("span", {
              style: markerStyle,
              children: parsed.markerText
            }, undefined, false, undefined, this),
            gapSpaces,
            parsed.content === "" ? "" : parsed.content
          ]
        }, `list-line-${index2}`, true, undefined, this);
      });
    };
    return /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("div", {
      style: {
        ...style,
        fontSize: `${mmToPtValue2(fontSizeMm)}pt`,
        fontWeight: textEl.fontWeight,
        fontStyle: textEl.italic ? "italic" : "normal",
        textDecoration: [
          textEl.underline ? "underline" : "",
          textEl.lineThrough ? "line-through" : ""
        ].filter(Boolean).join(" "),
        color: textEl.fill,
        fontFamily: '"Meiryo", "Hiragino Kaku Gothic ProN", "MS PGothic", sans-serif',
        display: "flex",
        flexDirection: "column",
        alignItems: "stretch",
        justifyContent: "flex-start",
        whiteSpace: "pre",
        lineHeight
      },
      children: /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("div", {
        style: { width: "100%", textAlign },
        children: renderListText()
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this);
  }
  if (element.t === "shape") {
    return /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("div", {
      style,
      children: /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("svg", {
        width: "100%",
        height: "100%",
        viewBox: `0 0 ${mmToPtValue2(element.w)} ${mmToPtValue2(element.h)}`,
        style: { overflow: "visible" },
        children: [
          /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("title", {
            children: resolveText("properties_preview", "Preview")
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime53.jsxDEV(RenderShape, {
            element
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    }, undefined, false, undefined, this);
  }
  if (element.t === "image") {
    return /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("div", {
      style,
      children: imageSrc ? /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("img", {
        src: imageSrc,
        alt: resolveText("properties_preview", "Preview"),
        style: {
          width: "100%",
          height: "100%",
          objectFit: "fill",
          display: "block",
          opacity: element.opacity ?? 1
        }
      }, undefined, false, undefined, this) : /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("div", {
        style: {
          width: "100%",
          height: "100%",
          border: "1pt dashed gray",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          fontSize: "10pt",
          color: "gray"
        },
        children: resolveText("no_image", "No Image")
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this);
  }
  return null;
};
var BedPrintLayout = import_react29.default.forwardRef(({ document: document2, i18nOverrides, surfaceId }, ref) => {
  const resolvedSurfaceId = surfaceId || document2.surfaces.find((s2) => s2.type === "canvas")?.id || document2.surfaces[0]?.id || "layout";
  const surface = document2.surfaces.find((s2) => s2.id === resolvedSurfaceId) || document2.surfaces[0];
  const width = surface?.w ?? 0;
  const height = surface?.h ?? 0;
  const pageSize = `${width}mm ${height}mm`;
  const nodes = document2.nodes.filter((n2) => n2.s === resolvedSurfaceId);
  return /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("div", {
    ref,
    className: "print-container",
    children: [
      /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("style", {
        children: `@media print { @page { size: ${pageSize}; margin: 0; } }`
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime53.jsxDEV("div", {
        className: "print-page",
        style: {
          width: mmPt2(width),
          height: mmPt2(height),
          backgroundColor: "white",
          position: "relative",
          overflow: "hidden"
        },
        children: nodes.map((element) => /* @__PURE__ */ jsx_dev_runtime53.jsxDEV(BedPrintElement, {
          element,
          i18nOverrides
        }, element.id, false, undefined, this))
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
// ../../src/features/konva-editor/viewers/BedLayoutViewer.tsx
var jsx_dev_runtime54 = __toESM(require_jsx_dev_runtime(), 1);
var BedLayoutViewer = ({
  document: document2,
  dashboardData,
  zoom,
  surfaceId
}) => {
  const resolvedSurfaceId = surfaceId || document2.surfaces.find((s2) => s2.type === "canvas")?.id || document2.surfaces[0]?.id || "layout";
  const surface = document2.surfaces.find((s2) => s2.id === resolvedSurfaceId) || document2.surfaces[0];
  const paperWidth = surface?.w ?? 0;
  const paperHeight = surface?.h ?? 0;
  const elements = document2.nodes.filter((n2) => n2.s === resolvedSurfaceId);
  return /* @__PURE__ */ jsx_dev_runtime54.jsxDEV(KonvaViewer, {
    elements,
    zoom,
    paperWidth,
    paperHeight,
    background: /* @__PURE__ */ jsx_dev_runtime54.jsxDEV(PaperBackground, {
      document: document2,
      surfaceId: resolvedSurfaceId
    }, undefined, false, undefined, this),
    overlay: elements.filter((n2) => n2.t === "widget" && n2.widget === "bed").map((n2) => {
      const bed = n2;
      const bedStatus = dashboardData ? dashboardData[bed.id] : undefined;
      return /* @__PURE__ */ jsx_dev_runtime54.jsxDEV(BedOverlayText, {
        element: bed,
        bedStatus
      }, `${bed.id}__overlay`, false, undefined, this);
    }),
    renderCustom: (el, commonProps, handleShapeRef) => {
      if (el.t === "widget" && el.widget === "bed") {
        const { ref: _ignoredRef, ...propsWithoutRef } = commonProps;
        const bedStatus = dashboardData ? dashboardData[el.id] : undefined;
        return /* @__PURE__ */ jsx_dev_runtime54.jsxDEV(BedElement, {
          ...propsWithoutRef,
          element: el,
          isSelected: false,
          shapeRef: handleShapeRef,
          bedStatus,
          enableStatusStyling: Boolean(dashboardData),
          renderText: false
        }, undefined, false, undefined, this);
      }
      return null;
    }
  }, undefined, false, undefined, this);
};
// ../../src/features/report-editor/components/Modals/ShortcutHelpModal.tsx
var import_react30 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/@radix-ui+react-dialog@1.1.15_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react_66d7d575cbd072ce29e52afb89085e9d/node_modules/@radix-ui/react-dialog/dist/index.mjs
var React49 = __toESM(require_react(), 1);
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
"use client";
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React49.useRef(null);
  const contentRef = React49.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DIALOG_NAME
  });
  return /* @__PURE__ */ import_jsx_runtime19.jsx(DialogProvider, {
    scope: __scopeDialog,
    triggerRef,
    contentRef,
    contentId: useId2(),
    titleId: useId2(),
    descriptionId: useId2(),
    open,
    onOpenChange: setOpen,
    onOpenToggle: React49.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
    modal,
    children
  });
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME4 = "DialogTrigger";
var DialogTrigger = React49.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...triggerProps } = props;
  const context = useDialogContext(TRIGGER_NAME4, __scopeDialog);
  const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
  return /* @__PURE__ */ import_jsx_runtime19.jsx(Primitive.button, {
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": context.open,
    "aria-controls": context.contentId,
    "data-state": getState2(context.open),
    ...triggerProps,
    ref: composedTriggerRef,
    onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
  });
});
DialogTrigger.displayName = TRIGGER_NAME4;
var PORTAL_NAME6 = "DialogPortal";
var [PortalProvider4, usePortalContext4] = createDialogContext(PORTAL_NAME6, {
  forceMount: undefined
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME6, __scopeDialog);
  return /* @__PURE__ */ import_jsx_runtime19.jsx(PortalProvider4, { scope: __scopeDialog, forceMount, children: React49.Children.map(children, (child) => /* @__PURE__ */ import_jsx_runtime19.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ import_jsx_runtime19.jsx(Portal, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME6;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = React49.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext4(OVERLAY_NAME, props.__scopeDialog);
  const { forceMount = portalContext.forceMount, ...overlayProps } = props;
  const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
  return context.modal ? /* @__PURE__ */ import_jsx_runtime19.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ import_jsx_runtime19.jsx(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
});
DialogOverlay.displayName = OVERLAY_NAME;
var Slot4 = createSlot2("DialogOverlay.RemoveScroll");
var DialogOverlayImpl = React49.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...overlayProps } = props;
  const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
  return /* @__PURE__ */ import_jsx_runtime19.jsx(Combination_default, { as: Slot4, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ import_jsx_runtime19.jsx(Primitive.div, {
    "data-state": getState2(context.open),
    ...overlayProps,
    ref: forwardedRef,
    style: { pointerEvents: "auto", ...overlayProps.style }
  }) });
});
var CONTENT_NAME6 = "DialogContent";
var DialogContent = React49.forwardRef((props, forwardedRef) => {
  const portalContext = usePortalContext4(CONTENT_NAME6, props.__scopeDialog);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = useDialogContext(CONTENT_NAME6, props.__scopeDialog);
  return /* @__PURE__ */ import_jsx_runtime19.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ import_jsx_runtime19.jsx(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ import_jsx_runtime19.jsx(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
});
DialogContent.displayName = CONTENT_NAME6;
var DialogContentModal = React49.forwardRef((props, forwardedRef) => {
  const context = useDialogContext(CONTENT_NAME6, props.__scopeDialog);
  const contentRef = React49.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
  React49.useEffect(() => {
    const content = contentRef.current;
    if (content)
      return hideOthers(content);
  }, []);
  return /* @__PURE__ */ import_jsx_runtime19.jsx(DialogContentImpl, {
    ...props,
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
      event.preventDefault();
      context.triggerRef.current?.focus();
    }),
    onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      if (isRightClick)
        event.preventDefault();
    }),
    onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => event.preventDefault())
  });
});
var DialogContentNonModal = React49.forwardRef((props, forwardedRef) => {
  const context = useDialogContext(CONTENT_NAME6, props.__scopeDialog);
  const hasInteractedOutsideRef = React49.useRef(false);
  const hasPointerDownOutsideRef = React49.useRef(false);
  return /* @__PURE__ */ import_jsx_runtime19.jsx(DialogContentImpl, {
    ...props,
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (event) => {
      props.onCloseAutoFocus?.(event);
      if (!event.defaultPrevented) {
        if (!hasInteractedOutsideRef.current)
          context.triggerRef.current?.focus();
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
      hasPointerDownOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      props.onInteractOutside?.(event);
      if (!event.defaultPrevented) {
        hasInteractedOutsideRef.current = true;
        if (event.detail.originalEvent.type === "pointerdown") {
          hasPointerDownOutsideRef.current = true;
        }
      }
      const target = event.target;
      const targetIsTrigger = context.triggerRef.current?.contains(target);
      if (targetIsTrigger)
        event.preventDefault();
      if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
        event.preventDefault();
      }
    }
  });
});
var DialogContentImpl = React49.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
  const context = useDialogContext(CONTENT_NAME6, __scopeDialog);
  const contentRef = React49.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, contentRef);
  useFocusGuards();
  return /* @__PURE__ */ import_jsx_runtime19.jsxs(import_jsx_runtime19.Fragment, { children: [
    /* @__PURE__ */ import_jsx_runtime19.jsx(FocusScope, {
      asChild: true,
      loop: true,
      trapped: trapFocus,
      onMountAutoFocus: onOpenAutoFocus,
      onUnmountAutoFocus: onCloseAutoFocus,
      children: /* @__PURE__ */ import_jsx_runtime19.jsx(DismissableLayer, {
        role: "dialog",
        id: context.contentId,
        "aria-describedby": context.descriptionId,
        "aria-labelledby": context.titleId,
        "data-state": getState2(context.open),
        ...contentProps,
        ref: composedRefs,
        onDismiss: () => context.onOpenChange(false)
      })
    }),
    /* @__PURE__ */ import_jsx_runtime19.jsxs(import_jsx_runtime19.Fragment, { children: [
      /* @__PURE__ */ import_jsx_runtime19.jsx(TitleWarning, { titleId: context.titleId }),
      /* @__PURE__ */ import_jsx_runtime19.jsx(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
    ] })
  ] });
});
var TITLE_NAME = "DialogTitle";
var DialogTitle = React49.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...titleProps } = props;
  const context = useDialogContext(TITLE_NAME, __scopeDialog);
  return /* @__PURE__ */ import_jsx_runtime19.jsx(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
});
DialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription = React49.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...descriptionProps } = props;
  const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
  return /* @__PURE__ */ import_jsx_runtime19.jsx(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
});
DialogDescription.displayName = DESCRIPTION_NAME;
var CLOSE_NAME2 = "DialogClose";
var DialogClose = React49.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...closeProps } = props;
  const context = useDialogContext(CLOSE_NAME2, __scopeDialog);
  return /* @__PURE__ */ import_jsx_runtime19.jsx(Primitive.button, {
    type: "button",
    ...closeProps,
    ref: forwardedRef,
    onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
  });
});
DialogClose.displayName = CLOSE_NAME2;
function getState2(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext22(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME6,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React49.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle)
        console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React49.useEffect(() => {
    const describedById = contentRef.current?.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription)
        console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root6 = Dialog;
var Trigger4 = DialogTrigger;
var Portal5 = DialogPortal;
var Overlay = DialogOverlay;
var Content3 = DialogContent;
var Title = DialogTitle;
var Description = DialogDescription;
var Close = DialogClose;

// ../../src/components/ui/Modal.tsx
var React50 = __toESM(require_react(), 1);
var jsx_dev_runtime55 = __toESM(require_jsx_dev_runtime(), 1);
var Modal = React50.memo(React50.forwardRef(({
  children,
  trigger,
  title,
  description,
  footer,
  footerClassName,
  className,
  contentClassName,
  open,
  onOpenChange,
  onClose,
  defaultOpen,
  draggable = true,
  noHeader,
  noPadding,
  ...props
}, ref) => {
  const { t: t2 } = useI18n();
  const [position, setPosition] = React50.useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = React50.useState(false);
  const dragStartPos = React50.useRef({ x: 0, y: 0 });
  const [internalOpen, setInternalOpen] = React50.useState(defaultOpen || false);
  const isControlled = open !== undefined;
  const show = isControlled ? open : internalOpen;
  React50.useEffect(() => {
    if (!show) {
      setPosition({ x: 0, y: 0 });
      setIsDragging(false);
    }
  }, [show]);
  const handleOpenChange = (newOpen) => {
    if (!isControlled) {
      setInternalOpen(newOpen);
    }
    onOpenChange?.(newOpen);
    if (!newOpen && onClose) {
      onClose();
    }
  };
  const handleMouseDown = (e2) => {
    if (!draggable)
      return;
    setIsDragging(true);
    dragStartPos.current = {
      x: e2.clientX - position.x,
      y: e2.clientY - position.y
    };
  };
  React50.useEffect(() => {
    if (!isDragging)
      return;
    const handleMouseMove = (e2) => {
      setPosition({
        x: e2.clientX - dragStartPos.current.x,
        y: e2.clientY - dragStartPos.current.y
      });
    };
    const handleMouseUp = () => {
      setIsDragging(false);
    };
    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };
  }, [isDragging]);
  const modalContent = /* @__PURE__ */ jsx_dev_runtime55.jsxDEV(jsx_dev_runtime55.Fragment, {
    children: [
      !noHeader && /* @__PURE__ */ jsx_dev_runtime55.jsxDEV("div", {
        className: cn2("flex flex-col space-y-1.5 border-b border-border bg-secondary/50 flex-shrink-0", draggable && "cursor-move", noPadding ? "p-1" : "p-1.5"),
        role: "button",
        tabIndex: 0,
        "aria-label": t2("modal_drag_handle", "Drag modal"),
        onMouseDown: handleMouseDown,
        onKeyDown: (event) => {
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
          }
        },
        children: [
          /* @__PURE__ */ jsx_dev_runtime55.jsxDEV("div", {
            className: "flex items-center justify-between",
            children: [
              /* @__PURE__ */ jsx_dev_runtime55.jsxDEV(Title, {
                className: cn2("text-lg font-semibold leading-none tracking-tight text-foreground", !title && "sr-only"),
                children: title || t2("dialog", "Dialog")
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime55.jsxDEV(Close, {
                className: "rounded-full p-1 opacity-70 ring-offset-background transition-all hover:opacity-100 hover:bg-accent focus:outline-none disabled:pointer-events-none cursor-pointer",
                children: [
                  /* @__PURE__ */ jsx_dev_runtime55.jsxDEV(X, {
                    className: "h-5 w-5 text-foreground"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime55.jsxDEV("span", {
                    className: "sr-only",
                    children: t2("close", "Close")
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this),
          description && /* @__PURE__ */ jsx_dev_runtime55.jsxDEV(Description, {
            className: "text-sm text-muted-foreground",
            children: description
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime55.jsxDEV("div", {
        className: cn2("flex-1 overflow-y-auto", noPadding ? "p-0" : "p-6 pt-4", contentClassName),
        children
      }, undefined, false, undefined, this),
      footer && /* @__PURE__ */ jsx_dev_runtime55.jsxDEV("div", {
        className: cn2("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2 bg-background flex-shrink-0", "p-2", footerClassName),
        children: footer
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
  return /* @__PURE__ */ jsx_dev_runtime55.jsxDEV(Root6, {
    open: show,
    onOpenChange: handleOpenChange,
    ...props,
    children: [
      trigger && /* @__PURE__ */ jsx_dev_runtime55.jsxDEV(Trigger4, {
        asChild: true,
        children: trigger
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime55.jsxDEV(Portal5, {
        children: [
          /* @__PURE__ */ jsx_dev_runtime55.jsxDEV(Overlay, {
            className: "fixed inset-0 z-50 bg-black/50 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime55.jsxDEV(Content3, {
            ref,
            ...!description ? { "aria-describedby": undefined } : {},
            className: cn2("fixed z-50 flex flex-col gap-0 bg-background", !draggable && "duration-200", !draggable && "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0", !draggable && "bottom-0 left-0 right-0 w-full h-[90vh] rounded-t-xl border-t border-border", !draggable && "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom", draggable && "left-[50%] top-[50%] h-auto max-h-[90vh] w-[90vw] max-w-lg rounded-md border border-border", !draggable && "sm:left-[50%] sm:top-[50%] sm:bottom-auto sm:right-auto sm:h-auto sm:max-h-[90vh] sm:max-w-lg sm:rounded-md sm:border sm:border-border", !draggable && "sm:data-[state=closed]:zoom-out-95 sm:data-[state=open]:zoom-in-95", !draggable && "sm:data-[state=closed]:slide-out-to-left-1/2 sm:data-[state=closed]:slide-out-to-top-[48%]", !draggable && "sm:data-[state=open]:slide-in-from-left-1/2 sm:data-[state=open]:slide-in-from-top-[48%]", className),
            style: draggable ? {
              transform: `translate(calc(-50% + ${position.x}px), calc(-50% + ${position.y}px))`,
              cursor: isDragging ? "grabbing" : undefined
            } : {
              transform: "translate(-50%, -50%)"
            },
            children: modalContent
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
}));
Modal.displayName = "Modal";
var ModalFooter = ({ children, className }) => {
  return /* @__PURE__ */ jsx_dev_runtime55.jsxDEV("div", {
    className: cn2("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2 gap-2 bg-background flex-shrink-0 p-2", className),
    children
  }, undefined, false, undefined, this);
};
ModalFooter.displayName = "ModalFooter";

// ../../src/features/report-editor/components/Modals/ShortcutHelpModal.tsx
var jsx_dev_runtime56 = __toESM(require_jsx_dev_runtime(), 1);
var ShortcutHelpModal = ({ open, onOpenChange }) => {
  const { t: t2 } = useI18n();
  const shortcuts = [
    { key: t2("shortcut_undo", "Undo"), cmd: "Ctrl/Cmd + Z" },
    { key: t2("shortcut_redo", "Redo"), cmd: "Ctrl/Cmd + Shift + Z / Ctrl + Y" },
    { key: t2("shortcut_copy", "Copy"), cmd: "Ctrl/Cmd + C" },
    { key: t2("shortcut_paste", "Paste"), cmd: "Ctrl/Cmd + V" },
    { key: t2("shortcut_delete", "Delete"), cmd: "Delete / Backspace" },
    { key: t2("shortcut_select_all", "Select All"), cmd: "Ctrl/Cmd + A" },
    { key: t2("shortcut_move", "Move"), cmd: "Arrow Keys" },
    { key: t2("shortcut_move_fast", "Move (Fast)"), cmd: "Shift + Arrow Keys" },
    { key: t2("shortcut_rotate_snap", "Snap rotation (45)"), cmd: "Hold Shift while rotating" }
  ];
  return /* @__PURE__ */ jsx_dev_runtime56.jsxDEV(Modal, {
    open,
    onOpenChange,
    title: t2("shortcut_title", "Keyboard Shortcuts"),
    description: t2("shortcut_description", "List of available keyboard shortcuts."),
    className: "max-w-md",
    children: [
      /* @__PURE__ */ jsx_dev_runtime56.jsxDEV("div", {
        className: "space-y-4",
        children: [
          /* @__PURE__ */ jsx_dev_runtime56.jsxDEV("div", {
            className: "flex items-center gap-2 text-muted-foreground mb-4",
            children: [
              /* @__PURE__ */ jsx_dev_runtime56.jsxDEV(Keyboard, {
                className: "w-5 h-5"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime56.jsxDEV("span", {
                className: "text-sm",
                children: t2("shortcut_helper_text", "Available shortcuts")
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime56.jsxDEV("div", {
            className: "grid grid-cols-[1fr_auto] gap-x-8 gap-y-3",
            children: shortcuts.map((s2, i3) => /* @__PURE__ */ jsx_dev_runtime56.jsxDEV(import_react30.default.Fragment, {
              children: [
                /* @__PURE__ */ jsx_dev_runtime56.jsxDEV("div", {
                  className: "text-sm font-medium text-foreground",
                  children: s2.key
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx_dev_runtime56.jsxDEV("div", {
                  className: "text-xs font-mono bg-muted px-2 py-1 rounded border border-border text-muted-foreground self-center",
                  children: s2.cmd
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx_dev_runtime56.jsxDEV("div", {
                  className: "col-span-2 h-px bg-border/50 last:hidden"
                }, undefined, false, undefined, this)
              ]
            }, i3, true, undefined, this))
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime56.jsxDEV(ModalFooter, {
        children: /* @__PURE__ */ jsx_dev_runtime56.jsxDEV("button", {
          onClick: () => onOpenChange(false),
          className: "px-4 py-2 text-sm font-medium text-primary-foreground bg-primary hover:bg-primary/90 rounded-md transition-colors",
          children: t2("close", "Close")
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
// ../../src/features/report-editor/components/PropertyPanel/WysiwygPropertiesPanel.tsx
var import_react34 = __toESM(require_react(), 1);

// ../../src/features/report-editor/components/PropertyPanel/BindingSelector.tsx
var jsx_dev_runtime57 = __toESM(require_jsx_dev_runtime(), 1);
var BindingSelector = ({
  binding,
  onUpdate,
  label,
  onOpenModal,
  i18nOverrides
}) => {
  const { t: t2 } = useI18n();
  const resolveText = (key, defaultValue) => {
    if (i18nOverrides?.[key])
      return i18nOverrides[key];
    return t2(key, defaultValue ?? key);
  };
  const displayLabel = label ?? resolveText("data_binding", "Data Binding");
  if (!binding) {
    return /* @__PURE__ */ jsx_dev_runtime57.jsxDEV("div", {
      className: "mb-4",
      children: /* @__PURE__ */ jsx_dev_runtime57.jsxDEV(Button, {
        variant: "outline",
        size: "sm",
        className: "font-normal",
        onClick: onOpenModal,
        type: "button",
        children: /* @__PURE__ */ jsx_dev_runtime57.jsxDEV("span", {
          children: displayLabel
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this);
  }
  const displayText = binding.field || binding.fieldId || binding.path || "";
  return /* @__PURE__ */ jsx_dev_runtime57.jsxDEV("div", {
    className: "mb-4 p-2.5 bg-blue-50/50 border border-blue-100 rounded",
    children: [
      /* @__PURE__ */ jsx_dev_runtime57.jsxDEV("div", {
        className: "flex items-center justify-between mb-2",
        children: /* @__PURE__ */ jsx_dev_runtime57.jsxDEV("div", {
          className: "flex items-center gap-2",
          children: [
            /* @__PURE__ */ jsx_dev_runtime57.jsxDEV(Database, {
              size: 14,
              className: "text-blue-600"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime57.jsxDEV("span", {
              className: "text-[11px] font-semibold text-blue-900",
              children: displayLabel
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime57.jsxDEV("div", {
        className: "bg-white border border-blue-100 rounded px-2 py-1.5 mb-2",
        children: [
          /* @__PURE__ */ jsx_dev_runtime57.jsxDEV("div", {
            className: "text-sm font-medium text-gray-900 break-all leading-tight",
            children: displayText
          }, undefined, false, undefined, this),
          binding.sourceId && /* @__PURE__ */ jsx_dev_runtime57.jsxDEV("div", {
            className: "text-[10px] text-gray-500 mt-0.5",
            children: [
              resolveText("source", "Source"),
              ": ",
              binding.sourceId
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime57.jsxDEV("div", {
        className: "flex justify-end gap-2",
        children: [
          /* @__PURE__ */ jsx_dev_runtime57.jsxDEV("button", {
            className: "px-2 py-1 h-6 text-[10px] text-red-500 hover:text-red-700 hover:bg-red-50 rounded transition-colors",
            onClick: () => onUpdate(undefined),
            type: "button",
            children: resolveText("remove", "Remove")
          }, undefined, false, undefined, this),
          onOpenModal && /* @__PURE__ */ jsx_dev_runtime57.jsxDEV("button", {
            className: "px-2 py-1 h-6 text-[10px] bg-white border border-blue-200 text-blue-700 hover:bg-blue-50 rounded transition-colors shadow-sm",
            onClick: onOpenModal,
            type: "button",
            children: resolveText("change", "Change")
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../node_modules/.pnpm/@tanstack+react-table@8.21.3_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@tanstack/react-table/build/lib/index.mjs
var React52 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/@tanstack+table-core@8.21.3/node_modules/@tanstack/table-core/build/lib/index.mjs
function createColumnHelper() {
  return {
    accessor: (accessor, column) => {
      return typeof accessor === "function" ? {
        ...column,
        accessorFn: accessor
      } : {
        ...column,
        accessorKey: accessor
      };
    },
    display: (column) => column,
    group: (column) => column
  };
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function makeStateUpdater(key, instance) {
  return (updater) => {
    instance.setState((old) => {
      return {
        ...old,
        [key]: functionalUpdate(updater, old[key])
      };
    });
  };
}
function isFunction2(d2) {
  return d2 instanceof Function;
}
function isNumberArray(d2) {
  return Array.isArray(d2) && d2.every((val) => typeof val === "number");
}
function flattenBy(arr, getChildren) {
  const flat = [];
  const recurse = (subArr) => {
    subArr.forEach((item) => {
      flat.push(item);
      const children = getChildren(item);
      if (children != null && children.length) {
        recurse(children);
      }
    });
  };
  recurse(arr);
  return flat;
}
function memo4(getDeps, fn, opts) {
  let deps = [];
  let result;
  return (depArgs) => {
    let depTime;
    if (opts.key && opts.debug)
      depTime = Date.now();
    const newDeps = getDeps(depArgs);
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index2) => deps[index2] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && opts.debug)
      resultTime = Date.now();
    result = fn(...newDeps);
    opts == null || opts.onChange == null || opts.onChange(result);
    if (opts.key && opts.debug) {
      if (opts != null && opts.debug()) {
        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
        const resultFpsPercentage = resultEndTime / 16;
        const pad = (str, num) => {
          str = String(str);
          while (str.length < num) {
            str = " " + str;
          }
          return str;
        };
        console.info(`%c ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? undefined : opts.key);
      }
    }
    return result;
  };
}
function getMemoOptions(tableOptions, debugLevel, key, onChange) {
  return {
    debug: () => {
      var _tableOptions$debugAl;
      return (_tableOptions$debugAl = tableOptions == null ? undefined : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];
    },
    key,
    onChange
  };
}
function createCell(table, row, column, columnId) {
  const getRenderValue = () => {
    var _cell$getValue;
    return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;
  };
  const cell = {
    id: `${row.id}_${column.id}`,
    row,
    column,
    getValue: () => row.getValue(columnId),
    renderValue: getRenderValue,
    getContext: memo4(() => [table, column, row, cell], (table2, column2, row2, cell2) => ({
      table: table2,
      column: column2,
      row: row2,
      cell: cell2,
      getValue: cell2.getValue,
      renderValue: cell2.renderValue
    }), getMemoOptions(table.options, "debugCells", "cell.getContext"))
  };
  table._features.forEach((feature) => {
    feature.createCell == null || feature.createCell(cell, column, row, table);
  }, {});
  return cell;
}
function createColumn(table, columnDef, depth, parent) {
  var _ref, _resolvedColumnDef$id;
  const defaultColumn = table._getDefaultColumnDef();
  const resolvedColumnDef = {
    ...defaultColumn,
    ...columnDef
  };
  const accessorKey = resolvedColumnDef.accessorKey;
  let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? typeof String.prototype.replaceAll === "function" ? accessorKey.replaceAll(".", "_") : accessorKey.replace(/\./g, "_") : undefined) != null ? _ref : typeof resolvedColumnDef.header === "string" ? resolvedColumnDef.header : undefined;
  let accessorFn;
  if (resolvedColumnDef.accessorFn) {
    accessorFn = resolvedColumnDef.accessorFn;
  } else if (accessorKey) {
    if (accessorKey.includes(".")) {
      accessorFn = (originalRow) => {
        let result = originalRow;
        for (const key of accessorKey.split(".")) {
          var _result;
          result = (_result = result) == null ? undefined : _result[key];
          if (result === undefined) {
            console.warn(`"${key}" in deeply nested key "${accessorKey}" returned undefined.`);
          }
        }
        return result;
      };
    } else {
      accessorFn = (originalRow) => originalRow[resolvedColumnDef.accessorKey];
    }
  }
  if (!id) {
    if (true) {
      throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);
    }
    throw new Error;
  }
  let column = {
    id: `${String(id)}`,
    accessorFn,
    parent,
    depth,
    columnDef: resolvedColumnDef,
    columns: [],
    getFlatColumns: memo4(() => [true], () => {
      var _column$columns;
      return [column, ...(_column$columns = column.columns) == null ? undefined : _column$columns.flatMap((d2) => d2.getFlatColumns())];
    }, getMemoOptions(table.options, "debugColumns", "column.getFlatColumns")),
    getLeafColumns: memo4(() => [table._getOrderColumnsFn()], (orderColumns) => {
      var _column$columns2;
      if ((_column$columns2 = column.columns) != null && _column$columns2.length) {
        let leafColumns = column.columns.flatMap((column2) => column2.getLeafColumns());
        return orderColumns(leafColumns);
      }
      return [column];
    }, getMemoOptions(table.options, "debugColumns", "column.getLeafColumns"))
  };
  for (const feature of table._features) {
    feature.createColumn == null || feature.createColumn(column, table);
  }
  return column;
}
var debug = "debugHeaders";
function createHeader(table, column, options2) {
  var _options$id;
  const id = (_options$id = options2.id) != null ? _options$id : column.id;
  let header = {
    id,
    column,
    index: options2.index,
    isPlaceholder: !!options2.isPlaceholder,
    placeholderId: options2.placeholderId,
    depth: options2.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const leafHeaders = [];
      const recurseHeader = (h3) => {
        if (h3.subHeaders && h3.subHeaders.length) {
          h3.subHeaders.map(recurseHeader);
        }
        leafHeaders.push(h3);
      };
      recurseHeader(header);
      return leafHeaders;
    },
    getContext: () => ({
      table,
      header,
      column
    })
  };
  table._features.forEach((feature) => {
    feature.createHeader == null || feature.createHeader(header, table);
  });
  return header;
}
var Headers = {
  createTable: (table) => {
    table.getHeaderGroups = memo4(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
      var _left$map$filter, _right$map$filter;
      const leftColumns = (_left$map$filter = left == null ? undefined : left.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];
      const rightColumns = (_right$map$filter = right == null ? undefined : right.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];
      const centerColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
      const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], table);
      return headerGroups;
    }, getMemoOptions(table.options, debug, "getHeaderGroups"));
    table.getCenterHeaderGroups = memo4(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
      leafColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
      return buildHeaderGroups(allColumns, leafColumns, table, "center");
    }, getMemoOptions(table.options, debug, "getCenterHeaderGroups"));
    table.getLeftHeaderGroups = memo4(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left], (allColumns, leafColumns, left) => {
      var _left$map$filter2;
      const orderedLeafColumns = (_left$map$filter2 = left == null ? undefined : left.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, "left");
    }, getMemoOptions(table.options, debug, "getLeftHeaderGroups"));
    table.getRightHeaderGroups = memo4(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.right], (allColumns, leafColumns, right) => {
      var _right$map$filter2;
      const orderedLeafColumns = (_right$map$filter2 = right == null ? undefined : right.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, "right");
    }, getMemoOptions(table.options, debug, "getRightHeaderGroups"));
    table.getFooterGroups = memo4(() => [table.getHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getFooterGroups"));
    table.getLeftFooterGroups = memo4(() => [table.getLeftHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getLeftFooterGroups"));
    table.getCenterFooterGroups = memo4(() => [table.getCenterHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getCenterFooterGroups"));
    table.getRightFooterGroups = memo4(() => [table.getRightHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getRightFooterGroups"));
    table.getFlatHeaders = memo4(() => [table.getHeaderGroups()], (headerGroups) => {
      return headerGroups.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getFlatHeaders"));
    table.getLeftFlatHeaders = memo4(() => [table.getLeftHeaderGroups()], (left) => {
      return left.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getLeftFlatHeaders"));
    table.getCenterFlatHeaders = memo4(() => [table.getCenterHeaderGroups()], (left) => {
      return left.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getCenterFlatHeaders"));
    table.getRightFlatHeaders = memo4(() => [table.getRightHeaderGroups()], (left) => {
      return left.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getRightFlatHeaders"));
    table.getCenterLeafHeaders = memo4(() => [table.getCenterFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders;
        return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);
      });
    }, getMemoOptions(table.options, debug, "getCenterLeafHeaders"));
    table.getLeftLeafHeaders = memo4(() => [table.getLeftFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders2;
        return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);
      });
    }, getMemoOptions(table.options, debug, "getLeftLeafHeaders"));
    table.getRightLeafHeaders = memo4(() => [table.getRightFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders3;
        return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);
      });
    }, getMemoOptions(table.options, debug, "getRightLeafHeaders"));
    table.getLeafHeaders = memo4(() => [table.getLeftHeaderGroups(), table.getCenterHeaderGroups(), table.getRightHeaderGroups()], (left, center, right) => {
      var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;
      return [...(_left$0$headers = (_left$ = left[0]) == null ? undefined : _left$.headers) != null ? _left$0$headers : [], ...(_center$0$headers = (_center$ = center[0]) == null ? undefined : _center$.headers) != null ? _center$0$headers : [], ...(_right$0$headers = (_right$ = right[0]) == null ? undefined : _right$.headers) != null ? _right$0$headers : []].map((header) => {
        return header.getLeafHeaders();
      }).flat();
    }, getMemoOptions(table.options, debug, "getLeafHeaders"));
  }
};
function buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {
  var _headerGroups$0$heade, _headerGroups$;
  let maxDepth = 0;
  const findMaxDepth = function(columns, depth) {
    if (depth === undefined) {
      depth = 1;
    }
    maxDepth = Math.max(maxDepth, depth);
    columns.filter((column) => column.getIsVisible()).forEach((column) => {
      var _column$columns;
      if ((_column$columns = column.columns) != null && _column$columns.length) {
        findMaxDepth(column.columns, depth + 1);
      }
    }, 0);
  };
  findMaxDepth(allColumns);
  let headerGroups = [];
  const createHeaderGroup = (headersToGroup, depth) => {
    const headerGroup = {
      depth,
      id: [headerFamily, `${depth}`].filter(Boolean).join("_"),
      headers: []
    };
    const pendingParentHeaders = [];
    headersToGroup.forEach((headerToGroup) => {
      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];
      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;
      let column;
      let isPlaceholder = false;
      if (isLeafHeader && headerToGroup.column.parent) {
        column = headerToGroup.column.parent;
      } else {
        column = headerToGroup.column;
        isPlaceholder = true;
      }
      if (latestPendingParentHeader && (latestPendingParentHeader == null ? undefined : latestPendingParentHeader.column) === column) {
        latestPendingParentHeader.subHeaders.push(headerToGroup);
      } else {
        const header = createHeader(table, column, {
          id: [headerFamily, depth, column.id, headerToGroup == null ? undefined : headerToGroup.id].filter(Boolean).join("_"),
          isPlaceholder,
          placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d2) => d2.column === column).length}` : undefined,
          depth,
          index: pendingParentHeaders.length
        });
        header.subHeaders.push(headerToGroup);
        pendingParentHeaders.push(header);
      }
      headerGroup.headers.push(headerToGroup);
      headerToGroup.headerGroup = headerGroup;
    });
    headerGroups.push(headerGroup);
    if (depth > 0) {
      createHeaderGroup(pendingParentHeaders, depth - 1);
    }
  };
  const bottomHeaders = columnsToGroup.map((column, index2) => createHeader(table, column, {
    depth: maxDepth,
    index: index2
  }));
  createHeaderGroup(bottomHeaders, maxDepth - 1);
  headerGroups.reverse();
  const recurseHeadersForSpans = (headers) => {
    const filteredHeaders = headers.filter((header) => header.column.getIsVisible());
    return filteredHeaders.map((header) => {
      let colSpan = 0;
      let rowSpan = 0;
      let childRowSpans = [0];
      if (header.subHeaders && header.subHeaders.length) {
        childRowSpans = [];
        recurseHeadersForSpans(header.subHeaders).forEach((_ref) => {
          let {
            colSpan: childColSpan,
            rowSpan: childRowSpan
          } = _ref;
          colSpan += childColSpan;
          childRowSpans.push(childRowSpan);
        });
      } else {
        colSpan = 1;
      }
      const minChildRowSpan = Math.min(...childRowSpans);
      rowSpan = rowSpan + minChildRowSpan;
      header.colSpan = colSpan;
      header.rowSpan = rowSpan;
      return {
        colSpan,
        rowSpan
      };
    });
  };
  recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? undefined : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);
  return headerGroups;
}
var createRow = (table, id, original, rowIndex, depth, subRows, parentId) => {
  let row = {
    id,
    index: rowIndex,
    original,
    depth,
    parentId,
    _valuesCache: {},
    _uniqueValuesCache: {},
    getValue: (columnId) => {
      if (row._valuesCache.hasOwnProperty(columnId)) {
        return row._valuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return;
      }
      row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);
      return row._valuesCache[columnId];
    },
    getUniqueValues: (columnId) => {
      if (row._uniqueValuesCache.hasOwnProperty(columnId)) {
        return row._uniqueValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return;
      }
      if (!column.columnDef.getUniqueValues) {
        row._uniqueValuesCache[columnId] = [row.getValue(columnId)];
        return row._uniqueValuesCache[columnId];
      }
      row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);
      return row._uniqueValuesCache[columnId];
    },
    renderValue: (columnId) => {
      var _row$getValue;
      return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;
    },
    subRows: subRows != null ? subRows : [],
    getLeafRows: () => flattenBy(row.subRows, (d2) => d2.subRows),
    getParentRow: () => row.parentId ? table.getRow(row.parentId, true) : undefined,
    getParentRows: () => {
      let parentRows = [];
      let currentRow = row;
      while (true) {
        const parentRow = currentRow.getParentRow();
        if (!parentRow)
          break;
        parentRows.push(parentRow);
        currentRow = parentRow;
      }
      return parentRows.reverse();
    },
    getAllCells: memo4(() => [table.getAllLeafColumns()], (leafColumns) => {
      return leafColumns.map((column) => {
        return createCell(table, row, column, column.id);
      });
    }, getMemoOptions(table.options, "debugRows", "getAllCells")),
    _getAllCellsByColumnId: memo4(() => [row.getAllCells()], (allCells) => {
      return allCells.reduce((acc, cell) => {
        acc[cell.column.id] = cell;
        return acc;
      }, {});
    }, getMemoOptions(table.options, "debugRows", "getAllCellsByColumnId"))
  };
  for (let i3 = 0;i3 < table._features.length; i3++) {
    const feature = table._features[i3];
    feature == null || feature.createRow == null || feature.createRow(row, table);
  }
  return row;
};
var ColumnFaceting = {
  createColumn: (column, table) => {
    column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);
    column.getFacetedRowModel = () => {
      if (!column._getFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return column._getFacetedRowModel();
    };
    column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);
    column.getFacetedUniqueValues = () => {
      if (!column._getFacetedUniqueValues) {
        return new Map;
      }
      return column._getFacetedUniqueValues();
    };
    column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);
    column.getFacetedMinMaxValues = () => {
      if (!column._getFacetedMinMaxValues) {
        return;
      }
      return column._getFacetedMinMaxValues();
    };
  }
};
var includesString = (row, columnId, filterValue) => {
  var _filterValue$toString, _row$getValue;
  const search = filterValue == null || (_filterValue$toString = filterValue.toString()) == null ? undefined : _filterValue$toString.toLowerCase();
  return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? undefined : _row$getValue.includes(search));
};
includesString.autoRemove = (val) => testFalsey(val);
var includesStringSensitive = (row, columnId, filterValue) => {
  var _row$getValue2;
  return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? undefined : _row$getValue2.includes(filterValue));
};
includesStringSensitive.autoRemove = (val) => testFalsey(val);
var equalsString = (row, columnId, filterValue) => {
  var _row$getValue3;
  return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? undefined : _row$getValue3.toLowerCase()) === (filterValue == null ? undefined : filterValue.toLowerCase());
};
equalsString.autoRemove = (val) => testFalsey(val);
var arrIncludes = (row, columnId, filterValue) => {
  var _row$getValue4;
  return (_row$getValue4 = row.getValue(columnId)) == null ? undefined : _row$getValue4.includes(filterValue);
};
arrIncludes.autoRemove = (val) => testFalsey(val);
var arrIncludesAll = (row, columnId, filterValue) => {
  return !filterValue.some((val) => {
    var _row$getValue5;
    return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));
  });
};
arrIncludesAll.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var arrIncludesSome = (row, columnId, filterValue) => {
  return filterValue.some((val) => {
    var _row$getValue6;
    return (_row$getValue6 = row.getValue(columnId)) == null ? undefined : _row$getValue6.includes(val);
  });
};
arrIncludesSome.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var equals = (row, columnId, filterValue) => {
  return row.getValue(columnId) === filterValue;
};
equals.autoRemove = (val) => testFalsey(val);
var weakEquals = (row, columnId, filterValue) => {
  return row.getValue(columnId) == filterValue;
};
weakEquals.autoRemove = (val) => testFalsey(val);
var inNumberRange = (row, columnId, filterValue) => {
  let [min2, max2] = filterValue;
  const rowValue = row.getValue(columnId);
  return rowValue >= min2 && rowValue <= max2;
};
inNumberRange.resolveFilterValue = (val) => {
  let [unsafeMin, unsafeMax] = val;
  let parsedMin = typeof unsafeMin !== "number" ? parseFloat(unsafeMin) : unsafeMin;
  let parsedMax = typeof unsafeMax !== "number" ? parseFloat(unsafeMax) : unsafeMax;
  let min2 = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;
  let max2 = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;
  if (min2 > max2) {
    const temp = min2;
    min2 = max2;
    max2 = temp;
  }
  return [min2, max2];
};
inNumberRange.autoRemove = (val) => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);
var filterFns = {
  includesString,
  includesStringSensitive,
  equalsString,
  arrIncludes,
  arrIncludesAll,
  arrIncludesSome,
  equals,
  weakEquals,
  inNumberRange
};
function testFalsey(val) {
  return val === undefined || val === null || val === "";
}
var ColumnFiltering = {
  getDefaultColumnDef: () => {
    return {
      filterFn: "auto"
    };
  },
  getInitialState: (state) => {
    return {
      columnFilters: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnFiltersChange: makeStateUpdater("columnFilters", table),
      filterFromLeafRows: false,
      maxLeafRowFilterDepth: 100
    };
  },
  createColumn: (column, table) => {
    column.getAutoFilterFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value = firstRow == null ? undefined : firstRow.getValue(column.id);
      if (typeof value === "string") {
        return filterFns.includesString;
      }
      if (typeof value === "number") {
        return filterFns.inNumberRange;
      }
      if (typeof value === "boolean") {
        return filterFns.equals;
      }
      if (value !== null && typeof value === "object") {
        return filterFns.equals;
      }
      if (Array.isArray(value)) {
        return filterFns.arrIncludes;
      }
      return filterFns.weakEquals;
    };
    column.getFilterFn = () => {
      var _table$options$filter, _table$options$filter2;
      return isFunction2(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === "auto" ? column.getAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? undefined : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn];
    };
    column.getCanFilter = () => {
      var _column$columnDef$ena, _table$options$enable, _table$options$enable2;
      return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;
    };
    column.getIsFiltered = () => column.getFilterIndex() > -1;
    column.getFilterValue = () => {
      var _table$getState$colum;
      return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d2) => d2.id === column.id)) == null ? undefined : _table$getState$colum.value;
    };
    column.getFilterIndex = () => {
      var _table$getState$colum2, _table$getState$colum3;
      return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? undefined : _table$getState$colum3.findIndex((d2) => d2.id === column.id)) != null ? _table$getState$colum2 : -1;
    };
    column.setFilterValue = (value) => {
      table.setColumnFilters((old) => {
        const filterFn = column.getFilterFn();
        const previousFilter = old == null ? undefined : old.find((d2) => d2.id === column.id);
        const newFilter = functionalUpdate(value, previousFilter ? previousFilter.value : undefined);
        if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {
          var _old$filter;
          return (_old$filter = old == null ? undefined : old.filter((d2) => d2.id !== column.id)) != null ? _old$filter : [];
        }
        const newFilterObj = {
          id: column.id,
          value: newFilter
        };
        if (previousFilter) {
          var _old$map;
          return (_old$map = old == null ? undefined : old.map((d2) => {
            if (d2.id === column.id) {
              return newFilterObj;
            }
            return d2;
          })) != null ? _old$map : [];
        }
        if (old != null && old.length) {
          return [...old, newFilterObj];
        }
        return [newFilterObj];
      });
    };
  },
  createRow: (row, _table) => {
    row.columnFilters = {};
    row.columnFiltersMeta = {};
  },
  createTable: (table) => {
    table.setColumnFilters = (updater) => {
      const leafColumns = table.getAllLeafColumns();
      const updateFn = (old) => {
        var _functionalUpdate;
        return (_functionalUpdate = functionalUpdate(updater, old)) == null ? undefined : _functionalUpdate.filter((filter) => {
          const column = leafColumns.find((d2) => d2.id === filter.id);
          if (column) {
            const filterFn = column.getFilterFn();
            if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {
              return false;
            }
          }
          return true;
        });
      };
      table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);
    };
    table.resetColumnFilters = (defaultState) => {
      var _table$initialState$c, _table$initialState;
      table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? undefined : _table$initialState.columnFilters) != null ? _table$initialState$c : []);
    };
    table.getPreFilteredRowModel = () => table.getCoreRowModel();
    table.getFilteredRowModel = () => {
      if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {
        table._getFilteredRowModel = table.options.getFilteredRowModel(table);
      }
      if (table.options.manualFiltering || !table._getFilteredRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getFilteredRowModel();
    };
  }
};
function shouldAutoRemoveFilter(filterFn, value, column) {
  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === "undefined" || typeof value === "string" && !value;
}
var sum = (columnId, _leafRows, childRows) => {
  return childRows.reduce((sum2, next) => {
    const nextValue = next.getValue(columnId);
    return sum2 + (typeof nextValue === "number" ? nextValue : 0);
  }, 0);
};
var min2 = (columnId, _leafRows, childRows) => {
  let min3;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (min3 > value || min3 === undefined && value >= value)) {
      min3 = value;
    }
  });
  return min3;
};
var max2 = (columnId, _leafRows, childRows) => {
  let max3;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (max3 < value || max3 === undefined && value >= value)) {
      max3 = value;
    }
  });
  return max3;
};
var extent = (columnId, _leafRows, childRows) => {
  let min3;
  let max3;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null) {
      if (min3 === undefined) {
        if (value >= value)
          min3 = max3 = value;
      } else {
        if (min3 > value)
          min3 = value;
        if (max3 < value)
          max3 = value;
      }
    }
  });
  return [min3, max3];
};
var mean = (columnId, leafRows) => {
  let count3 = 0;
  let sum2 = 0;
  leafRows.forEach((row) => {
    let value = row.getValue(columnId);
    if (value != null && (value = +value) >= value) {
      ++count3, sum2 += value;
    }
  });
  if (count3)
    return sum2 / count3;
  return;
};
var median = (columnId, leafRows) => {
  if (!leafRows.length) {
    return;
  }
  const values = leafRows.map((row) => row.getValue(columnId));
  if (!isNumberArray(values)) {
    return;
  }
  if (values.length === 1) {
    return values[0];
  }
  const mid = Math.floor(values.length / 2);
  const nums = values.sort((a4, b4) => a4 - b4);
  return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;
};
var unique = (columnId, leafRows) => {
  return Array.from(new Set(leafRows.map((d2) => d2.getValue(columnId))).values());
};
var uniqueCount = (columnId, leafRows) => {
  return new Set(leafRows.map((d2) => d2.getValue(columnId))).size;
};
var count3 = (_columnId, leafRows) => {
  return leafRows.length;
};
var aggregationFns = {
  sum,
  min: min2,
  max: max2,
  extent,
  mean,
  median,
  unique,
  uniqueCount,
  count: count3
};
var ColumnGrouping = {
  getDefaultColumnDef: () => {
    return {
      aggregatedCell: (props) => {
        var _toString, _props$getValue;
        return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? undefined : _props$getValue.toString()) != null ? _toString : null;
      },
      aggregationFn: "auto"
    };
  },
  getInitialState: (state) => {
    return {
      grouping: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onGroupingChange: makeStateUpdater("grouping", table),
      groupedColumnMode: "reorder"
    };
  },
  createColumn: (column, table) => {
    column.toggleGrouping = () => {
      table.setGrouping((old) => {
        if (old != null && old.includes(column.id)) {
          return old.filter((d2) => d2 !== column.id);
        }
        return [...old != null ? old : [], column.id];
      });
    };
    column.getCanGroup = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGrouping) != null ? _table$options$enable : true) && (!!column.accessorFn || !!column.columnDef.getGroupingValue);
    };
    column.getIsGrouped = () => {
      var _table$getState$group;
      return (_table$getState$group = table.getState().grouping) == null ? undefined : _table$getState$group.includes(column.id);
    };
    column.getGroupedIndex = () => {
      var _table$getState$group2;
      return (_table$getState$group2 = table.getState().grouping) == null ? undefined : _table$getState$group2.indexOf(column.id);
    };
    column.getToggleGroupingHandler = () => {
      const canGroup = column.getCanGroup();
      return () => {
        if (!canGroup)
          return;
        column.toggleGrouping();
      };
    };
    column.getAutoAggregationFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value = firstRow == null ? undefined : firstRow.getValue(column.id);
      if (typeof value === "number") {
        return aggregationFns.sum;
      }
      if (Object.prototype.toString.call(value) === "[object Date]") {
        return aggregationFns.extent;
      }
    };
    column.getAggregationFn = () => {
      var _table$options$aggreg, _table$options$aggreg2;
      if (!column) {
        throw new Error;
      }
      return isFunction2(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === "auto" ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? undefined : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];
    };
  },
  createTable: (table) => {
    table.setGrouping = (updater) => table.options.onGroupingChange == null ? undefined : table.options.onGroupingChange(updater);
    table.resetGrouping = (defaultState) => {
      var _table$initialState$g, _table$initialState;
      table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? undefined : _table$initialState.grouping) != null ? _table$initialState$g : []);
    };
    table.getPreGroupedRowModel = () => table.getFilteredRowModel();
    table.getGroupedRowModel = () => {
      if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {
        table._getGroupedRowModel = table.options.getGroupedRowModel(table);
      }
      if (table.options.manualGrouping || !table._getGroupedRowModel) {
        return table.getPreGroupedRowModel();
      }
      return table._getGroupedRowModel();
    };
  },
  createRow: (row, table) => {
    row.getIsGrouped = () => !!row.groupingColumnId;
    row.getGroupingValue = (columnId) => {
      if (row._groupingValuesCache.hasOwnProperty(columnId)) {
        return row._groupingValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.columnDef.getGroupingValue)) {
        return row.getValue(columnId);
      }
      row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);
      return row._groupingValuesCache[columnId];
    };
    row._groupingValuesCache = {};
  },
  createCell: (cell, column, row, table) => {
    cell.getIsGrouped = () => column.getIsGrouped() && column.id === row.groupingColumnId;
    cell.getIsPlaceholder = () => !cell.getIsGrouped() && column.getIsGrouped();
    cell.getIsAggregated = () => {
      var _row$subRows;
      return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
  }
};
function orderColumns(leafColumns, grouping, groupedColumnMode) {
  if (!(grouping != null && grouping.length) || !groupedColumnMode) {
    return leafColumns;
  }
  const nonGroupingColumns = leafColumns.filter((col) => !grouping.includes(col.id));
  if (groupedColumnMode === "remove") {
    return nonGroupingColumns;
  }
  const groupingColumns = grouping.map((g2) => leafColumns.find((col) => col.id === g2)).filter(Boolean);
  return [...groupingColumns, ...nonGroupingColumns];
}
var ColumnOrdering = {
  getInitialState: (state) => {
    return {
      columnOrder: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnOrderChange: makeStateUpdater("columnOrder", table)
    };
  },
  createColumn: (column, table) => {
    column.getIndex = memo4((position) => [_getVisibleLeafColumns(table, position)], (columns) => columns.findIndex((d2) => d2.id === column.id), getMemoOptions(table.options, "debugColumns", "getIndex"));
    column.getIsFirstColumn = (position) => {
      var _columns$;
      const columns = _getVisibleLeafColumns(table, position);
      return ((_columns$ = columns[0]) == null ? undefined : _columns$.id) === column.id;
    };
    column.getIsLastColumn = (position) => {
      var _columns;
      const columns = _getVisibleLeafColumns(table, position);
      return ((_columns = columns[columns.length - 1]) == null ? undefined : _columns.id) === column.id;
    };
  },
  createTable: (table) => {
    table.setColumnOrder = (updater) => table.options.onColumnOrderChange == null ? undefined : table.options.onColumnOrderChange(updater);
    table.resetColumnOrder = (defaultState) => {
      var _table$initialState$c;
      table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);
    };
    table._getOrderColumnsFn = memo4(() => [table.getState().columnOrder, table.getState().grouping, table.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => (columns) => {
      let orderedColumns = [];
      if (!(columnOrder != null && columnOrder.length)) {
        orderedColumns = columns;
      } else {
        const columnOrderCopy = [...columnOrder];
        const columnsCopy = [...columns];
        while (columnsCopy.length && columnOrderCopy.length) {
          const targetColumnId = columnOrderCopy.shift();
          const foundIndex = columnsCopy.findIndex((d2) => d2.id === targetColumnId);
          if (foundIndex > -1) {
            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);
          }
        }
        orderedColumns = [...orderedColumns, ...columnsCopy];
      }
      return orderColumns(orderedColumns, grouping, groupedColumnMode);
    }, getMemoOptions(table.options, "debugTable", "_getOrderColumnsFn"));
  }
};
var getDefaultColumnPinningState = () => ({
  left: [],
  right: []
});
var ColumnPinning = {
  getInitialState: (state) => {
    return {
      columnPinning: getDefaultColumnPinningState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnPinningChange: makeStateUpdater("columnPinning", table)
    };
  },
  createColumn: (column, table) => {
    column.pin = (position) => {
      const columnIds = column.getLeafColumns().map((d2) => d2.id).filter(Boolean);
      table.setColumnPinning((old) => {
        var _old$left3, _old$right3;
        if (position === "right") {
          var _old$left, _old$right;
          return {
            left: ((_old$left = old == null ? undefined : old.left) != null ? _old$left : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))),
            right: [...((_old$right = old == null ? undefined : old.right) != null ? _old$right : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))), ...columnIds]
          };
        }
        if (position === "left") {
          var _old$left2, _old$right2;
          return {
            left: [...((_old$left2 = old == null ? undefined : old.left) != null ? _old$left2 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))), ...columnIds],
            right: ((_old$right2 = old == null ? undefined : old.right) != null ? _old$right2 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2)))
          };
        }
        return {
          left: ((_old$left3 = old == null ? undefined : old.left) != null ? _old$left3 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))),
          right: ((_old$right3 = old == null ? undefined : old.right) != null ? _old$right3 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2)))
        };
      });
    };
    column.getCanPin = () => {
      const leafColumns = column.getLeafColumns();
      return leafColumns.some((d2) => {
        var _d$columnDef$enablePi, _ref, _table$options$enable;
        return ((_d$columnDef$enablePi = d2.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);
      });
    };
    column.getIsPinned = () => {
      const leafColumnIds = column.getLeafColumns().map((d2) => d2.id);
      const {
        left,
        right
      } = table.getState().columnPinning;
      const isLeft = leafColumnIds.some((d2) => left == null ? undefined : left.includes(d2));
      const isRight = leafColumnIds.some((d2) => right == null ? undefined : right.includes(d2));
      return isLeft ? "left" : isRight ? "right" : false;
    };
    column.getPinnedIndex = () => {
      var _table$getState$colum, _table$getState$colum2;
      const position = column.getIsPinned();
      return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? undefined : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;
    };
  },
  createRow: (row, table) => {
    row.getCenterVisibleCells = memo4(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allCells, left, right) => {
      const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
      return allCells.filter((d2) => !leftAndRight.includes(d2.column.id));
    }, getMemoOptions(table.options, "debugRows", "getCenterVisibleCells"));
    row.getLeftVisibleCells = memo4(() => [row._getAllVisibleCells(), table.getState().columnPinning.left], (allCells, left) => {
      const cells = (left != null ? left : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d2) => ({
        ...d2,
        position: "left"
      }));
      return cells;
    }, getMemoOptions(table.options, "debugRows", "getLeftVisibleCells"));
    row.getRightVisibleCells = memo4(() => [row._getAllVisibleCells(), table.getState().columnPinning.right], (allCells, right) => {
      const cells = (right != null ? right : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d2) => ({
        ...d2,
        position: "right"
      }));
      return cells;
    }, getMemoOptions(table.options, "debugRows", "getRightVisibleCells"));
  },
  createTable: (table) => {
    table.setColumnPinning = (updater) => table.options.onColumnPinningChange == null ? undefined : table.options.onColumnPinningChange(updater);
    table.resetColumnPinning = (defaultState) => {
      var _table$initialState$c, _table$initialState;
      return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? undefined : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());
    };
    table.getIsSomeColumnsPinned = (position) => {
      var _pinningState$positio;
      const pinningState = table.getState().columnPinning;
      if (!position) {
        var _pinningState$left, _pinningState$right;
        return Boolean(((_pinningState$left = pinningState.left) == null ? undefined : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? undefined : _pinningState$right.length));
      }
      return Boolean((_pinningState$positio = pinningState[position]) == null ? undefined : _pinningState$positio.length);
    };
    table.getLeftLeafColumns = memo4(() => [table.getAllLeafColumns(), table.getState().columnPinning.left], (allColumns, left) => {
      return (left != null ? left : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
    }, getMemoOptions(table.options, "debugColumns", "getLeftLeafColumns"));
    table.getRightLeafColumns = memo4(() => [table.getAllLeafColumns(), table.getState().columnPinning.right], (allColumns, right) => {
      return (right != null ? right : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
    }, getMemoOptions(table.options, "debugColumns", "getRightLeafColumns"));
    table.getCenterLeafColumns = memo4(() => [table.getAllLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, left, right) => {
      const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
      return allColumns.filter((d2) => !leftAndRight.includes(d2.id));
    }, getMemoOptions(table.options, "debugColumns", "getCenterLeafColumns"));
  }
};
function safelyAccessDocument(_document) {
  return _document || (typeof document !== "undefined" ? document : null);
}
var defaultColumnSizing = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
};
var getDefaultColumnSizingInfoState = () => ({
  startOffset: null,
  startSize: null,
  deltaOffset: null,
  deltaPercentage: null,
  isResizingColumn: false,
  columnSizingStart: []
});
var ColumnSizing = {
  getDefaultColumnDef: () => {
    return defaultColumnSizing;
  },
  getInitialState: (state) => {
    return {
      columnSizing: {},
      columnSizingInfo: getDefaultColumnSizingInfoState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      columnResizeMode: "onEnd",
      columnResizeDirection: "ltr",
      onColumnSizingChange: makeStateUpdater("columnSizing", table),
      onColumnSizingInfoChange: makeStateUpdater("columnSizingInfo", table)
    };
  },
  createColumn: (column, table) => {
    column.getSize = () => {
      var _column$columnDef$min, _ref, _column$columnDef$max;
      const columnSize = table.getState().columnSizing[column.id];
      return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);
    };
    column.getStart = memo4((position) => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(0, column.getIndex(position)).reduce((sum2, column2) => sum2 + column2.getSize(), 0), getMemoOptions(table.options, "debugColumns", "getStart"));
    column.getAfter = memo4((position) => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(column.getIndex(position) + 1).reduce((sum2, column2) => sum2 + column2.getSize(), 0), getMemoOptions(table.options, "debugColumns", "getAfter"));
    column.resetSize = () => {
      table.setColumnSizing((_ref2) => {
        let {
          [column.id]: _2,
          ...rest
        } = _ref2;
        return rest;
      });
    };
    column.getCanResize = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);
    };
    column.getIsResizing = () => {
      return table.getState().columnSizingInfo.isResizingColumn === column.id;
    };
  },
  createHeader: (header, table) => {
    header.getSize = () => {
      let sum2 = 0;
      const recurse = (header2) => {
        if (header2.subHeaders.length) {
          header2.subHeaders.forEach(recurse);
        } else {
          var _header$column$getSiz;
          sum2 += (_header$column$getSiz = header2.column.getSize()) != null ? _header$column$getSiz : 0;
        }
      };
      recurse(header);
      return sum2;
    };
    header.getStart = () => {
      if (header.index > 0) {
        const prevSiblingHeader = header.headerGroup.headers[header.index - 1];
        return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();
      }
      return 0;
    };
    header.getResizeHandler = (_contextDocument) => {
      const column = table.getColumn(header.column.id);
      const canResize = column == null ? undefined : column.getCanResize();
      return (e2) => {
        if (!column || !canResize) {
          return;
        }
        e2.persist == null || e2.persist();
        if (isTouchStartEvent(e2)) {
          if (e2.touches && e2.touches.length > 1) {
            return;
          }
        }
        const startSize = header.getSize();
        const columnSizingStart = header ? header.getLeafHeaders().map((d2) => [d2.column.id, d2.column.getSize()]) : [[column.id, column.getSize()]];
        const clientX = isTouchStartEvent(e2) ? Math.round(e2.touches[0].clientX) : e2.clientX;
        const newColumnSizing = {};
        const updateOffset = (eventType, clientXPos) => {
          if (typeof clientXPos !== "number") {
            return;
          }
          table.setColumnSizingInfo((old) => {
            var _old$startOffset, _old$startSize;
            const deltaDirection = table.options.columnResizeDirection === "rtl" ? -1 : 1;
            const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? undefined : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;
            const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? undefined : old.startSize) != null ? _old$startSize : 0), -0.999999);
            old.columnSizingStart.forEach((_ref3) => {
              let [columnId, headerSize] = _ref3;
              newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;
            });
            return {
              ...old,
              deltaOffset,
              deltaPercentage
            };
          });
          if (table.options.columnResizeMode === "onChange" || eventType === "end") {
            table.setColumnSizing((old) => ({
              ...old,
              ...newColumnSizing
            }));
          }
        };
        const onMove = (clientXPos) => updateOffset("move", clientXPos);
        const onEnd = (clientXPos) => {
          updateOffset("end", clientXPos);
          table.setColumnSizingInfo((old) => ({
            ...old,
            isResizingColumn: false,
            startOffset: null,
            startSize: null,
            deltaOffset: null,
            deltaPercentage: null,
            columnSizingStart: []
          }));
        };
        const contextDocument = safelyAccessDocument(_contextDocument);
        const mouseEvents = {
          moveHandler: (e3) => onMove(e3.clientX),
          upHandler: (e3) => {
            contextDocument == null || contextDocument.removeEventListener("mousemove", mouseEvents.moveHandler);
            contextDocument == null || contextDocument.removeEventListener("mouseup", mouseEvents.upHandler);
            onEnd(e3.clientX);
          }
        };
        const touchEvents = {
          moveHandler: (e3) => {
            if (e3.cancelable) {
              e3.preventDefault();
              e3.stopPropagation();
            }
            onMove(e3.touches[0].clientX);
            return false;
          },
          upHandler: (e3) => {
            var _e$touches$;
            contextDocument == null || contextDocument.removeEventListener("touchmove", touchEvents.moveHandler);
            contextDocument == null || contextDocument.removeEventListener("touchend", touchEvents.upHandler);
            if (e3.cancelable) {
              e3.preventDefault();
              e3.stopPropagation();
            }
            onEnd((_e$touches$ = e3.touches[0]) == null ? undefined : _e$touches$.clientX);
          }
        };
        const passiveIfSupported = passiveEventSupported() ? {
          passive: false
        } : false;
        if (isTouchStartEvent(e2)) {
          contextDocument == null || contextDocument.addEventListener("touchmove", touchEvents.moveHandler, passiveIfSupported);
          contextDocument == null || contextDocument.addEventListener("touchend", touchEvents.upHandler, passiveIfSupported);
        } else {
          contextDocument == null || contextDocument.addEventListener("mousemove", mouseEvents.moveHandler, passiveIfSupported);
          contextDocument == null || contextDocument.addEventListener("mouseup", mouseEvents.upHandler, passiveIfSupported);
        }
        table.setColumnSizingInfo((old) => ({
          ...old,
          startOffset: clientX,
          startSize,
          deltaOffset: 0,
          deltaPercentage: 0,
          columnSizingStart,
          isResizingColumn: column.id
        }));
      };
    };
  },
  createTable: (table) => {
    table.setColumnSizing = (updater) => table.options.onColumnSizingChange == null ? undefined : table.options.onColumnSizingChange(updater);
    table.setColumnSizingInfo = (updater) => table.options.onColumnSizingInfoChange == null ? undefined : table.options.onColumnSizingInfoChange(updater);
    table.resetColumnSizing = (defaultState) => {
      var _table$initialState$c;
      table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});
    };
    table.resetHeaderSizeInfo = (defaultState) => {
      var _table$initialState$c2;
      table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());
    };
    table.getTotalSize = () => {
      var _table$getHeaderGroup, _table$getHeaderGroup2;
      return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? undefined : _table$getHeaderGroup2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getHeaderGroup : 0;
    };
    table.getLeftTotalSize = () => {
      var _table$getLeftHeaderG, _table$getLeftHeaderG2;
      return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? undefined : _table$getLeftHeaderG2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getLeftHeaderG : 0;
    };
    table.getCenterTotalSize = () => {
      var _table$getCenterHeade, _table$getCenterHeade2;
      return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? undefined : _table$getCenterHeade2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getCenterHeade : 0;
    };
    table.getRightTotalSize = () => {
      var _table$getRightHeader, _table$getRightHeader2;
      return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? undefined : _table$getRightHeader2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getRightHeader : 0;
    };
  }
};
var passiveSupported2 = null;
function passiveEventSupported() {
  if (typeof passiveSupported2 === "boolean")
    return passiveSupported2;
  let supported = false;
  try {
    const options2 = {
      get passive() {
        supported = true;
        return false;
      }
    };
    const noop3 = () => {};
    window.addEventListener("test", noop3, options2);
    window.removeEventListener("test", noop3);
  } catch (err) {
    supported = false;
  }
  passiveSupported2 = supported;
  return passiveSupported2;
}
function isTouchStartEvent(e2) {
  return e2.type === "touchstart";
}
var ColumnVisibility = {
  getInitialState: (state) => {
    return {
      columnVisibility: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnVisibilityChange: makeStateUpdater("columnVisibility", table)
    };
  },
  createColumn: (column, table) => {
    column.toggleVisibility = (value) => {
      if (column.getCanHide()) {
        table.setColumnVisibility((old) => ({
          ...old,
          [column.id]: value != null ? value : !column.getIsVisible()
        }));
      }
    };
    column.getIsVisible = () => {
      var _ref, _table$getState$colum;
      const childColumns = column.columns;
      return (_ref = childColumns.length ? childColumns.some((c3) => c3.getIsVisible()) : (_table$getState$colum = table.getState().columnVisibility) == null ? undefined : _table$getState$colum[column.id]) != null ? _ref : true;
    };
    column.getCanHide = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);
    };
    column.getToggleVisibilityHandler = () => {
      return (e2) => {
        column.toggleVisibility == null || column.toggleVisibility(e2.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row._getAllVisibleCells = memo4(() => [row.getAllCells(), table.getState().columnVisibility], (cells) => {
      return cells.filter((cell) => cell.column.getIsVisible());
    }, getMemoOptions(table.options, "debugRows", "_getAllVisibleCells"));
    row.getVisibleCells = memo4(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left, center, right) => [...left, ...center, ...right], getMemoOptions(table.options, "debugRows", "getVisibleCells"));
  },
  createTable: (table) => {
    const makeVisibleColumnsMethod = (key, getColumns) => {
      return memo4(() => [getColumns(), getColumns().filter((d2) => d2.getIsVisible()).map((d2) => d2.id).join("_")], (columns) => {
        return columns.filter((d2) => d2.getIsVisible == null ? undefined : d2.getIsVisible());
      }, getMemoOptions(table.options, "debugColumns", key));
    };
    table.getVisibleFlatColumns = makeVisibleColumnsMethod("getVisibleFlatColumns", () => table.getAllFlatColumns());
    table.getVisibleLeafColumns = makeVisibleColumnsMethod("getVisibleLeafColumns", () => table.getAllLeafColumns());
    table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod("getLeftVisibleLeafColumns", () => table.getLeftLeafColumns());
    table.getRightVisibleLeafColumns = makeVisibleColumnsMethod("getRightVisibleLeafColumns", () => table.getRightLeafColumns());
    table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod("getCenterVisibleLeafColumns", () => table.getCenterLeafColumns());
    table.setColumnVisibility = (updater) => table.options.onColumnVisibilityChange == null ? undefined : table.options.onColumnVisibilityChange(updater);
    table.resetColumnVisibility = (defaultState) => {
      var _table$initialState$c;
      table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});
    };
    table.toggleAllColumnsVisible = (value) => {
      var _value;
      value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();
      table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column) => ({
        ...obj,
        [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value
      }), {}));
    };
    table.getIsAllColumnsVisible = () => !table.getAllLeafColumns().some((column) => !(column.getIsVisible != null && column.getIsVisible()));
    table.getIsSomeColumnsVisible = () => table.getAllLeafColumns().some((column) => column.getIsVisible == null ? undefined : column.getIsVisible());
    table.getToggleAllColumnsVisibilityHandler = () => {
      return (e2) => {
        var _target;
        table.toggleAllColumnsVisible((_target = e2.target) == null ? undefined : _target.checked);
      };
    };
  }
};
function _getVisibleLeafColumns(table, position) {
  return !position ? table.getVisibleLeafColumns() : position === "center" ? table.getCenterVisibleLeafColumns() : position === "left" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();
}
var GlobalFaceting = {
  createTable: (table) => {
    table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, "__global__");
    table.getGlobalFacetedRowModel = () => {
      if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getGlobalFacetedRowModel();
    };
    table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, "__global__");
    table.getGlobalFacetedUniqueValues = () => {
      if (!table._getGlobalFacetedUniqueValues) {
        return new Map;
      }
      return table._getGlobalFacetedUniqueValues();
    };
    table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, "__global__");
    table.getGlobalFacetedMinMaxValues = () => {
      if (!table._getGlobalFacetedMinMaxValues) {
        return;
      }
      return table._getGlobalFacetedMinMaxValues();
    };
  }
};
var GlobalFiltering = {
  getInitialState: (state) => {
    return {
      globalFilter: undefined,
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onGlobalFilterChange: makeStateUpdater("globalFilter", table),
      globalFilterFn: "auto",
      getColumnCanGlobalFilter: (column) => {
        var _table$getCoreRowMode;
        const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? undefined : _table$getCoreRowMode.getValue();
        return typeof value === "string" || typeof value === "number";
      }
    };
  },
  createColumn: (column, table) => {
    column.getCanGlobalFilter = () => {
      var _column$columnDef$ena, _table$options$enable, _table$options$enable2, _table$options$getCol;
      return ((_column$columnDef$ena = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGlobalFilter) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? undefined : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;
    };
  },
  createTable: (table) => {
    table.getGlobalAutoFilterFn = () => {
      return filterFns.includesString;
    };
    table.getGlobalFilterFn = () => {
      var _table$options$filter, _table$options$filter2;
      const {
        globalFilterFn
      } = table.options;
      return isFunction2(globalFilterFn) ? globalFilterFn : globalFilterFn === "auto" ? table.getGlobalAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? undefined : _table$options$filter2[globalFilterFn]) != null ? _table$options$filter : filterFns[globalFilterFn];
    };
    table.setGlobalFilter = (updater) => {
      table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);
    };
    table.resetGlobalFilter = (defaultState) => {
      table.setGlobalFilter(defaultState ? undefined : table.initialState.globalFilter);
    };
  }
};
var RowExpanding = {
  getInitialState: (state) => {
    return {
      expanded: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onExpandedChange: makeStateUpdater("expanded", table),
      paginateExpandedRows: true
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    table._autoResetExpanded = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {
        if (queued)
          return;
        queued = true;
        table._queue(() => {
          table.resetExpanded();
          queued = false;
        });
      }
    };
    table.setExpanded = (updater) => table.options.onExpandedChange == null ? undefined : table.options.onExpandedChange(updater);
    table.toggleAllRowsExpanded = (expanded) => {
      if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {
        table.setExpanded(true);
      } else {
        table.setExpanded({});
      }
    };
    table.resetExpanded = (defaultState) => {
      var _table$initialState$e, _table$initialState;
      table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? undefined : _table$initialState.expanded) != null ? _table$initialState$e : {});
    };
    table.getCanSomeRowsExpand = () => {
      return table.getPrePaginationRowModel().flatRows.some((row) => row.getCanExpand());
    };
    table.getToggleAllRowsExpandedHandler = () => {
      return (e2) => {
        e2.persist == null || e2.persist();
        table.toggleAllRowsExpanded();
      };
    };
    table.getIsSomeRowsExpanded = () => {
      const expanded = table.getState().expanded;
      return expanded === true || Object.values(expanded).some(Boolean);
    };
    table.getIsAllRowsExpanded = () => {
      const expanded = table.getState().expanded;
      if (typeof expanded === "boolean") {
        return expanded === true;
      }
      if (!Object.keys(expanded).length) {
        return false;
      }
      if (table.getRowModel().flatRows.some((row) => !row.getIsExpanded())) {
        return false;
      }
      return true;
    };
    table.getExpandedDepth = () => {
      let maxDepth = 0;
      const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);
      rowIds.forEach((id) => {
        const splitId = id.split(".");
        maxDepth = Math.max(maxDepth, splitId.length);
      });
      return maxDepth;
    };
    table.getPreExpandedRowModel = () => table.getSortedRowModel();
    table.getExpandedRowModel = () => {
      if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {
        table._getExpandedRowModel = table.options.getExpandedRowModel(table);
      }
      if (table.options.manualExpanding || !table._getExpandedRowModel) {
        return table.getPreExpandedRowModel();
      }
      return table._getExpandedRowModel();
    };
  },
  createRow: (row, table) => {
    row.toggleExpanded = (expanded) => {
      table.setExpanded((old) => {
        var _expanded;
        const exists = old === true ? true : !!(old != null && old[row.id]);
        let oldExpanded = {};
        if (old === true) {
          Object.keys(table.getRowModel().rowsById).forEach((rowId) => {
            oldExpanded[rowId] = true;
          });
        } else {
          oldExpanded = old;
        }
        expanded = (_expanded = expanded) != null ? _expanded : !exists;
        if (!exists && expanded) {
          return {
            ...oldExpanded,
            [row.id]: true
          };
        }
        if (exists && !expanded) {
          const {
            [row.id]: _2,
            ...rest
          } = oldExpanded;
          return rest;
        }
        return old;
      });
    };
    row.getIsExpanded = () => {
      var _table$options$getIsR;
      const expanded = table.getState().expanded;
      return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? undefined : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? undefined : expanded[row.id]));
    };
    row.getCanExpand = () => {
      var _table$options$getRow, _table$options$enable, _row$subRows;
      return (_table$options$getRow = table.options.getRowCanExpand == null ? undefined : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
    row.getIsAllParentsExpanded = () => {
      let isFullyExpanded = true;
      let currentRow = row;
      while (isFullyExpanded && currentRow.parentId) {
        currentRow = table.getRow(currentRow.parentId, true);
        isFullyExpanded = currentRow.getIsExpanded();
      }
      return isFullyExpanded;
    };
    row.getToggleExpandedHandler = () => {
      const canExpand = row.getCanExpand();
      return () => {
        if (!canExpand)
          return;
        row.toggleExpanded();
      };
    };
  }
};
var defaultPageIndex = 0;
var defaultPageSize = 10;
var getDefaultPaginationState = () => ({
  pageIndex: defaultPageIndex,
  pageSize: defaultPageSize
});
var RowPagination = {
  getInitialState: (state) => {
    return {
      ...state,
      pagination: {
        ...getDefaultPaginationState(),
        ...state == null ? undefined : state.pagination
      }
    };
  },
  getDefaultOptions: (table) => {
    return {
      onPaginationChange: makeStateUpdater("pagination", table)
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    table._autoResetPageIndex = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {
        if (queued)
          return;
        queued = true;
        table._queue(() => {
          table.resetPageIndex();
          queued = false;
        });
      }
    };
    table.setPagination = (updater) => {
      const safeUpdater = (old) => {
        let newState = functionalUpdate(updater, old);
        return newState;
      };
      return table.options.onPaginationChange == null ? undefined : table.options.onPaginationChange(safeUpdater);
    };
    table.resetPagination = (defaultState) => {
      var _table$initialState$p;
      table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());
    };
    table.setPageIndex = (updater) => {
      table.setPagination((old) => {
        let pageIndex = functionalUpdate(updater, old.pageIndex);
        const maxPageIndex = typeof table.options.pageCount === "undefined" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;
        pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));
        return {
          ...old,
          pageIndex
        };
      });
    };
    table.resetPageIndex = (defaultState) => {
      var _table$initialState$p2, _table$initialState;
      table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? undefined : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);
    };
    table.resetPageSize = (defaultState) => {
      var _table$initialState$p3, _table$initialState2;
      table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? undefined : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);
    };
    table.setPageSize = (updater) => {
      table.setPagination((old) => {
        const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));
        const topRowIndex = old.pageSize * old.pageIndex;
        const pageIndex = Math.floor(topRowIndex / pageSize);
        return {
          ...old,
          pageIndex,
          pageSize
        };
      });
    };
    table.setPageCount = (updater) => table.setPagination((old) => {
      var _table$options$pageCo;
      let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);
      if (typeof newPageCount === "number") {
        newPageCount = Math.max(-1, newPageCount);
      }
      return {
        ...old,
        pageCount: newPageCount
      };
    });
    table.getPageOptions = memo4(() => [table.getPageCount()], (pageCount) => {
      let pageOptions = [];
      if (pageCount && pageCount > 0) {
        pageOptions = [...new Array(pageCount)].fill(null).map((_2, i3) => i3);
      }
      return pageOptions;
    }, getMemoOptions(table.options, "debugTable", "getPageOptions"));
    table.getCanPreviousPage = () => table.getState().pagination.pageIndex > 0;
    table.getCanNextPage = () => {
      const {
        pageIndex
      } = table.getState().pagination;
      const pageCount = table.getPageCount();
      if (pageCount === -1) {
        return true;
      }
      if (pageCount === 0) {
        return false;
      }
      return pageIndex < pageCount - 1;
    };
    table.previousPage = () => {
      return table.setPageIndex((old) => old - 1);
    };
    table.nextPage = () => {
      return table.setPageIndex((old) => {
        return old + 1;
      });
    };
    table.firstPage = () => {
      return table.setPageIndex(0);
    };
    table.lastPage = () => {
      return table.setPageIndex(table.getPageCount() - 1);
    };
    table.getPrePaginationRowModel = () => table.getExpandedRowModel();
    table.getPaginationRowModel = () => {
      if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {
        table._getPaginationRowModel = table.options.getPaginationRowModel(table);
      }
      if (table.options.manualPagination || !table._getPaginationRowModel) {
        return table.getPrePaginationRowModel();
      }
      return table._getPaginationRowModel();
    };
    table.getPageCount = () => {
      var _table$options$pageCo2;
      return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getRowCount() / table.getState().pagination.pageSize);
    };
    table.getRowCount = () => {
      var _table$options$rowCou;
      return (_table$options$rowCou = table.options.rowCount) != null ? _table$options$rowCou : table.getPrePaginationRowModel().rows.length;
    };
  }
};
var getDefaultRowPinningState = () => ({
  top: [],
  bottom: []
});
var RowPinning = {
  getInitialState: (state) => {
    return {
      rowPinning: getDefaultRowPinningState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onRowPinningChange: makeStateUpdater("rowPinning", table)
    };
  },
  createRow: (row, table) => {
    row.pin = (position, includeLeafRows, includeParentRows) => {
      const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref) => {
        let {
          id
        } = _ref;
        return id;
      }) : [];
      const parentRowIds = includeParentRows ? row.getParentRows().map((_ref2) => {
        let {
          id
        } = _ref2;
        return id;
      }) : [];
      const rowIds = new Set([...parentRowIds, row.id, ...leafRowIds]);
      table.setRowPinning((old) => {
        var _old$top3, _old$bottom3;
        if (position === "bottom") {
          var _old$top, _old$bottom;
          return {
            top: ((_old$top = old == null ? undefined : old.top) != null ? _old$top : []).filter((d2) => !(rowIds != null && rowIds.has(d2))),
            bottom: [...((_old$bottom = old == null ? undefined : old.bottom) != null ? _old$bottom : []).filter((d2) => !(rowIds != null && rowIds.has(d2))), ...Array.from(rowIds)]
          };
        }
        if (position === "top") {
          var _old$top2, _old$bottom2;
          return {
            top: [...((_old$top2 = old == null ? undefined : old.top) != null ? _old$top2 : []).filter((d2) => !(rowIds != null && rowIds.has(d2))), ...Array.from(rowIds)],
            bottom: ((_old$bottom2 = old == null ? undefined : old.bottom) != null ? _old$bottom2 : []).filter((d2) => !(rowIds != null && rowIds.has(d2)))
          };
        }
        return {
          top: ((_old$top3 = old == null ? undefined : old.top) != null ? _old$top3 : []).filter((d2) => !(rowIds != null && rowIds.has(d2))),
          bottom: ((_old$bottom3 = old == null ? undefined : old.bottom) != null ? _old$bottom3 : []).filter((d2) => !(rowIds != null && rowIds.has(d2)))
        };
      });
    };
    row.getCanPin = () => {
      var _ref3;
      const {
        enableRowPinning,
        enablePinning
      } = table.options;
      if (typeof enableRowPinning === "function") {
        return enableRowPinning(row);
      }
      return (_ref3 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref3 : true;
    };
    row.getIsPinned = () => {
      const rowIds = [row.id];
      const {
        top,
        bottom
      } = table.getState().rowPinning;
      const isTop = rowIds.some((d2) => top == null ? undefined : top.includes(d2));
      const isBottom = rowIds.some((d2) => bottom == null ? undefined : bottom.includes(d2));
      return isTop ? "top" : isBottom ? "bottom" : false;
    };
    row.getPinnedIndex = () => {
      var _ref4, _visiblePinnedRowIds$;
      const position = row.getIsPinned();
      if (!position)
        return -1;
      const visiblePinnedRowIds = (_ref4 = position === "top" ? table.getTopRows() : table.getBottomRows()) == null ? undefined : _ref4.map((_ref5) => {
        let {
          id
        } = _ref5;
        return id;
      });
      return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? undefined : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;
    };
  },
  createTable: (table) => {
    table.setRowPinning = (updater) => table.options.onRowPinningChange == null ? undefined : table.options.onRowPinningChange(updater);
    table.resetRowPinning = (defaultState) => {
      var _table$initialState$r, _table$initialState;
      return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState = table.initialState) == null ? undefined : _table$initialState.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());
    };
    table.getIsSomeRowsPinned = (position) => {
      var _pinningState$positio;
      const pinningState = table.getState().rowPinning;
      if (!position) {
        var _pinningState$top, _pinningState$bottom;
        return Boolean(((_pinningState$top = pinningState.top) == null ? undefined : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? undefined : _pinningState$bottom.length));
      }
      return Boolean((_pinningState$positio = pinningState[position]) == null ? undefined : _pinningState$positio.length);
    };
    table._getPinnedRows = (visibleRows, pinnedRowIds, position) => {
      var _table$options$keepPi;
      const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => {
        const row = table.getRow(rowId, true);
        return row.getIsAllParentsExpanded() ? row : null;
      }) : (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => visibleRows.find((row) => row.id === rowId));
      return rows.filter(Boolean).map((d2) => ({
        ...d2,
        position
      }));
    };
    table.getTopRows = memo4(() => [table.getRowModel().rows, table.getState().rowPinning.top], (allRows, topPinnedRowIds) => table._getPinnedRows(allRows, topPinnedRowIds, "top"), getMemoOptions(table.options, "debugRows", "getTopRows"));
    table.getBottomRows = memo4(() => [table.getRowModel().rows, table.getState().rowPinning.bottom], (allRows, bottomPinnedRowIds) => table._getPinnedRows(allRows, bottomPinnedRowIds, "bottom"), getMemoOptions(table.options, "debugRows", "getBottomRows"));
    table.getCenterRows = memo4(() => [table.getRowModel().rows, table.getState().rowPinning.top, table.getState().rowPinning.bottom], (allRows, top, bottom) => {
      const topAndBottom = new Set([...top != null ? top : [], ...bottom != null ? bottom : []]);
      return allRows.filter((d2) => !topAndBottom.has(d2.id));
    }, getMemoOptions(table.options, "debugRows", "getCenterRows"));
  }
};
var RowSelection = {
  getInitialState: (state) => {
    return {
      rowSelection: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onRowSelectionChange: makeStateUpdater("rowSelection", table),
      enableRowSelection: true,
      enableMultiRowSelection: true,
      enableSubRowSelection: true
    };
  },
  createTable: (table) => {
    table.setRowSelection = (updater) => table.options.onRowSelectionChange == null ? undefined : table.options.onRowSelectionChange(updater);
    table.resetRowSelection = (defaultState) => {
      var _table$initialState$r;
      return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});
    };
    table.toggleAllRowsSelected = (value) => {
      table.setRowSelection((old) => {
        value = typeof value !== "undefined" ? value : !table.getIsAllRowsSelected();
        const rowSelection = {
          ...old
        };
        const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;
        if (value) {
          preGroupedFlatRows.forEach((row) => {
            if (!row.getCanSelect()) {
              return;
            }
            rowSelection[row.id] = true;
          });
        } else {
          preGroupedFlatRows.forEach((row) => {
            delete rowSelection[row.id];
          });
        }
        return rowSelection;
      });
    };
    table.toggleAllPageRowsSelected = (value) => table.setRowSelection((old) => {
      const resolvedValue = typeof value !== "undefined" ? value : !table.getIsAllPageRowsSelected();
      const rowSelection = {
        ...old
      };
      table.getRowModel().rows.forEach((row) => {
        mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);
      });
      return rowSelection;
    });
    table.getPreSelectedRowModel = () => table.getCoreRowModel();
    table.getSelectedRowModel = memo4(() => [table.getState().rowSelection, table.getCoreRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable", "getSelectedRowModel"));
    table.getFilteredSelectedRowModel = memo4(() => [table.getState().rowSelection, table.getFilteredRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable", "getFilteredSelectedRowModel"));
    table.getGroupedSelectedRowModel = memo4(() => [table.getState().rowSelection, table.getSortedRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable", "getGroupedSelectedRowModel"));
    table.getIsAllRowsSelected = () => {
      const preGroupedFlatRows = table.getFilteredRowModel().flatRows;
      const {
        rowSelection
      } = table.getState();
      let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);
      if (isAllRowsSelected) {
        if (preGroupedFlatRows.some((row) => row.getCanSelect() && !rowSelection[row.id])) {
          isAllRowsSelected = false;
        }
      }
      return isAllRowsSelected;
    };
    table.getIsAllPageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row) => row.getCanSelect());
      const {
        rowSelection
      } = table.getState();
      let isAllPageRowsSelected = !!paginationFlatRows.length;
      if (isAllPageRowsSelected && paginationFlatRows.some((row) => !rowSelection[row.id])) {
        isAllPageRowsSelected = false;
      }
      return isAllPageRowsSelected;
    };
    table.getIsSomeRowsSelected = () => {
      var _table$getState$rowSe;
      const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;
      return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;
    };
    table.getIsSomePageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows;
      return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row) => row.getCanSelect()).some((d2) => d2.getIsSelected() || d2.getIsSomeSelected());
    };
    table.getToggleAllRowsSelectedHandler = () => {
      return (e2) => {
        table.toggleAllRowsSelected(e2.target.checked);
      };
    };
    table.getToggleAllPageRowsSelectedHandler = () => {
      return (e2) => {
        table.toggleAllPageRowsSelected(e2.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row.toggleSelected = (value, opts) => {
      const isSelected = row.getIsSelected();
      table.setRowSelection((old) => {
        var _opts$selectChildren;
        value = typeof value !== "undefined" ? value : !isSelected;
        if (row.getCanSelect() && isSelected === value) {
          return old;
        }
        const selectedRowIds = {
          ...old
        };
        mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? undefined : opts.selectChildren) != null ? _opts$selectChildren : true, table);
        return selectedRowIds;
      });
    };
    row.getIsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isRowSelected(row, rowSelection);
    };
    row.getIsSomeSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === "some";
    };
    row.getIsAllSubRowsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === "all";
    };
    row.getCanSelect = () => {
      var _table$options$enable;
      if (typeof table.options.enableRowSelection === "function") {
        return table.options.enableRowSelection(row);
      }
      return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;
    };
    row.getCanSelectSubRows = () => {
      var _table$options$enable2;
      if (typeof table.options.enableSubRowSelection === "function") {
        return table.options.enableSubRowSelection(row);
      }
      return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;
    };
    row.getCanMultiSelect = () => {
      var _table$options$enable3;
      if (typeof table.options.enableMultiRowSelection === "function") {
        return table.options.enableMultiRowSelection(row);
      }
      return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;
    };
    row.getToggleSelectedHandler = () => {
      const canSelect = row.getCanSelect();
      return (e2) => {
        var _target;
        if (!canSelect)
          return;
        row.toggleSelected((_target = e2.target) == null ? undefined : _target.checked);
      };
    };
  }
};
var mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table) => {
  var _row$subRows;
  const row = table.getRow(id, true);
  if (value) {
    if (!row.getCanMultiSelect()) {
      Object.keys(selectedRowIds).forEach((key) => delete selectedRowIds[key]);
    }
    if (row.getCanSelect()) {
      selectedRowIds[id] = true;
    }
  } else {
    delete selectedRowIds[id];
  }
  if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {
    row.subRows.forEach((row2) => mutateRowIsSelected(selectedRowIds, row2.id, value, includeChildren, table));
  }
};
function selectRowsFn(table, rowModel) {
  const rowSelection = table.getState().rowSelection;
  const newSelectedFlatRows = [];
  const newSelectedRowsById = {};
  const recurseRows = function(rows, depth) {
    return rows.map((row) => {
      var _row$subRows2;
      const isSelected = isRowSelected(row, rowSelection);
      if (isSelected) {
        newSelectedFlatRows.push(row);
        newSelectedRowsById[row.id] = row;
      }
      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {
        row = {
          ...row,
          subRows: recurseRows(row.subRows)
        };
      }
      if (isSelected) {
        return row;
      }
    }).filter(Boolean);
  };
  return {
    rows: recurseRows(rowModel.rows),
    flatRows: newSelectedFlatRows,
    rowsById: newSelectedRowsById
  };
}
function isRowSelected(row, selection) {
  var _selection$row$id;
  return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;
}
function isSubRowSelected(row, selection, table) {
  var _row$subRows3;
  if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length))
    return false;
  let allChildrenSelected = true;
  let someSelected = false;
  row.subRows.forEach((subRow) => {
    if (someSelected && !allChildrenSelected) {
      return;
    }
    if (subRow.getCanSelect()) {
      if (isRowSelected(subRow, selection)) {
        someSelected = true;
      } else {
        allChildrenSelected = false;
      }
    }
    if (subRow.subRows && subRow.subRows.length) {
      const subRowChildrenSelected = isSubRowSelected(subRow, selection);
      if (subRowChildrenSelected === "all") {
        someSelected = true;
      } else if (subRowChildrenSelected === "some") {
        someSelected = true;
        allChildrenSelected = false;
      } else {
        allChildrenSelected = false;
      }
    }
  });
  return allChildrenSelected ? "all" : someSelected ? "some" : false;
}
var reSplitAlphaNumeric = /([0-9]+)/gm;
var alphanumeric = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
var alphanumericCaseSensitive = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
var text = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
var textCaseSensitive = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
var datetime = (rowA, rowB, columnId) => {
  const a4 = rowA.getValue(columnId);
  const b4 = rowB.getValue(columnId);
  return a4 > b4 ? 1 : a4 < b4 ? -1 : 0;
};
var basic = (rowA, rowB, columnId) => {
  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));
};
function compareBasic(a4, b4) {
  return a4 === b4 ? 0 : a4 > b4 ? 1 : -1;
}
function toString(a4) {
  if (typeof a4 === "number") {
    if (isNaN(a4) || a4 === Infinity || a4 === -Infinity) {
      return "";
    }
    return String(a4);
  }
  if (typeof a4 === "string") {
    return a4;
  }
  return "";
}
function compareAlphanumeric(aStr, bStr) {
  const a4 = aStr.split(reSplitAlphaNumeric).filter(Boolean);
  const b4 = bStr.split(reSplitAlphaNumeric).filter(Boolean);
  while (a4.length && b4.length) {
    const aa = a4.shift();
    const bb = b4.shift();
    const an = parseInt(aa, 10);
    const bn = parseInt(bb, 10);
    const combo = [an, bn].sort();
    if (isNaN(combo[0])) {
      if (aa > bb) {
        return 1;
      }
      if (bb > aa) {
        return -1;
      }
      continue;
    }
    if (isNaN(combo[1])) {
      return isNaN(an) ? -1 : 1;
    }
    if (an > bn) {
      return 1;
    }
    if (bn > an) {
      return -1;
    }
  }
  return a4.length - b4.length;
}
var sortingFns = {
  alphanumeric,
  alphanumericCaseSensitive,
  text,
  textCaseSensitive,
  datetime,
  basic
};
var RowSorting = {
  getInitialState: (state) => {
    return {
      sorting: [],
      ...state
    };
  },
  getDefaultColumnDef: () => {
    return {
      sortingFn: "auto",
      sortUndefined: 1
    };
  },
  getDefaultOptions: (table) => {
    return {
      onSortingChange: makeStateUpdater("sorting", table),
      isMultiSortEvent: (e2) => {
        return e2.shiftKey;
      }
    };
  },
  createColumn: (column, table) => {
    column.getAutoSortingFn = () => {
      const firstRows = table.getFilteredRowModel().flatRows.slice(10);
      let isString = false;
      for (const row of firstRows) {
        const value = row == null ? undefined : row.getValue(column.id);
        if (Object.prototype.toString.call(value) === "[object Date]") {
          return sortingFns.datetime;
        }
        if (typeof value === "string") {
          isString = true;
          if (value.split(reSplitAlphaNumeric).length > 1) {
            return sortingFns.alphanumeric;
          }
        }
      }
      if (isString) {
        return sortingFns.text;
      }
      return sortingFns.basic;
    };
    column.getAutoSortDir = () => {
      const firstRow = table.getFilteredRowModel().flatRows[0];
      const value = firstRow == null ? undefined : firstRow.getValue(column.id);
      if (typeof value === "string") {
        return "asc";
      }
      return "desc";
    };
    column.getSortingFn = () => {
      var _table$options$sortin, _table$options$sortin2;
      if (!column) {
        throw new Error;
      }
      return isFunction2(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === "auto" ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? undefined : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];
    };
    column.toggleSorting = (desc, multi) => {
      const nextSortingOrder = column.getNextSortingOrder();
      const hasManualValue = typeof desc !== "undefined" && desc !== null;
      table.setSorting((old) => {
        const existingSorting = old == null ? undefined : old.find((d2) => d2.id === column.id);
        const existingIndex = old == null ? undefined : old.findIndex((d2) => d2.id === column.id);
        let newSorting = [];
        let sortAction;
        let nextDesc = hasManualValue ? desc : nextSortingOrder === "desc";
        if (old != null && old.length && column.getCanMultiSort() && multi) {
          if (existingSorting) {
            sortAction = "toggle";
          } else {
            sortAction = "add";
          }
        } else {
          if (old != null && old.length && existingIndex !== old.length - 1) {
            sortAction = "replace";
          } else if (existingSorting) {
            sortAction = "toggle";
          } else {
            sortAction = "replace";
          }
        }
        if (sortAction === "toggle") {
          if (!hasManualValue) {
            if (!nextSortingOrder) {
              sortAction = "remove";
            }
          }
        }
        if (sortAction === "add") {
          var _table$options$maxMul;
          newSorting = [...old, {
            id: column.id,
            desc: nextDesc
          }];
          newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));
        } else if (sortAction === "toggle") {
          newSorting = old.map((d2) => {
            if (d2.id === column.id) {
              return {
                ...d2,
                desc: nextDesc
              };
            }
            return d2;
          });
        } else if (sortAction === "remove") {
          newSorting = old.filter((d2) => d2.id !== column.id);
        } else {
          newSorting = [{
            id: column.id,
            desc: nextDesc
          }];
        }
        return newSorting;
      });
    };
    column.getFirstSortDir = () => {
      var _ref, _column$columnDef$sor;
      const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === "desc";
      return sortDescFirst ? "desc" : "asc";
    };
    column.getNextSortingOrder = (multi) => {
      var _table$options$enable, _table$options$enable2;
      const firstSortDirection = column.getFirstSortDir();
      const isSorted = column.getIsSorted();
      if (!isSorted) {
        return firstSortDirection;
      }
      if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true)) {
        return false;
      }
      return isSorted === "desc" ? "asc" : "desc";
    };
    column.getCanSort = () => {
      var _column$columnDef$ena, _table$options$enable3;
      return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;
    };
    column.getCanMultiSort = () => {
      var _ref2, _column$columnDef$ena2;
      return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;
    };
    column.getIsSorted = () => {
      var _table$getState$sorti;
      const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? undefined : _table$getState$sorti.find((d2) => d2.id === column.id);
      return !columnSort ? false : columnSort.desc ? "desc" : "asc";
    };
    column.getSortIndex = () => {
      var _table$getState$sorti2, _table$getState$sorti3;
      return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? undefined : _table$getState$sorti3.findIndex((d2) => d2.id === column.id)) != null ? _table$getState$sorti2 : -1;
    };
    column.clearSorting = () => {
      table.setSorting((old) => old != null && old.length ? old.filter((d2) => d2.id !== column.id) : []);
    };
    column.getToggleSortingHandler = () => {
      const canSort = column.getCanSort();
      return (e2) => {
        if (!canSort)
          return;
        e2.persist == null || e2.persist();
        column.toggleSorting == null || column.toggleSorting(undefined, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? undefined : table.options.isMultiSortEvent(e2) : false);
      };
    };
  },
  createTable: (table) => {
    table.setSorting = (updater) => table.options.onSortingChange == null ? undefined : table.options.onSortingChange(updater);
    table.resetSorting = (defaultState) => {
      var _table$initialState$s, _table$initialState;
      table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? undefined : _table$initialState.sorting) != null ? _table$initialState$s : []);
    };
    table.getPreSortedRowModel = () => table.getGroupedRowModel();
    table.getSortedRowModel = () => {
      if (!table._getSortedRowModel && table.options.getSortedRowModel) {
        table._getSortedRowModel = table.options.getSortedRowModel(table);
      }
      if (table.options.manualSorting || !table._getSortedRowModel) {
        return table.getPreSortedRowModel();
      }
      return table._getSortedRowModel();
    };
  }
};
var builtInFeatures = [
  Headers,
  ColumnVisibility,
  ColumnOrdering,
  ColumnPinning,
  ColumnFaceting,
  ColumnFiltering,
  GlobalFaceting,
  GlobalFiltering,
  RowSorting,
  ColumnGrouping,
  RowExpanding,
  RowPagination,
  RowPinning,
  RowSelection,
  ColumnSizing
];
function createTable(options2) {
  var _options$_features, _options$initialState;
  if (options2.debugAll || options2.debugTable) {
    console.info("Creating Table Instance...");
  }
  const _features = [...builtInFeatures, ...(_options$_features = options2._features) != null ? _options$_features : []];
  let table = {
    _features
  };
  const defaultOptions = table._features.reduce((obj, feature) => {
    return Object.assign(obj, feature.getDefaultOptions == null ? undefined : feature.getDefaultOptions(table));
  }, {});
  const mergeOptions = (options3) => {
    if (table.options.mergeOptions) {
      return table.options.mergeOptions(defaultOptions, options3);
    }
    return {
      ...defaultOptions,
      ...options3
    };
  };
  const coreInitialState = {};
  let initialState = {
    ...coreInitialState,
    ...(_options$initialState = options2.initialState) != null ? _options$initialState : {}
  };
  table._features.forEach((feature) => {
    var _feature$getInitialSt;
    initialState = (_feature$getInitialSt = feature.getInitialState == null ? undefined : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;
  });
  const queued = [];
  let queuedTimeout = false;
  const coreInstance = {
    _features,
    options: {
      ...defaultOptions,
      ...options2
    },
    initialState,
    _queue: (cb) => {
      queued.push(cb);
      if (!queuedTimeout) {
        queuedTimeout = true;
        Promise.resolve().then(() => {
          while (queued.length) {
            queued.shift()();
          }
          queuedTimeout = false;
        }).catch((error) => setTimeout(() => {
          throw error;
        }));
      }
    },
    reset: () => {
      table.setState(table.initialState);
    },
    setOptions: (updater) => {
      const newOptions = functionalUpdate(updater, table.options);
      table.options = mergeOptions(newOptions);
    },
    getState: () => {
      return table.options.state;
    },
    setState: (updater) => {
      table.options.onStateChange == null || table.options.onStateChange(updater);
    },
    _getRowId: (row, index2, parent) => {
      var _table$options$getRow;
      return (_table$options$getRow = table.options.getRowId == null ? undefined : table.options.getRowId(row, index2, parent)) != null ? _table$options$getRow : `${parent ? [parent.id, index2].join(".") : index2}`;
    },
    getCoreRowModel: () => {
      if (!table._getCoreRowModel) {
        table._getCoreRowModel = table.options.getCoreRowModel(table);
      }
      return table._getCoreRowModel();
    },
    getRowModel: () => {
      return table.getPaginationRowModel();
    },
    getRow: (id, searchAll) => {
      let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id];
      if (!row) {
        row = table.getCoreRowModel().rowsById[id];
        if (!row) {
          if (true) {
            throw new Error(`getRow could not find row with ID: ${id}`);
          }
          throw new Error;
        }
      }
      return row;
    },
    _getDefaultColumnDef: memo4(() => [table.options.defaultColumn], (defaultColumn) => {
      var _defaultColumn;
      defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};
      return {
        header: (props) => {
          const resolvedColumnDef = props.header.column.columnDef;
          if (resolvedColumnDef.accessorKey) {
            return resolvedColumnDef.accessorKey;
          }
          if (resolvedColumnDef.accessorFn) {
            return resolvedColumnDef.id;
          }
          return null;
        },
        cell: (props) => {
          var _props$renderValue$to, _props$renderValue;
          return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? undefined : _props$renderValue.toString()) != null ? _props$renderValue$to : null;
        },
        ...table._features.reduce((obj, feature) => {
          return Object.assign(obj, feature.getDefaultColumnDef == null ? undefined : feature.getDefaultColumnDef());
        }, {}),
        ...defaultColumn
      };
    }, getMemoOptions(options2, "debugColumns", "_getDefaultColumnDef")),
    _getColumnDefs: () => table.options.columns,
    getAllColumns: memo4(() => [table._getColumnDefs()], (columnDefs) => {
      const recurseColumns = function(columnDefs2, parent, depth) {
        if (depth === undefined) {
          depth = 0;
        }
        return columnDefs2.map((columnDef) => {
          const column = createColumn(table, columnDef, depth, parent);
          const groupingColumnDef = columnDef;
          column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];
          return column;
        });
      };
      return recurseColumns(columnDefs);
    }, getMemoOptions(options2, "debugColumns", "getAllColumns")),
    getAllFlatColumns: memo4(() => [table.getAllColumns()], (allColumns) => {
      return allColumns.flatMap((column) => {
        return column.getFlatColumns();
      });
    }, getMemoOptions(options2, "debugColumns", "getAllFlatColumns")),
    _getAllFlatColumnsById: memo4(() => [table.getAllFlatColumns()], (flatColumns) => {
      return flatColumns.reduce((acc, column) => {
        acc[column.id] = column;
        return acc;
      }, {});
    }, getMemoOptions(options2, "debugColumns", "getAllFlatColumnsById")),
    getAllLeafColumns: memo4(() => [table.getAllColumns(), table._getOrderColumnsFn()], (allColumns, orderColumns2) => {
      let leafColumns = allColumns.flatMap((column) => column.getLeafColumns());
      return orderColumns2(leafColumns);
    }, getMemoOptions(options2, "debugColumns", "getAllLeafColumns")),
    getColumn: (columnId) => {
      const column = table._getAllFlatColumnsById()[columnId];
      if (!column) {
        console.error(`[Table] Column with id '${columnId}' does not exist.`);
      }
      return column;
    }
  };
  Object.assign(table, coreInstance);
  for (let index2 = 0;index2 < table._features.length; index2++) {
    const feature = table._features[index2];
    feature == null || feature.createTable == null || feature.createTable(table);
  }
  return table;
}
function getCoreRowModel() {
  return (table) => memo4(() => [table.options.data], (data) => {
    const rowModel = {
      rows: [],
      flatRows: [],
      rowsById: {}
    };
    const accessRows = function(originalRows, depth, parentRow) {
      if (depth === undefined) {
        depth = 0;
      }
      const rows = [];
      for (let i3 = 0;i3 < originalRows.length; i3++) {
        const row = createRow(table, table._getRowId(originalRows[i3], i3, parentRow), originalRows[i3], i3, depth, undefined, parentRow == null ? undefined : parentRow.id);
        rowModel.flatRows.push(row);
        rowModel.rowsById[row.id] = row;
        rows.push(row);
        if (table.options.getSubRows) {
          var _row$originalSubRows;
          row.originalSubRows = table.options.getSubRows(originalRows[i3], i3);
          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {
            row.subRows = accessRows(row.originalSubRows, depth + 1, row);
          }
        }
      }
      return rows;
    };
    rowModel.rows = accessRows(data);
    return rowModel;
  }, getMemoOptions(table.options, "debugTable", "getRowModel", () => table._autoResetPageIndex()));
}
function getExpandedRowModel() {
  return (table) => memo4(() => [table.getState().expanded, table.getPreExpandedRowModel(), table.options.paginateExpandedRows], (expanded, rowModel, paginateExpandedRows) => {
    if (!rowModel.rows.length || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {
      return rowModel;
    }
    if (!paginateExpandedRows) {
      return rowModel;
    }
    return expandRows(rowModel);
  }, getMemoOptions(table.options, "debugTable", "getExpandedRowModel"));
}
function expandRows(rowModel) {
  const expandedRows = [];
  const handleRow = (row) => {
    var _row$subRows;
    expandedRows.push(row);
    if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {
      row.subRows.forEach(handleRow);
    }
  };
  rowModel.rows.forEach(handleRow);
  return {
    rows: expandedRows,
    flatRows: rowModel.flatRows,
    rowsById: rowModel.rowsById
  };
}

// ../../node_modules/.pnpm/@tanstack+react-table@8.21.3_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@tanstack/react-table/build/lib/index.mjs
function flexRender(Comp, props) {
  return !Comp ? null : isReactComponent(Comp) ? /* @__PURE__ */ React52.createElement(Comp, props) : Comp;
}
function isReactComponent(component) {
  return isClassComponent(component) || typeof component === "function" || isExoticComponent(component);
}
function isClassComponent(component) {
  return typeof component === "function" && (() => {
    const proto = Object.getPrototypeOf(component);
    return proto.prototype && proto.prototype.isReactComponent;
  })();
}
function isExoticComponent(component) {
  return typeof component === "object" && typeof component.$$typeof === "symbol" && ["react.memo", "react.forward_ref"].includes(component.$$typeof.description);
}
function useReactTable(options2) {
  const resolvedOptions = {
    state: {},
    onStateChange: () => {},
    renderFallbackValue: null,
    ...options2
  };
  const [tableRef] = React52.useState(() => ({
    current: createTable(resolvedOptions)
  }));
  const [state, setState] = React52.useState(() => tableRef.current.initialState);
  tableRef.current.setOptions((prev) => ({
    ...prev,
    ...options2,
    state: {
      ...state,
      ...options2.state
    },
    onStateChange: (updater) => {
      setState(updater);
      options2.onStateChange == null || options2.onStateChange(updater);
    }
  }));
  return tableRef.current;
}

// ../../src/features/report-editor/components/PropertyPanel/DataBindingModal.tsx
var import_react33 = __toESM(require_react(), 1);

// ../../src/components/ui/Dialog.tsx
var React53 = __toESM(require_react(), 1);
var jsx_dev_runtime58 = __toESM(require_jsx_dev_runtime(), 1);
var Dialog2 = Root6;
var DialogPortal2 = Portal5;
var DialogOverlay2 = React53.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx_dev_runtime58.jsxDEV(Overlay, {
  ref,
  className: cn2("fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0", className),
  ...props
}, undefined, false, undefined, this));
DialogOverlay2.displayName = Overlay.displayName;
var DialogContent2 = React53.forwardRef(({ className, children, ...props }, ref) => {
  const { t: t2 } = useI18n();
  return /* @__PURE__ */ jsx_dev_runtime58.jsxDEV(DialogPortal2, {
    children: [
      /* @__PURE__ */ jsx_dev_runtime58.jsxDEV(DialogOverlay2, {}, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime58.jsxDEV(Content3, {
        ref,
        className: cn2("fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border border-border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg text-foreground", className),
        ...props,
        children: [
          children,
          /* @__PURE__ */ jsx_dev_runtime58.jsxDEV(Close, {
            className: "absolute right-4 top-4 rounded-sm opacity-70 transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground text-foreground",
            children: [
              /* @__PURE__ */ jsx_dev_runtime58.jsxDEV(X, {
                className: "h-4 w-4"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime58.jsxDEV("span", {
                className: "sr-only",
                children: t2("close", "Close")
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
});
DialogContent2.displayName = Content3.displayName;
var DialogHeader = ({ className, ...props }) => /* @__PURE__ */ jsx_dev_runtime58.jsxDEV("div", {
  className: cn2("flex flex-col space-y-1.5 text-center sm:text-left", className),
  ...props
}, undefined, false, undefined, this);
DialogHeader.displayName = "DialogHeader";
var DialogFooter = ({ className, ...props }) => /* @__PURE__ */ jsx_dev_runtime58.jsxDEV("div", {
  className: cn2("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className),
  ...props
}, undefined, false, undefined, this);
DialogFooter.displayName = "DialogFooter";
var DialogTitle2 = React53.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx_dev_runtime58.jsxDEV(Title, {
  ref,
  className: cn2("text-lg font-semibold leading-none tracking-tight text-foreground", className),
  ...props
}, undefined, false, undefined, this));
DialogTitle2.displayName = Title.displayName;
var DialogDescription2 = React53.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx_dev_runtime58.jsxDEV(Description, {
  ref,
  className: cn2("text-sm text-muted-foreground", className),
  ...props
}, undefined, false, undefined, this));
DialogDescription2.displayName = Description.displayName;

// ../../src/components/ui/SimpleSearchInput.tsx
var import_react31 = __toESM(require_react(), 1);
var jsx_dev_runtime59 = __toESM(require_jsx_dev_runtime(), 1);
var SimpleSearchInput = import_react31.default.memo(import_react31.default.forwardRef(({ onSearch, placeholder, ...props }, ref) => {
  const { t: t2 } = useI18n();
  const effectivePlaceholder = placeholder ?? t2("search_placeholder", "Search...");
  return /* @__PURE__ */ jsx_dev_runtime59.jsxDEV("div", {
    style: { position: "relative", width: "100%" },
    children: [
      /* @__PURE__ */ jsx_dev_runtime59.jsxDEV(Search, {
        style: {
          position: "absolute",
          left: "12px",
          top: "50%",
          transform: "translateY(-50%)",
          color: "hsl(var(--muted-foreground))",
          fontSize: "18px",
          pointerEvents: "none"
        }
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime59.jsxDEV("input", {
        ref,
        type: "text",
        style: {
          width: "100%",
          paddingLeft: "40px",
          paddingRight: "16px",
          paddingTop: "10px",
          paddingBottom: "10px",
          fontSize: "14px",
          lineHeight: "1.5",
          border: "1px solid",
          borderColor: "hsl(var(--border))",
          backgroundColor: "hsl(var(--secondary))",
          color: "hsl(var(--foreground))",
          borderRadius: "6px",
          fontFamily: "inherit",
          boxSizing: "border-box",
          transition: "all 150ms ease-in-out"
        },
        placeholder: effectivePlaceholder,
        onChange: (e2) => onSearch?.(e2.target.value),
        ...props
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}));
SimpleSearchInput.displayName = "SimpleSearchInput";

// ../../src/components/ui/SimpleTreeTable.tsx
var import_react32 = __toESM(require_react(), 1);
var jsx_dev_runtime60 = __toESM(require_jsx_dev_runtime(), 1);
var SimpleTreeTable = ({
  data,
  columns,
  onRowClick,
  className,
  getRowId,
  getSubRows
}) => {
  const [expanded, setExpanded] = import_react32.useState({});
  const table = useReactTable({
    data,
    columns,
    state: {
      expanded
    },
    onExpandedChange: setExpanded,
    getSubRows,
    getRowId,
    getCoreRowModel: getCoreRowModel(),
    getExpandedRowModel: getExpandedRowModel()
  });
  return /* @__PURE__ */ jsx_dev_runtime60.jsxDEV("div", {
    className: cn2("w-full border border-border rounded-md overflow-hidden bg-background", className),
    children: [
      /* @__PURE__ */ jsx_dev_runtime60.jsxDEV("table", {
        className: "w-full text-sm text-left",
        children: [
          /* @__PURE__ */ jsx_dev_runtime60.jsxDEV("thead", {
            className: "bg-muted text-muted-foreground font-medium border-b border-border",
            children: table.getHeaderGroups().map((headerGroup) => /* @__PURE__ */ jsx_dev_runtime60.jsxDEV("tr", {
              children: headerGroup.headers.map((header) => /* @__PURE__ */ jsx_dev_runtime60.jsxDEV("th", {
                className: "px-4 py-2 font-normal",
                children: header.isPlaceholder ? null : flexRender(header.column.columnDef.header, header.getContext())
              }, header.id, false, undefined, this))
            }, headerGroup.id, false, undefined, this))
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime60.jsxDEV("tbody", {
            children: table.getRowModel().rows.map((row) => {
              return /* @__PURE__ */ jsx_dev_runtime60.jsxDEV("tr", {
                className: cn2("border-b border-border last:border-0 hover:bg-muted/50 transition-colors text-foreground", onRowClick ? "cursor-pointer" : ""),
                onClick: () => onRowClick?.(row.original),
                children: row.getVisibleCells().map((cell) => /* @__PURE__ */ jsx_dev_runtime60.jsxDEV("td", {
                  className: "px-4 py-2 align-middle",
                  children: cell.column.id === "label" && row.getCanExpand() ? /* @__PURE__ */ jsx_dev_runtime60.jsxDEV("div", {
                    className: "flex items-center gap-1",
                    children: [
                      /* @__PURE__ */ jsx_dev_runtime60.jsxDEV("button", {
                        type: "button",
                        onClick: (e2) => {
                          e2.stopPropagation();
                          row.toggleExpanded();
                        },
                        className: "p-0.5 rounded hover:bg-accent",
                        children: /* @__PURE__ */ jsx_dev_runtime60.jsxDEV(ChevronRight, {
                          size: 14,
                          className: cn2("transition-transform", row.getIsExpanded() ? "rotate-90" : "")
                        }, undefined, false, undefined, this)
                      }, undefined, false, undefined, this),
                      flexRender(cell.column.columnDef.cell, cell.getContext())
                    ]
                  }, undefined, true, undefined, this) : cell.column.id === "label" ? /* @__PURE__ */ jsx_dev_runtime60.jsxDEV("div", {
                    style: {
                      paddingLeft: row.depth > 0 ? `${row.depth * 1.5}rem` : "1.25rem"
                    },
                    children: flexRender(cell.column.columnDef.cell, cell.getContext())
                  }, undefined, false, undefined, this) : flexRender(cell.column.columnDef.cell, cell.getContext())
                }, cell.id, false, undefined, this))
              }, row.id, false, undefined, this);
            })
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      table.getRowModel().rows.length === 0 && /* @__PURE__ */ jsx_dev_runtime60.jsxDEV("div", {
        className: "p-4 text-center text-muted-foreground",
        children: "No data found"
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/report-editor/components/PropertyPanel/DataBindingModal.tsx
var jsx_dev_runtime61 = __toESM(require_jsx_dev_runtime(), 1);
var columnHelper = createColumnHelper();
var getFieldIcon = (type) => {
  switch (type) {
    case "string":
      return /* @__PURE__ */ jsx_dev_runtime61.jsxDEV(Type, {
        size: 16,
        className: "text-gray-500"
      }, undefined, false, undefined, this);
    case "number":
      return /* @__PURE__ */ jsx_dev_runtime61.jsxDEV(Hash, {
        size: 16,
        className: "text-gray-500"
      }, undefined, false, undefined, this);
    case "date":
      return /* @__PURE__ */ jsx_dev_runtime61.jsxDEV(Calendar, {
        size: 16,
        className: "text-gray-500"
      }, undefined, false, undefined, this);
    case "image":
      return /* @__PURE__ */ jsx_dev_runtime61.jsxDEV(Image4, {
        size: 16,
        className: "text-gray-500"
      }, undefined, false, undefined, this);
    case "array":
      return /* @__PURE__ */ jsx_dev_runtime61.jsxDEV(Link, {
        size: 16,
        className: "text-gray-500"
      }, undefined, false, undefined, this);
    default:
      return /* @__PURE__ */ jsx_dev_runtime61.jsxDEV(Type, {
        size: 16,
        className: "text-gray-500"
      }, undefined, false, undefined, this);
  }
};
var DataBindingModal = ({
  isOpen,
  onClose,
  schema,
  onSelect,
  mode
}) => {
  const { t: t2 } = useI18n();
  const [searchQuery, setSearchQuery] = import_react33.useState("");
  const hierarchyItems = import_react33.useMemo(() => {
    const query = searchQuery.toLowerCase();
    const rootItems = schema.categories.map((cat) => {
      const children = cat.fields.map((field) => ({
        id: field.id,
        label: field.label,
        type: field.type,
        categoryId: cat.id,
        categoryLabel: cat.label,
        raw: field
      }));
      return {
        id: cat.id,
        label: cat.label,
        type: "category",
        raw: cat,
        subRows: children
      };
    });
    if (!query)
      return rootItems;
    return rootItems.reduce((acc, cat) => {
      const catMatches = cat.label.toLowerCase().includes(query);
      const matchingChildren = cat.subRows?.filter((child) => child.label.toLowerCase().includes(query));
      if (catMatches) {
        acc.push({
          ...cat,
          subRows: matchingChildren && matchingChildren.length > 0 ? matchingChildren : cat.subRows || []
        });
      } else if (matchingChildren && matchingChildren.length > 0) {
        acc.push({
          ...cat,
          subRows: matchingChildren
        });
      }
      return acc;
    }, []);
  }, [schema, searchQuery]);
  const handleSelect = (item) => {
    if (mode === "repeater") {
      if (item.type === "category") {
        onSelect({
          field: item.id,
          sourceId: item.id,
          fieldId: item.id,
          path: item.id
        });
        onClose();
      }
    } else {
      if (item.type !== "category" && item.categoryId) {
        const dotPath = `${item.categoryId}.${item.id}`;
        onSelect({
          field: dotPath,
          sourceId: item.categoryId,
          fieldId: item.id,
          path: item.id
        });
        onClose();
      }
    }
  };
  const columns = import_react33.useMemo(() => [
    columnHelper.accessor("label", {
      id: "label",
      header: t2("data_binding_name", "Name"),
      cell: (info) => {
        const item = info.row.original;
        return /* @__PURE__ */ jsx_dev_runtime61.jsxDEV("span", {
          className: item.type === "category" ? "font-bold text-foreground" : "font-medium text-muted-foreground",
          children: info.getValue()
        }, undefined, false, undefined, this);
      }
    }),
    columnHelper.accessor("type", {
      id: "type",
      header: t2("data_binding_type", "Type"),
      cell: (info) => {
        const typeValue = info.getValue();
        if (typeValue === "category")
          return /* @__PURE__ */ jsx_dev_runtime61.jsxDEV("span", {
            className: "text-xs font-semibold text-muted-foreground uppercase tracking-wider",
            children: t2("data_binding_category", "Category")
          }, undefined, false, undefined, this);
        return /* @__PURE__ */ jsx_dev_runtime61.jsxDEV("div", {
          className: "flex items-center gap-2",
          children: [
            getFieldIcon(typeValue),
            /* @__PURE__ */ jsx_dev_runtime61.jsxDEV("span", {
              className: "text-xs text-muted-foreground capitalize",
              children: typeValue
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this);
      }
    }),
    columnHelper.accessor("id", {
      id: "id",
      header: t2("data_binding_id", "ID"),
      cell: (info) => /* @__PURE__ */ jsx_dev_runtime61.jsxDEV("span", {
        className: "font-mono text-xs",
        children: info.getValue()
      }, undefined, false, undefined, this)
    })
  ], [t2]);
  return /* @__PURE__ */ jsx_dev_runtime61.jsxDEV(Dialog2, {
    open: isOpen,
    onOpenChange: onClose,
    children: /* @__PURE__ */ jsx_dev_runtime61.jsxDEV(DialogContent2, {
      className: "max-w-4xl h-[80vh] flex flex-col p-0 gap-0",
      children: [
        /* @__PURE__ */ jsx_dev_runtime61.jsxDEV(DialogHeader, {
          className: "px-6 py-4 border-b border-border",
          children: /* @__PURE__ */ jsx_dev_runtime61.jsxDEV(DialogTitle2, {
            children: mode === "field" ? t2("data_binding_select_field", "Select Field") : t2("data_binding_select_repeater", "Select Repeater")
          }, undefined, false, undefined, this)
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime61.jsxDEV("div", {
          className: "flex-1 flex flex-col p-4 min-h-0 overflow-hidden bg-secondary",
          children: [
            /* @__PURE__ */ jsx_dev_runtime61.jsxDEV("div", {
              className: "w-full max-w-sm mb-4 shrink-0",
              children: /* @__PURE__ */ jsx_dev_runtime61.jsxDEV(SimpleSearchInput, {
                placeholder: t2("search_placeholder", "Search..."),
                value: searchQuery,
                onSearch: setSearchQuery,
                autoFocus: true
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime61.jsxDEV("div", {
              className: "flex-1 min-h-0 overflow-auto bg-background rounded-md border border-border",
              children: /* @__PURE__ */ jsx_dev_runtime61.jsxDEV(SimpleTreeTable, {
                data: hierarchyItems,
                columns,
                onRowClick: handleSelect,
                getRowId: (row) => row.id,
                getSubRows: (row) => row.subRows,
                className: "border-0 rounded-none shadow-none"
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime61.jsxDEV(DialogFooter, {
          className: "p-4 border-t border-border bg-background",
          children: /* @__PURE__ */ jsx_dev_runtime61.jsxDEV(Button, {
            variant: "outline",
            size: "sm",
            onClick: onClose,
            children: t2("cancel", "Cancel")
          }, undefined, false, undefined, this)
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this);
};

// ../../src/components/ui/EditableSelect.tsx
var React55 = __toESM(require_react(), 1);
var jsx_dev_runtime62 = __toESM(require_jsx_dev_runtime(), 1);
var EditableSelect = ({
  value,
  onChange,
  options: options2,
  className,
  placeholder
}) => {
  const [isOpen, setIsOpen] = React55.useState(false);
  const containerRef = React55.useRef(null);
  React55.useEffect(() => {
    const handleClickOutside = (event) => {
      if (containerRef.current && !containerRef.current.contains(event.target)) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);
  const handleOptionClick = (option) => {
    onChange(String(option));
    setIsOpen(false);
  };
  return /* @__PURE__ */ jsx_dev_runtime62.jsxDEV("div", {
    className: cn2("relative", className),
    ref: containerRef,
    children: [
      /* @__PURE__ */ jsx_dev_runtime62.jsxDEV("div", {
        className: "flex items-center w-full border border-border rounded bg-background focus-within:ring-1 focus-within:ring-ring",
        children: [
          /* @__PURE__ */ jsx_dev_runtime62.jsxDEV("input", {
            type: "text",
            value,
            onChange: (e2) => onChange(e2.target.value),
            placeholder,
            className: "w-full px-1.5 py-1 text-[11px] bg-transparent border-none focus:outline-none text-foreground",
            onFocus: () => setIsOpen(true)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime62.jsxDEV("button", {
            type: "button",
            onClick: () => setIsOpen(!isOpen),
            className: "px-1 py-1 text-muted-foreground hover:bg-accent focus:outline-none",
            tabIndex: -1,
            children: /* @__PURE__ */ jsx_dev_runtime62.jsxDEV(ChevronDown, {
              size: 14
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      isOpen && /* @__PURE__ */ jsx_dev_runtime62.jsxDEV("div", {
        className: "absolute z-50 w-full mt-1 max-h-60 overflow-y-auto bg-background border border-border rounded shadow-lg scrollbar-thin",
        children: options2.map((option) => /* @__PURE__ */ jsx_dev_runtime62.jsxDEV("button", {
          type: "button",
          onClick: () => handleOptionClick(option),
          className: "w-full px-2 py-1 text-[11px] text-left text-foreground hover:bg-accent hover:text-accent-foreground",
          children: option
        }, option, false, undefined, this))
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/report-editor/components/PropertyPanel/TableProperties.tsx
var jsx_dev_runtime63 = __toESM(require_jsx_dev_runtime(), 1);
var TableProperties = ({
  element,
  onUpdate,
  selectedCell,
  i18nOverrides
}) => {
  const { t: t2 } = useI18n();
  const resolveText = (key, defaultValue) => {
    if (i18nOverrides?.[key])
      return i18nOverrides[key];
    return t2(key, defaultValue ?? key);
  };
  const updateCells = (updates) => {
    const newCells = [...element.table.cells];
    if (selectedCell) {
      const index2 = newCells.findIndex((c3) => c3.r === selectedCell.row && c3.c === selectedCell.col);
      if (index2 >= 0) {
        newCells[index2] = { ...newCells[index2], ...updates };
      } else {
        newCells.push({
          r: selectedCell.row,
          c: selectedCell.col,
          v: "",
          ...updates
        });
      }
    } else {
      const rowCount = element.table.rows.length;
      const colCount = element.table.cols.length;
      const covered = Array(rowCount).fill(null).map(() => Array(colCount).fill(false));
      for (const cell of newCells) {
        const rs = cell.rs || 1;
        const cs = cell.cs || 1;
        if (rs <= 1 && cs <= 1)
          continue;
        for (let rr = 0;rr < rs; rr++) {
          for (let cc = 0;cc < cs; cc++) {
            if (rr === 0 && cc === 0)
              continue;
            const r3 = cell.r + rr;
            const c3 = cell.c + cc;
            if (r3 >= 0 && r3 < rowCount && c3 >= 0 && c3 < colCount) {
              covered[r3][c3] = true;
            }
          }
        }
      }
      for (let r3 = 0;r3 < rowCount; r3++) {
        for (let c3 = 0;c3 < colCount; c3++) {
          if (covered[r3][c3])
            continue;
          if (!newCells.find((cell) => cell.r === r3 && cell.c === c3)) {
            const { r: _r, c: _c, v: _v, ...styles } = activeData;
            newCells.push({
              r: r3,
              c: c3,
              v: "",
              ...styles
            });
          }
        }
      }
      for (let i3 = 0;i3 < newCells.length; i3++) {
        const cell = newCells[i3];
        if (!covered[cell.r]?.[cell.c]) {
          newCells[i3] = { ...cell, ...updates };
        }
      }
    }
    onUpdate({ table: { ...element.table, cells: newCells } });
  };
  const isGlobal = !selectedCell;
  const defaultCell = {
    fontSize: 12,
    font: "Meiryo",
    bg: "transparent",
    align: "l",
    vAlign: "m",
    color: "#000000",
    borderW: 1,
    borderColor: "#000000",
    border: "#000000"
  };
  let activeData = defaultCell;
  if (selectedCell) {
    const found = element.table.cells.find((c3) => c3.r === selectedCell.row && c3.c === selectedCell.col);
    if (found)
      activeData = found;
  } else {
    if (element.table.cells.length > 0)
      activeData = element.table.cells[0];
  }
  const labelClass2 = "block text-[11px] text-muted-foreground mb-0.5";
  const headingClass = "text-[11px] font-medium text-muted-foreground mb-1.5";
  const fontSizes = [8, 9, 10, 10.5, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];
  const borderWidthOptions = [0, 0.5, 1, 1.5, 2, 3, 4];
  return /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("div", {
    className: "space-y-4",
    children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("div", {
      children: [
        /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("h4", {
          className: headingClass,
          children: isGlobal ? `${resolveText("properties_table_style", "Table Style")} (All Cells)` : resolveText("properties_table_cell_style", "Cell Style")
        }, undefined, false, undefined, this),
        !isGlobal && selectedCell && /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("div", {
          className: "text-[10px] text-blue-500 mb-2",
          children: [
            resolveText("properties_table_selected_cell", "Selected"),
            ": R",
            selectedCell.row + 1,
            ":C",
            selectedCell.col + 1
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("div", {
          className: "space-y-3",
          children: [
            /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("div", {
              children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("div", {
                className: "grid grid-cols-3 gap-1.5 mb-1.5",
                children: [
                  /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("div", {
                    children: [
                      /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("label", {
                        className: labelClass2,
                        children: resolveText("properties_font", "Font")
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(EditableSelect, {
                        value: activeData.font || "Meiryo",
                        onChange: (val) => updateCells({ font: String(val) }),
                        options: DEFAULT_FONT_FAMILIES,
                        className: "w-full"
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("div", {
                    children: [
                      /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("label", {
                        className: labelClass2,
                        children: resolveText("properties_size", "Size")
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(EditableSelect, {
                        value: activeData.fontSize || 12,
                        onChange: (val) => updateCells({ fontSize: Number(val) }),
                        options: fontSizes,
                        className: "w-full"
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("div", {
                    children: [
                      /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("label", {
                        className: labelClass2,
                        children: resolveText("properties_font_color", "FontColor")
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(ColorInput, {
                        value: activeData.color || "#000000",
                        onChange: (val) => updateCells({ color: val })
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this)
                ]
              }, undefined, true, undefined, this)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("div", {
              children: [
                /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("label", {
                  className: `${labelClass2} font-medium`,
                  children: resolveText("properties_text_align", "Text Align")
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("div", {
                  className: "flex bg-background rounded border border-border p-0.5 mb-2",
                  children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(TooltipProvider2, {
                    children: [
                      /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(Tooltip2, {
                        children: [
                          /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(TooltipTrigger2, {
                            asChild: true,
                            children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("button", {
                              type: "button",
                              onClick: () => updateCells({ align: "l" }),
                              className: `flex-1 flex items-center justify-center py-1 rounded ${activeData.align === "l" ? "bg-accent text-accent-foreground" : "text-muted-foreground hover:bg-accent"}`,
                              children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(AlignLeft, {
                                size: 14
                              }, undefined, false, undefined, this)
                            }, undefined, false, undefined, this)
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(TooltipContent2, {
                            children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("p", {
                              children: resolveText("side_left", "Left")
                            }, undefined, false, undefined, this)
                          }, undefined, false, undefined, this)
                        ]
                      }, undefined, true, undefined, this),
                      /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(Tooltip2, {
                        children: [
                          /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(TooltipTrigger2, {
                            asChild: true,
                            children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("button", {
                              type: "button",
                              onClick: () => updateCells({ align: "c" }),
                              className: `flex-1 flex items-center justify-center py-1 rounded ${activeData.align === "c" ? "bg-accent text-accent-foreground" : "text-muted-foreground hover:bg-accent"}`,
                              children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(AlignCenter, {
                                size: 14
                              }, undefined, false, undefined, this)
                            }, undefined, false, undefined, this)
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(TooltipContent2, {
                            children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("p", {
                              children: resolveText("center", "Center")
                            }, undefined, false, undefined, this)
                          }, undefined, false, undefined, this)
                        ]
                      }, undefined, true, undefined, this),
                      /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(Tooltip2, {
                        children: [
                          /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(TooltipTrigger2, {
                            asChild: true,
                            children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("button", {
                              type: "button",
                              onClick: () => updateCells({ align: "r" }),
                              className: `flex-1 flex items-center justify-center py-1 rounded ${activeData.align === "r" ? "bg-accent text-accent-foreground" : "text-muted-foreground hover:bg-accent"}`,
                              children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(AlignRight, {
                                size: 14
                              }, undefined, false, undefined, this)
                            }, undefined, false, undefined, this)
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(TooltipContent2, {
                            children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("p", {
                              children: resolveText("side_right", "Right")
                            }, undefined, false, undefined, this)
                          }, undefined, false, undefined, this)
                        ]
                      }, undefined, true, undefined, this)
                    ]
                  }, undefined, true, undefined, this)
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("div", {
              children: [
                /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("label", {
                  className: `${labelClass2} font-medium`,
                  children: resolveText("properties_vertical_align", "Vertical Alignment")
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("div", {
                  className: "flex bg-background rounded border border-border p-0.5",
                  children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(TooltipProvider2, {
                    children: [
                      /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(Tooltip2, {
                        children: [
                          /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(TooltipTrigger2, {
                            asChild: true,
                            children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("button", {
                              type: "button",
                              onClick: () => updateCells({ vAlign: "t" }),
                              className: `flex-1 flex items-center justify-center py-1 rounded ${activeData.vAlign === "t" ? "bg-accent text-accent-foreground" : "text-muted-foreground hover:bg-accent"}`,
                              children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(ArrowUpToLine, {
                                size: 14
                              }, undefined, false, undefined, this)
                            }, undefined, false, undefined, this)
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(TooltipContent2, {
                            children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("p", {
                              children: resolveText("top", "Top")
                            }, undefined, false, undefined, this)
                          }, undefined, false, undefined, this)
                        ]
                      }, undefined, true, undefined, this),
                      /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(Tooltip2, {
                        children: [
                          /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(TooltipTrigger2, {
                            asChild: true,
                            children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("button", {
                              type: "button",
                              onClick: () => updateCells({ vAlign: "m" }),
                              className: `flex-1 flex items-center justify-center py-1 rounded ${activeData.vAlign === "m" ? "bg-accent text-accent-foreground" : "text-muted-foreground hover:bg-accent"}`,
                              children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(AlignVerticalJustifyCenter, {
                                size: 14
                              }, undefined, false, undefined, this)
                            }, undefined, false, undefined, this)
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(TooltipContent2, {
                            children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("p", {
                              children: resolveText("middle", "Middle")
                            }, undefined, false, undefined, this)
                          }, undefined, false, undefined, this)
                        ]
                      }, undefined, true, undefined, this),
                      /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(Tooltip2, {
                        children: [
                          /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(TooltipTrigger2, {
                            asChild: true,
                            children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("button", {
                              type: "button",
                              onClick: () => updateCells({ vAlign: "b" }),
                              className: `flex-1 flex items-center justify-center py-1 rounded ${activeData.vAlign === "b" ? "bg-accent text-accent-foreground" : "text-muted-foreground hover:bg-accent"}`,
                              children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(ArrowDownToLine, {
                                size: 14
                              }, undefined, false, undefined, this)
                            }, undefined, false, undefined, this)
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(TooltipContent2, {
                            children: /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("p", {
                              children: resolveText("bottom", "Bottom")
                            }, undefined, false, undefined, this)
                          }, undefined, false, undefined, this)
                        ]
                      }, undefined, true, undefined, this)
                    ]
                  }, undefined, true, undefined, this)
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("div", {
              className: "grid grid-cols-3 gap-1.5",
              children: [
                /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("div", {
                  children: [
                    /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("label", {
                      className: labelClass2,
                      children: resolveText("properties_background_color", "Background Color")
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(ColorInput, {
                      value: activeData.bg || "transparent",
                      onChange: (val) => updateCells({ bg: val })
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this),
                /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("div", {
                  children: [
                    /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("label", {
                      className: labelClass2,
                      children: resolveText("properties_border_color", "Border Color")
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(ColorInput, {
                      value: activeData.borderColor || activeData.border || "#000000",
                      onChange: (val) => updateCells({ borderColor: val, border: val })
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this),
                /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("div", {
                  children: [
                    /* @__PURE__ */ jsx_dev_runtime63.jsxDEV("label", {
                      className: labelClass2,
                      children: resolveText("properties_border_width", "Border Width")
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx_dev_runtime63.jsxDEV(EditableSelect, {
                      value: activeData.borderW ?? (activeData.border ? 1 : 0),
                      onChange: (val) => updateCells({ borderW: Number(val) }),
                      options: borderWidthOptions,
                      className: "w-full"
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this)
              ]
            }, undefined, true, undefined, this)
          ]
        }, undefined, true, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this);
};

// ../../src/features/report-editor/components/PropertyPanel/WysiwygPropertiesPanel.tsx
var jsx_dev_runtime64 = __toESM(require_jsx_dev_runtime(), 1);
var FIBONACCI_GRID_SIZES2 = [2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377];
var labelClass2 = "block text-[13px] text-muted-foreground mb-0.5";
var inputClass2 = "w-full px-1.5 py-1 border border-border rounded text-[13px] bg-background text-foreground focus:outline-none focus:ring-1 focus:ring-ring";
var CanvasSettingsPanel2 = ({
  templateDoc,
  currentPageId,
  onTemplateChange,
  showGrid,
  onShowGridChange,
  gridSize,
  onGridSizeChange,
  snapStrength,
  onSnapStrengthChange,
  resolveText
}) => {
  const { t: t2 } = useI18n();
  const currentSurface = templateDoc.surfaces.find((s2) => s2.id === currentPageId) || templateDoc.surfaces[0];
  const bg = currentSurface?.bg || "#ffffff";
  const isColor = bg.startsWith("#") || bg.startsWith("rgb");
  const updateSurface = (updates) => {
    const nextDoc = {
      ...templateDoc,
      surfaces: templateDoc.surfaces.map((s2) => s2.id === currentSurface.id ? { ...s2, ...updates } : s2)
    };
    onTemplateChange(nextDoc);
  };
  return /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
    className: "w-64 bg-secondary px-2 py-1 overflow-x-hidden overflow-y-auto text-foreground",
    children: [
      /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
        className: "mb-3",
        children: [
          /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("h4", {
            className: "text-[13px] font-medium text-muted-foreground mb-1",
            children: resolveText("properties_page_background", "Background")
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
            className: "mb-1",
            children: [
              /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("label", {
                className: labelClass2,
                children: resolveText("color", "Color")
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("input", {
                type: "color",
                value: isColor ? bg : "#ffffff",
                onChange: (e2) => updateSurface({ bg: e2.target.value }),
                className: `${inputClass2} h-8 p-0.5 cursor-pointer`
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
            children: [
              /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("label", {
                className: labelClass2,
                children: resolveText("properties_image_url", "Image URL")
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
                className: "flex gap-1 mb-1",
                children: [
                  /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("input", {
                    value: !isColor ? bg : "",
                    onChange: (e2) => updateSurface({ bg: e2.target.value }),
                    placeholder: resolveText("properties_image_url_placeholder", "http://..."),
                    className: `${inputClass2} flex-1`
                  }, undefined, false, undefined, this),
                  !isColor && /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("button", {
                    onClick: () => updateSurface({ bg: "#ffffff" }),
                    className: "px-2 py-1 text-xs bg-destructive text-destructive-foreground rounded hover:bg-destructive/90 transition-colors",
                    title: resolveText("remove", "Remove"),
                    children: ""
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("label", {
                className: "flex flex-col items-center justify-center w-full h-8 border border-border border-dashed rounded cursor-pointer hover:bg-muted transition-colors",
                children: [
                  /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("span", {
                    className: "text-xs text-muted-foreground",
                    children: resolveText("browse", "Browse...")
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("input", {
                    type: "file",
                    accept: "image/*",
                    className: "hidden",
                    onChange: (e2) => {
                      const file = e2.target.files?.[0];
                      if (file) {
                        const reader = new FileReader;
                        reader.onload = (ev) => {
                          const result = ev.target?.result;
                          if (result) {
                            updateSurface({ bg: result });
                          }
                        };
                        reader.readAsDataURL(file);
                      }
                    }
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      onShowGridChange && /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
        className: "mb-3",
        children: [
          /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
            className: "flex items-center justify-between mb-1",
            children: [
              /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("label", {
                className: "text-[13px] text-muted-foreground",
                children: t2("settings_show_grid", "Grid")
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("input", {
                type: "checkbox",
                checked: showGrid ?? false,
                onChange: (e2) => onShowGridChange(e2.target.checked),
                className: "h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          showGrid && onGridSizeChange && /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
            children: [
              /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("label", {
                className: labelClass2,
                children: t2("settings_grid_size", "Size")
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("select", {
                value: gridSize ?? 13,
                onChange: (e2) => onGridSizeChange(Number(e2.target.value)),
                className: inputClass2,
                children: FIBONACCI_GRID_SIZES2.map((size4) => /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("option", {
                  value: size4,
                  children: [
                    size4,
                    "pt"
                  ]
                }, size4, true, undefined, this))
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      onSnapStrengthChange && /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
        className: "mb-3",
        children: /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
          className: "flex items-center justify-between",
          children: [
            /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("label", {
              className: "text-[13px] text-muted-foreground",
              children: t2("settings_snap_to_grid", "Snap to Grid")
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("input", {
              type: "checkbox",
              checked: (snapStrength ?? 0) > 0,
              onChange: (e2) => onSnapStrengthChange(e2.target.checked ? gridSize ?? 15 : 0),
              className: "h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
var SignatureDrawingPanel = ({ drawingSettings, onDrawingSettingsChange, onToolSelect, resolveText }) => /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
  className: "mb-4 space-y-3",
  children: [
    /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("h4", {
      className: "text-[13px] font-medium text-muted-foreground mb-1",
      children: resolveText("toolbar_signature", "Signature")
    }, undefined, false, undefined, this),
    /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
      children: [
        /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("label", {
          className: labelClass2,
          children: resolveText("properties_stroke_color", "Stroke Color")
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("input", {
          type: "color",
          value: drawingSettings.stroke,
          onChange: (e2) => onDrawingSettingsChange({ ...drawingSettings, stroke: e2.target.value }),
          className: `${inputClass2} h-8 p-0.5 cursor-pointer`
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this),
    /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
      children: [
        /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("label", {
          className: labelClass2,
          children: resolveText("properties_stroke_width", "Thickness")
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
          className: "flex items-center gap-2",
          children: [
            /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("input", {
              type: "number",
              min: "0.2",
              step: "0.2",
              value: drawingSettings.strokeWidth,
              onChange: (e2) => {
                const val = Number(e2.target.value);
                if (val >= 0.2)
                  onDrawingSettingsChange({ ...drawingSettings, strokeWidth: val });
              },
              className: inputClass2
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("span", {
              className: "text-[11px] text-muted-foreground",
              children: "mm"
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this)
      ]
    }, undefined, true, undefined, this),
    /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
      className: "mb-3",
      children: [
        /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("label", {
          className: labelClass2,
          children: [
            resolveText("properties_data_simplification", "Data Simplification"),
            ":",
            " ",
            drawingSettings.simplification ?? 0
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("input", {
          type: "range",
          min: "0",
          max: "3.0",
          step: "0.1",
          value: drawingSettings.simplification ?? 0,
          onChange: (e2) => onDrawingSettingsChange({ ...drawingSettings, simplification: parseFloat(e2.target.value) }),
          className: "w-full accent-accent"
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this),
    /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
      className: "mt-4 pt-4 border-t border-border",
      children: [
        /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("p", {
          className: "text-xs text-muted-foreground mb-3",
          children: resolveText("signature_instruction", "Drag on canvas to draw.")
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("button", {
          type: "button",
          onClick: () => onToolSelect("select"),
          className: "w-full flex items-center justify-center py-2 px-4 rounded bg-primary text-primary-foreground hover:bg-primary/90 transition-colors",
          children: resolveText("properties_finish_drawing", "Finish Drawing")
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this)
  ]
}, undefined, true, undefined, this);
var WysiwygPropertiesPanel = ({
  templateDoc,
  selectedElementId,
  selectedCell,
  onTemplateChange,
  currentPageId,
  schema,
  i18nOverrides,
  activeTool,
  onToolSelect,
  drawingSettings,
  onDrawingSettingsChange,
  showGrid,
  onShowGridChange,
  gridSize,
  onGridSizeChange,
  snapStrength,
  onSnapStrengthChange
}) => {
  const { t: t2 } = useI18n();
  const [activeBindingMode, setActiveBindingMode] = import_react34.default.useState(null);
  const resolveText = (key, fallback) => {
    if (i18nOverrides?.[key])
      return i18nOverrides[key];
    return t2(key, fallback ?? key);
  };
  const selectedElement = import_react34.default.useMemo(() => {
    return templateDoc.nodes.find((el) => el.id === selectedElementId);
  }, [templateDoc.nodes, selectedElementId]);
  const isDrawing = activeTool === "signature";
  const handleChange = (id, updates, options2) => {
    const currentNode = templateDoc.nodes.find((n2) => n2.id === id);
    const finalUpdates = currentNode && currentNode.t === "text" ? applyTextLayoutUpdates(currentNode, updates) : updates;
    const nextDoc = {
      ...templateDoc,
      nodes: templateDoc.nodes.map((el) => el.id === id ? { ...el, ...finalUpdates } : el)
    };
    onTemplateChange(nextDoc, options2);
  };
  if (isDrawing && drawingSettings && onDrawingSettingsChange && onToolSelect) {
    return /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
      className: "w-full h-full bg-secondary px-2 py-1 overflow-x-hidden overflow-y-auto",
      children: /* @__PURE__ */ jsx_dev_runtime64.jsxDEV(SignatureDrawingPanel, {
        drawingSettings,
        onDrawingSettingsChange,
        onToolSelect,
        resolveText
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this);
  }
  if (!selectedElement) {
    return /* @__PURE__ */ jsx_dev_runtime64.jsxDEV(CanvasSettingsPanel2, {
      templateDoc,
      currentPageId,
      onTemplateChange,
      showGrid,
      onShowGridChange,
      gridSize,
      onGridSizeChange,
      snapStrength,
      onSnapStrengthChange,
      resolveText
    }, undefined, false, undefined, this);
  }
  const customRenderers = {
    tableProperties: ({ node }) => /* @__PURE__ */ jsx_dev_runtime64.jsxDEV(TableProperties, {
      element: node,
      onUpdate: (newAttrs) => handleChange(node.id, newAttrs),
      selectedCell,
      i18nOverrides
    }, undefined, false, undefined, this),
    dataBindingField: ({ node }) => /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
      children: /* @__PURE__ */ jsx_dev_runtime64.jsxDEV(BindingSelector, {
        binding: node.bind ? { field: node.bind } : undefined,
        onUpdate: (binding) => handleChange(node.id, { bind: binding?.field }),
        onOpenModal: () => setActiveBindingMode("field"),
        i18nOverrides
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this),
    dataBindingRepeater: ({ node }) => /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
      children: /* @__PURE__ */ jsx_dev_runtime64.jsxDEV(BindingSelector, {
        binding: node.bind ? { field: node.bind } : undefined,
        onUpdate: (binding) => handleChange(node.id, { bind: binding?.field }),
        onOpenModal: () => setActiveBindingMode("repeater"),
        i18nOverrides
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this),
    lineRouting: ({ node }) => {
      const line = node;
      return /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
        className: "mb-3",
        children: /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("label", {
          className: "flex items-center space-x-2 cursor-pointer",
          children: [
            /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("input", {
              type: "checkbox",
              checked: line.routing === "orthogonal",
              onChange: (e2) => handleChange(node.id, { routing: e2.target.checked ? "orthogonal" : "straight" }),
              className: "h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("span", {
              className: "text-[13px] text-muted-foreground",
              children: "Orthogonal Routing (90)"
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this)
      }, undefined, false, undefined, this);
    },
    lineWaypoints: ({ node }) => {
      const line = node;
      const intermediateCount = Math.max(0, (line.pts.length - 4) / 2);
      const updateCount = (newCount) => {
        if (Number.isNaN(newCount) || newCount < 0)
          return;
        const currentCount = (line.pts.length - 4) / 2;
        if (newCount === currentCount)
          return;
        const newPts = [...line.pts];
        if (newCount > currentCount) {
          const addCount = newCount - currentCount;
          for (let i3 = 0;i3 < addCount; i3++) {
            const len = newPts.length;
            const p1x = newPts[len - 4], p1y = newPts[len - 3];
            const p2x = newPts[len - 2], p2y = newPts[len - 1];
            const mx = (p1x + p2x) / 2;
            const my = (p1y + p2y) / 2;
            newPts.splice(len - 2, 0, mx, my);
          }
        } else {
          const removeCount = currentCount - newCount;
          newPts.splice(newPts.length - 2 - removeCount * 2, removeCount * 2);
        }
        handleChange(node.id, { pts: newPts });
      };
      return /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
        className: "mb-3",
        children: [
          /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("label", {
            className: labelClass2,
            children: "Waypoints Count"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("input", {
            type: "number",
            min: "0",
            value: intermediateCount,
            onChange: (e2) => updateCount(parseInt(e2.target.value, 10)),
            className: inputClass2
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this);
    }
  };
  const handleBindingSelect = (binding) => {
    if (selectedElement) {
      handleChange(selectedElement.id, { bind: binding.field });
    }
    setActiveBindingMode(null);
  };
  return /* @__PURE__ */ jsx_dev_runtime64.jsxDEV("div", {
    className: "w-full h-full bg-secondary px-2 py-1 overflow-x-hidden overflow-y-auto",
    children: [
      /* @__PURE__ */ jsx_dev_runtime64.jsxDEV(UnifiedPropertyPanel, {
        config: REPORT_PANEL_CONFIG,
        selectedNode: selectedElement,
        onChange: handleChange,
        i18nOverrides,
        customRenderers
      }, undefined, false, undefined, this),
      activeBindingMode && schema && /* @__PURE__ */ jsx_dev_runtime64.jsxDEV(DataBindingModal, {
        isOpen: true,
        onClose: () => setActiveBindingMode(null),
        onSelect: handleBindingSelect,
        mode: activeBindingMode,
        schema
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
// ../../src/features/konva-editor/hooks/useCanvasOperations.ts
var import_react35 = __toESM(require_react(), 1);

// ../../src/utils/id.ts
var prefixMap = {
  text: "txt",
  shape: "shp",
  line: "ln",
  image: "img",
  group: "grp",
  table: "tbl",
  signature: "sig",
  widget: "wgt"
};
function generateNodeId(doc, nodeType) {
  const prefix = prefixMap[nodeType];
  const existingIds = new Set(doc.nodes.map((n2) => n2.id));
  let counter = 1;
  let candidateId = `${prefix}-${counter}`;
  while (existingIds.has(candidateId)) {
    counter++;
    candidateId = `${prefix}-${counter}`;
  }
  return candidateId;
}
function generateSurfaceId(doc, surfaceType) {
  const prefix = surfaceType === "slide" ? "slide" : surfaceType === "page" ? "page" : "canvas";
  const existingIds = new Set(doc.surfaces.map((s2) => s2.id));
  let counter = 1;
  let candidateId = `${prefix}-${counter}`;
  while (existingIds.has(candidateId)) {
    counter++;
    candidateId = `${prefix}-${counter}`;
  }
  return candidateId;
}

// ../../src/features/konva-editor/hooks/useCanvasOperations.ts
var log3 = createContextLogger("useCanvasOperations");
function useCanvasOperations({
  templateDoc,
  onTemplateChange,
  onSelectElement,
  onToolSelect,
  resolveText,
  dpi: dpi2 = 96
}) {
  const getTargetSurfaceId = import_react35.useCallback((currentPageId) => {
    if (currentPageId)
      return currentPageId;
    return templateDoc.surfaces[0]?.id ?? "page-1";
  }, [templateDoc.surfaces]);
  const calculateInitialPosition = import_react35.useCallback((surfaceId) => {
    const surface = templateDoc.surfaces.find((s2) => s2.id === surfaceId);
    const surfaceW = surface?.w ?? 210;
    const surfaceH = surface?.h ?? 297;
    const nodesOnSurface = templateDoc.nodes.filter((n2) => n2.s === surfaceId).length;
    const offset4 = nodesOnSurface * 10;
    const startX = surfaceW * 0.15;
    const startY = surfaceH * 0.15;
    const x3 = Math.min(startX + offset4, surfaceW - 50);
    const y2 = Math.min(startY + offset4, surfaceH - 50);
    return { x: x3, y: y2 };
  }, [templateDoc]);
  const withNewElement = import_react35.useCallback((element) => {
    const nextDoc = {
      ...templateDoc,
      nodes: [...templateDoc.nodes, element]
    };
    onTemplateChange(nextDoc);
    onSelectElement(element.id);
    onToolSelect?.("select");
    log3.debug("Element added", { id: element.id, type: element.t });
  }, [templateDoc, onTemplateChange, onSelectElement, onToolSelect]);
  const addText = import_react35.useCallback((currentPageId) => {
    const s2 = getTargetSurfaceId(currentPageId);
    const { x: x3, y: y2 } = calculateInitialPosition(s2);
    const id = generateNodeId(templateDoc, "text");
    const textContent = resolveText("toolbar_default_text", "Text");
    const fontSizePt = 24;
    const fontSizeMm = ptToMm(fontSizePt);
    const font = {
      family: "Meiryo",
      sizeMm: fontSizeMm,
      weight: 400
    };
    const { w: w2, h: h3 } = calculateInitialTextBoxSize(textContent, font, { dpi: dpi2 });
    const text2 = {
      id,
      t: "text",
      s: s2,
      locked: false,
      r: 0,
      name: "Text",
      text: textContent,
      font: font.family,
      fontSize: fontSizeMm,
      fontWeight: font.weight,
      fill: "#000000",
      align: "l",
      vAlign: "t",
      x: x3,
      y: y2,
      w: w2,
      h: h3
    };
    withNewElement(text2);
  }, [getTargetSurfaceId, calculateInitialPosition, resolveText, dpi2, withNewElement]);
  const addShape = import_react35.useCallback((shapeType, currentPageId) => {
    const s2 = getTargetSurfaceId(currentPageId);
    const { x: x3, y: y2 } = calculateInitialPosition(s2);
    const id = generateNodeId(templateDoc, "shape");
    let width = 30;
    let height = 30;
    if (shapeType === "trapezoid") {
      width = 40;
      height = 24;
    } else if (shapeType === "cylinder") {
      width = 24;
      height = 40;
    } else if (["arrow-u", "arrow-d"].includes(shapeType)) {
      width = 16;
      height = 32;
    } else if (["arrow-l", "arrow-r"].includes(shapeType)) {
      width = 32;
      height = 16;
    }
    const shape = {
      id,
      t: "shape",
      shape: shapeType.toLowerCase(),
      s: s2,
      locked: false,
      r: 0,
      name: shapeType,
      x: x3,
      y: y2,
      w: width,
      h: height,
      stroke: "#000000",
      strokeW: 0.2,
      fill: "#ffffff"
    };
    withNewElement(shape);
  }, [getTargetSurfaceId, calculateInitialPosition, withNewElement]);
  const addLine = import_react35.useCallback((currentPageId) => {
    const s2 = getTargetSurfaceId(currentPageId);
    const { x: x3, y: y2 } = calculateInitialPosition(s2);
    const id = generateNodeId(templateDoc, "line");
    const line = {
      id,
      t: "line",
      s: s2,
      locked: false,
      name: "Line",
      pts: [x3, y2, x3 + 50, y2],
      stroke: "#000000",
      strokeW: 0.2,
      routing: "orthogonal"
    };
    withNewElement(line);
  }, [getTargetSurfaceId, calculateInitialPosition, withNewElement]);
  const addImage = import_react35.useCallback((currentPageId) => {
    const s2 = getTargetSurfaceId(currentPageId);
    const { x: x3, y: y2 } = calculateInitialPosition(s2);
    const id = generateNodeId(templateDoc, "image");
    const image = {
      id,
      t: "image",
      s: s2,
      locked: false,
      r: 0,
      name: "Image",
      x: x3,
      y: y2,
      w: 40,
      h: 30,
      src: ""
    };
    withNewElement(image);
  }, [getTargetSurfaceId, calculateInitialPosition, withNewElement]);
  const addTable = import_react35.useCallback((currentPageId) => {
    const s2 = getTargetSurfaceId(currentPageId);
    const { x: x3, y: y2 } = calculateInitialPosition(s2);
    const id = generateNodeId(templateDoc, "table");
    const table = {
      id,
      t: "table",
      s: s2,
      locked: false,
      r: 0,
      name: "Table",
      x: x3,
      y: y2,
      w: 90,
      h: 30,
      table: {
        rows: [10, 10, 10],
        cols: [30, 30, 30],
        cells: [
          { r: 0, c: 0, v: "", borderW: 0.2, borderColor: "#000000" },
          { r: 0, c: 1, v: "", borderW: 0.2, borderColor: "#000000" },
          { r: 0, c: 2, v: "", borderW: 0.2, borderColor: "#000000" }
        ]
      }
    };
    for (let r3 = 0;r3 < 3; r3++) {
      for (let c3 = 0;c3 < 3; c3++) {
        if (!table.table.cells.find((cell) => cell.r === r3 && cell.c === c3)) {
          table.table.cells.push({ r: r3, c: c3, v: "", borderW: 0.2, borderColor: "#000000" });
        }
      }
    }
    withNewElement(table);
  }, [getTargetSurfaceId, calculateInitialPosition, withNewElement]);
  return {
    addText,
    addShape,
    addLine,
    addImage,
    addTable
  };
}

// ../../src/features/konva-editor/constants/shapes.tsx
var jsx_dev_runtime65 = __toESM(require_jsx_dev_runtime(), 1);
var TrapezoidIcon2 = ({ size: size4 = 20, className = "", title = "Trapezoid" }) => /* @__PURE__ */ jsx_dev_runtime65.jsxDEV("svg", {
  width: size4,
  height: size4,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: "2",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  className,
  children: [
    /* @__PURE__ */ jsx_dev_runtime65.jsxDEV("title", {
      children: title
    }, undefined, false, undefined, this),
    /* @__PURE__ */ jsx_dev_runtime65.jsxDEV("path", {
      d: "M4 20h16l-4-16H8L4 20z"
    }, undefined, false, undefined, this)
  ]
}, undefined, true, undefined, this);
var ConeIcon = ({ size: size4 = 20, className = "" }) => /* @__PURE__ */ jsx_dev_runtime65.jsxDEV("svg", {
  width: size4,
  height: size4,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: "2",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  className,
  children: [
    /* @__PURE__ */ jsx_dev_runtime65.jsxDEV("path", {
      d: "M12 2L4 18a4 2 0 0 0 8 2 4 2 0 0 0 8-2L12 2z"
    }, undefined, false, undefined, this),
    /* @__PURE__ */ jsx_dev_runtime65.jsxDEV("ellipse", {
      cx: "12",
      cy: "18",
      rx: "8",
      ry: "2"
    }, undefined, false, undefined, this)
  ]
}, undefined, true, undefined, this);
var EDITOR_SHAPES = [
  { type: "rect", icon: /* @__PURE__ */ jsx_dev_runtime65.jsxDEV(Square, {
    size: 20
  }, undefined, false, undefined, this), label: "Rectangle" },
  { type: "circle", icon: /* @__PURE__ */ jsx_dev_runtime65.jsxDEV(Circle3, {
    size: 20
  }, undefined, false, undefined, this), label: "Circle" },
  { type: "triangle", icon: /* @__PURE__ */ jsx_dev_runtime65.jsxDEV(Triangle, {
    size: 20
  }, undefined, false, undefined, this), label: "Triangle" },
  { type: "trapezoid", icon: /* @__PURE__ */ jsx_dev_runtime65.jsxDEV(TrapezoidIcon2, {
    size: 20
  }, undefined, false, undefined, this), label: "Trapezoid" },
  { type: "diamond", icon: /* @__PURE__ */ jsx_dev_runtime65.jsxDEV(Diamond, {
    size: 20
  }, undefined, false, undefined, this), label: "Diamond" },
  { type: "cylinder", icon: /* @__PURE__ */ jsx_dev_runtime65.jsxDEV(Database, {
    size: 20
  }, undefined, false, undefined, this), label: "Cylinder" },
  { type: "heart", icon: /* @__PURE__ */ jsx_dev_runtime65.jsxDEV(Heart, {
    size: 20
  }, undefined, false, undefined, this), label: "Heart" },
  { type: "star", icon: /* @__PURE__ */ jsx_dev_runtime65.jsxDEV(Star3, {
    size: 20
  }, undefined, false, undefined, this), label: "Star" },
  { type: "pentagon", icon: /* @__PURE__ */ jsx_dev_runtime65.jsxDEV(Pentagon, {
    size: 20
  }, undefined, false, undefined, this), label: "Pentagon" },
  { type: "hexagon", icon: /* @__PURE__ */ jsx_dev_runtime65.jsxDEV(Hexagon, {
    size: 20
  }, undefined, false, undefined, this), label: "Hexagon" },
  { type: "arrow-u", icon: /* @__PURE__ */ jsx_dev_runtime65.jsxDEV(ArrowUp, {
    size: 20
  }, undefined, false, undefined, this), label: "Arrow Up" },
  { type: "arrow-d", icon: /* @__PURE__ */ jsx_dev_runtime65.jsxDEV(ArrowDown, {
    size: 20
  }, undefined, false, undefined, this), label: "Arrow Down" },
  { type: "arrow-l", icon: /* @__PURE__ */ jsx_dev_runtime65.jsxDEV(ArrowLeft, {
    size: 20
  }, undefined, false, undefined, this), label: "Arrow Left" },
  { type: "arrow-r", icon: /* @__PURE__ */ jsx_dev_runtime65.jsxDEV(ArrowRight, {
    size: 20
  }, undefined, false, undefined, this), label: "Arrow Right" },
  { type: "cone", icon: /* @__PURE__ */ jsx_dev_runtime65.jsxDEV(ConeIcon, {
    size: 20
  }, undefined, false, undefined, this), label: "Cone" },
  { type: "house", icon: /* @__PURE__ */ jsx_dev_runtime65.jsxDEV(House, {
    size: 20
  }, undefined, false, undefined, this), label: "House" }
];

// ../../src/features/report-editor/components/Toolbar/WysiwygEditorToolbar.tsx
var jsx_dev_runtime66 = __toESM(require_jsx_dev_runtime(), 1);
var TOOLBAR_BUTTON_CLASS2 = "w-10 h-10 flex items-center justify-center rounded border border-border bg-muted text-muted-foreground hover:bg-accent transition-colors";
var TOOLBAR_BUTTON_ACTIVE_CLASS = "w-10 h-10 flex items-center justify-center rounded border border-primary bg-primary/10 text-primary";
var WysiwygEditorToolbar = ({
  zoom,
  onZoomChange,
  templateDoc,
  onTemplateChange,
  onSelectElement,
  currentPageId,
  i18nOverrides,
  activeTool = "select",
  onToolSelect
}) => {
  const { t: t2 } = useI18n();
  const dpi2 = 96;
  const resolveText = (key, defaultValue) => {
    if (i18nOverrides?.[key])
      return i18nOverrides[key];
    return t2(key, defaultValue ?? key);
  };
  const handleZoomIn = () => {
    onZoomChange(Math.min(200, zoom + 25));
  };
  const handleZoomOut = () => {
    onZoomChange(Math.max(25, zoom - 25));
  };
  const handleZoomReset = () => {
    onZoomChange(100);
  };
  const { addText, addShape, addLine, addImage, addTable } = useCanvasOperations({
    templateDoc,
    onTemplateChange,
    onSelectElement,
    onToolSelect,
    resolveText,
    dpi: dpi2
  });
  const handleAddText = () => addText(currentPageId);
  const handleAddLine = () => addLine(currentPageId);
  const handleAddImage = () => addImage(currentPageId);
  const handleAddTable = () => addTable(currentPageId);
  const handleAddShape = (type) => addShape(type, currentPageId);
  return /* @__PURE__ */ jsx_dev_runtime66.jsxDEV("div", {
    className: "flex flex-col items-center gap-2 p-2 bg-secondary border-r border-border text-muted-foreground",
    children: [
      /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(TooltipProvider2, {
        children: [
          /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(Tooltip2, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(TooltipTrigger2, {
                asChild: true,
                children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV("span", {
                  children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV("button", {
                    type: "button",
                    onClick: () => onToolSelect?.("select"),
                    className: activeTool === "select" ? TOOLBAR_BUTTON_ACTIVE_CLASS : TOOLBAR_BUTTON_CLASS2,
                    "aria-label": resolveText("toolbar_select", "Select"),
                    children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(MousePointer2, {
                      size: 20
                    }, undefined, false, undefined, this)
                  }, undefined, false, undefined, this)
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(TooltipContent2, {
                side: "right",
                children: resolveText("toolbar_select", "Select")
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(Tooltip2, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(TooltipTrigger2, {
                asChild: true,
                children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV("span", {
                  children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV("button", {
                    type: "button",
                    onClick: () => onToolSelect?.("signature"),
                    className: activeTool === "signature" ? TOOLBAR_BUTTON_ACTIVE_CLASS : TOOLBAR_BUTTON_CLASS2,
                    "aria-label": resolveText("toolbar_signature", "Signature"),
                    children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(PenTool, {
                      size: 20
                    }, undefined, false, undefined, this)
                  }, undefined, false, undefined, this)
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(TooltipContent2, {
                side: "right",
                children: resolveText("toolbar_signature", "Signature")
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime66.jsxDEV("div", {
            className: "border-t border-border my-1 w-full"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(Tooltip2, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(TooltipTrigger2, {
                asChild: true,
                children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV("button", {
                  type: "button",
                  onClick: handleAddText,
                  className: TOOLBAR_BUTTON_CLASS2,
                  "aria-label": resolveText("toolbar_add_text", "Add Text"),
                  "data-testid": "toolbar-add-text",
                  children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(Type, {
                    size: 20
                  }, undefined, false, undefined, this)
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(TooltipContent2, {
                side: "right",
                children: resolveText("toolbar_add_text", "Add Text")
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(Tooltip2, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(TooltipTrigger2, {
                asChild: true,
                children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV("button", {
                  type: "button",
                  onClick: handleAddImage,
                  className: TOOLBAR_BUTTON_CLASS2,
                  "aria-label": resolveText("toolbar_add_image", "Add Image"),
                  children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(Image4, {
                    size: 20
                  }, undefined, false, undefined, this)
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(TooltipContent2, {
                side: "right",
                children: resolveText("toolbar_add_image", "Add Image")
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(Tooltip2, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(TooltipTrigger2, {
                asChild: true,
                children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV("button", {
                  type: "button",
                  onClick: handleAddLine,
                  className: TOOLBAR_BUTTON_CLASS2,
                  "aria-label": resolveText("toolbar_line", "Line"),
                  children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(Minus, {
                    size: 20
                  }, undefined, false, undefined, this)
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(TooltipContent2, {
                side: "right",
                children: resolveText("toolbar_line", "Line")
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(Tooltip2, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(TooltipTrigger2, {
                asChild: true,
                children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV("button", {
                  type: "button",
                  onClick: handleAddTable,
                  className: TOOLBAR_BUTTON_CLASS2,
                  "aria-label": resolveText("toolbar_add_table", "Table"),
                  children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(Table, {
                    size: 20
                  }, undefined, false, undefined, this)
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(TooltipContent2, {
                side: "right",
                children: resolveText("toolbar_add_table", "Table")
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(DropdownMenu2, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(Tooltip2, {
                children: [
                  /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(TooltipTrigger2, {
                    asChild: true,
                    children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(DropdownMenuTrigger2, {
                      asChild: true,
                      children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV("button", {
                        type: "button",
                        className: TOOLBAR_BUTTON_CLASS2,
                        "aria-label": resolveText("toolbar_shape", "Shape"),
                        children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(Shapes, {
                          size: 20
                        }, undefined, false, undefined, this)
                      }, undefined, false, undefined, this)
                    }, undefined, false, undefined, this)
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(TooltipContent2, {
                    side: "right",
                    children: resolveText("toolbar_shape", "Shape")
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(DropdownMenuContent2, {
                align: "start",
                className: "w-56 grid grid-cols-4 gap-1 p-2",
                children: EDITOR_SHAPES.map((shape) => /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(DropdownMenuItem2, {
                  onClick: () => handleAddShape(shape.type),
                  className: "flex items-center justify-center p-2 rounded cursor-pointer hover:bg-accent text-foreground",
                  title: shape.label,
                  children: shape.icon
                }, shape.type, false, undefined, this))
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime66.jsxDEV("div", {
        className: "border-t border-border my-3 w-full"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime66.jsxDEV("div", {
        className: "flex flex-col items-center gap-1",
        children: [
          /* @__PURE__ */ jsx_dev_runtime66.jsxDEV("button", {
            type: "button",
            onClick: handleZoomIn,
            className: `${TOOLBAR_BUTTON_CLASS2} disabled:opacity-50`,
            "aria-label": resolveText("toolbar_zoom_in", "Zoom in"),
            disabled: zoom >= 200,
            children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(ZoomIn, {
              size: 18
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime66.jsxDEV("button", {
            type: "button",
            onClick: handleZoomReset,
            className: "text-muted-foreground text-xs font-medium hover:text-primary transition-colors",
            "aria-label": resolveText("toolbar_zoom_reset", "Reset zoom"),
            children: [
              zoom,
              "%"
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime66.jsxDEV("button", {
            type: "button",
            onClick: handleZoomOut,
            className: `${TOOLBAR_BUTTON_CLASS2} disabled:opacity-50`,
            "aria-label": resolveText("toolbar_zoom_out", "Zoom out"),
            disabled: zoom <= 25,
            children: /* @__PURE__ */ jsx_dev_runtime66.jsxDEV(ZoomOut, {
              size: 18
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
// ../../src/features/report-editor/hooks/useReportHistory.ts
var import_react36 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/external.js
var exports_external = {};
__export(exports_external, {
  void: () => voidType,
  util: () => util,
  unknown: () => unknownType,
  union: () => unionType,
  undefined: () => undefinedType,
  tuple: () => tupleType,
  transformer: () => effectsType,
  symbol: () => symbolType,
  string: () => stringType,
  strictObject: () => strictObjectType,
  setErrorMap: () => setErrorMap,
  set: () => setType,
  record: () => recordType,
  quotelessJson: () => quotelessJson,
  promise: () => promiseType,
  preprocess: () => preprocessType,
  pipeline: () => pipelineType,
  ostring: () => ostring,
  optional: () => optionalType,
  onumber: () => onumber,
  oboolean: () => oboolean,
  objectUtil: () => objectUtil,
  object: () => objectType,
  number: () => numberType,
  nullable: () => nullableType,
  null: () => nullType,
  never: () => neverType,
  nativeEnum: () => nativeEnumType,
  nan: () => nanType,
  map: () => mapType,
  makeIssue: () => makeIssue,
  literal: () => literalType,
  lazy: () => lazyType,
  late: () => late,
  isValid: () => isValid,
  isDirty: () => isDirty,
  isAsync: () => isAsync,
  isAborted: () => isAborted,
  intersection: () => intersectionType,
  instanceof: () => instanceOfType,
  getParsedType: () => getParsedType,
  getErrorMap: () => getErrorMap,
  function: () => functionType,
  enum: () => enumType,
  effect: () => effectsType,
  discriminatedUnion: () => discriminatedUnionType,
  defaultErrorMap: () => en_default,
  datetimeRegex: () => datetimeRegex,
  date: () => dateType,
  custom: () => custom,
  coerce: () => coerce,
  boolean: () => booleanType,
  bigint: () => bigIntType,
  array: () => arrayType,
  any: () => anyType,
  addIssueToContext: () => addIssueToContext,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransformer: () => ZodEffects,
  ZodSymbol: () => ZodSymbol,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodSchema: () => ZodType,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPipeline: () => ZodPipeline,
  ZodParsedType: () => ZodParsedType,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNever: () => ZodNever,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEffects: () => ZodEffects,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCatch: () => ZodCatch,
  ZodBranded: () => ZodBranded,
  ZodBoolean: () => ZodBoolean,
  ZodBigInt: () => ZodBigInt,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  Schema: () => ZodType,
  ParseStatus: () => ParseStatus,
  OK: () => OK,
  NEVER: () => NEVER,
  INVALID: () => INVALID,
  EMPTY_PATH: () => EMPTY_PATH,
  DIRTY: () => DIRTY,
  BRAND: () => BRAND
});

// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_2) => {};
  function assertIs(_arg) {}
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i3 = 0;
          while (i3 < issue.path.length) {
            const el = issue.path[i3];
            const terminal = i3 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i3++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var en_default = errorMap;

// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m3) => !!m3).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === en_default ? undefined : en_default
    ].filter((x3) => !!x3)
  });
  ctx.common.issues.push(issue);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x3) => x3.status === "aborted";
var isDirty = (x3) => x3.status === "dirty";
var isValid = (x3) => x3.status === "valid";
var isAsync = (x3) => typeof Promise !== "undefined" && x3 instanceof Promise;
// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/types.js
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options2) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options2) });
  }
  ip(options2) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options2) });
  }
  cidr(options2) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options2) });
  }
  datetime(options2) {
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options2
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options2?.precision === "undefined" ? null : options2?.precision,
      offset: options2?.offset ?? false,
      local: options2?.local ?? false,
      ...errorUtil.errToObj(options2?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options2) {
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options2
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options2?.precision === "undefined" ? null : options2?.precision,
      ...errorUtil.errToObj(options2?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options2) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options2?.position,
      ...errorUtil.errToObj(options2?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min3 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min3 === null || ch.value > min3)
          min3 = ch.value;
      }
    }
    return min3;
  }
  get maxLength() {
    let max3 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max3 === null || ch.value < max3)
          max3 = ch.value;
      }
    }
    return max3;
  }
}
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min3 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min3 === null || ch.value > min3)
          min3 = ch.value;
      }
    }
    return min3;
  }
  get maxValue() {
    let max3 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max3 === null || ch.value < max3)
          max3 = ch.value;
      }
    }
    return max3;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max3 = null;
    let min3 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min3 === null || ch.value > min3)
          min3 = ch.value;
      } else if (ch.kind === "max") {
        if (max3 === null || ch.value < max3)
          max3 = ch.value;
      }
    }
    return Number.isFinite(min3) && Number.isFinite(max3);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min3 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min3 === null || ch.value > min3)
          min3 = ch.value;
      }
    }
    return min3;
  }
  get maxValue() {
    let max3 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max3 === null || ch.value < max3)
          max3 = ch.value;
      }
    }
    return max3;
  }
}
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min3 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min3 === null || ch.value > min3)
          min3 = ch.value;
      }
    }
    return min3 != null ? new Date(min3) : null;
  }
  get maxDate() {
    let max3 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max3 === null || ch.value < max3)
          max3 = ch.value;
      }
    }
    return max3 != null ? new Date(max3) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i3) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i3) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {} else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options2 = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options2.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options2) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options2, params) {
    const optionsMap = new Map;
    for (const type of options2) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options: options2,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a4, b4) {
  const aType = getParsedType(a4);
  const bType = getParsedType(b4);
  if (a4 === b4) {
    return { valid: true, data: a4 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b4);
    const sharedKeys = util.objectKeys(a4).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a4, ...b4 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a4[key], b4[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a4.length !== b4.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0;index2 < a4.length; index2++) {
      const itemA = a4[index2];
      const itemB = b4[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a4 === +b4) {
    return { valid: true, data: a4 };
  } else {
    return { valid: false };
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x3) => !!x3);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i3) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i3)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size4, message) {
    return this.min(size4, message).max(size4, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x3) => !!x3),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x3) => !!x3),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me2 = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e2) => {
          error.addIssue(makeArgsIssue(args, e2));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error.addIssue(makeReturnsIssue(result, e2));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me2 = this;
      return OK(function(...args) {
        const parsedArgs = me2._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me2._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a4, b4) {
    return new ZodPipeline({
      in: a4,
      out: b4,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p3 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p22 = typeof p3 === "string" ? { message: p3 } : p3;
  return p22;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r3 = check(data);
      if (r3 instanceof Promise) {
        return r3.then((r4) => {
          if (!r4) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r3) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
// ../../src/types/doc.schema.ts
var NodeIdSchema = exports_external.string().min(1);
var SurfaceIdSchema = exports_external.string().min(1);
var ColorSchema = exports_external.string().regex(/^(#[0-9A-Fa-f]{6}|rgba?\(|hsla?\(|transparent)/);
var BaseNodeSchema = exports_external.object({
  id: NodeIdSchema,
  s: SurfaceIdSchema,
  r: exports_external.number().optional().default(0),
  opacity: exports_external.number().min(0).max(1).optional().default(1),
  locked: exports_external.boolean().optional(),
  hidden: exports_external.boolean().optional(),
  tags: exports_external.array(exports_external.string()).optional(),
  bind: exports_external.string().optional(),
  name: exports_external.string().optional(),
  data: exports_external.record(exports_external.unknown()).optional(),
  isPlaceholder: exports_external.boolean().optional()
});
var TextNodeSchema = BaseNodeSchema.extend({
  t: exports_external.literal("text"),
  x: exports_external.number(),
  y: exports_external.number(),
  w: exports_external.number().positive(),
  h: exports_external.number().positive(),
  text: exports_external.string(),
  font: exports_external.string().optional(),
  fontSize: exports_external.number().positive().optional(),
  fontWeight: exports_external.number().optional(),
  italic: exports_external.boolean().optional(),
  underline: exports_external.boolean().optional(),
  lineThrough: exports_external.boolean().optional(),
  align: exports_external.enum(["l", "c", "r", "j"]).optional(),
  vAlign: exports_external.enum(["t", "m", "b"]).optional(),
  fill: ColorSchema.optional(),
  hasFrame: exports_external.boolean().optional(),
  borderColor: ColorSchema.optional(),
  borderWidth: exports_external.number().optional(),
  backgroundColor: ColorSchema.optional(),
  padding: exports_external.number().optional(),
  cornerRadius: exports_external.number().optional(),
  stroke: ColorSchema.optional(),
  strokeW: exports_external.number().optional(),
  dynamicContent: exports_external.string().optional()
});
var ShapeNodeSchema = BaseNodeSchema.extend({
  t: exports_external.literal("shape"),
  x: exports_external.number(),
  y: exports_external.number(),
  w: exports_external.number().positive(),
  h: exports_external.number().positive(),
  shape: exports_external.enum([
    "rect",
    "circle",
    "triangle",
    "diamond",
    "star",
    "pentagon",
    "hexagon",
    "arrow-u",
    "arrow-d",
    "arrow-l",
    "arrow-r",
    "trapezoid",
    "cylinder",
    "heart",
    "tree",
    "house"
  ]),
  radius: exports_external.number().optional(),
  fill: ColorSchema.optional(),
  stroke: ColorSchema.optional(),
  strokeW: exports_external.number().positive().optional(),
  dash: exports_external.array(exports_external.number()).optional(),
  sides: exports_external.number().int().min(3).optional()
});
var LineNodeSchema = BaseNodeSchema.extend({
  t: exports_external.literal("line"),
  pts: exports_external.array(exports_external.number()).min(4),
  arrows: exports_external.tuple([
    exports_external.enum([
      "none",
      "arrow",
      "circle",
      "diamond",
      "standard",
      "filled",
      "triangle",
      "open",
      "square"
    ]),
    exports_external.enum([
      "none",
      "arrow",
      "circle",
      "diamond",
      "standard",
      "filled",
      "triangle",
      "open",
      "square"
    ])
  ]).optional(),
  stroke: ColorSchema,
  strokeW: exports_external.number().positive(),
  dash: exports_external.array(exports_external.number()).optional(),
  routing: exports_external.enum(["straight", "orthogonal", "bezier"]).optional(),
  startConn: exports_external.object({
    nodeId: NodeIdSchema,
    anchor: exports_external.enum(["auto", "t", "b", "l", "r", "tl", "tr", "bl", "br"])
  }).optional(),
  endConn: exports_external.object({
    nodeId: NodeIdSchema,
    anchor: exports_external.enum(["auto", "t", "b", "l", "r", "tl", "tr", "bl", "br"])
  }).optional()
});
var ImageNodeSchema = BaseNodeSchema.extend({
  t: exports_external.literal("image"),
  x: exports_external.number(),
  y: exports_external.number(),
  w: exports_external.number().positive(),
  h: exports_external.number().positive(),
  src: exports_external.string().min(1).optional(),
  assetId: exports_external.string().optional()
});
var GroupNodeSchema = BaseNodeSchema.extend({
  t: exports_external.literal("group"),
  x: exports_external.number(),
  y: exports_external.number(),
  w: exports_external.number().positive(),
  h: exports_external.number().positive(),
  children: exports_external.array(NodeIdSchema)
});
var CellSchema = exports_external.object({
  r: exports_external.number().int().min(0),
  c: exports_external.number().int().min(0),
  rs: exports_external.number().int().min(1).optional(),
  cs: exports_external.number().int().min(1).optional(),
  v: exports_external.string(),
  bg: exports_external.string().optional(),
  border: exports_external.string().optional(),
  borderColor: exports_external.string().optional(),
  borderW: exports_external.number().optional(),
  font: exports_external.string().optional(),
  fontSize: exports_external.number().optional(),
  align: exports_external.enum(["l", "c", "r"]).optional(),
  vAlign: exports_external.enum(["t", "m", "b"]).optional(),
  color: exports_external.string().optional()
});
var TableDataSchema = exports_external.object({
  rows: exports_external.array(exports_external.number().positive()),
  cols: exports_external.array(exports_external.number().positive()),
  cells: exports_external.array(CellSchema)
});
var TableNodeSchema = BaseNodeSchema.extend({
  t: exports_external.literal("table"),
  x: exports_external.number(),
  y: exports_external.number(),
  w: exports_external.number().positive(),
  h: exports_external.number().positive(),
  table: TableDataSchema
});
var SignatureNodeSchema = BaseNodeSchema.extend({
  t: exports_external.literal("signature"),
  x: exports_external.number(),
  y: exports_external.number(),
  w: exports_external.number().positive(),
  h: exports_external.number().positive(),
  strokes: exports_external.array(exports_external.array(exports_external.number())),
  stroke: ColorSchema,
  strokeW: exports_external.number().positive(),
  pressureData: exports_external.array(exports_external.array(exports_external.number())).optional(),
  usePressureSim: exports_external.boolean().optional()
});
var WidgetNodeSchema = BaseNodeSchema.extend({
  t: exports_external.literal("widget"),
  x: exports_external.number(),
  y: exports_external.number(),
  w: exports_external.number().positive(),
  h: exports_external.number().positive(),
  widget: exports_external.string()
});
var UnifiedNodeSchema = exports_external.discriminatedUnion("t", [
  TextNodeSchema,
  ShapeNodeSchema,
  LineNodeSchema,
  ImageNodeSchema,
  GroupNodeSchema,
  TableNodeSchema,
  SignatureNodeSchema,
  WidgetNodeSchema
]);
var MarginSchema = exports_external.object({
  t: exports_external.number(),
  r: exports_external.number(),
  b: exports_external.number(),
  l: exports_external.number()
});
var SurfaceSchema = exports_external.object({
  id: SurfaceIdSchema,
  type: exports_external.enum(["page", "canvas", "slide"]),
  w: exports_external.number().positive(),
  h: exports_external.number().positive(),
  margin: MarginSchema.optional(),
  bg: exports_external.string().optional(),
  masterId: exports_external.string().optional()
});
var DocSchema = exports_external.object({
  v: exports_external.literal(1),
  id: exports_external.string().min(1),
  title: exports_external.string(),
  unit: exports_external.literal("mm"),
  surfaces: exports_external.array(SurfaceSchema).min(1),
  nodes: exports_external.array(UnifiedNodeSchema),
  assets: exports_external.array(exports_external.object({
    id: exports_external.string(),
    type: exports_external.enum(["image", "font", "video"]),
    uri: exports_external.string(),
    mime: exports_external.string().optional(),
    size: exports_external.number().optional(),
    metadata: exports_external.record(exports_external.unknown()).optional()
  })).optional(),
  binding: exports_external.object({
    sampleData: exports_external.record(exports_external.unknown()),
    sources: exports_external.array(exports_external.object({
      id: exports_external.string(),
      type: exports_external.enum(["json", "api"]),
      url: exports_external.string().optional()
    })).optional()
  }).optional(),
  animation: exports_external.any().optional(),
  snap: exports_external.object({
    grid: exports_external.number().optional(),
    guides: exports_external.boolean().optional()
  }).optional()
});
function validateDoc(doc) {
  const result = DocSchema.safeParse(doc);
  if (result.success) {
    return { success: true, data: result.data };
  }
  return {
    success: false,
    errors: result.error.issues.map((e2) => `${e2.path.join(".")}: ${e2.message}`)
  };
}

// ../../src/features/report-editor/hooks/useReportHistory.ts
function useReportHistory(initialDocument) {
  if (initialDocument?.unit && initialDocument.unit !== "mm") {
    console.warn("[useReportHistory] Doc.unit is not mm. Please convert the document before passing it in.");
  }
  const [history, setHistory] = import_react36.useState({
    past: [],
    present: initialDocument,
    future: []
  });
  const setDocument = import_react36.useCallback((docOrUpdater, options2 = {}) => {
    const { saveToHistory = true, force = false } = options2;
    setHistory((prev) => {
      const newPresent = typeof docOrUpdater === "function" ? docOrUpdater(prev.present) : docOrUpdater;
      if (!force && JSON.stringify(newPresent) === JSON.stringify(prev.present)) {
        return prev;
      }
      if (!saveToHistory) {
        return {
          ...prev,
          present: newPresent,
          future: []
        };
      }
      return {
        past: [...prev.past, prev.present],
        present: newPresent,
        future: []
      };
    });
  }, []);
  const undo = import_react36.useCallback(() => {
    setHistory((prev) => {
      if (prev.past.length === 0)
        return prev;
      const newPast = prev.past.slice(0, prev.past.length - 1);
      const newPresent = prev.past[prev.past.length - 1];
      return {
        past: newPast,
        present: newPresent,
        future: [prev.present, ...prev.future]
      };
    });
  }, []);
  const redo = import_react36.useCallback(() => {
    setHistory((prev) => {
      if (prev.future.length === 0)
        return prev;
      const newFuture = prev.future.slice(1);
      const newPresent = prev.future[0];
      return {
        past: [...prev.past, prev.present],
        present: newPresent,
        future: newFuture
      };
    });
  }, []);
  const reset = import_react36.useCallback((doc) => {
    if (doc?.unit && doc.unit !== "mm") {
      console.warn("[useReportHistory.reset] Doc.unit is not mm. Please convert the document before passing it in.");
    }
    const validation = validateDoc(doc);
    if (!validation.success) {
      console.warn("[useReportHistory] Doc validation failed:", validation.errors);
    }
    setHistory({
      past: [],
      present: doc,
      future: []
    });
  }, []);
  return {
    document: history.present,
    setDocument,
    canUndo: history.past.length > 0,
    canRedo: history.future.length > 0,
    undo,
    redo,
    reset
  };
}
// ../../src/features/report-editor/ReportEditor.tsx
var import_react43 = __toESM(require_react(), 1);

// ../../src/features/report-editor/ReportKonvaEditor.tsx
var import_react42 = __toESM(require_react(), 1);

// ../../src/features/report-editor/components/ContextMenu/TableContextMenu.tsx
var import_react37 = __toESM(require_react(), 1);
var jsx_dev_runtime67 = __toESM(require_jsx_dev_runtime(), 1);
var TableContextMenu = ({
  visible,
  x: x3,
  y: y2,
  onClose,
  onAction
}) => {
  const { t: t2 } = useI18n();
  const ref = import_react37.useRef(null);
  import_react37.useEffect(() => {
    const handleClickOutside = (event) => {
      if (ref.current && !ref.current.contains(event.target)) {
        onClose();
      }
    };
    if (visible) {
      document.addEventListener("mousedown", handleClickOutside);
    }
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [visible, onClose]);
  if (!visible)
    return null;
  const itemClass = "flex items-center w-full px-3 py-2 text-sm text-left hover:bg-accent text-foreground gap-2 cursor-pointer";
  return /* @__PURE__ */ jsx_dev_runtime67.jsxDEV("div", {
    ref,
    className: "fixed z-50 bg-popover text-popover-foreground border border-border rounded shadow-lg w-56 py-1",
    style: { top: y2, left: x3 },
    onContextMenu: (e2) => e2.preventDefault(),
    role: "menu",
    tabIndex: -1,
    children: [
      /* @__PURE__ */ jsx_dev_runtime67.jsxDEV("button", {
        type: "button",
        onClick: () => onAction("mergeRight"),
        className: itemClass,
        children: t2("table_ctx_merge_right", "Merge Right")
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime67.jsxDEV("button", {
        type: "button",
        onClick: () => onAction("mergeDown"),
        className: itemClass,
        children: t2("table_ctx_merge_down", "Merge Down")
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime67.jsxDEV("button", {
        type: "button",
        onClick: () => onAction("unmerge"),
        className: itemClass,
        children: t2("table_ctx_unmerge", "Unmerge")
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime67.jsxDEV("div", {
        className: "my-1 border-t border-border"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime67.jsxDEV("button", {
        type: "button",
        onClick: () => onAction("insertRowAbove"),
        className: itemClass,
        children: [
          /* @__PURE__ */ jsx_dev_runtime67.jsxDEV(ArrowUpToLine, {
            className: "w-4 h-4"
          }, undefined, false, undefined, this),
          t2("table_ctx_insert_row_above", "Insert Row Above")
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime67.jsxDEV("button", {
        type: "button",
        onClick: () => onAction("insertRowBelow"),
        className: itemClass,
        children: [
          /* @__PURE__ */ jsx_dev_runtime67.jsxDEV(ArrowDownToLine, {
            className: "w-4 h-4"
          }, undefined, false, undefined, this),
          t2("table_ctx_insert_row_below", "Insert Row Below")
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime67.jsxDEV("button", {
        type: "button",
        onClick: () => onAction("deleteRow"),
        className: `${itemClass} text-red-500 hover:text-red-600`,
        children: [
          /* @__PURE__ */ jsx_dev_runtime67.jsxDEV(Trash2, {
            className: "w-4 h-4"
          }, undefined, false, undefined, this),
          t2("table_ctx_delete_row", "Delete Row")
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime67.jsxDEV("div", {
        className: "my-1 border-t border-border"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime67.jsxDEV("button", {
        type: "button",
        onClick: () => onAction("insertColLeft"),
        className: itemClass,
        children: [
          /* @__PURE__ */ jsx_dev_runtime67.jsxDEV(ArrowLeftToLine, {
            className: "w-4 h-4"
          }, undefined, false, undefined, this),
          t2("table_ctx_insert_col_left", "Insert Column Left")
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime67.jsxDEV("button", {
        type: "button",
        onClick: () => onAction("insertColRight"),
        className: itemClass,
        children: [
          /* @__PURE__ */ jsx_dev_runtime67.jsxDEV(ArrowRightToLine, {
            className: "w-4 h-4"
          }, undefined, false, undefined, this),
          t2("table_ctx_insert_col_right", "Insert Column Right")
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime67.jsxDEV("button", {
        type: "button",
        onClick: () => onAction("deleteCol"),
        className: `${itemClass} text-red-500 hover:text-red-600`,
        children: [
          /* @__PURE__ */ jsx_dev_runtime67.jsxDEV(Trash2, {
            className: "w-4 h-4"
          }, undefined, false, undefined, this),
          t2("table_ctx_delete_col", "Delete Column")
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/report-editor/hooks/useReportContextMenu.ts
var import_react38 = __toESM(require_react(), 1);

// ../../src/features/report-editor/utils/tableOperations.ts
var sum2 = (arr) => arr.reduce((a4, b4) => a4 + b4, 0);
var clamp3 = (v2, min3, max3) => v2 < min3 ? min3 : v2 > max3 ? max3 : v2;
var findCell = (cells, r3, c3) => cells.find((cc) => cc.r === r3 && cc.c === c3);
var cellRect = (c3) => {
  const rs = c3.rs || 1;
  const cs = c3.cs || 1;
  return { r1: c3.r, c1: c3.c, r2: c3.r + rs - 1, c2: c3.c + cs - 1 };
};
var rectIntersects = (a4, b4) => {
  return !(a4.r2 < b4.r1 || a4.r1 > b4.r2 || a4.c2 < b4.c1 || a4.c1 > b4.c2);
};
var insertRow = (table, targetRow, where) => {
  const insertIndex = where === "above" ? targetRow : targetRow + 1;
  const newRows = [...table.table.rows];
  newRows.splice(insertIndex, 0, 50);
  const cells = table.table.cells;
  const nextCells = cells.map((c3) => {
    if (c3.r >= insertIndex)
      return { ...c3, r: c3.r + 1 };
    const rs = c3.rs || 1;
    if (rs > 1 && c3.r < insertIndex && insertIndex <= c3.r + rs - 1) {
      return { ...c3, rs: rs + 1 };
    }
    return c3;
  });
  for (let c3 = 0;c3 < table.table.cols.length; c3++) {
    const template = cells.find((cell) => cell.r === targetRow && cell.c === c3) || findCell(cells, targetRow, 0);
    if (template) {
      const { r: _r, c: _c, v: _v, rs: _rs, cs: _cs, ...styles } = template;
      nextCells.push({
        r: insertIndex,
        c: c3,
        v: "",
        ...styles,
        rs: 1,
        cs: 1
      });
    } else {
      nextCells.push({
        r: insertIndex,
        c: c3,
        v: "",
        rs: 1,
        cs: 1,
        borderW: 2,
        borderColor: "#000000"
      });
    }
  }
  return {
    ...table,
    h: sum2(newRows),
    table: {
      ...table.table,
      rows: newRows,
      cells: nextCells
    }
  };
};
var insertCol = (table, targetCol, targetRow, where) => {
  const insertIndex = where === "left" ? targetCol : targetCol + 1;
  const newCols = [...table.table.cols];
  newCols.splice(insertIndex, 0, 100);
  const cells = table.table.cells;
  const nextCells = cells.map((c3) => {
    if (c3.c >= insertIndex)
      return { ...c3, c: c3.c + 1 };
    const cs = c3.cs || 1;
    if (cs > 1 && c3.c < insertIndex && insertIndex <= c3.c + cs - 1) {
      return { ...c3, cs: cs + 1 };
    }
    return c3;
  });
  for (let r3 = 0;r3 < table.table.rows.length; r3++) {
    const template = cells.find((cell) => cell.r === r3 && cell.c === targetCol) || findCell(cells, targetRow, targetCol);
    if (template) {
      const { r: _r, c: _c, v: _v, rs: _rs, cs: _cs, ...styles } = template;
      nextCells.push({
        r: r3,
        c: insertIndex,
        v: "",
        ...styles,
        rs: 1,
        cs: 1
      });
    } else {
      nextCells.push({
        r: r3,
        c: insertIndex,
        v: "",
        rs: 1,
        cs: 1,
        borderW: 2,
        borderColor: "#000000"
      });
    }
  }
  return {
    ...table,
    w: sum2(newCols),
    table: {
      ...table.table,
      cols: newCols,
      cells: nextCells
    }
  };
};
var deleteRow = (table, targetRow) => {
  const rowCount = table.table.rows.length;
  if (rowCount <= 1)
    return table;
  const deleteIndex = clamp3(targetRow, 0, rowCount - 1);
  const newRows = table.table.rows.filter((_2, i3) => i3 !== deleteIndex);
  const cells = table.table.cells;
  const nextCells = [];
  for (const c3 of cells) {
    if (c3.r === deleteIndex) {
      const rs2 = c3.rs || 1;
      if (rs2 > 1) {
        nextCells.push({ ...c3, rs: rs2 - 1 });
      }
      continue;
    }
    if (c3.r > deleteIndex) {
      nextCells.push({ ...c3, r: c3.r - 1 });
      continue;
    }
    const rs = c3.rs || 1;
    if (rs > 1 && c3.r < deleteIndex && deleteIndex <= c3.r + rs - 1) {
      nextCells.push({ ...c3, rs: rs - 1 });
      continue;
    }
    nextCells.push(c3);
  }
  return {
    ...table,
    h: sum2(newRows),
    table: {
      ...table.table,
      rows: newRows,
      cells: nextCells
    }
  };
};
var deleteCol = (table, targetCol) => {
  const colCount = table.table.cols.length;
  if (colCount <= 1)
    return table;
  const deleteIndex = clamp3(targetCol, 0, colCount - 1);
  const newCols = table.table.cols.filter((_2, i3) => i3 !== deleteIndex);
  const cells = table.table.cells;
  const nextCells = [];
  for (const c3 of cells) {
    if (c3.c === deleteIndex) {
      const cs2 = c3.cs || 1;
      if (cs2 > 1) {
        nextCells.push({ ...c3, cs: cs2 - 1 });
      }
      continue;
    }
    if (c3.c > deleteIndex) {
      nextCells.push({ ...c3, c: c3.c - 1 });
      continue;
    }
    const cs = c3.cs || 1;
    if (cs > 1 && c3.c < deleteIndex && deleteIndex <= c3.c + cs - 1) {
      nextCells.push({ ...c3, cs: cs - 1 });
      continue;
    }
    nextCells.push(c3);
  }
  return {
    ...table,
    w: sum2(newCols),
    table: {
      ...table.table,
      cols: newCols,
      cells: nextCells
    }
  };
};
var mergeCells = (table, targetRow, targetCol, direction) => {
  const cells = [...table.table.cells];
  const findOrBase = (r3, c3) => {
    const found = findCell(cells, r3, c3);
    if (found)
      return found;
    return { r: r3, c: c3, v: "" };
  };
  const current = findOrBase(targetRow, targetCol);
  const workingCells = [...cells];
  if (!findCell(workingCells, targetRow, targetCol)) {
    workingCells.push({ ...current });
  }
  const rs = current.rs || 1;
  const cs = current.cs || 1;
  if (direction === "right") {
    const colCount = table.table.cols.length;
    const targetColIdx = targetCol + cs;
    if (targetColIdx >= colCount)
      return table;
    const baseRect = cellRect({ r: targetRow, c: targetCol, rs, cs: cs + 1 });
    const neighbor = findCell(workingCells, targetRow, targetColIdx);
    if (!neighbor)
      return table;
    const neighborRs = neighbor.rs || 1;
    const neighborCs = neighbor.cs || 1;
    if (neighborRs !== rs || neighborCs !== 1)
      return table;
    for (const other of workingCells) {
      if (other.r === targetRow && other.c === targetCol)
        continue;
      if (other.r === targetRow && other.c === targetColIdx)
        continue;
      const oRect = cellRect(other);
      if (rectIntersects(oRect, baseRect)) {
        return table;
      }
    }
    const nextCells = workingCells.filter((c3) => {
      if (c3.r === targetRow && c3.c === targetCol)
        return true;
      if (c3.r === targetRow && c3.c === targetColIdx)
        return false;
      return !(c3.c === targetColIdx && c3.r >= targetRow && c3.r < targetRow + rs);
    });
    const idx = nextCells.findIndex((c3) => c3.r === targetRow && c3.c === targetCol);
    if (idx >= 0)
      nextCells[idx] = { ...nextCells[idx], cs: cs + 1 };
    return {
      ...table,
      table: {
        ...table.table,
        cells: nextCells
      }
    };
  } else {
    const rowCount = table.table.rows.length;
    const targetRowIdx = targetRow + rs;
    if (targetRowIdx >= rowCount)
      return table;
    const baseRect = cellRect({ r: targetRow, c: targetCol, rs: rs + 1, cs });
    const neighbor = findCell(workingCells, targetRowIdx, targetCol);
    if (!neighbor)
      return table;
    const neighborRs = neighbor.rs || 1;
    const neighborCs = neighbor.cs || 1;
    if (neighborCs !== cs || neighborRs !== 1)
      return table;
    for (const other of workingCells) {
      if (other.r === targetRow && other.c === targetCol)
        continue;
      if (other.r === targetRowIdx && other.c === targetCol)
        continue;
      const oRect = cellRect(other);
      if (rectIntersects(oRect, baseRect)) {
        return table;
      }
    }
    const nextCells = workingCells.filter((c3) => {
      if (c3.r === targetRow && c3.c === targetCol)
        return true;
      if (c3.r === targetRowIdx && c3.c === targetCol)
        return false;
      return !(c3.r === targetRowIdx && c3.c >= targetCol && c3.c < targetCol + cs);
    });
    const idx = nextCells.findIndex((c3) => c3.r === targetRow && c3.c === targetCol);
    if (idx >= 0)
      nextCells[idx] = { ...nextCells[idx], rs: rs + 1 };
    return {
      ...table,
      table: {
        ...table.table,
        cells: nextCells
      }
    };
  }
};
var unmergeCells = (table, targetRow, targetCol) => {
  const cells = table.table.cells;
  const current = findCell(cells, targetRow, targetCol);
  if (!current)
    return table;
  const rs = current.rs || 1;
  const cs = current.cs || 1;
  if (rs <= 1 && cs <= 1)
    return table;
  const nextCells = cells.filter((c3) => !(c3.r === targetRow && c3.c === targetCol));
  const { rs: _rs, cs: _cs, ...rest } = current;
  const base = { ...rest, r: targetRow, c: targetCol, v: current.v };
  nextCells.push(base);
  const materializeCellAt = (targetCells, r3, c3, inheritFrom) => {
    if (targetCells.find((cc) => cc.r === r3 && cc.c === c3))
      return;
    const { rs: _rs2, cs: _cs2, v: _v, ...style } = inheritFrom || base;
    targetCells.push({ ...style, r: r3, c: c3, v: "" });
  };
  const rowCount = table.table.rows.length;
  const colCount = table.table.cols.length;
  for (let rr = 0;rr < rs; rr++) {
    for (let cc = 0;cc < cs; cc++) {
      if (rr === 0 && cc === 0)
        continue;
      const r3 = targetRow + rr;
      const c3 = targetCol + cc;
      if (r3 < 0 || r3 >= rowCount || c3 < 0 || c3 >= colCount)
        continue;
      materializeCellAt(nextCells, r3, c3, current);
    }
  }
  return {
    ...table,
    table: {
      ...table.table,
      cells: nextCells
    }
  };
};

// ../../src/features/report-editor/hooks/useReportContextMenu.ts
var useReportContextMenu = ({
  templateDoc,
  onTemplateChange,
  stageRef,
  activeTool,
  setSelectedCell,
  setEditingCell,
  onElementSelect,
  selectedElementId
}) => {
  const [contextMenu, setContextMenu] = import_react38.useState(null);
  const handleContextMenu = import_react38.useCallback((e2, element) => {
    e2.evt.preventDefault();
    if (activeTool !== "select")
      return;
    const stage = stageRef.current;
    if (!stage)
      return;
    const parseFromId = (id) => {
      const parts = id.split("_cell_");
      if (parts.length !== 2)
        return null;
      const elementId = parts[0];
      const rc = parts[1].split("_");
      if (rc.length < 2)
        return null;
      const row = Number.parseInt(rc[0], 10);
      const col = Number.parseInt(rc[1], 10);
      if (Number.isNaN(row) || Number.isNaN(col))
        return null;
      return { elementId, row, col };
    };
    let menuType = "object";
    let cellInfo = null;
    if (element.t === "table") {
      const target = e2.target;
      const idsToTry = [
        target.id(),
        target.getParent()?.id(),
        target.getParent()?.getParent()?.id()
      ].filter(Boolean);
      for (const id of idsToTry) {
        const parsed = parseFromId(id);
        if (parsed) {
          cellInfo = parsed;
          break;
        }
      }
      if (cellInfo) {
        menuType = "table";
        setSelectedCell(cellInfo);
        setEditingCell(null);
      }
    } else if (element.t === "line") {
      menuType = "line";
    }
    if (element.id !== selectedElementId) {
      onElementSelect(element);
    }
    setContextMenu({
      visible: true,
      x: e2.evt.clientX,
      y: e2.evt.clientY,
      elementId: element.id,
      type: menuType,
      row: cellInfo?.row,
      col: cellInfo?.col
    });
  }, [activeTool, stageRef, selectedElementId, onElementSelect, setSelectedCell, setEditingCell]);
  const handleReorder = import_react38.useCallback((action) => {
    if (!contextMenu || !contextMenu.elementId)
      return;
    const nextNodes = reorderNodes(templateDoc.nodes, contextMenu.elementId, action);
    onTemplateChange({ ...templateDoc, nodes: nextNodes });
    setContextMenu(null);
  }, [contextMenu, onTemplateChange, templateDoc]);
  const applyTableUpdate = import_react38.useCallback((elementId, updater) => {
    const nextNodes = templateDoc.nodes.map((n2) => {
      if (n2.id !== elementId || n2.t !== "table")
        return n2;
      return updater(n2);
    });
    onTemplateChange({ ...templateDoc, nodes: nextNodes });
  }, [onTemplateChange, templateDoc]);
  const handleContextMenuAction = import_react38.useCallback((action) => {
    if (!contextMenu || contextMenu.type !== "table" || !contextMenu.elementId)
      return;
    const { elementId, row, col } = contextMenu;
    if (typeof row !== "number" || typeof col !== "number")
      return;
    applyTableUpdate(elementId, (table) => {
      switch (action) {
        case "insertRowAbove":
          return insertRow(table, row, "above");
        case "insertRowBelow":
          return insertRow(table, row, "below");
        case "insertColLeft":
          return insertCol(table, col, row, "left");
        case "insertColRight":
          return insertCol(table, col, row, "right");
        case "deleteRow":
          return deleteRow(table, row);
        case "deleteCol":
          return deleteCol(table, col);
        case "mergeRight":
          return mergeCells(table, row, col, "right");
        case "mergeDown":
          return mergeCells(table, row, col, "down");
        case "unmerge":
          return unmergeCells(table, row, col);
        default:
          return table;
      }
    });
    setContextMenu(null);
  }, [contextMenu, applyTableUpdate]);
  return {
    contextMenu,
    setContextMenu,
    handleContextMenu,
    handleReorder,
    handleContextMenuAction
  };
};

// ../../src/features/report-editor/hooks/useNodeOperations.ts
var import_react39 = __toESM(require_react(), 1);
var useNodeOperations = ({
  templateDoc,
  onTemplateChange,
  selectedElementId,
  editingElementId,
  setEditingElementId
}) => {
  const handleElementChange = import_react39.useCallback((updates, options2) => {
    const updateList = Array.isArray(updates) ? updates : [updates];
    const updateMap = new Map(updateList.map((u2) => {
      const id = u2.id || selectedElementId;
      return [id, u2];
    }));
    const nextNodes = templateDoc.nodes.map((el) => {
      const update = updateMap.get(el.id);
      if (update) {
        return { ...el, ...update, id: el.id };
      }
      return el;
    });
    onTemplateChange({ ...templateDoc, nodes: nextNodes }, options2);
  }, [onTemplateChange, selectedElementId, templateDoc]);
  const handleTextUpdate = import_react39.useCallback((text2) => {
    if (!editingElementId)
      return;
    const element = templateDoc.nodes.find((n2) => n2.id === editingElementId);
    if (!element || element.t !== "text") {
      handleElementChange({ id: editingElementId, text: text2 }, { saveToHistory: false });
      return;
    }
    const textNode = element;
    const updatePatch = applyTextLayoutUpdates(textNode, { text: text2 });
    handleElementChange({ id: editingElementId, ...updatePatch }, { saveToHistory: false });
  }, [editingElementId, templateDoc.nodes, handleElementChange]);
  const handleTextEditFinish = import_react39.useCallback(() => {
    if (editingElementId) {
      const element = templateDoc.nodes.find((n2) => n2.id === editingElementId);
      if (element && element.t === "text") {
        const textNode = element;
        if (textNode.vertical) {
          const fontSize = textNode.fontSize ?? ptToMm(12);
          const padding = textNode.padding ?? 10;
          const newH = calculateVerticalTextHeight(textNode.text ?? "", fontSize, padding);
          const updatePatch = { id: editingElementId, h: newH };
          handleElementChange(updatePatch, { saveToHistory: true, force: true });
        } else {
          handleElementChange({ id: editingElementId }, { saveToHistory: true, force: true });
        }
      }
    }
    setEditingElementId(null);
  }, [editingElementId, templateDoc.nodes, handleElementChange, setEditingElementId]);
  return {
    handleElementChange,
    handleTextUpdate,
    handleTextEditFinish
  };
};

// ../../src/features/report-editor/hooks/useSignature.ts
var import_react40 = __toESM(require_react(), 1);

// ../../src/utils/geometry.ts
function getPerpendicularDistance(pointX, pointY, lineStartX, lineStartY, lineEndX, lineEndY) {
  let dx = lineEndX - lineStartX;
  let dy = lineEndY - lineStartY;
  const mag = Math.sqrt(dx * dx + dy * dy);
  if (mag > 0) {
    dx /= mag;
    dy /= mag;
  }
  const pvx = pointX - lineStartX;
  const pvy = pointY - lineStartY;
  const pvdot = pvx * dx + pvy * dy;
  const dsx = pvdot * dx;
  const dsy = pvdot * dy;
  const ax = pvx - dsx;
  const ay = pvy - dsy;
  return Math.sqrt(ax * ax + ay * ay);
}
function simplifyPoints(points, tolerance) {
  if (points.length <= 4) {
    return points;
  }
  const pointCount = points.length / 2;
  const firstPointX = points[0];
  const firstPointY = points[1];
  const lastPointX = points[points.length - 2];
  const lastPointY = points[points.length - 1];
  let maxDistance = 0;
  let indexFarthest = 0;
  for (let i3 = 1;i3 < pointCount - 1; i3++) {
    const pointX = points[i3 * 2];
    const pointY = points[i3 * 2 + 1];
    const distance = getPerpendicularDistance(pointX, pointY, firstPointX, firstPointY, lastPointX, lastPointY);
    if (distance > maxDistance) {
      maxDistance = distance;
      indexFarthest = i3;
    }
  }
  if (maxDistance > tolerance) {
    const leftPath = points.slice(0, (indexFarthest + 1) * 2);
    const rightPath = points.slice(indexFarthest * 2);
    const simplifiedLeft = simplifyPoints(leftPath, tolerance);
    const simplifiedRight = simplifyPoints(rightPath, tolerance);
    return [...simplifiedLeft.slice(0, simplifiedLeft.length - 2), ...simplifiedRight];
  } else {
    return [firstPointX, firstPointY, lastPointX, lastPointY];
  }
}

// ../../src/features/report-editor/utils/signatureUtils.ts
var getStrokesBox = (strokes) => {
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  strokes.forEach((stroke) => {
    for (let i3 = 0;i3 < stroke.length; i3 += 2) {
      const x3 = stroke[i3];
      const y2 = stroke[i3 + 1];
      if (x3 < minX)
        minX = x3;
      if (y2 < minY)
        minY = y2;
      if (x3 > maxX)
        maxX = x3;
      if (y2 > maxY)
        maxY = y2;
    }
  });
  if (minX === Infinity)
    return { x: 0, y: 0, w: 100, h: 50 };
  return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
};
var processStrokes = (strokes, options2 = {}) => {
  return strokes.map((s2) => {
    const tol = options2.simplification ?? 0;
    if (s2.length > 4 && tol > 0) {
      return simplifyPoints(s2, tol);
    }
    if (s2.length === 2)
      return [...s2, ...s2];
    return s2;
  });
};
var normalizeStrokes = (strokes, box) => {
  return strokes.map((stroke) => {
    const newStroke = [];
    for (let i3 = 0;i3 < stroke.length; i3 += 2) {
      const x3 = stroke[i3] - box.x;
      const y2 = stroke[i3 + 1] - box.y;
      newStroke.push(Math.round(x3 * 100) / 100, Math.round(y2 * 100) / 100);
    }
    return newStroke;
  });
};

// ../../src/features/report-editor/hooks/useSignature.ts
var useSignature = ({
  templateDoc,
  onTemplateChange,
  currentSurface,
  onElementSelect,
  drawingSettings = { stroke: "#000000", strokeWidth: 0.2, simplification: 0 }
}) => {
  const [isDrawing, setIsDrawing] = import_react40.useState(false);
  const [currentStrokes, setCurrentStrokes] = import_react40.useState([]);
  const [currentPoints, setCurrentPoints] = import_react40.useState([]);
  const [currentPressure, setCurrentPressure] = import_react40.useState([]);
  const [allPressureData, setAllPressureData] = import_react40.useState([]);
  const commitSignature = import_react40.useCallback(() => {
    if (currentStrokes.length === 0)
      return null;
    const simplifiedStrokes = processStrokes(currentStrokes, {
      simplification: drawingSettings.simplification
    });
    const box = getStrokesBox(simplifiedStrokes);
    const normalizedStrokes = normalizeStrokes(simplifiedStrokes, box);
    const hasPressureData = allPressureData.some((pressure) => pressure.length > 0);
    const element = {
      id: `sig-${crypto.randomUUID()}`,
      t: "signature",
      s: currentSurface.id,
      name: "Signature",
      x: box.x,
      y: box.y,
      w: box.w,
      h: box.h,
      strokes: normalizedStrokes,
      stroke: drawingSettings.stroke,
      strokeW: drawingSettings.strokeWidth,
      pressureData: hasPressureData ? allPressureData : undefined,
      usePressureSim: !hasPressureData,
      r: 0,
      locked: false,
      hidden: false
    };
    const nextDoc = {
      ...templateDoc,
      nodes: [...templateDoc.nodes, element]
    };
    onTemplateChange(nextDoc);
    setCurrentStrokes([]);
    setCurrentPoints([]);
    setCurrentPressure([]);
    setAllPressureData([]);
    setIsDrawing(false);
    onElementSelect(element);
    return nextDoc;
  }, [
    currentStrokes,
    currentSurface.id,
    templateDoc,
    onTemplateChange,
    onElementSelect,
    drawingSettings.stroke,
    drawingSettings.strokeWidth,
    drawingSettings.simplification,
    allPressureData
  ]);
  const handleSignatureMouseDown = import_react40.useCallback((e2) => {
    const stage = e2.target.getStage();
    const interestedInBackground = e2.target === stage || e2.target.name() === "_background";
    if (interestedInBackground) {
      setIsDrawing(true);
      const nativeEvent = e2.evt;
      const pressure = nativeEvent && "pressure" in nativeEvent ? nativeEvent.pressure : undefined;
      const isPressureDevice = typeof pressure === "number" && pressure !== 0.5 && pressure !== 0;
      const point = stage?.getPointerPosition();
      if (point) {
        const transform = stage?.getAbsoluteTransform().copy();
        transform?.invert();
        const pos = transform?.point(point);
        if (pos) {
          setCurrentPoints([pos.x, pos.y]);
          if (isPressureDevice && typeof pressure === "number") {
            setCurrentPressure([pressure]);
          }
        }
      }
    }
  }, []);
  const handleSignatureMouseMove = import_react40.useCallback((e2) => {
    if (isDrawing) {
      const stage = e2.target.getStage();
      const nativeEvent = e2.evt;
      const pressure = nativeEvent && "pressure" in nativeEvent ? nativeEvent.pressure : undefined;
      const isPressureDevice = typeof pressure === "number" && pressure !== 0.5 && pressure !== 0;
      const point = stage?.getPointerPosition();
      if (point) {
        const transform = stage?.getAbsoluteTransform().copy();
        transform?.invert();
        const pos = transform?.point(point);
        if (pos) {
          setCurrentPoints((prev) => [...prev, pos.x, pos.y]);
          if (isPressureDevice) {
            setCurrentPressure((prev) => [...prev, pressure]);
          }
        }
      }
    }
  }, [isDrawing]);
  const handleSignatureMouseUp = import_react40.useCallback(() => {
    if (isDrawing) {
      setIsDrawing(false);
      if (currentPoints.length > 0) {
        setCurrentStrokes((prev) => [...prev, currentPoints]);
        setCurrentPoints([]);
        setAllPressureData((prev) => [
          ...prev,
          currentPressure.length > 0 ? currentPressure : []
        ]);
        setCurrentPressure([]);
      }
    }
  }, [currentPoints, currentPressure, isDrawing]);
  return {
    isDrawing,
    currentStrokes,
    commitSignature,
    handleSignatureMouseDown,
    handleSignatureMouseMove,
    handleSignatureMouseUp,
    currentPoints
  };
};

// ../../src/features/report-editor/components/PageBackground.tsx
var import_react41 = __toESM(require_react(), 1);
var jsx_dev_runtime68 = __toESM(require_jsx_dev_runtime(), 1);
var PageBackground = ({ width, height, surface }) => {
  const [image, setImage] = import_react41.useState(null);
  const bg = surface.bg;
  const isColor = bg ? bg.startsWith("#") || bg.startsWith("rgb") : true;
  import_react41.useEffect(() => {
    if (!bg || isColor) {
      setImage(null);
      return;
    }
    if (!bg.startsWith("http") && !bg.startsWith("data:")) {
      findImageWithExtension(bg).then((res) => {
        if (res)
          setImage(res.img);
      });
    } else {
      const img = new window.Image;
      img.src = bg;
      img.onload = () => setImage(img);
    }
  }, [bg, isColor]);
  return /* @__PURE__ */ jsx_dev_runtime68.jsxDEV(jsx_dev_runtime68.Fragment, {
    children: [
      /* @__PURE__ */ jsx_dev_runtime68.jsxDEV(Rect2, {
        name: "_background",
        x: 0,
        y: 0,
        width,
        height,
        fill: isColor ? bg || "#ffffff" : "#ffffff",
        shadowColor: "black",
        shadowBlur: 10,
        shadowOpacity: 0.1
      }, undefined, false, undefined, this),
      image && /* @__PURE__ */ jsx_dev_runtime68.jsxDEV(Image3, {
        name: "_background",
        x: 0,
        y: 0,
        width,
        height,
        image,
        listening: false
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/report-editor/ReportKonvaEditor.tsx
var jsx_dev_runtime69 = __toESM(require_jsx_dev_runtime(), 1);
var dpi2 = 96;
var getRowY = (rows, rowIndex) => {
  let y2 = 0;
  for (let i3 = 0;i3 < rowIndex; i3++) {
    if (rows[i3] !== undefined)
      y2 += rows[i3];
  }
  return y2;
};
var getColX = (cols, colIndex) => {
  let x3 = 0;
  for (let i3 = 0;i3 < colIndex; i3++) {
    if (cols[i3] !== undefined)
      x3 += cols[i3];
  }
  return x3;
};
var getRowHeight = (rows, rowIndex, span = 1) => {
  let h3 = 0;
  for (let i3 = 0;i3 < span; i3++) {
    const rh = rows[rowIndex + i3];
    if (rh !== undefined)
      h3 += rh;
  }
  return h3;
};
var getColWidth = (cols, colIndex, span = 1) => {
  let w2 = 0;
  for (let i3 = 0;i3 < span; i3++) {
    const cw = cols[colIndex + i3];
    if (cw !== undefined)
      w2 += cw;
  }
  return w2;
};
var ReportKonvaEditor = import_react42.forwardRef(({
  templateDoc,
  zoom,
  selectedElementId,
  onElementSelect,
  onTemplateChange,
  currentPageId,
  onUndo,
  onRedo,
  onSelectedCellChange,
  activeTool,
  drawingSettings = { stroke: "#000000", strokeWidth: 0.2, simplification: 0 },
  showGrid = false,
  gridSize = 50
}, ref) => {
  const stageRef = import_react42.useRef(null);
  const containerRef = import_react42.useRef(null);
  const [editingElementId, setEditingElementId] = import_react42.useState(null);
  const [pasteCount, setPasteCount] = import_react42.useState(1);
  const [selectedCell, setSelectedCell] = import_react42.useState(null);
  const [editingCell, setEditingCell] = import_react42.useState(null);
  import_react42.useEffect(() => {
    onSelectedCellChange?.(selectedCell);
  }, [selectedCell, onSelectedCellChange]);
  const currentSurface = templateDoc.surfaces.find((s2) => s2.id === currentPageId) || templateDoc.surfaces[0];
  const nodes = templateDoc.nodes.filter((n2) => n2.s === currentSurface.id);
  const selectedNode = import_react42.useMemo(() => {
    if (!selectedElementId)
      return null;
    return templateDoc.nodes.find((n2) => n2.id === selectedElementId) || null;
  }, [selectedElementId, templateDoc.nodes]);
  const selectedTable = selectedNode?.t === "table" ? selectedNode : null;
  const editingElement = import_react42.useMemo(() => {
    if (!editingElementId)
      return null;
    const node = templateDoc.nodes.find((n2) => n2.id === editingElementId);
    if (!node || node.t !== "text")
      return null;
    return node;
  }, [editingElementId, templateDoc.nodes]);
  const selectedCellBox = import_react42.useMemo(() => {
    if (!selectedTable || !selectedCell || selectedCell.elementId !== selectedTable.id)
      return null;
    const cell = selectedTable.table.cells.find((c3) => c3.r === selectedCell.row && c3.c === selectedCell.col);
    const rs = cell?.rs || 1;
    const cs = cell?.cs || 1;
    const x3 = (selectedTable.x || 0) + getColX(selectedTable.table.cols, selectedCell.col);
    const y2 = (selectedTable.y || 0) + getRowY(selectedTable.table.rows, selectedCell.row);
    const w2 = getColWidth(selectedTable.table.cols, selectedCell.col, cs);
    const h3 = getRowHeight(selectedTable.table.rows, selectedCell.row, rs);
    return { x: x3, y: y2, w: w2, h: h3 };
  }, [selectedCell, selectedTable]);
  const width = currentSurface.w;
  const height = currentSurface.h;
  const displayScale = zoom * mmToPx(1, { dpi: dpi2 });
  const handleElementSelect = (element) => {
    onElementSelect(element);
  };
  const {
    handleElementChange,
    handleTextUpdate,
    handleTextEditFinish
  } = useNodeOperations({
    templateDoc,
    onTemplateChange,
    selectedElementId,
    editingElementId,
    setEditingElementId
  });
  const {
    currentStrokes,
    commitSignature,
    handleSignatureMouseDown,
    handleSignatureMouseMove,
    handleSignatureMouseUp
  } = useSignature({
    templateDoc,
    onTemplateChange,
    currentSurface,
    onElementSelect,
    drawingSettings
  });
  const {
    contextMenu,
    setContextMenu,
    handleContextMenu,
    handleReorder,
    handleContextMenuAction
  } = useReportContextMenu({
    templateDoc,
    onTemplateChange,
    stageRef,
    activeTool,
    setSelectedCell,
    setEditingCell,
    onElementSelect,
    selectedElementId
  });
  import_react42.useEffect(() => {
    if (activeTool !== "signature" && currentStrokes.length > 0) {
      commitSignature();
    }
  }, [activeTool, commitSignature, currentStrokes.length]);
  const handleStageMouseDown = (e2) => {
    if (activeTool === "signature") {
      handleSignatureMouseDown(e2);
      return;
    }
    const stage = e2.target.getStage();
    const interestedInBackground = e2.target === stage || e2.target.name() === "_background";
    if (interestedInBackground) {
      handleElementSelect(null);
      setSelectedCell(null);
      setEditingCell(null);
    }
  };
  const handleStageMouseMove = (e2) => {
    handleSignatureMouseMove(e2);
  };
  const handleStageMouseUp = () => {
    handleSignatureMouseUp();
  };
  const handleDelete = () => {
    if (selectedElementId) {
      const nextNodes = templateDoc.nodes.filter((el) => el.id !== selectedElementId);
      onTemplateChange({ ...templateDoc, nodes: nextNodes });
      onElementSelect(null);
    }
  };
  const handleSelectAll = () => {
    if (nodes.length > 0)
      onElementSelect(nodes[0]);
  };
  const handleMove = (dx, dy) => {
    if (selectedElementId) {
      const el = nodes.find((n2) => n2.id === selectedElementId);
      if (el && el.t !== "line") {
        handleElementChange({ id: selectedElementId, x: (el.x || 0) + dx, y: (el.y || 0) + dy });
      }
    }
  };
  const handleCopy = () => {
    if (!selectedElementId)
      return;
    const selected = nodes.find((n2) => n2.id === selectedElementId);
    if (selected) {
      const clipboardData = [selected];
      localStorage.setItem("__konva_clipboard", JSON.stringify(clipboardData));
      setPasteCount(1);
    }
  };
  const handlePaste = () => {
    try {
      const json = localStorage.getItem("__konva_clipboard");
      if (!json)
        return;
      const clipboardElements = JSON.parse(json);
      if (!Array.isArray(clipboardElements) || clipboardElements.length === 0)
        return;
      const step = currentSurface.w * 0.01;
      const offset4 = step * pasteCount;
      const newNodes = [];
      clipboardElements.forEach((el) => {
        const newId = crypto.randomUUID();
        const newEl = { ...el, id: newId, s: currentSurface.id };
        if ("x" in newEl && "y" in newEl && typeof newEl.x === "number" && typeof newEl.y === "number") {
          newEl.x += offset4;
          newEl.y += offset4;
        }
        newNodes.push(newEl);
      });
      onTemplateChange({ ...templateDoc, nodes: [...templateDoc.nodes, ...newNodes] });
      if (newNodes.length > 0) {
        onElementSelect(newNodes[newNodes.length - 1]);
      }
      setPasteCount((c3) => c3 + 1);
    } catch (e2) {
      console.error("Failed to paste elements", e2);
    }
  };
  useKeyboardShortcuts({
    onUndo,
    onRedo,
    onDelete: handleDelete,
    onCopy: handleCopy,
    onPaste: handlePaste,
    onSelectAll: handleSelectAll,
    onMoveUp: (step) => handleMove(0, -step),
    onMoveDown: (step) => handleMove(0, step),
    onMoveLeft: (step) => handleMove(-step, 0),
    onMoveRight: (step) => handleMove(step, 0)
  });
  import_react42.useImperativeHandle(ref, () => ({
    downloadImage: () => {
      if (!stageRef.current)
        return;
      const stage = stageRef.current;
      const gridLayer = stage.findOne(".grid-layer");
      const wasGridVisible = gridLayer?.visible();
      const transformers = stage.find("Transformer").filter((n2) => n2.getClassName?.() === "Transformer");
      const transformerVisibility = transformers.map((tr) => tr.visible());
      try {
        gridLayer?.hide();
        transformers.forEach((tr) => {
          tr.hide();
        });
        const dataURL = stage.toDataURL({ pixelRatio: 2 });
        const link = document.createElement("a");
        link.download = `report-${Date.now()}.png`;
        link.href = dataURL;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      } finally {
        if (gridLayer && wasGridVisible) {
          gridLayer.show();
        }
        transformers.forEach((tr, idx) => {
          const prev = transformerVisibility[idx];
          if (prev)
            tr.show();
        });
      }
    },
    flushSignature: () => {
      const result = commitSignature();
      return result;
    }
  }));
  const handleDrop = (e2) => {
    e2.preventDefault();
    if (!stageRef.current)
      return;
    try {
      const jsonData = e2.dataTransfer.getData("application/json");
      if (!jsonData)
        return;
      const payload = JSON.parse(jsonData);
      if (payload.type !== "binding")
        return;
      const { text: text2 } = payload.data;
      stageRef.current.setPointersPositions(e2);
      const stagePos = stageRef.current.getPointerPosition();
      if (!stagePos)
        return;
      const logicX = stagePos.x / displayScale;
      const logicY = stagePos.y / displayScale;
      const newNode = {
        id: `text-${crypto.randomUUID()}`,
        t: "text",
        s: currentSurface.id,
        x: logicX,
        y: logicY,
        w: 100,
        h: 10,
        text: `{${text2}}`,
        fontSize: ptToMm(10),
        fill: "#000000",
        align: "l",
        vertical: false
      };
      onTemplateChange({ ...templateDoc, nodes: [...templateDoc.nodes, newNode] });
      onElementSelect(newNode);
    } catch (e3) {
      console.error("Failed to parse drop data", e3);
    }
  };
  return /* @__PURE__ */ jsx_dev_runtime69.jsxDEV("div", {
    ref: containerRef,
    className: "w-full h-full bg-gray-100 dark:bg-gray-900 overflow-auto flex scrollbar-thin p-8",
    onDrop: handleDrop,
    onDragOver: (e2) => {
      e2.preventDefault();
      e2.dataTransfer.dropEffect = "copy";
    },
    children: /* @__PURE__ */ jsx_dev_runtime69.jsxDEV("div", {
      className: "relative bg-white shadow-lg border border-gray-200 dark:border-gray-700",
      children: [
        /* @__PURE__ */ jsx_dev_runtime69.jsxDEV(Stage2, {
          width: width * displayScale,
          height: height * displayScale,
          scaleX: displayScale,
          scaleY: displayScale,
          ref: stageRef,
          onMouseDown: handleStageMouseDown,
          onMouseMove: handleStageMouseMove,
          onMouseUp: handleStageMouseUp,
          onTouchStart: handleStageMouseDown,
          onTouchMove: (e2) => handleStageMouseMove(e2),
          onTouchEnd: () => handleStageMouseUp(),
          style: { touchAction: "none" },
          children: [
            /* @__PURE__ */ jsx_dev_runtime69.jsxDEV(Layer2, {
              children: [
                /* @__PURE__ */ jsx_dev_runtime69.jsxDEV(PageBackground, {
                  width,
                  height,
                  surface: currentSurface
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx_dev_runtime69.jsxDEV(GridLayer, {
                  width,
                  height,
                  gridSize,
                  scale: displayScale,
                  visible: showGrid
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime69.jsxDEV(Layer2, {
              children: [
                nodes.map((element) => /* @__PURE__ */ jsx_dev_runtime69.jsxDEV(CanvasElementRenderer, {
                  element,
                  isSelected: selectedElementId === element.id,
                  onSelect: () => {
                    handleElementSelect(element);
                    if (contextMenu && contextMenu.elementId !== element.id) {
                      setContextMenu(null);
                    }
                  },
                  onChange: handleElementChange,
                  onDblClick: () => {
                    if (element.t === "text")
                      setEditingElementId(element.id);
                  },
                  isEditing: editingElementId === element.id,
                  stageScale: displayScale,
                  allElements: nodes,
                  onContextMenu: (e2) => handleContextMenu(e2, element)
                }, element.id, false, undefined, this)),
                selectedCellBox && /* @__PURE__ */ jsx_dev_runtime69.jsxDEV(Rect2, {
                  x: selectedCellBox.x,
                  y: selectedCellBox.y,
                  width: selectedCellBox.w,
                  height: selectedCellBox.h,
                  stroke: "#3b82f6",
                  strokeWidth: 2 / displayScale,
                  listening: false
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this)
          ]
        }, undefined, true, undefined, this),
        editingElement && /* @__PURE__ */ jsx_dev_runtime69.jsxDEV(TextEditOverlay, {
          element: editingElement,
          scale: displayScale,
          stageNode: stageRef.current,
          onUpdate: handleTextUpdate,
          onFinish: handleTextEditFinish
        }, undefined, false, undefined, this),
        editingCell && selectedTable && /* @__PURE__ */ jsx_dev_runtime69.jsxDEV("div", {
          style: {
            position: "absolute",
            top: 0,
            left: 0
          }
        }, undefined, false, undefined, this),
        contextMenu && contextMenu.type === "table" && /* @__PURE__ */ jsx_dev_runtime69.jsxDEV(TableContextMenu, {
          visible: contextMenu.visible,
          x: contextMenu.x,
          y: contextMenu.y,
          onAction: handleContextMenuAction,
          onClose: () => setContextMenu(null)
        }, undefined, false, undefined, this),
        contextMenu && contextMenu.type === "object" && /* @__PURE__ */ jsx_dev_runtime69.jsxDEV(ObjectContextMenu, {
          visible: contextMenu.visible,
          x: contextMenu.x,
          y: contextMenu.y,
          onAction: handleReorder,
          onClose: () => setContextMenu(null)
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this);
});
ReportKonvaEditor.displayName = "ReportKonvaEditor";

// ../../src/features/report-editor/ReportEditor.tsx
var jsx_dev_runtime70 = __toESM(require_jsx_dev_runtime(), 1);
var ReportEditor = ({
  templateDoc,
  onTemplateChange,
  schema,
  initialZoom = 1,
  showGrid = false,
  gridSize = 15
}) => {
  const [zoom, setZoom] = import_react43.useState(initialZoom * 100);
  const [selectedElementId, setSelectedElementId] = import_react43.useState(null);
  const [selectedCell, setSelectedCell] = import_react43.useState(null);
  const [drawingSettings, setDrawingSettings] = import_react43.useState({
    stroke: "#000000",
    strokeWidth: 0.2,
    simplification: 0
  });
  const editorRef = import_react43.useRef(null);
  const [activeTool, setActiveTool] = import_react43.useState("select");
  const currentPageId = templateDoc.surfaces[0]?.id || "";
  const handleElementSelect = (element) => {
    setSelectedElementId(element?.id ?? null);
    if (!element) {
      setSelectedCell(null);
    }
  };
  const handleToolSelect = import_react43.useCallback((tool) => {
    setActiveTool(tool);
    if (tool !== "select") {
      setSelectedElementId(null);
      setSelectedCell(null);
    }
  }, []);
  return /* @__PURE__ */ jsx_dev_runtime70.jsxDEV("div", {
    className: "flex h-full w-full overflow-hidden border border-border bg-background text-foreground",
    children: [
      /* @__PURE__ */ jsx_dev_runtime70.jsxDEV("div", {
        className: "w-16 border-r border-border bg-secondary shrink-0 flex flex-col z-10 relative",
        children: /* @__PURE__ */ jsx_dev_runtime70.jsxDEV(WysiwygEditorToolbar, {
          zoom,
          onZoomChange: setZoom,
          templateDoc,
          onTemplateChange,
          onSelectElement: (id) => setSelectedElementId(id),
          currentPageId,
          activeTool,
          onToolSelect: handleToolSelect
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime70.jsxDEV("div", {
        className: "flex-1 relative overflow-hidden bg-gray-100 dark:bg-gray-900",
        children: /* @__PURE__ */ jsx_dev_runtime70.jsxDEV(ReportKonvaEditor, {
          ref: editorRef,
          templateDoc,
          zoom: zoom / 100,
          selectedElementId: selectedElementId || undefined,
          onElementSelect: handleElementSelect,
          onTemplateChange,
          currentPageId,
          onSelectedCellChange: setSelectedCell,
          activeTool,
          drawingSettings,
          showGrid,
          gridSize
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime70.jsxDEV("div", {
        className: "w-64 border-l border-border bg-secondary shrink-0 overflow-hidden flex flex-col",
        children: /* @__PURE__ */ jsx_dev_runtime70.jsxDEV(WysiwygPropertiesPanel, {
          templateDoc,
          selectedElementId,
          onTemplateChange,
          currentPageId,
          selectedCell,
          schema,
          activeTool,
          onToolSelect: handleToolSelect,
          drawingSettings,
          onDrawingSettingsChange: setDrawingSettings
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
// ../../src/components/ui/DocumentLoadMenu.tsx
var import_react44 = __toESM(require_react(), 1);
var jsx_dev_runtime71 = __toESM(require_jsx_dev_runtime(), 1);
var formatDate = (timestamp) => new Date(timestamp).toLocaleString();
var DocumentLoadMenu = ({
  fetchRecent,
  fetchBrowse,
  onLoad,
  triggerClassName,
  triggerTooltip
}) => {
  const [quickList, setQuickList] = import_react44.useState([]);
  const [quickLoading, setQuickLoading] = import_react44.useState(false);
  const [browseOpen, setBrowseOpen] = import_react44.useState(false);
  const [browseList, setBrowseList] = import_react44.useState([]);
  const [browseLoading, setBrowseLoading] = import_react44.useState(false);
  const [browseQuery, setBrowseQuery] = import_react44.useState("");
  const [browseOffset, setBrowseOffset] = import_react44.useState(0);
  const [browseHasMore, setBrowseHasMore] = import_react44.useState(true);
  const loadQuickList = import_react44.useCallback(async () => {
    setQuickLoading(true);
    try {
      const items = await fetchRecent();
      setQuickList(items);
    } finally {
      setQuickLoading(false);
    }
  }, [fetchRecent]);
  const handleFetchBrowse = import_react44.useCallback(async (options2) => {
    setBrowseLoading(true);
    try {
      const nextOffset = options2.reset ? 0 : browseOffset;
      const { items, hasMore } = await fetchBrowse(browseQuery.trim(), nextOffset);
      setBrowseList((prev) => options2.reset ? items : [...prev, ...items]);
      setBrowseOffset(nextOffset + items.length);
      setBrowseHasMore(hasMore);
    } finally {
      setBrowseLoading(false);
    }
  }, [fetchBrowse, browseQuery, browseOffset]);
  const quickContent = import_react44.useMemo(() => {
    if (quickLoading) {
      return /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("div", {
        className: "px-3 py-2 text-xs text-muted-foreground flex items-center gap-2",
        children: [
          /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(LoaderCircle, {
            className: "w-3 h-3 animate-spin"
          }, undefined, false, undefined, this),
          "Loading..."
        ]
      }, undefined, true, undefined, this);
    }
    if (quickList.length === 0) {
      return /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("div", {
        className: "px-3 py-2 text-xs text-muted-foreground",
        children: "No saved documents"
      }, undefined, false, undefined, this);
    }
    return quickList.map((doc) => /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(Item22, {
      onSelect: (event) => {
        event.preventDefault();
        onLoad(doc.id);
      },
      className: "px-3 py-2 text-sm text-foreground hover:bg-accent cursor-pointer outline-none",
      children: /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("div", {
        className: "flex flex-col",
        children: [
          /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("span", {
            className: "font-medium truncate max-w-[220px]",
            children: doc.title
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("span", {
            className: "text-xs text-muted-foreground",
            children: formatDate(doc.updatedAt)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    }, doc.id, false, undefined, this));
  }, [quickLoading, quickList, onLoad]);
  import_react44.useEffect(() => {
    if (browseOpen) {
      handleFetchBrowse({ reset: true });
    }
  }, [browseOpen, handleFetchBrowse]);
  return /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(Root6, {
    open: browseOpen,
    onOpenChange: setBrowseOpen,
    children: [
      /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(Root23, {
        onOpenChange: (open) => open && loadQuickList(),
        children: [
          /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(Trigger2, {
            asChild: true,
            children: /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("button", {
              type: "button",
              title: triggerTooltip ?? "Load",
              className: `flex items-center gap-2 px-3 py-1.5 text-sm font-medium text-foreground hover:bg-accent rounded-md border border-border transition-colors shadow-sm whitespace-nowrap flex-shrink-0 ${triggerClassName ?? ""}`,
              children: [
                /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(FolderOpen, {
                  className: "w-4 h-4"
                }, undefined, false, undefined, this),
                "Load",
                /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(ChevronDown, {
                  className: "w-3 h-3"
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(Portal22, {
            children: /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(Content23, {
              align: "end",
              sideOffset: 8,
              className: "bg-popover border border-border rounded-md shadow-md min-w-[260px] py-2 z-50 animate-in fade-in-80 zoom-in-95",
              children: [
                /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("div", {
                  className: "px-3 py-1 text-xs font-semibold text-muted-foreground",
                  children: "Quick List"
                }, undefined, false, undefined, this),
                quickContent,
                /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(Separator2, {
                  className: "h-px bg-border my-1"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(Item22, {
                  onSelect: (event) => {
                    event.preventDefault();
                    setBrowseOpen(true);
                  },
                  className: "px-3 py-2 text-sm text-foreground hover:bg-accent cursor-pointer outline-none",
                  children: "Browse..."
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(Portal5, {
        children: [
          /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(Overlay, {
            className: "fixed inset-0 bg-black/40 z-[60]"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(Content3, {
            className: "fixed left-1/2 top-1/2 w-full max-w-xl -translate-x-1/2 -translate-y-1/2 rounded-lg bg-background border border-border shadow-lg p-6 z-[61] outline-none animate-in fade-in-90 zoom-in-95",
            children: [
              /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(Title, {
                className: "text-lg font-semibold text-foreground",
                children: "Browse Documents"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(Description, {
                className: "text-sm text-muted-foreground mt-1",
                children: "Select a saved document to load."
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("div", {
                className: "mt-4 flex items-center gap-2",
                children: [
                  /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("div", {
                    className: "flex items-center gap-2 flex-1 border border-border rounded-md px-2 py-1 bg-background",
                    children: [
                      /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(Search, {
                        className: "w-4 h-4 text-muted-foreground"
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("input", {
                        value: browseQuery,
                        onChange: (event) => setBrowseQuery(event.target.value),
                        placeholder: "Search by title",
                        className: "flex-1 bg-transparent text-sm text-foreground outline-none"
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("button", {
                    type: "button",
                    onClick: () => handleFetchBrowse({ reset: true }),
                    className: "px-3 py-1.5 text-sm font-medium border border-border rounded-md hover:bg-accent transition-colors",
                    children: "Search"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("div", {
                className: "mt-4 border border-border rounded-md max-h-72 overflow-auto divide-y divide-border",
                children: [
                  browseLoading && browseList.length === 0 && /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("div", {
                    className: "px-4 py-6 text-sm text-muted-foreground flex items-center gap-2",
                    children: [
                      /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(LoaderCircle, {
                        className: "w-4 h-4 animate-spin"
                      }, undefined, false, undefined, this),
                      "Loading..."
                    ]
                  }, undefined, true, undefined, this),
                  !browseLoading && browseList.length === 0 && /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("div", {
                    className: "px-4 py-6 text-sm text-muted-foreground",
                    children: "No documents found"
                  }, undefined, false, undefined, this),
                  browseList.map((doc) => /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("button", {
                    type: "button",
                    onClick: async () => {
                      try {
                        await onLoad(doc.id);
                      } finally {
                        setBrowseOpen(false);
                      }
                    },
                    className: "w-full text-left px-4 py-3 hover:bg-accent transition-colors block",
                    children: [
                      /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("div", {
                        className: "text-sm font-medium text-foreground truncate",
                        children: doc.title
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("div", {
                        className: "text-xs text-muted-foreground",
                        children: formatDate(doc.updatedAt)
                      }, undefined, false, undefined, this)
                    ]
                  }, doc.id, true, undefined, this)),
                  browseLoading && browseList.length > 0 && /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("div", {
                    className: "px-4 py-3 text-sm text-muted-foreground flex items-center gap-2 justify-center",
                    children: [
                      /* @__PURE__ */ jsx_dev_runtime71.jsxDEV(LoaderCircle, {
                        className: "w-4 h-4 animate-spin"
                      }, undefined, false, undefined, this),
                      "Loading more..."
                    ]
                  }, undefined, true, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("div", {
                className: "mt-4 flex items-center justify-between",
                children: [
                  /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("button", {
                    type: "button",
                    onClick: () => setBrowseOpen(false),
                    className: "px-3 py-1.5 text-sm font-medium text-muted-foreground hover:text-foreground transition-colors",
                    children: "Close"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime71.jsxDEV("button", {
                    type: "button",
                    onClick: () => handleFetchBrowse({ reset: false }),
                    disabled: !browseHasMore || browseLoading,
                    className: "px-3 py-1.5 text-sm font-medium border border-border rounded-md hover:bg-accent disabled:opacity-50 transition-colors",
                    children: "Load More"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
// ../../src/features/konva-editor/components/SettingsDrawer.tsx
var jsx_dev_runtime72 = __toESM(require_jsx_dev_runtime(), 1);
var FIBONACCI_grid_SIZES = [2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377];
var SettingsDrawer = ({
  isOpen,
  onClose,
  showGrid,
  onShowGridChange,
  gridSize,
  onGridSizeChange,
  snapStrength,
  onSnapStrengthChange
}) => {
  const { t: t2 } = useI18n();
  return /* @__PURE__ */ jsx_dev_runtime72.jsxDEV("div", {
    className: `absolute top-0 right-0 h-full w-64 bg-secondary shadow-xl border-l-[3px] border-border z-50 flex flex-col transform transition-transform duration-300 ease-in-out ${isOpen ? "translate-x-0" : "translate-x-full"}`,
    children: [
      /* @__PURE__ */ jsx_dev_runtime72.jsxDEV("div", {
        className: "flex items-center justify-between p-4 border-b border-border",
        children: [
          /* @__PURE__ */ jsx_dev_runtime72.jsxDEV("h3", {
            className: "font-semibold text-foreground",
            children: t2("settings_title", "Settings")
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime72.jsxDEV("button", {
            onClick: onClose,
            className: "p-1 rounded hover:bg-accent text-muted-foreground transition-colors",
            children: /* @__PURE__ */ jsx_dev_runtime72.jsxDEV(X, {
              className: "w-5 h-5"
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime72.jsxDEV("div", {
        className: "p-4 space-y-6",
        children: [
          /* @__PURE__ */ jsx_dev_runtime72.jsxDEV("div", {
            className: "space-y-3",
            children: [
              /* @__PURE__ */ jsx_dev_runtime72.jsxDEV("div", {
                className: "flex items-center justify-between",
                children: [
                  /* @__PURE__ */ jsx_dev_runtime72.jsxDEV("label", {
                    className: "text-sm font-medium text-foreground",
                    children: t2("settings_show_grid", "Show Grid")
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime72.jsxDEV("input", {
                    type: "checkbox",
                    checked: showGrid,
                    onChange: (e2) => onShowGridChange(e2.target.checked),
                    className: "h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              showGrid && /* @__PURE__ */ jsx_dev_runtime72.jsxDEV("div", {
                className: "flex items-center justify-between pl-2",
                children: [
                  /* @__PURE__ */ jsx_dev_runtime72.jsxDEV("label", {
                    className: "text-xs font-medium text-muted-foreground",
                    children: t2("settings_grid_size", "Grid Size (pt)")
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime72.jsxDEV("div", {
                    className: "w-24",
                    children: /* @__PURE__ */ jsx_dev_runtime72.jsxDEV(EditableSelect, {
                      value: gridSize,
                      onChange: (val) => {
                        const num = parseFloat(String(val));
                        if (!Number.isNaN(num) && num > 0) {
                          onGridSizeChange(num);
                        }
                      },
                      options: FIBONACCI_grid_SIZES
                    }, undefined, false, undefined, this)
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime72.jsxDEV("div", {
            className: "space-y-2",
            children: /* @__PURE__ */ jsx_dev_runtime72.jsxDEV("div", {
              className: "flex items-center justify-between",
              children: [
                /* @__PURE__ */ jsx_dev_runtime72.jsxDEV("label", {
                  className: "text-sm font-medium text-foreground",
                  children: t2("settings_snap_to_grid", "Snap to Grid")
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx_dev_runtime72.jsxDEV("input", {
                  type: "checkbox",
                  checked: snapStrength > 0,
                  onChange: (e2) => onSnapStrengthChange(e2.target.checked ? gridSize : 0),
                  className: "h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
// ../../src/features/konva-editor/signature/SignatureKonvaEditor.tsx
var import_react45 = __toESM(require_react(), 1);
var import_use_image = __toESM(require_use_image(), 1);

// ../../src/features/konva-editor/cursors.ts
var PEN_CURSOR_URL = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="black"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/><path d="M0 0h24v24H0z" fill="none"/></svg>') 0 24, auto`;

// ../../src/features/konva-editor/signature/SignatureKonvaEditor.tsx
var jsx_dev_runtime73 = __toESM(require_jsx_dev_runtime(), 1);
var SignatureKonvaEditor = ({
  width = 600,
  height = 300,
  simplification = 0,
  initialDataUrl,
  onSave,
  onCancel
}) => {
  const { t: t2 } = useI18n();
  const [lines, setLines] = import_react45.useState([]);
  const [isDrawing, setIsDrawing] = import_react45.useState(false);
  const [backgroundUrl, setBackgroundUrl] = import_react45.useState(initialDataUrl ?? null);
  const [backgroundImage] = import_use_image.default(backgroundUrl ?? "");
  const stageRef = import_react45.useRef(null);
  import_react45.useEffect(() => {
    setBackgroundUrl(initialDataUrl ?? null);
  }, [initialDataUrl]);
  const handleMouseDown = (e2) => {
    setIsDrawing(true);
    const pos = e2.target.getStage()?.getPointerPosition();
    if (!pos)
      return;
    setLines([...lines, { points: [pos.x, pos.y], color: "#000000", strokeWidth: 3 }]);
  };
  const handleMouseMove = (e2) => {
    if (!isDrawing) {
      return;
    }
    const stage = e2.target.getStage();
    const point = stage?.getPointerPosition();
    if (!point)
      return;
    const lastLine = { ...lines[lines.length - 1] };
    lastLine.points = lastLine.points.concat([point.x, point.y]);
    const newLines = lines.slice();
    newLines.splice(lines.length - 1, 1, lastLine);
    setLines(newLines);
  };
  const handleMouseUp = () => {
    setIsDrawing(false);
  };
  const handleSave = () => {
    if (stageRef.current) {
      const dataURL = stageRef.current.toDataURL();
      const optimizedLines = lines.map((line) => {
        let points = line.points;
        if (simplification && simplification > 0) {
          points = simplifyPoints(line.points, simplification);
        }
        const rounded = points.map((val) => Math.round(val * 100) / 100);
        return {
          ...line,
          points: rounded
        };
      });
      console.log("Signature Lines Object (Optimized):", optimizedLines);
      onSave?.(dataURL);
    }
  };
  const handleClear = () => {
    setLines([]);
    setBackgroundUrl(null);
  };
  const handleDownload = () => {
    if (stageRef.current) {
      const dataURL = stageRef.current.toDataURL();
      const link = document.createElement("a");
      link.download = "signature.png";
      link.href = dataURL;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  };
  return /* @__PURE__ */ jsx_dev_runtime73.jsxDEV("div", {
    className: "flex flex-col items-center gap-4 p-4 border rounded-lg bg-white shadow-sm",
    children: [
      /* @__PURE__ */ jsx_dev_runtime73.jsxDEV("div", {
        className: "border-2 border-gray-400 bg-white rounded overflow-hidden",
        style: {
          cursor: PEN_CURSOR_URL
        },
        children: /* @__PURE__ */ jsx_dev_runtime73.jsxDEV(Stage2, {
          width,
          height,
          onMouseDown: handleMouseDown,
          onTouchStart: handleMouseDown,
          onMouseMove: handleMouseMove,
          onTouchMove: handleMouseMove,
          onMouseUp: handleMouseUp,
          onTouchEnd: handleMouseUp,
          ref: stageRef,
          children: /* @__PURE__ */ jsx_dev_runtime73.jsxDEV(Layer2, {
            children: [
              backgroundImage && /* @__PURE__ */ jsx_dev_runtime73.jsxDEV(Image3, {
                image: backgroundImage,
                x: 0,
                y: 0,
                width,
                height,
                listening: false
              }, undefined, false, undefined, this),
              lines.map((line, i3) => {
                let points = line.points;
                const isLastLine = i3 === lines.length - 1;
                const shouldSimplify = simplification && simplification > 0 && points.length > 4 && (!isLastLine || !isDrawing);
                if (shouldSimplify) {
                  points = simplifyPoints(points, simplification);
                }
                return /* @__PURE__ */ jsx_dev_runtime73.jsxDEV(Line2, {
                  points,
                  stroke: line.color,
                  strokeWidth: line.strokeWidth,
                  tension: 0.5,
                  lineCap: "round",
                  lineJoin: "round",
                  globalCompositeOperation: "source-over"
                }, i3, false, undefined, this);
              })
            ]
          }, undefined, true, undefined, this)
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime73.jsxDEV("div", {
        className: "flex w-full justify-between items-center px-2",
        children: [
          /* @__PURE__ */ jsx_dev_runtime73.jsxDEV("div", {
            className: "flex gap-2",
            children: /* @__PURE__ */ jsx_dev_runtime73.jsxDEV("button", {
              onClick: handleClear,
              className: "px-4 py-2 text-sm font-medium text-red-600 bg-red-50 hover:bg-red-100 rounded-md transition-colors",
              children: t2("clear", "Clear")
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime73.jsxDEV("div", {
            className: "flex gap-2",
            children: [
              /* @__PURE__ */ jsx_dev_runtime73.jsxDEV("button", {
                onClick: onCancel,
                className: "px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-md transition-colors",
                children: t2("cancel", "Cancel")
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime73.jsxDEV("button", {
                onClick: handleDownload,
                className: "px-4 py-2 text-sm font-medium text-blue-700 bg-blue-50 hover:bg-blue-100 rounded-md transition-colors",
                children: t2("download", "Download")
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime73.jsxDEV("button", {
                onClick: handleSave,
                className: "px-4 py-2 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 rounded-md transition-colors",
                children: t2("save", "Save")
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
// ../../src/features/mindmap-editor/MindmapEditor.tsx
var import_react55 = __toESM(require_react(), 1);

// ../../src/features/mindmap-editor/hooks/useMindmapGraph.ts
var import_react46 = __toESM(require_react(), 1);

// ../../src/features/mindmap-editor/utils/treeUtils.ts
var buildMindmapGraph = (nodes) => {
  const nodeMap = new Map;
  const linesMap = new Map;
  const childrenMap = new Map;
  const parentIdMap = new Map;
  const potentialRoots = new Set;
  nodes.forEach((node) => {
    if (node.t === "line") {
      const line = node;
      if (line.startConn?.nodeId && line.endConn?.nodeId) {
        const childId = line.endConn.nodeId;
        const parentId = line.startConn.nodeId;
        linesMap.set(childId, line);
        parentIdMap.set(childId, parentId);
        if (!childrenMap.has(parentId)) {
          childrenMap.set(parentId, []);
        }
        childrenMap.get(parentId).push(childId);
      }
    } else {
      nodeMap.set(node.id, node);
      potentialRoots.add(node.id);
    }
  });
  let rootId = null;
  for (const nodeId of potentialRoots) {
    if (!parentIdMap.has(nodeId)) {
      rootId = nodeId;
      const node = nodeMap.get(nodeId);
      if (node?.tags?.includes("root")) {
        break;
      }
    }
  }
  if (!rootId && potentialRoots.size > 0) {
    rootId = Array.from(potentialRoots)[0];
  }
  const depthMap = new Map;
  if (rootId) {
    calculateDepth(rootId, 0, childrenMap, depthMap);
  }
  const linesById = new Map;
  linesMap.forEach((line) => {
    linesById.set(line.id, line);
  });
  return {
    rootId,
    parentIdMap,
    childrenMap,
    nodeMap,
    linesMap,
    linesById,
    depthMap,
    isAncestor: (ancestorId, descendantId) => isAncestor(ancestorId, descendantId, parentIdMap)
  };
};
var calculateDepth = (nodeId, depth, childrenMap, depthMap) => {
  depthMap.set(nodeId, depth);
  const children = childrenMap.get(nodeId) || [];
  children.forEach((childId) => {
    calculateDepth(childId, depth + 1, childrenMap, depthMap);
  });
};
var getSubtreeIds = (rootId, childrenMap) => {
  const result = [rootId];
  const children = childrenMap.get(rootId) || [];
  children.forEach((child) => {
    result.push(...getSubtreeIds(child, childrenMap));
  });
  return result;
};
var isAncestor = (ancestorId, descendantId, parentIdMap) => {
  let currentId = parentIdMap.get(descendantId);
  while (currentId) {
    if (currentId === ancestorId)
      return true;
    currentId = parentIdMap.get(currentId);
  }
  return false;
};

// ../../src/features/mindmap-editor/hooks/useMindmapGraph.ts
var useMindmapGraph = (doc) => {
  const nodes = doc.nodes;
  const graph = import_react46.useMemo(() => {
    return buildMindmapGraph(nodes);
  }, [nodes]);
  return graph;
};

// ../../src/features/mindmap-editor/hooks/useMindmapLayout.ts
var import_react47 = __toESM(require_react(), 1);

// ../../src/features/mindmap-editor/utils/layoutEngine.ts
var calculateMindmapLayout = (graph, collapsedNodes, config = {
  horizontalSpacing: 80,
  verticalSpacing: 20,
  rootX: 0,
  rootY: 0
}) => {
  const updates = new Map;
  const lineUpdates = new Map;
  const { rootId, childrenMap, nodeMap, linesMap } = graph;
  if (!rootId)
    return { updates, lineUpdates };
  const rootNode = nodeMap.get(rootId);
  if (!rootNode)
    return { updates, lineUpdates };
  const startX = rootNode.x ?? config.rootX;
  const rootChildren = childrenMap.get(rootId) || [];
  const rightChildren = [];
  const leftChildren = [];
  rootChildren.forEach((childId, index2) => {
    const node = nodeMap.get(childId);
    let side = "right";
    if (node?.data?.layoutDir) {
      side = node.data.layoutDir;
    } else if (node && typeof node.x === "number") {
      if (node.x < startX)
        side = "left";
      else
        side = "right";
    } else {
      side = index2 % 2 === 0 ? "right" : "left";
    }
    if (side === "right")
      rightChildren.push(childId);
    else
      leftChildren.push(childId);
  });
  const subtreeHeights = new Map;
  const calculateHeight = (nodeId) => {
    const isCollapsed = collapsedNodes.has(nodeId);
    const node = nodeMap.get(nodeId);
    const h3 = node?.h || 40;
    if (isCollapsed) {
      subtreeHeights.set(nodeId, h3);
      return h3;
    }
    const children = childrenMap.get(nodeId) || [];
    if (children.length === 0) {
      subtreeHeights.set(nodeId, h3);
      return h3;
    }
    let childrenTotalHeight = 0;
    children.forEach((childId) => {
      childrenTotalHeight += calculateHeight(childId);
    });
    childrenTotalHeight += (children.length - 1) * config.verticalSpacing;
    const totalH = Math.max(h3, childrenTotalHeight);
    subtreeHeights.set(nodeId, totalH);
    return totalH;
  };
  rootChildren.forEach((childId) => {
    calculateHeight(childId);
  });
  const layoutBranch = (nodeId, x3, y2, direction) => {
    updates.set(nodeId, { x: x3, y: y2 });
    const node = nodeMap.get(nodeId);
    const w2 = node?.w || 120;
    const h3 = node?.h || 40;
    const myLine = linesMap.get(nodeId);
    if (myLine) {
      const parentId = graph.parentIdMap.get(nodeId);
      if (parentId) {
        const parentPos = updates.get(parentId);
        const parentNode = nodeMap.get(parentId);
        if (parentPos && parentNode) {
          const pW = parentNode.w || 120;
          const pH = parentNode.h || 40;
          let startX2 = 0, startY2 = 0, endX = 0, endY = 0;
          let startAnchor = "r";
          let endAnchor = "l";
          if (direction === "right") {
            startAnchor = "r";
            endAnchor = "l";
            startX2 = parentPos.x + pW;
            startY2 = parentPos.y + pH / 2;
            endX = x3;
            endY = y2 + h3 / 2;
          } else {
            startAnchor = "l";
            endAnchor = "r";
            startX2 = parentPos.x;
            startY2 = parentPos.y + pH / 2;
            endX = x3 + w2;
            endY = y2 + h3 / 2;
          }
          const midX = (startX2 + endX) / 2;
          const pts = [
            startX2,
            startY2,
            midX,
            startY2,
            midX,
            endY,
            endX,
            endY
          ];
          lineUpdates.set(myLine.id, { startAnchor, endAnchor, pts });
        }
      }
    }
    const isCollapsed = collapsedNodes.has(nodeId);
    if (isCollapsed)
      return;
    const children = childrenMap.get(nodeId) || [];
    if (children.length === 0)
      return;
    let childrenBlockHeight = 0;
    for (const c3 of children) {
      childrenBlockHeight += subtreeHeights.get(c3) || 0;
    }
    childrenBlockHeight += (children.length - 1) * config.verticalSpacing;
    const parentCenterY = y2 + h3 / 2;
    let currentChildY = parentCenterY - childrenBlockHeight / 2;
    children.forEach((childId) => {
      const childH = subtreeHeights.get(childId) || 0;
      const childNode = nodeMap.get(childId);
      const childW = childNode?.w || 120;
      const childH_Node = childNode?.h || 40;
      const childTop = currentChildY + childH / 2 - childH_Node / 2;
      let childX = 0;
      if (direction === "right") {
        childX = x3 + w2 + config.horizontalSpacing;
      } else {
        childX = x3 - config.horizontalSpacing - childW;
      }
      layoutBranch(childId, childX, childTop, direction);
      currentChildY += childH + config.verticalSpacing;
    });
  };
  const startY = rootNode.y ?? config.rootY;
  updates.set(rootId, { x: startX, y: startY });
  const rootW = rootNode.w || 120;
  const rootH = rootNode.h || 40;
  const rootCenterY = startY + rootH / 2;
  let rightBlockHeight = 0;
  for (const c3 of rightChildren) {
    rightBlockHeight += subtreeHeights.get(c3) || 0;
  }
  rightBlockHeight += Math.max(0, rightChildren.length - 1) * config.verticalSpacing;
  let currentRightY = rootCenterY - rightBlockHeight / 2;
  rightChildren.forEach((childId) => {
    const h3 = subtreeHeights.get(childId) || 0;
    const node = nodeMap.get(childId);
    const nodeH = node?.h || 40;
    const nodeTop = currentRightY + h3 / 2 - nodeH / 2;
    const nodeX = startX + rootW + config.horizontalSpacing;
    layoutBranch(childId, nodeX, nodeTop, "right");
    currentRightY += h3 + config.verticalSpacing;
  });
  let leftBlockHeight = 0;
  for (const c3 of leftChildren) {
    leftBlockHeight += subtreeHeights.get(c3) || 0;
  }
  leftBlockHeight += Math.max(0, leftChildren.length - 1) * config.verticalSpacing;
  let currentLeftY = rootCenterY - leftBlockHeight / 2;
  leftChildren.forEach((childId) => {
    const h3 = subtreeHeights.get(childId) || 0;
    const node = nodeMap.get(childId);
    const nodeH = node?.h || 40;
    const nodeW = node?.w || 120;
    const nodeTop = currentLeftY + h3 / 2 - nodeH / 2;
    const nodeX = startX - config.horizontalSpacing - nodeW;
    layoutBranch(childId, nodeX, nodeTop, "left");
    currentLeftY += h3 + config.verticalSpacing;
  });
  return { updates, lineUpdates };
};

// ../../src/features/mindmap-editor/hooks/useMindmapLayout.ts
var useMindmapLayout = ({
  graph,
  collapsedNodes,
  onChange,
  isLayoutActive,
  rootX,
  rootY
}) => {
  import_react47.useEffect(() => {
    if (!isLayoutActive || !graph.rootId)
      return;
    const result = calculateMindmapLayout(graph, collapsedNodes, {
      horizontalSpacing: 30,
      verticalSpacing: 10,
      rootX: rootX ?? 0,
      rootY: rootY ?? 0
    });
    const updatesToApply = [];
    result.updates.forEach((pos, id) => {
      const node = graph.nodeMap.get(id);
      if (!node)
        return;
      const dx = Math.abs((node.x || 0) - pos.x);
      const dy = Math.abs((node.y || 0) - pos.y);
      if (dx > 1 || dy > 1) {
        updatesToApply.push({ id, x: pos.x, y: pos.y });
      }
    });
    result.lineUpdates.forEach((anchors, lineId) => {
      const currentLine = graph.linesById.get(lineId);
      if (!currentLine)
        return;
      const currentStart = currentLine.startConn?.anchor;
      const currentEnd = currentLine.endConn?.anchor;
      if (currentStart !== anchors.startAnchor || currentEnd !== anchors.endAnchor) {
        updatesToApply.push({
          id: lineId,
          startConn: { ...currentLine.startConn, anchor: anchors.startAnchor },
          endConn: { ...currentLine.endConn, anchor: anchors.endAnchor }
        });
      }
    });
    if (updatesToApply.length > 0) {
      onChange(updatesToApply);
    }
  }, [graph, collapsedNodes, isLayoutActive, rootX, rootY]);
};

// ../../src/features/mindmap-editor/hooks/useMindmapOperations.ts
var import_react48 = __toESM(require_react(), 1);
var useMindmapOperations = ({
  setDoc,
  graph,
  selectedNodeId,
  onSelect
}) => {
  const addChildNode = import_react48.useCallback(() => {
    if (!selectedNodeId)
      return;
    setDoc((prev) => {
      const parent = prev.nodes.find((n2) => n2.id === selectedNodeId);
      if (!parent)
        return prev;
      let layoutDir;
      if (selectedNodeId === graph.rootId) {
        const children = graph.childrenMap.get(selectedNodeId) || [];
        let leftCount = 0;
        let rightCount = 0;
        children.forEach((childId) => {
          const child = prev.nodes.find((n2) => n2.id === childId);
          if (child) {
            const dir = child.data?.layoutDir || ((child.x || 0) < (parent.x || 0) ? "left" : "right");
            if (dir === "left")
              leftCount++;
            else
              rightCount++;
          }
        });
        layoutDir = rightCount <= leftCount ? "right" : "left";
      }
      const newId = generateNodeId(prev, "text");
      const linkId = generateNodeId({ ...prev, nodes: [...prev.nodes, { id: newId }] }, "line");
      const newNode = {
        id: newId,
        t: "text",
        s: parent.s,
        x: (parent.x || 0) + 40,
        y: parent.y || 0,
        w: 30,
        h: 10,
        text: "New Topic",
        align: "c",
        backgroundColor: "#ffffff",
        borderColor: "#64748b",
        borderWidth: 0.5,
        padding: 2,
        fontSize: 4.23,
        locked: true,
        data: layoutDir ? { layoutDir } : undefined
      };
      const newLink = {
        id: linkId,
        t: "line",
        s: parent.s,
        pts: [0, 0, 0, 0],
        stroke: "#94a3b8",
        strokeW: 1,
        routing: "orthogonal",
        startConn: { nodeId: selectedNodeId, anchor: "auto" },
        endConn: { nodeId: newId, anchor: "auto" },
        locked: true
      };
      if (onSelect) {
        requestAnimationFrame(() => onSelect(newId));
      }
      return {
        ...prev,
        nodes: [...prev.nodes, newNode, newLink]
      };
    });
  }, [selectedNodeId, graph, onSelect]);
  const addSiblingNode = import_react48.useCallback(() => {
    if (!selectedNodeId || !graph.rootId || selectedNodeId === graph.rootId)
      return;
    const parentId = graph.parentIdMap.get(selectedNodeId);
    if (!parentId)
      return;
    setDoc((prev) => {
      const parent = prev.nodes.find((n2) => n2.id === parentId);
      if (!parent)
        return prev;
      let layoutDir;
      if (parentId === graph.rootId) {
        const sibling = prev.nodes.find((n2) => n2.id === selectedNodeId);
        if (sibling) {
          if (sibling.data?.layoutDir) {
            layoutDir = sibling.data.layoutDir;
          } else {
            layoutDir = (sibling.x || 0) < (parent.x || 0) ? "left" : "right";
          }
        }
      }
      const newId = generateNodeId(prev, "text");
      const linkId = generateNodeId({ ...prev, nodes: [...prev.nodes, { id: newId }] }, "line");
      const newNode = {
        id: newId,
        t: "text",
        s: parent.s,
        x: (parent.x || 0) + 40,
        y: (parent.y || 0) + 20,
        w: 30,
        h: 10,
        text: "New Topic",
        align: "c",
        backgroundColor: "#ffffff",
        borderColor: "#334155",
        borderWidth: 0.5,
        padding: 2,
        fontSize: 4.23,
        locked: true,
        data: layoutDir ? { layoutDir } : undefined
      };
      const newLink = {
        id: linkId,
        t: "line",
        s: parent.s,
        pts: [0, 0, 0, 0],
        stroke: "#94a3b8",
        strokeW: 1,
        routing: "orthogonal",
        startConn: { nodeId: parentId, anchor: "auto" },
        endConn: { nodeId: newId, anchor: "auto" },
        locked: true
      };
      const nodes = [...prev.nodes];
      const selectedLineIndex = nodes.findIndex((n2) => n2.t === "line" && n2.endConn?.nodeId === selectedNodeId);
      if (selectedLineIndex !== -1) {
        nodes.splice(selectedLineIndex + 1, 0, newLink);
        nodes.push(newNode);
      } else {
        nodes.push(newNode, newLink);
      }
      if (onSelect) {
        requestAnimationFrame(() => onSelect(newId));
      }
      return {
        ...prev,
        nodes
      };
    });
  }, [selectedNodeId, graph, onSelect]);
  const updateNodes = import_react48.useCallback((updates) => {
    setDoc((prev) => {
      if (updates.length === 0)
        return prev;
      const updateMap = new Map(updates.map((u2) => [u2.id, u2]));
      const newNodes = prev.nodes.map((node) => {
        if (updateMap.has(node.id)) {
          const update = updateMap.get(node.id);
          const { id, ...rest } = update;
          return { ...node, ...rest };
        }
        return node;
      });
      return {
        ...prev,
        nodes: newNodes
      };
    });
  }, [setDoc]);
  const deleteNode = import_react48.useCallback(() => {
    if (!selectedNodeId)
      return;
    if (selectedNodeId === graph.rootId)
      return;
    setDoc((prev) => {
      const node = prev.nodes.find((n2) => n2.id === selectedNodeId);
      if (!node)
        return prev;
      const idsToDelete = new Set(getSubtreeIds(selectedNodeId, graph.childrenMap));
      const remainingNodes = prev.nodes.filter((n2) => {
        if (idsToDelete.has(n2.id))
          return false;
        if (n2.t === "line") {
          const line = n2;
          if (line.startConn?.nodeId && idsToDelete.has(line.startConn.nodeId) || line.endConn?.nodeId && idsToDelete.has(line.endConn.nodeId)) {
            return false;
          }
        }
        return true;
      });
      return {
        ...prev,
        nodes: remainingNodes
      };
    });
  }, [selectedNodeId, graph]);
  const removeChildNode = import_react48.useCallback((parentId, childId) => {
    setDoc((prev) => {
      const newNodes = prev.nodes.filter((n2) => {
        if (n2.t === "line") {
          const line = n2;
          if (line.endConn?.nodeId === childId && line.startConn?.nodeId === parentId) {
            return false;
          }
        }
        return true;
      });
      if (newNodes.length === prev.nodes.length)
        return prev;
      return {
        ...prev,
        nodes: newNodes
      };
    });
  }, []);
  const addChildNodeTo = import_react48.useCallback((parentId, childId) => {
    setDoc((prev) => {
      const parent = prev.nodes.find((n2) => n2.id === parentId);
      if (!parent)
        return prev;
      const child = prev.nodes.find((n2) => n2.id === childId);
      if (!child)
        return prev;
      const linkId = generateNodeId(prev, "line");
      const newLink = {
        id: linkId,
        t: "line",
        s: parent.s,
        pts: [0, 0, 0, 0],
        stroke: "#94a3b8",
        strokeW: 1,
        routing: "orthogonal",
        startConn: { nodeId: parentId, anchor: "auto" },
        endConn: { nodeId: childId, anchor: "auto" },
        locked: true
      };
      return {
        ...prev,
        nodes: [...prev.nodes, newLink]
      };
    });
  }, []);
  const insertChildNodeAt = import_react48.useCallback((_parentId, childId, _insertIndex) => {
    setDoc((prev) => {
      const parent = prev.nodes.find((n2) => n2.id === _parentId);
      if (!parent)
        return prev;
      const child = prev.nodes.find((n2) => n2.id === childId);
      if (!child)
        return prev;
      const linkId = generateNodeId(prev, "line");
      const newLink = {
        id: linkId,
        t: "line",
        s: parent.s,
        pts: [0, 0, 0, 0],
        stroke: "#94a3b8",
        strokeW: 1,
        routing: "orthogonal",
        startConn: { nodeId: _parentId, anchor: "auto" },
        endConn: { nodeId: childId, anchor: "auto" },
        locked: true
      };
      return {
        ...prev,
        nodes: [...prev.nodes, newLink]
      };
    });
  }, []);
  const moveNode = import_react48.useCallback((sourceId, targetId, position) => {
    setDoc((prev) => {
      const sourceNode = prev.nodes.find((n2) => n2.id === sourceId);
      if (!sourceNode)
        return prev;
      const newNodes = prev.nodes.filter((n2) => {
        if (n2.t === "line") {
          const line = n2;
          if (line.endConn?.nodeId === sourceId)
            return false;
        }
        return true;
      });
      const linkId = generateNodeId({ ...prev, nodes: newNodes }, "line");
      let parentId = targetId;
      if (position !== "child") {
        const targetLine = prev.nodes.find((n2) => n2.t === "line" && n2.endConn?.nodeId === targetId);
        if (targetLine?.startConn?.nodeId) {
          parentId = targetLine.startConn.nodeId;
        } else {
          return prev;
        }
      }
      const parent = prev.nodes.find((n2) => n2.id === parentId) || prev.nodes.find((n2) => n2.id === targetId);
      if (!parent)
        return { ...prev, nodes: newNodes };
      const newLink = {
        id: linkId,
        t: "line",
        s: sourceNode.s,
        pts: [0, 0, 0, 0],
        stroke: "#94a3b8",
        strokeW: 1,
        routing: "orthogonal",
        startConn: { nodeId: parentId, anchor: "auto" },
        endConn: { nodeId: sourceId, anchor: "auto" },
        locked: true
      };
      let insertIndex = newNodes.length;
      if (position !== "child") {
        const targetLineIndex = newNodes.findIndex((n2) => n2.t === "line" && n2.endConn?.nodeId === targetId);
        if (targetLineIndex !== -1) {
          insertIndex = position === "before" ? targetLineIndex : targetLineIndex + 1;
        }
      }
      newNodes.splice(insertIndex, 0, newLink);
      return { ...prev, nodes: newNodes };
    });
  }, []);
  return {
    addChildNode,
    addSiblingNode,
    deleteNode,
    updateNodes,
    removeChildNode,
    addChildNodeTo,
    insertChildNodeAt,
    moveNode
  };
};

// ../../src/features/mindmap-editor/hooks/useMindmapHistory.ts
var import_react49 = __toESM(require_react(), 1);
function useMindmapHistory(initialDoc) {
  const [history, setHistory] = import_react49.useState({
    past: [],
    present: initialDoc,
    future: []
  });
  const setDoc = import_react49.useCallback((docOrUpdater, options2 = {}) => {
    const { saveToHistory = true, force = false } = options2;
    setHistory((prev) => {
      const newPresent = typeof docOrUpdater === "function" ? docOrUpdater(prev.present) : docOrUpdater;
      if (!force && JSON.stringify(newPresent) === JSON.stringify(prev.present)) {
        return prev;
      }
      if (!saveToHistory) {
        return {
          ...prev,
          present: newPresent,
          future: []
        };
      }
      return {
        past: [...prev.past, prev.present],
        present: newPresent,
        future: []
      };
    });
  }, []);
  const undo = import_react49.useCallback(() => {
    setHistory((prev) => {
      if (prev.past.length === 0)
        return prev;
      const newPast = prev.past.slice(0, prev.past.length - 1);
      const newPresent = prev.past[prev.past.length - 1];
      return {
        past: newPast,
        present: newPresent,
        future: [prev.present, ...prev.future]
      };
    });
  }, []);
  const redo = import_react49.useCallback(() => {
    setHistory((prev) => {
      if (prev.future.length === 0)
        return prev;
      const newFuture = prev.future.slice(1);
      const newPresent = prev.future[0];
      return {
        past: [...prev.past, prev.present],
        present: newPresent,
        future: newFuture
      };
    });
  }, []);
  const reset = import_react49.useCallback((doc) => {
    const validation = validateDoc(doc);
    if (!validation.success) {
      console.warn("[useMindmapHistory] Doc validation failed:", validation.errors);
    }
    setHistory({
      past: [],
      present: doc,
      future: []
    });
  }, []);
  return {
    doc: history.present,
    setDoc,
    canUndo: history.past.length > 0,
    canRedo: history.future.length > 0,
    undo,
    redo,
    reset
  };
}

// ../../src/features/mindmap-editor/hooks/useMindmapInteraction.ts
var import_react50 = __toESM(require_react(), 1);
var useMindmapInteraction = ({
  selectedNodeId,
  setSelectedNodeId,
  graph,
  ops,
  isEditing
}) => {
  import_react50.useEffect(() => {
    const handleKeyDown = (e2) => {
      if (isEditing)
        return;
      if (e2.target.tagName === "INPUT" || e2.target.tagName === "TEXTAREA" || e2.target.isContentEditable) {
        return;
      }
      if (!selectedNodeId)
        return;
      switch (e2.key) {
        case "Tab":
        case "Insert":
          e2.preventDefault();
          ops.addChildNode();
          break;
        case "Enter":
          e2.preventDefault();
          ops.addSiblingNode();
          break;
        case "Backspace":
        case "Delete":
          ops.deleteNode();
          break;
        case "ArrowRight":
          e2.preventDefault();
          navigate("right");
          break;
        case "ArrowLeft":
          e2.preventDefault();
          navigate("left");
          break;
        case "ArrowUp":
          e2.preventDefault();
          navigate("up");
          break;
        case "ArrowDown":
          e2.preventDefault();
          navigate("down");
          break;
      }
    };
    const navigate = (direction) => {
      if (!selectedNodeId)
        return;
      const children = graph.childrenMap.get(selectedNodeId) || [];
      const parentId = graph.parentIdMap.get(selectedNodeId);
      if (direction === "right") {
        if (children.length > 0) {
          setSelectedNodeId(children[0]);
        }
      } else if (direction === "left") {
        if (parentId) {
          setSelectedNodeId(parentId);
        }
      } else if (direction === "down" || direction === "up") {
        if (parentId) {
          const siblings = graph.childrenMap.get(parentId) || [];
          const idx = siblings.indexOf(selectedNodeId);
          if (idx === -1)
            return;
          if (direction === "down") {
            if (idx < siblings.length - 1)
              setSelectedNodeId(siblings[idx + 1]);
          } else {
            if (idx > 0)
              setSelectedNodeId(siblings[idx - 1]);
          }
        }
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [selectedNodeId, graph, ops, isEditing]);
};

// ../../src/features/mindmap-editor/hooks/useMindmapVisibility.ts
var import_react51 = __toESM(require_react(), 1);
var useMindmapVisibility = (doc, graph, collapsedNodes) => {
  const visibleNodes = import_react51.useMemo(() => {
    const visibleNodeIds = new Set;
    doc.nodes.forEach((node) => {
      if (node.t === "line")
        return;
      let isVisible = true;
      let curr = graph.parentIdMap.get(node.id);
      while (curr) {
        if (collapsedNodes.has(curr)) {
          isVisible = false;
          break;
        }
        curr = graph.parentIdMap.get(curr);
      }
      if (isVisible) {
        visibleNodeIds.add(node.id);
      }
    });
    const filtered = doc.nodes.filter((node) => {
      if (node.t === "line") {
        const lineNode = node;
        const childId = lineNode.endConn?.nodeId;
        const parentId = lineNode.startConn?.nodeId;
        return childId && visibleNodeIds.has(childId) && parentId && visibleNodeIds.has(parentId);
      }
      return visibleNodeIds.has(node.id);
    });
    return filtered.map((node) => {
      if (graph.childrenMap.has(node.id)) {
        return {
          ...node,
          data: {
            ...node.data,
            hasChildren: true,
            isCollapsed: collapsedNodes.has(node.id)
          }
        };
      }
      return node;
    });
  }, [doc.nodes, graph, collapsedNodes]);
  return visibleNodes;
};

// ../../src/features/mindmap-editor/hooks/useMindmapDrag.ts
var import_react52 = __toESM(require_react(), 1);
var initialDragState = {
  isDragging: false,
  draggedNodeId: null,
  dragStartPosition: null,
  dragPosition: null,
  dropTargetId: null,
  dropPosition: null,
  canDrop: false
};
var useMindmapDrag = ({ graph, onNodeDrop }) => {
  const [dragState, setDragState] = import_react52.useState(initialDragState);
  const handleDragStart = import_react52.useCallback((nodeId, startPosition) => {
    if (nodeId === graph.rootId)
      return;
    setDragState({
      isDragging: false,
      draggedNodeId: nodeId,
      dragStartPosition: startPosition,
      dragPosition: startPosition,
      dropTargetId: null,
      dropPosition: null,
      canDrop: false
    });
  }, [graph.rootId]);
  const handleDragMove = import_react52.useCallback((position) => {
    if (!dragState.draggedNodeId || !dragState.dragStartPosition)
      return;
    const currentPos = position;
    const distance = Math.hypot(currentPos.x - dragState.dragStartPosition.x, currentPos.y - dragState.dragStartPosition.y);
    if (distance > 5 && !dragState.isDragging) {
      setDragState((prev) => ({ ...prev, isDragging: true }));
    }
    if (dragState.isDragging) {
      setDragState((prev) => ({ ...prev, dragPosition: currentPos }));
    }
  }, [dragState.draggedNodeId, dragState.dragStartPosition, dragState.isDragging]);
  const handleDragEnter = import_react52.useCallback((targetNodeId, relativeY) => {
    if (!dragState.isDragging)
      return;
    const isAncestor2 = graph.isAncestor(dragState.draggedNodeId, targetNodeId);
    const isSelf = targetNodeId === dragState.draggedNodeId;
    const canDrop = !isAncestor2 && !isSelf;
    let dropPosition = "child";
    if (relativeY < 0.2) {
      dropPosition = "before";
    } else if (relativeY > 0.8) {
      dropPosition = "after";
    }
    setDragState((prev) => ({
      ...prev,
      dropTargetId: targetNodeId,
      dropPosition,
      canDrop
    }));
  }, [dragState.isDragging, dragState.draggedNodeId, graph]);
  const handleDragLeave = import_react52.useCallback(() => {
    if (!dragState.isDragging)
      return;
    setDragState((prev) => ({
      ...prev,
      dropTargetId: null,
      dropPosition: null,
      canDrop: false
    }));
  }, [dragState.isDragging]);
  const handleDragEnd = import_react52.useCallback(() => {
    if (dragState.canDrop && dragState.dropTargetId && dragState.draggedNodeId && dragState.dropPosition) {
      onNodeDrop(dragState.draggedNodeId, dragState.dropTargetId, dragState.dropPosition);
    }
    setDragState(initialDragState);
  }, [dragState, onNodeDrop]);
  return {
    dragState,
    handleDragStart,
    handleDragMove,
    handleDragEnter,
    handleDragLeave,
    handleDragEnd
  };
};

// ../../src/features/mindmap-editor/components/MermaidExportModal.tsx
var import_react53 = __toESM(require_react(), 1);

// ../../src/features/mindmap-editor/utils/mermaidUtils.ts
var exportToMermaid = (_doc, graph) => {
  const lines = ["mindmap"];
  if (!graph.rootId)
    return "";
  const rootNode = graph.nodeMap.get(graph.rootId);
  if (!rootNode || rootNode.t !== "text")
    return "";
  const rootText = rootNode.text;
  const sanitizedRootText = /[\(\)\[\]\{\}\n]/.test(rootText) ? `"${rootText.replace(/"/g, "'")}"` : rootText;
  lines.push(`  root((${sanitizedRootText}))`);
  const buildTree = (nodeId, depth) => {
    const children = graph.childrenMap.get(nodeId) || [];
    children.forEach((childId) => {
      const child = graph.nodeMap.get(childId);
      if (child && child.t === "text") {
        const indent = "  ".repeat(depth + 1);
        const text2 = child.text;
        const sanitizedText = /[\(\)\[\]\{\}\n]/.test(text2) ? `"${text2.replace(/"/g, "'")}"` : text2;
        lines.push(`${indent}${sanitizedText}`);
        buildTree(childId, depth + 1);
      }
    });
  };
  buildTree(graph.rootId, 1);
  return lines.join(`
`);
};
var importFromMermaid = (syntax, surfaceId = "s1") => {
  const lines = syntax.split(`
`).filter((line) => line.trim() !== "");
  if (lines.length === 0) {
    throw new Error("No content to import");
  }
  if (lines[0].trim() !== "mindmap") {
    throw new Error('Invalid Mermaid syntax: must start with "mindmap"');
  }
  const rootMatch = lines[1]?.match(/root\(\((.*?)\)\)/);
  if (!rootMatch) {
    throw new Error("Invalid Mermaid syntax: root node not found");
  }
  const rootText = rootMatch[1];
  const tree = parseTree(lines.slice(2));
  return buildDoc(rootText, tree, surfaceId);
};
var parseTree = (lines) => {
  const nodes = [];
  const stack = [];
  lines.forEach((line) => {
    const depth = (line.match(/^ */)?.[0].length || 0) / 2;
    const text2 = line.trim();
    const node = { text: text2, depth, children: [] };
    while (stack.length > 0 && stack[stack.length - 1].depth >= depth) {
      stack.pop();
    }
    if (stack.length > 0) {
      stack[stack.length - 1].node.children.push(node);
    } else {
      nodes.push(node);
    }
    stack.push({ depth, node });
  });
  return nodes;
};
var buildDoc = (rootText, tree, surfaceId) => {
  const nodes = [];
  const tempDoc = {
    v: 1,
    id: "temp",
    title: "temp",
    unit: "mm",
    surfaces: [{ id: surfaceId, type: "canvas", w: 4000, h: 4000, bg: "#f8fafc" }],
    nodes: []
  };
  const rootId = generateNodeId(tempDoc, "text");
  tempDoc.nodes.push({ id: rootId, t: "text" });
  const rootNode = {
    id: rootId,
    t: "text",
    s: surfaceId,
    x: 300,
    y: 200,
    w: 50,
    h: 12,
    text: rootText,
    align: "c",
    vAlign: "m",
    backgroundColor: "#dbeafe",
    borderColor: "#3b82f6",
    borderWidth: 1,
    padding: 3,
    fontSize: 5.64,
    fontWeight: 700,
    fill: "#1e3a8a",
    cornerRadius: 1,
    hasFrame: true,
    locked: true,
    tags: ["root"]
  };
  nodes.push(rootNode);
  const buildNodes = (parentId, children, isRight) => {
    children.forEach((child) => {
      const childId = generateNodeId(tempDoc, "text");
      tempDoc.nodes.push({ id: childId, t: "text" });
      const linkId = generateNodeId(tempDoc, "line");
      tempDoc.nodes.push({ id: linkId, t: "line" });
      const layoutDir = isRight ? "right" : "left";
      const childNode = {
        id: childId,
        t: "text",
        s: surfaceId,
        x: 300,
        y: 200,
        w: 40,
        h: 10,
        text: child.text,
        align: "c",
        vAlign: "m",
        backgroundColor: "#ffffff",
        borderColor: "#64748b",
        borderWidth: 0.5,
        padding: 2,
        fontSize: 4.23,
        fontWeight: 400,
        fill: "#000000",
        cornerRadius: 1,
        hasFrame: true,
        locked: true,
        data: { layoutDir }
      };
      const link = {
        id: linkId,
        t: "line",
        s: surfaceId,
        pts: [0, 0, 0, 0],
        stroke: "#94a3b8",
        strokeW: 1,
        routing: "orthogonal",
        startConn: { nodeId: parentId, anchor: "auto" },
        endConn: { nodeId: childId, anchor: "auto" },
        locked: true
      };
      nodes.push(childNode, link);
      if (child.children.length > 0) {
        buildNodes(childId, child.children, isRight);
      }
    });
  };
  tree.forEach((child, index2) => {
    const isRight = index2 % 2 === 0;
    buildNodes(rootId, [child], isRight);
  });
  const docId = `mindmap-${generateSurfaceId(tempDoc, "canvas").replace("canvas-", "")}`;
  return {
    v: 1,
    id: docId,
    title: "Imported Mindmap",
    unit: "mm",
    surfaces: [{ id: surfaceId, type: "canvas", w: 4000, h: 4000, bg: "#f8fafc" }],
    nodes
  };
};

// ../../src/features/mindmap-editor/components/MermaidExportModal.tsx
var jsx_dev_runtime74 = __toESM(require_jsx_dev_runtime(), 1);
var MermaidExportModal = ({
  isOpen,
  onClose,
  doc,
  graph
}) => {
  const [copied, setCopied] = import_react53.useState(false);
  const mermaidSyntax = import_react53.useMemo(() => {
    if (!isOpen)
      return "";
    return exportToMermaid(doc, graph);
  }, [isOpen, doc, graph]);
  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(mermaidSyntax);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error("Failed to copy to clipboard:", err);
    }
  };
  import_react53.useEffect(() => {
    if (isOpen) {
      setCopied(false);
    }
  }, [isOpen]);
  return /* @__PURE__ */ jsx_dev_runtime74.jsxDEV(Modal, {
    open: isOpen,
    onOpenChange: onClose,
    title: "Export to Mermaid",
    description: "Copy the Mermaid mindmap syntax below.",
    className: "max-w-md",
    children: [
      /* @__PURE__ */ jsx_dev_runtime74.jsxDEV("div", {
        className: "space-y-4",
        children: /* @__PURE__ */ jsx_dev_runtime74.jsxDEV("textarea", {
          readOnly: true,
          value: mermaidSyntax,
          className: "w-full h-[350px] font-mono text-sm bg-muted p-3 rounded-md border border-border resize-none"
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime74.jsxDEV(ModalFooter, {
        children: [
          /* @__PURE__ */ jsx_dev_runtime74.jsxDEV("button", {
            onClick: handleCopy,
            className: "px-4 py-2 text-sm font-medium text-primary-foreground bg-primary hover:bg-primary/90 rounded-md transition-colors mr-2",
            children: copied ? "Copied!" : "Copy to Clipboard"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime74.jsxDEV("button", {
            onClick: onClose,
            className: "px-4 py-2 text-sm font-medium text-foreground bg-secondary hover:bg-secondary/80 rounded-md transition-colors",
            children: "Close"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/mindmap-editor/components/MermaidImportModal.tsx
var import_react54 = __toESM(require_react(), 1);
var jsx_dev_runtime75 = __toESM(require_jsx_dev_runtime(), 1);
var PLACEHOLDER = `mindmap
  root((Central Topic))
    Topic 1
      Subtopic 1-1
    Topic 2
      Subtopic 2-1`;
var MermaidImportModal = ({
  isOpen,
  onClose,
  onImport
}) => {
  const [syntax, setSyntax] = import_react54.useState("");
  const [error, setError] = import_react54.useState(null);
  const handleImport = () => {
    setError(null);
    try {
      const doc = importFromMermaid(syntax);
      onImport(doc);
      onClose();
      setSyntax("");
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to import Mermaid syntax");
    }
  };
  const handleCancel = () => {
    setError(null);
    setSyntax("");
    onClose();
  };
  return /* @__PURE__ */ jsx_dev_runtime75.jsxDEV(Modal, {
    open: isOpen,
    onOpenChange: onClose,
    title: "Import from Mermaid",
    description: "Paste Mermaid mindmap syntax below to import.",
    className: "max-w-md",
    children: [
      /* @__PURE__ */ jsx_dev_runtime75.jsxDEV("div", {
        className: "space-y-4",
        children: [
          /* @__PURE__ */ jsx_dev_runtime75.jsxDEV("textarea", {
            value: syntax,
            onChange: (e2) => setSyntax(e2.target.value),
            placeholder: PLACEHOLDER,
            className: "w-full h-[350px] font-mono text-sm bg-background p-3 rounded-md border border-border resize-none focus:outline-none focus:ring-2 focus:ring-ring"
          }, undefined, false, undefined, this),
          error && /* @__PURE__ */ jsx_dev_runtime75.jsxDEV("div", {
            className: "bg-destructive/10 border border-destructive text-destructive px-3 py-2 rounded-md text-sm",
            children: error
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime75.jsxDEV(ModalFooter, {
        children: [
          /* @__PURE__ */ jsx_dev_runtime75.jsxDEV("button", {
            onClick: handleCancel,
            className: "px-4 py-2 text-sm font-medium text-foreground bg-secondary hover:bg-secondary/80 rounded-md transition-colors mr-2",
            children: "Cancel"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime75.jsxDEV("button", {
            onClick: handleImport,
            className: "px-4 py-2 text-sm font-medium text-primary-foreground bg-primary hover:bg-primary/90 rounded-md transition-colors",
            children: "Import"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/mindmap-editor/MindmapEditor.tsx
var jsx_dev_runtime76 = __toESM(require_jsx_dev_runtime(), 1);
var INITIAL_DOC = {
  v: 1,
  id: "mindmap-1",
  title: "New Mindmap",
  unit: "mm",
  surfaces: [{ id: "s1", type: "canvas", w: 4000, h: 4000, bg: "#f8fafc" }],
  nodes: [
    {
      id: "root",
      t: "text",
      s: "s1",
      x: 280,
      y: 192.5,
      w: 40,
      h: 15,
      text: "Central Topic",
      align: "c",
      vAlign: "m",
      backgroundColor: "#ffffff",
      borderColor: "#0000FF",
      borderWidth: 0.5,
      cornerRadius: 1,
      hasFrame: true,
      padding: 2,
      fontWeight: 700,
      fill: "#1e3a8a",
      fontSize: 4.23,
      locked: true
    }
  ]
};
var MindmapEditor = ({
  readOnly = false,
  loadDoc,
  loadNonce,
  onDocChange,
  showHeader = true
}) => {
  const canvasRef = import_react55.useRef(null);
  const { doc, setDoc, undo, redo, reset } = useMindmapHistory(INITIAL_DOC);
  const [selectedNodeId, setSelectedNodeId] = import_react55.useState(null);
  const [collapsedNodes, setCollapsedNodes] = import_react55.useState(new Set);
  const [showShortcuts, setShowShortcuts] = import_react55.useState(false);
  const [showMermaidExport, setShowMermaidExport] = import_react55.useState(false);
  const [showMermaidImport, setShowMermaidImport] = import_react55.useState(false);
  const { t: t2 } = useI18n();
  const lastLoadNonceRef = import_react55.useRef(undefined);
  import_react55.useEffect(() => {
    onDocChange?.(doc);
  }, [doc, onDocChange]);
  import_react55.useEffect(() => {
    if (!loadDoc)
      return;
    if (loadNonce === undefined)
      return;
    if (lastLoadNonceRef.current === loadNonce)
      return;
    reset(loadDoc);
    setCollapsedNodes(new Set);
    setSelectedNodeId(null);
    setShowMermaidExport(false);
    setShowMermaidImport(false);
    setShowShortcuts(false);
    lastLoadNonceRef.current = loadNonce;
  }, [loadDoc, loadNonce, reset]);
  const graph = useMindmapGraph(doc);
  const handleSelectHelper = import_react55.useCallback((id) => {
    setSelectedNodeId(id);
  }, []);
  const operations = useMindmapOperations({
    setDoc,
    graph,
    selectedNodeId,
    onSelect: handleSelectHelper
  });
  const handleChangeNodes = import_react55.useCallback((changes) => {
    const changesArray = Array.isArray(changes) ? changes : [changes];
    setDoc((prev) => {
      const nextNodes = prev.nodes.map((n2) => {
        const change = changesArray.find((c3) => c3.id === n2.id);
        if (change) {
          return { ...n2, ...change };
        }
        return n2;
      });
      return { ...prev, nodes: nextNodes };
    });
  }, []);
  const handleToggleCollapse = import_react55.useCallback((nodeId) => {
    setCollapsedNodes((prev) => {
      const next = new Set(prev);
      if (next.has(nodeId)) {
        next.delete(nodeId);
      } else {
        next.add(nodeId);
      }
      return next;
    });
  }, []);
  const handleExpandAll = import_react55.useCallback(() => {
    setCollapsedNodes(new Set);
  }, []);
  const handleCollapseAll = import_react55.useCallback(() => {
    const collapsibleIds = Array.from(graph.childrenMap.keys());
    setCollapsedNodes(new Set(collapsibleIds));
  }, [graph]);
  const handleMermaidImport = import_react55.useCallback((importedDoc) => {
    setDoc(importedDoc);
    setCollapsedNodes(new Set);
    setShowMermaidImport(false);
  }, []);
  const handleDownloadImage = import_react55.useCallback(() => {
    const stage = canvasRef.current?.getStage();
    if (!stage)
      return;
    const gridLayer = stage.findOne(".grid-layer");
    const wasGridVisible = gridLayer?.visible();
    const transformers = stage.find("Transformer").filter((n2) => n2.getClassName?.() === "Transformer");
    const transformerVisibility = transformers.map((tr) => tr.visible());
    try {
      gridLayer?.hide();
      transformers.forEach((tr) => {
        tr.hide();
      });
      const dataURL = stage.toDataURL({ pixelRatio: 2 });
      const link = document.createElement("a");
      link.download = `mindmap-${Date.now()}.png`;
      link.href = dataURL;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    } finally {
      if (gridLayer && wasGridVisible) {
        gridLayer.show();
      }
      transformers.forEach((tr, idx) => {
        const prev = transformerVisibility[idx];
        if (prev)
          tr.show();
      });
    }
  }, []);
  const handleDownloadPdf = import_react55.useCallback(() => {
    window.print();
  }, []);
  const handleNodeReplace = import_react55.useCallback((sourceId, targetId, position) => {
    const oldParentId = graph.parentIdMap.get(sourceId);
    if (oldParentId) {
      operations.removeChildNode(oldParentId, sourceId);
    }
    if (position === "child") {
      operations.addChildNodeTo(targetId, sourceId);
    } else {
      const targetParentId = graph.parentIdMap.get(targetId);
      if (targetParentId) {
        const siblings = graph.childrenMap.get(targetParentId) ?? [];
        const targetIndex = siblings.indexOf(targetId);
        const insertIndex = position === "before" ? targetIndex : targetIndex + 1;
        operations.insertChildNodeAt(targetParentId, sourceId, insertIndex);
      }
    }
  }, [graph, operations]);
  const visibleNodes = useMindmapVisibility(doc, graph, collapsedNodes);
  const handleNodeReplaceWrapper = import_react55.useCallback((sourceId, targetId, position) => {
    handleNodeReplace(sourceId, targetId, position);
  }, [handleNodeReplace]);
  const {
    dragState,
    handleDragStart,
    handleDragMove,
    handleDragEnter,
    handleDragLeave,
    handleDragEnd
  } = useMindmapDrag({
    graph,
    onNodeDrop: handleNodeReplaceWrapper
  });
  const handleLayoutChange = import_react55.useCallback((updates) => {
    if (updates.length === 0)
      return;
    setDoc((prev) => {
      const updateMap = new Map(updates.map((u2) => [u2.id, u2]));
      const newNodes = prev.nodes.map((node) => {
        if (updateMap.has(node.id)) {
          const update = updateMap.get(node.id);
          const { id, ...rest } = update;
          return { ...node, ...rest };
        }
        return node;
      });
      return { ...prev, nodes: newNodes };
    }, { saveToHistory: false });
  }, [setDoc]);
  useMindmapLayout({
    graph,
    collapsedNodes,
    onChange: handleLayoutChange,
    isLayoutActive: true,
    rootX: 300,
    rootY: 200
  });
  const handleSelect = import_react55.useCallback((ids) => {
    setSelectedNodeId(ids.length > 0 ? ids[0] : null);
  }, []);
  useMindmapInteraction({
    selectedNodeId,
    setSelectedNodeId,
    graph,
    ops: operations,
    isEditing: false
  });
  import_react55.default.useEffect(() => {
    const handleKeyDown = (e2) => {
      const target = e2.target;
      if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
        return;
      }
      if ((e2.metaKey || e2.ctrlKey) && e2.key === "z") {
        if (e2.shiftKey) {
          e2.preventDefault();
          redo();
        } else {
          e2.preventDefault();
          undo();
        }
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [operations, undo, redo]);
  return /* @__PURE__ */ jsx_dev_runtime76.jsxDEV("div", {
    className: "flex flex-col w-full h-full mindmap-root",
    children: [
      showHeader && /* @__PURE__ */ jsx_dev_runtime76.jsxDEV("div", {
        className: "h-12 border-b bg-white flex items-center justify-between px-4 shadow-sm z-10 mindmap-header",
        children: [
          /* @__PURE__ */ jsx_dev_runtime76.jsxDEV("h1", {
            className: "font-bold text-slate-700",
            children: "Mindmap Editor"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime76.jsxDEV("div", {
            className: "flex gap-2",
            children: [
              /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(Button, {
                variant: "circle-help",
                size: "circle",
                title: "",
                children: "?"
              }, undefined, false, undefined, this),
              !readOnly && /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(jsx_dev_runtime76.Fragment, {
                children: [
                  /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(Button, {
                    variant: "outline",
                    size: "sm",
                    onClick: handleExpandAll,
                    children: [
                      /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(ChevronsDown, {
                        className: "h-4 w-4 mr-1"
                      }, undefined, false, undefined, this),
                      ""
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(Button, {
                    variant: "outline",
                    size: "sm",
                    onClick: handleCollapseAll,
                    children: [
                      /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(ChevronsUp, {
                        className: "h-4 w-4 mr-1"
                      }, undefined, false, undefined, this),
                      ""
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(Button, {
                    variant: "outline",
                    size: "sm",
                    onClick: () => setShowMermaidExport(true),
                    children: [
                      /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(Download, {
                        className: "h-4 w-4 mr-1"
                      }, undefined, false, undefined, this),
                      t2("export_mermaid", "")
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(Button, {
                    variant: "outline",
                    size: "sm",
                    onClick: () => setShowMermaidImport(true),
                    children: [
                      /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(Upload, {
                        className: "h-4 w-4 mr-1"
                      }, undefined, false, undefined, this),
                      t2("import_mermaid", "")
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime76.jsxDEV("div", {
                    className: "h-6 w-px bg-border"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(Button, {
                variant: "outline",
                size: "sm",
                onClick: handleDownloadImage,
                children: [
                  /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(Image4, {
                    className: "h-4 w-4 mr-1"
                  }, undefined, false, undefined, this),
                  t2("download_image", "Image")
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(Button, {
                variant: "outline",
                size: "sm",
                onClick: handleDownloadPdf,
                children: [
                  /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(FileDown, {
                    className: "h-4 w-4 mr-1"
                  }, undefined, false, undefined, this),
                  t2("download_pdf", "PDF")
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime76.jsxDEV("div", {
        className: "flex-1 overflow-hidden mindmap-canvas-container",
        children: /* @__PURE__ */ jsx_dev_runtime76.jsxDEV("div", {
          className: "w-full h-full content-container",
          children: /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(KonvaCanvasEditor, {
            ref: canvasRef,
            elements: visibleNodes,
            selectedIds: selectedNodeId ? [selectedNodeId] : [],
            onSelect: handleSelect,
            onChange: handleChangeNodes,
            zoom: 1,
            paperWidth: 600,
            paperHeight: 400,
            readOnly,
            initialScrollCenter: { x: 300, y: 200 },
            onToggleCollapse: handleToggleCollapse,
            onDragStart: handleDragStart,
            onDragMove: handleDragMove,
            onDragEnter: handleDragEnter,
            onDragLeave: handleDragLeave,
            onDragEnd: handleDragEnd,
            dragState
          }, undefined, false, undefined, this)
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(Modal, {
        open: showShortcuts,
        onOpenChange: setShowShortcuts,
        title: t2("shortcut_title", ""),
        description: t2("shortcut_description", ""),
        className: "max-w-md",
        children: [
          /* @__PURE__ */ jsx_dev_runtime76.jsxDEV("div", {
            className: "space-y-4",
            children: [
              /* @__PURE__ */ jsx_dev_runtime76.jsxDEV("div", {
                className: "flex items-center gap-2 text-muted-foreground mb-4",
                children: [
                  /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(Keyboard, {
                    className: "w-5 h-5"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime76.jsxDEV("span", {
                    className: "text-sm",
                    children: t2("shortcut_helper_text", "")
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime76.jsxDEV("div", {
                className: "grid grid-cols-[1fr_auto] gap-x-8 gap-y-3",
                children: [
                  { key: t2("shortcut_add_child", ""), cmd: "Tab" },
                  { key: t2("shortcut_add_sibling", ""), cmd: "Enter" },
                  { key: t2("shortcut_delete", ""), cmd: "Delete / Backspace" },
                  { key: t2("shortcut_delete", ""), cmd: "Delete / Backspace" },
                  { key: t2("shortcut_edit_text", ""), cmd: "" },
                  { key: t2("shortcut_undo", ""), cmd: "Ctrl/Cmd + Z" },
                  { key: t2("shortcut_redo", ""), cmd: "Ctrl/Cmd + Shift + Z" }
                ].map((s2, i3) => /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(import_react55.default.Fragment, {
                  children: [
                    /* @__PURE__ */ jsx_dev_runtime76.jsxDEV("div", {
                      className: "text-sm font-medium text-foreground",
                      children: s2.key
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx_dev_runtime76.jsxDEV("div", {
                      className: "text-xs font-mono bg-muted px-2 py-1 rounded border border-border text-muted-foreground self-center",
                      children: s2.cmd
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx_dev_runtime76.jsxDEV("div", {
                      className: "col-span-2 h-px bg-border/50 last:hidden"
                    }, undefined, false, undefined, this)
                  ]
                }, i3, true, undefined, this))
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(ModalFooter, {
            children: /* @__PURE__ */ jsx_dev_runtime76.jsxDEV("button", {
              onClick: () => setShowShortcuts(false),
              className: "px-4 py-2 text-sm font-medium text-primary-foreground bg-primary hover:bg-primary/90 rounded-md transition-colors",
              children: t2("close", "")
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(MermaidExportModal, {
        isOpen: showMermaidExport,
        onClose: () => setShowMermaidExport(false),
        doc,
        graph
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime76.jsxDEV(MermaidImportModal, {
        isOpen: showMermaidImport,
        onClose: () => setShowMermaidImport(false),
        onImport: handleMermaidImport
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
// ../../src/features/slide-editor/components/SlideEditor.tsx
var import_react63 = __toESM(require_react(), 1);

// ../../src/features/slide-editor/components/SlideListPanel.tsx
var import_react56 = __toESM(require_react(), 1);

// ../../src/features/slide-editor/components/SlidePreview.tsx
var jsx_dev_runtime77 = __toESM(require_jsx_dev_runtime(), 1);
var SlidePreview = ({
  width,
  height,
  surface,
  nodes
}) => {
  if (!surface.w || !surface.h || !width || !height)
    return null;
  const scaleX = width / surface.w;
  const scaleY = height / surface.h;
  const scale = Math.min(scaleX, scaleY);
  const contentWidthPx = surface.w * scale;
  const contentHeightPx = surface.h * scale;
  const x3 = (width - contentWidthPx) / 2;
  const y2 = (height - contentHeightPx) / 2;
  const noOp = () => {};
  return /* @__PURE__ */ jsx_dev_runtime77.jsxDEV(Stage2, {
    width,
    height,
    scaleX: scale,
    scaleY: scale,
    x: x3,
    y: y2,
    style: { pointerEvents: "none" },
    children: /* @__PURE__ */ jsx_dev_runtime77.jsxDEV(Layer2, {
      children: [
        /* @__PURE__ */ jsx_dev_runtime77.jsxDEV(Rect2, {
          x: 0,
          y: 0,
          width: surface.w,
          height: surface.h,
          fill: surface.bg
        }, undefined, false, undefined, this),
        nodes.map((node) => /* @__PURE__ */ jsx_dev_runtime77.jsxDEV(CanvasElementRenderer, {
          element: node,
          isSelected: false,
          readOnly: true,
          allElements: nodes,
          stageScale: scale,
          onSelect: noOp,
          onChange: noOp,
          onDblClick: noOp,
          onCellClick: noOp,
          onCellDblClick: noOp,
          onContextMenu: noOp,
          isEditing: false,
          onToggleCollapse: noOp
        }, node.id, false, undefined, this))
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this);
};

// ../../src/features/slide-editor/components/SlideListPanel.tsx
var jsx_dev_runtime78 = __toESM(require_jsx_dev_runtime(), 1);
var SlideListPanel = ({
  doc,
  currentSlideId,
  onSlideSelect,
  onChange,
  thumbnails = {},
  onAddSlide,
  isMasterEditMode = false
}) => {
  const surfaces = import_react56.useMemo(() => {
    if (isMasterEditMode) {
      return doc.surfaces.filter((s2) => !s2.masterId && s2.id !== "master-blank");
    }
    return doc.surfaces.filter((s2) => !!s2.masterId);
  }, [doc.surfaces, isMasterEditMode]);
  const [draggedSlideId, setDraggedSlideId] = import_react56.default.useState(null);
  const handleDragStart = (e2, id) => {
    setDraggedSlideId(id);
    e2.dataTransfer.effectAllowed = "move";
  };
  const handleDragOver = (e2, targetId) => {
    e2.preventDefault();
    if (!draggedSlideId || draggedSlideId === targetId)
      return;
    e2.dataTransfer.dropEffect = "move";
  };
  const handleDrop = (e2, targetId) => {
    e2.preventDefault();
    if (!draggedSlideId || draggedSlideId === targetId)
      return;
    const oldIndex = doc.surfaces.findIndex((s2) => s2.id === draggedSlideId);
    const newIndex = doc.surfaces.findIndex((s2) => s2.id === targetId);
    if (oldIndex === -1 || newIndex === -1)
      return;
    const newSurfaces = [...doc.surfaces];
    const [moved] = newSurfaces.splice(oldIndex, 1);
    newSurfaces.splice(newIndex, 0, moved);
    onChange({
      ...doc,
      surfaces: newSurfaces
    });
    setDraggedSlideId(null);
  };
  const handleDelete = (e2, id) => {
    e2.stopPropagation();
    if (doc.surfaces.length <= 1)
      return;
    const newSurfaces = doc.surfaces.filter((s2) => s2.id !== id);
    const newNodes = doc.nodes.filter((n2) => n2.s !== id);
    let newCurrentId = currentSlideId;
    if (currentSlideId === id) {
      const uiIndex = surfaces.findIndex((s2) => s2.id === id);
      const nextUiIndex = uiIndex > 0 ? uiIndex - 1 : 0;
      newCurrentId = surfaces.filter((s2) => s2.id !== id)[nextUiIndex]?.id ?? "";
    }
    onChange({
      ...doc,
      surfaces: newSurfaces,
      nodes: newNodes
    });
    if (newCurrentId && newCurrentId !== currentSlideId) {
      onSlideSelect(newCurrentId);
    }
  };
  const handleDuplicate = (e2, id) => {
    e2.stopPropagation();
    const surfaceToClone = doc.surfaces.find((s2) => s2.id === id);
    if (!surfaceToClone)
      return;
    const newId = `slide-${crypto.randomUUID()}`;
    const newSurface = {
      ...surfaceToClone,
      id: newId
    };
    const nodesToClone = doc.nodes.filter((n2) => n2.s === id);
    const newNodes = nodesToClone.map((n2) => ({
      ...n2,
      id: `${n2.t}-${crypto.randomUUID()}`,
      s: newId
    }));
    const index2 = doc.surfaces.findIndex((s2) => s2.id === id);
    const newSurfaces = [...doc.surfaces];
    if (index2 !== -1) {
      newSurfaces.splice(index2 + 1, 0, newSurface);
    } else {
      newSurfaces.push(newSurface);
    }
    onChange({
      ...doc,
      surfaces: newSurfaces,
      nodes: [...doc.nodes, ...newNodes]
    });
    onSlideSelect(newId);
  };
  return /* @__PURE__ */ jsx_dev_runtime78.jsxDEV("div", {
    className: "flex flex-col w-full h-full bg-muted/30 border-r border-border overflow-hidden",
    children: [
      /* @__PURE__ */ jsx_dev_runtime78.jsxDEV("div", {
        className: "p-2 border-b border-border bg-background/50",
        children: /* @__PURE__ */ jsx_dev_runtime78.jsxDEV("span", {
          className: "text-xs font-semibold text-muted-foreground uppercase",
          children: isMasterEditMode ? "Slide Layouts" : "Slides"
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime78.jsxDEV("div", {
        className: "flex-1 overflow-y-auto p-2 space-y-4",
        children: surfaces.map((slide, index2) => {
          const isSelected = slide.id === currentSlideId;
          return /* @__PURE__ */ jsx_dev_runtime78.jsxDEV(SlideThumbnail, {
            slide,
            isSelected,
            isDragged: draggedSlideId === slide.id,
            index: index2,
            onSelect: onSlideSelect,
            onDragStart: handleDragStart,
            onDragOver: handleDragOver,
            onDrop: handleDrop,
            onDuplicate: handleDuplicate,
            onDelete: handleDelete,
            onAddSlide,
            surfacesCount: surfaces.length,
            thumbnailUrl: thumbnails[slide.id],
            doc,
            isMasterEditMode
          }, slide.id, false, undefined, this);
        })
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
var SlideThumbnail = ({
  slide,
  isSelected,
  isDragged,
  index: index2,
  onSelect,
  onDragStart,
  onDragOver,
  onDrop,
  onDuplicate,
  onDelete,
  onAddSlide,
  surfacesCount,
  thumbnailUrl,
  doc,
  isMasterEditMode
}) => {
  const containerRef = import_react56.default.useRef(null);
  const [dimensions, setDimensions] = import_react56.default.useState({ width: 0, height: 0 });
  import_react56.default.useEffect(() => {
    if (!containerRef.current)
      return;
    const updateDims = () => {
      if (containerRef.current) {
        const { clientWidth, clientHeight } = containerRef.current;
        setDimensions({ width: clientWidth, height: clientHeight });
      }
    };
    updateDims();
    const ro = new ResizeObserver(updateDims);
    ro.observe(containerRef.current);
    return () => ro.disconnect();
  }, []);
  const handleKeyDown = (e2) => {
    if (e2.key === "Enter") {
      e2.preventDefault();
      e2.stopPropagation();
      onAddSlide("title-content");
    }
    if (e2.key === "Delete" || e2.key === "Backspace") {
      e2.preventDefault();
      e2.stopPropagation();
      onDelete(e2, slide.id);
    }
  };
  const previewNodes = import_react56.default.useMemo(() => {
    if (!isMasterEditMode)
      return [];
    return doc.nodes.filter((n2) => n2.s === slide.id);
  }, [doc.nodes, slide.id, isMasterEditMode]);
  const slidePreview = import_react56.default.useMemo(() => {
    if (isMasterEditMode) {
      return {
        surface: slide,
        nodes: previewNodes
      };
    }
    const masterSurface = slide.masterId ? doc.surfaces.find((s2) => s2.id === slide.masterId) : null;
    const masterNodes = masterSurface ? doc.nodes.filter((n2) => n2.s === masterSurface.id) : [];
    const slideNodes = doc.nodes.filter((n2) => n2.s === slide.id);
    const pageNumber = index2 + 1;
    const processedMasterNodes = masterNodes.filter((n2) => !n2.isPlaceholder).map((n2) => {
      const node = { ...n2, locked: true };
      if (node.t === "text" && node.dynamicContent === "slide-number") {
        return { ...node, text: String(pageNumber) };
      }
      return node;
    });
    return {
      surface: {
        ...slide,
        bg: slide.bg || masterSurface?.bg || "#ffffff"
      },
      nodes: [...processedMasterNodes, ...slideNodes]
    };
  }, [doc.nodes, doc.surfaces, index2, isMasterEditMode, previewNodes, slide]);
  return /* @__PURE__ */ jsx_dev_runtime78.jsxDEV("div", {
    draggable: true,
    tabIndex: 0,
    onKeyDown: handleKeyDown,
    onDragStart: (e2) => onDragStart(e2, slide.id),
    onDragOver: (e2) => onDragOver(e2, slide.id),
    onDrop: (e2) => onDrop(e2, slide.id),
    onClick: () => onSelect(slide.id),
    className: cn("group relative flex flex-col gap-1 items-start rounded-md p-2 transition-all cursor-pointer border-2 bg-background shadow-sm focus:outline-none focus:ring-2 focus:ring-primary", isSelected ? "border-primary ring-1 ring-primary/20" : "border-transparent hover:border-border", isDragged && "opacity-50"),
    children: [
      /* @__PURE__ */ jsx_dev_runtime78.jsxDEV("div", {
        ref: containerRef,
        className: "relative w-full shadow-sm overflow-hidden rounded-sm ring-1 ring-border/20 pointer-events-none select-none flex items-center justify-center bg-white",
        style: { aspectRatio: `${slide.w || 297}/${slide.h || 210}` },
        children: [
          isMasterEditMode ? dimensions.width > 0 && /* @__PURE__ */ jsx_dev_runtime78.jsxDEV(SlidePreview, {
            width: dimensions.width,
            height: dimensions.height,
            surface: slide,
            nodes: previewNodes
          }, undefined, false, undefined, this) : thumbnailUrl ? /* @__PURE__ */ jsx_dev_runtime78.jsxDEV("img", {
            src: thumbnailUrl,
            alt: `Slide ${index2 + 1}`,
            className: "w-full h-full object-contain"
          }, undefined, false, undefined, this) : dimensions.width > 0 && /* @__PURE__ */ jsx_dev_runtime78.jsxDEV(SlidePreview, {
            width: dimensions.width,
            height: dimensions.height,
            surface: slidePreview.surface,
            nodes: slidePreview.nodes
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime78.jsxDEV("div", {
            className: "absolute top-0 left-0 bg-background/80 text-foreground text-[10px] font-mono px-1.5 py-0.5 rounded-br border-r border-b border-border/50 backdrop-blur-[2px]",
            children: index2 + 1
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime78.jsxDEV("div", {
        className: cn("absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity z-10", "focus-within:opacity-100"),
        children: /* @__PURE__ */ jsx_dev_runtime78.jsxDEV(DropdownMenu2, {
          children: [
            /* @__PURE__ */ jsx_dev_runtime78.jsxDEV(DropdownMenuTrigger2, {
              asChild: true,
              children: /* @__PURE__ */ jsx_dev_runtime78.jsxDEV(Button, {
                variant: "ghost",
                size: "icon",
                className: "h-6 w-6 rounded-full bg-background/80 shadow-sm backdrop-blur-sm",
                children: /* @__PURE__ */ jsx_dev_runtime78.jsxDEV(Ellipsis, {
                  className: "h-3 w-3"
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime78.jsxDEV(DropdownMenuContent2, {
              align: "start",
              children: [
                /* @__PURE__ */ jsx_dev_runtime78.jsxDEV(DropdownMenuItem2, {
                  onClick: (e2) => onDuplicate(e2, slide.id),
                  children: [
                    /* @__PURE__ */ jsx_dev_runtime78.jsxDEV(Copy, {
                      className: "mr-2 h-4 w-4"
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx_dev_runtime78.jsxDEV("span", {
                      children: "Duplicate"
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this),
                /* @__PURE__ */ jsx_dev_runtime78.jsxDEV(DropdownMenuItem2, {
                  onClick: (e2) => onDelete(e2, slide.id),
                  className: "text-destructive focus:text-destructive",
                  disabled: surfacesCount <= 1,
                  children: [
                    /* @__PURE__ */ jsx_dev_runtime78.jsxDEV(Trash2, {
                      className: "mr-2 h-4 w-4"
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx_dev_runtime78.jsxDEV("span", {
                      children: "Delete"
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this)
              ]
            }, undefined, true, undefined, this)
          ]
        }, undefined, true, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/slide-editor/components/TopToolbar.tsx
var import_react57 = __toESM(require_react(), 1);

// ../../src/features/slide-editor/constants/templates.ts
var SLIDE_TEMPLATES = [
  {
    id: "default",
    name: "Default (White)",
    master: {
      bg: "#ffffff",
      textColor: "#333333",
      nodes: []
    }
  },
  {
    id: "corporate-dark",
    name: "Corporate Dark",
    master: {
      bg: "#1e293b",
      textColor: "#f8fafc",
      nodes: [
        {
          id: "master-shape-1",
          t: "shape",
          shape: "rect",
          s: "master",
          x: 0,
          y: 0,
          w: 297,
          h: 5,
          fill: "#3b82f6",
          strokeW: 0,
          r: 0,
          locked: true
        },
        {
          id: "master-shape-2",
          t: "shape",
          shape: "rect",
          s: "master",
          x: 0,
          y: 205,
          w: 297,
          h: 5,
          fill: "#334155",
          strokeW: 0,
          r: 0,
          locked: true
        },
        {
          id: "master-text-page-num",
          t: "text",
          s: "master",
          x: 270,
          y: 200,
          w: 20,
          h: 10,
          text: "#",
          dynamicContent: "slide-number",
          fontSize: 4,
          font: "Arial",
          fill: "#94a3b8",
          align: "r",
          vAlign: "m",
          locked: true
        },
        {
          id: "master-text-copyright",
          t: "text",
          s: "master",
          x: 10,
          y: 200,
          w: 100,
          h: 10,
          text: " 2024 Your Company",
          fontSize: 3.5,
          font: "Arial",
          fill: "#64748b",
          align: "l",
          vAlign: "m",
          locked: true
        }
      ]
    }
  }
];

// ../../src/features/slide-editor/utils/pptxExport.ts
async function isPptxAvailable() {
  try {
    await Promise.resolve().then(() => (init_pptxgen_es(), exports_pptxgen_es));
    return true;
  } catch (e2) {
    return false;
  }
}
async function exportToPptx(doc, fileName = "presentation.pptx") {
  let PptxGenJS2;
  try {
    const module = await Promise.resolve().then(() => (init_pptxgen_es(), exports_pptxgen_es));
    PptxGenJS2 = module.default;
  } catch (e2) {
    console.error("pptxgenjs is not installed.", e2);
    throw new Error("PPTX generation library is not available.");
  }
  const pptx = new PptxGenJS2;
  pptx.defineLayout({ name: "A4", width: 11.69, height: 8.27 });
  pptx.layout = "A4";
  const slides = doc.surfaces.filter((s2) => s2.type === "slide");
  for (const surface of slides) {
    const slide = pptx.addSlide();
    if (surface.bg) {
      slide.background = { color: sanitizeHex(surface.bg, "FFFFFF") };
    }
    const nodes = doc.nodes.filter((n2) => n2.s === surface.id);
    for (const node of nodes) {
      if (node.hidden)
        continue;
      await addNodeToSlide(slide, node);
    }
  }
  await pptx.writeFile({ fileName });
}
var MM_TO_INCH = 0.03937007874015748;
function sanitizeHex(color, defaultColor = "000000") {
  if (!color)
    return defaultColor;
  let c3 = color.trim();
  if (c3.startsWith("#"))
    c3 = c3.substring(1);
  if (/^[0-9A-Fa-f]{3}$/.test(c3)) {
    return c3.split("").map((char) => char + char).join("");
  }
  if (/^[0-9A-Fa-f]{6}$/.test(c3))
    return c3;
  return defaultColor;
}
function sanitizeNum(val) {
  return typeof val === "number" && Number.isFinite(val) ? val : 0;
}
async function addNodeToSlide(slide, node) {
  const x3 = sanitizeNum(node.x) * MM_TO_INCH;
  const y2 = sanitizeNum(node.y) * MM_TO_INCH;
  const w2 = sanitizeNum(node.w) * MM_TO_INCH;
  const h3 = sanitizeNum(node.h) * MM_TO_INCH;
  const options2 = {
    x: x3,
    y: y2,
    w: w2,
    h: h3
  };
  if (node.r) {
    options2.rotate = sanitizeNum(node.r);
  }
  if (node.t === "text") {
    const tCheck = node;
    const color = sanitizeHex(tCheck.fill, "000000");
    const bg = tCheck.backgroundColor ? sanitizeHex(tCheck.backgroundColor) : undefined;
    slide.addText(tCheck.text || "", {
      ...options2,
      fontSize: Math.max(1, sanitizeNum(tCheck.fontSize) * 2.83),
      fontFace: tCheck.font || "Arial",
      color,
      bold: !!(tCheck.fontWeight && tCheck.fontWeight >= 700),
      italic: !!tCheck.italic,
      underline: !!tCheck.underline,
      strike: !!tCheck.lineThrough,
      align: tCheck.align === "j" ? "justify" : tCheck.align || "left",
      valign: tCheck.vAlign === "m" ? "middle" : tCheck.vAlign === "b" ? "bottom" : "top",
      fill: bg ? { color: bg } : undefined,
      lineSpacing: 18
    });
  } else if (node.t === "shape") {
    const sCheck = node;
    const fillColor = sanitizeHex(sCheck.fill, "FFFFFF");
    const lineColor = sanitizeHex(sCheck.stroke, "000000");
    const lineWidth = Math.max(0, sanitizeNum(sCheck.strokeW) * 2.83);
    let shapeType = "rect";
    if (sCheck.shape === "circle")
      shapeType = "oval";
    else if (sCheck.shape === "triangle")
      shapeType = "triangle";
    else if (sCheck.shape === "star")
      shapeType = "star5";
    slide.addShape(shapeType, {
      ...options2,
      fill: { color: fillColor },
      line: { color: lineColor, width: lineWidth }
    });
  } else if (node.t === "image") {
    const iCheck = node;
    if (iCheck.src) {
      slide.addImage({
        ...options2,
        path: iCheck.src
      });
    }
  } else if (node.t === "line") {
    const lCheck = node;
    if (lCheck.pts && lCheck.pts.length >= 4) {
      const x1 = sanitizeNum(lCheck.pts[0]) * MM_TO_INCH;
      const y1 = sanitizeNum(lCheck.pts[1]) * MM_TO_INCH;
      const x22 = sanitizeNum(lCheck.pts[2]) * MM_TO_INCH;
      const y22 = sanitizeNum(lCheck.pts[3]) * MM_TO_INCH;
      const lx = Math.min(x1, x22);
      const ly = Math.min(y1, y22);
      const lw = Math.abs(x22 - x1);
      const lh = Math.abs(y22 - y1);
      const lineColor = sanitizeHex(lCheck.stroke, "000000");
      const lineWidth = Math.max(1, sanitizeNum(lCheck.strokeW) * 2.83);
      let flipH = false;
      let flipV = false;
      if (x1 > x22)
        flipH = true;
      if (y1 > y22)
        flipV = true;
      slide.addShape("line", {
        x: lx,
        y: ly,
        w: lw,
        h: lh,
        line: { color: lineColor, width: lineWidth },
        flipH,
        flipV
      });
    }
  } else if (node.t === "signature") {}
}

// ../../src/features/slide-editor/constants/layouts.tsx
var jsx_dev_runtime79 = __toESM(require_jsx_dev_runtime(), 1);
var SECTION_MARGIN = 20;
var TITLE_Y = 15;
var TITLE_H = 20;
var CONTENT_Y = TITLE_Y + TITLE_H + 10;
var createText = (s2, text2, x3, y2, w2, h3, fontSizePt, align = "l", fontWeight = 400) => ({
  id: `text-${crypto.randomUUID()}`,
  t: "text",
  s: s2,
  x: x3,
  y: y2,
  w: w2,
  h: h3,
  text: text2,
  fontSize: ptToMm(fontSizePt),
  font: "Meiryo",
  align,
  vAlign: "t",
  fill: "#333333",
  fontWeight,
  isPlaceholder: true
});
var createPlaceholder = (s2, x3, y2, w2, h3) => ({
  id: `shape-${crypto.randomUUID()}`,
  t: "shape",
  s: s2,
  x: x3,
  y: y2,
  w: w2,
  h: h3,
  shape: "rect",
  fill: "#f0f0f0",
  stroke: "#cccccc",
  strokeW: 1,
  isPlaceholder: true
});
var IconWrapper = ({ children }) => /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
  className: "w-24 h-16 border border-border bg-white relative rounded-sm shadow-sm group-hover:border-primary transition-all overflow-hidden border-muted-foreground/20",
  children
}, undefined, false, undefined, this);
var Rect3 = ({ x: x3, y: y2, w: w2, h: h3, fill = "#cbd5e1" }) => /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
  className: "absolute",
  style: { left: x3, top: y2, width: w2, height: h3, backgroundColor: fill }
}, undefined, false, undefined, this);
var SLIDE_LAYOUTS = [
  {
    id: "title",
    label: "Title Slide",
    description: "Large title and subtitle",
    icon: /* @__PURE__ */ jsx_dev_runtime79.jsxDEV(IconWrapper, {
      children: /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
        className: "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 flex flex-col gap-2 items-center w-3/4",
        children: [
          /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
            className: "h-2 w-full bg-primary/60 rounded-[1px]"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
            className: "h-1.5 w-2/3 bg-muted-foreground/40 rounded-[1px]"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    }, undefined, false, undefined, this),
    generateNodes: (s2, w2, h3) => {
      const titleY = h3 / 2 - 25;
      const subY = h3 / 2 + 15;
      return [
        createText(s2, "Click to add Title", SECTION_MARGIN, titleY, w2 - SECTION_MARGIN * 2, 35, 44, "c", 700),
        createText(s2, "Click to add Subtitle", SECTION_MARGIN, subY, w2 - SECTION_MARGIN * 2, 20, 24, "c", 400)
      ];
    }
  },
  {
    id: "title-only",
    label: "Title Only",
    description: "Only a title at the top",
    icon: /* @__PURE__ */ jsx_dev_runtime79.jsxDEV(IconWrapper, {
      children: /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
        className: "absolute top-2 left-[10%] w-[80%] h-2 bg-primary/60 rounded-[1px]"
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this),
    generateNodes: (s2, w2) => [
      createText(s2, "Click to add Title", SECTION_MARGIN, TITLE_Y, w2 - SECTION_MARGIN * 2, TITLE_H, 36, "c", 700)
    ]
  },
  {
    id: "title-content",
    label: "Title & Content",
    description: "Standard layout",
    icon: /* @__PURE__ */ jsx_dev_runtime79.jsxDEV(IconWrapper, {
      children: [
        /* @__PURE__ */ jsx_dev_runtime79.jsxDEV(Rect3, {
          x: "10%",
          y: "10%",
          w: "80%",
          h: "15%",
          fill: "hsl(var(--primary) / 0.6)"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
          className: "absolute top-[35%] left-[10%] w-[80%] flex flex-col gap-1.5",
          children: [
            /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
              className: "h-1 w-full bg-muted-foreground/40"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
              className: "h-1 w-3/4 bg-muted-foreground/40"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
              className: "h-1 w-full bg-muted-foreground/40"
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this)
      ]
    }, undefined, true, undefined, this),
    generateNodes: (s2, w2, h3) => [
      createText(s2, "Click to add Title", SECTION_MARGIN, TITLE_Y, w2 - SECTION_MARGIN * 2, TITLE_H, 32, "l", 700),
      createText(s2, ` Click to add text
 Second point`, SECTION_MARGIN, CONTENT_Y, w2 - SECTION_MARGIN * 2, h3 - CONTENT_Y - SECTION_MARGIN, 18, "l")
    ]
  },
  {
    id: "two-column",
    label: "Two Content",
    description: "Two columns of content",
    icon: /* @__PURE__ */ jsx_dev_runtime79.jsxDEV(IconWrapper, {
      children: [
        /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
          className: "absolute top-[10%] left-[10%] w-[80%] h-[15%] bg-primary/60"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
          className: "absolute top-[35%] left-[10%] w-[35%] h-[50%] bg-muted-foreground/20 border border-muted-foreground/30"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
          className: "absolute top-[35%] right-[10%] w-[35%] h-[50%] bg-muted-foreground/20 border border-muted-foreground/30"
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this),
    generateNodes: (s2, w2, h3) => {
      const colW = (w2 - SECTION_MARGIN * 2 - 10) / 2;
      return [
        createText(s2, "Click to add Title", SECTION_MARGIN, TITLE_Y, w2 - SECTION_MARGIN * 2, TITLE_H, 32, "l", 700),
        createText(s2, " Bullet point 1", SECTION_MARGIN, CONTENT_Y, colW, h3 - CONTENT_Y - SECTION_MARGIN, 18, "l"),
        createPlaceholder(s2, SECTION_MARGIN + colW + 10, CONTENT_Y, colW, h3 - CONTENT_Y - SECTION_MARGIN)
      ];
    }
  },
  {
    id: "three-column",
    label: "Three Columns",
    description: "Three columns of text/content",
    icon: /* @__PURE__ */ jsx_dev_runtime79.jsxDEV(IconWrapper, {
      children: [
        /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
          className: "absolute top-[10%] left-[10%] w-[80%] h-[15%] bg-primary/60"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
          className: "absolute top-[35%] left-[5%] w-[26%] h-[50%] bg-muted-foreground/20 border border-muted-foreground/30"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
          className: "absolute top-[35%] left-[37%] w-[26%] h-[50%] bg-muted-foreground/20 border border-muted-foreground/30"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
          className: "absolute top-[35%] right-[5%] w-[26%] h-[50%] bg-muted-foreground/20 border border-muted-foreground/30"
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this),
    generateNodes: (s2, w2, h3) => {
      const gap = 10;
      const colW = (w2 - SECTION_MARGIN * 2 - gap * 2) / 3;
      return [
        createText(s2, "Click to add Title", SECTION_MARGIN, TITLE_Y, w2 - SECTION_MARGIN * 2, TITLE_H, 32, "c", 700),
        createText(s2, "Column 1", SECTION_MARGIN, CONTENT_Y, colW, h3, 18, "l"),
        createText(s2, "Column 2", SECTION_MARGIN + colW + gap, CONTENT_Y, colW, h3, 18, "l"),
        createText(s2, "Column 3", SECTION_MARGIN + (colW + gap) * 2, CONTENT_Y, colW, h3, 18, "l")
      ];
    }
  },
  {
    id: "four-images",
    label: "Four Images",
    description: "Title with 4 images",
    icon: /* @__PURE__ */ jsx_dev_runtime79.jsxDEV(IconWrapper, {
      children: [
        /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
          className: "absolute top-[10%] left-[10%] w-[80%] h-[15%] bg-primary/60"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
          className: "absolute top-[35%] left-[10%] w-[35%] h-[25%] bg-muted-foreground/20 border border-muted-foreground/30"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
          className: "absolute top-[35%] right-[10%] w-[35%] h-[25%] bg-muted-foreground/20 border border-muted-foreground/30"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
          className: "absolute bottom-[10%] left-[10%] w-[35%] h-[25%] bg-muted-foreground/20 border border-muted-foreground/30"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
          className: "absolute bottom-[10%] right-[10%] w-[35%] h-[25%] bg-muted-foreground/20 border border-muted-foreground/30"
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this),
    generateNodes: (s2, w2, h3) => {
      const gap = 10;
      const gridW = (w2 - SECTION_MARGIN * 2 - gap) / 2;
      const gridH = (h3 - CONTENT_Y - SECTION_MARGIN - gap) / 2;
      return [
        createText(s2, "Click to add Title", SECTION_MARGIN, TITLE_Y, w2 - SECTION_MARGIN * 2, TITLE_H, 32, "l", 700),
        createPlaceholder(s2, SECTION_MARGIN, CONTENT_Y, gridW, gridH),
        createPlaceholder(s2, SECTION_MARGIN + gridW + gap, CONTENT_Y, gridW, gridH),
        createPlaceholder(s2, SECTION_MARGIN, CONTENT_Y + gridH + gap, gridW, gridH),
        createPlaceholder(s2, SECTION_MARGIN + gridW + gap, CONTENT_Y + gridH + gap, gridW, gridH)
      ];
    }
  },
  {
    id: "big-number",
    label: "Big Number",
    description: "Centered big statistic",
    icon: /* @__PURE__ */ jsx_dev_runtime79.jsxDEV(IconWrapper, {
      children: [
        /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
          className: "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-2xl font-bold text-primary/80",
          children: "#"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {
          className: "absolute bottom-2 left-1/2 -translate-x-1/2 w-1/2 h-1 bg-muted-foreground/40"
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this),
    generateNodes: (s2, w2, h3) => [
      createText(s2, "42%", w2 / 2 - 50, h3 / 2 - 40, 100, 60, 80, "c", 700),
      createText(s2, "Total Growth", w2 / 2 - 50, h3 / 2 + 30, 100, 20, 24, "c", 400)
    ]
  },
  {
    id: "blank",
    label: "Blank",
    description: "Empty slide",
    icon: /* @__PURE__ */ jsx_dev_runtime79.jsxDEV(IconWrapper, {
      children: /* @__PURE__ */ jsx_dev_runtime79.jsxDEV("div", {}, undefined, false, undefined, this)
    }, undefined, false, undefined, this),
    generateNodes: () => []
  }
];

// ../../src/features/slide-editor/components/TopToolbar.tsx
var jsx_dev_runtime80 = __toESM(require_jsx_dev_runtime(), 1);
var TopToolbar = ({
  doc,
  presentationTitle,
  onPresentationTitleChange,
  currentSlideId,
  onDocChange,
  onSelectElement,
  zoom,
  onZoomChange,
  onPlay,
  onExport,
  onExportImage,
  canUndo,
  canRedo,
  onUndo,
  onRedo,
  activeTool: _activeTool,
  onToolSelect,
  onAddSlide,
  isMasterEditMode,
  onToggleMasterEdit,
  onSelectTemplate,
  savedMasters,
  onLoadSavedMaster,
  extraActions
}) => {
  const [pptxEnabled, setPptxEnabled] = import_react57.useState(false);
  const { addText, addShape, addLine, addImage } = useCanvasOperations({
    templateDoc: doc,
    onTemplateChange: onDocChange,
    onSelectElement,
    onToolSelect,
    resolveText: (key, def) => def || key,
    dpi: 96
  });
  import_react57.useEffect(() => {
    isPptxAvailable().then(setPptxEnabled);
  }, []);
  const handleAddText = () => addText(currentSlideId);
  const handleAddLine = () => addLine(currentSlideId);
  const handleAddImage = () => addImage(currentSlideId);
  const handleAddShape = (type) => addShape(type, currentSlideId);
  return /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("div", {
    className: "h-12 border-b border-border bg-background flex items-center px-2 gap-1 overflow-x-auto",
    children: [
      /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(DropdownMenu2, {
        children: [
          /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(DropdownMenuTrigger2, {
            asChild: true,
            children: /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Button, {
              variant: "ghost",
              size: "icon",
              title: "",
              children: /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(LayoutTemplate, {
                className: "h-4 w-4"
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(DropdownMenuContent2, {
            className: "w-[360px] p-2",
            align: "start",
            children: /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("div", {
              className: "grid grid-cols-2 gap-2",
              children: SLIDE_LAYOUTS.map((layout) => /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("button", {
                type: "button",
                className: "flex flex-col items-center p-2 hover:bg-accent rounded-md group text-center border border-transparent hover:border-border transition-all",
                onClick: () => onAddSlide(layout.id),
                children: [
                  layout.icon,
                  /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("span", {
                    className: "text-xs mt-2 font-medium",
                    children: layout.label
                  }, undefined, false, undefined, this)
                ]
              }, layout.id, true, undefined, this))
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("input", {
        value: presentationTitle,
        onChange: (event) => onPresentationTitleChange(event.target.value),
        placeholder: "",
        className: "border border-border rounded-md px-2 py-1 text-xs w-48 bg-background text-foreground focus:outline-none focus:ring-1 focus:ring-ring"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("div", {
        className: "h-6 w-px bg-border"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("div", {
        className: "flex items-center gap-0.5",
        children: [
          /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Button, {
            variant: "ghost",
            size: "icon",
            onClick: handleAddText,
            title: "",
            children: /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Type, {
              className: "h-4 w-4"
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(DropdownMenu2, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(DropdownMenuTrigger2, {
                asChild: true,
                children: /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Button, {
                  variant: "ghost",
                  size: "icon",
                  title: "",
                  children: /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Square, {
                    className: "h-4 w-4"
                  }, undefined, false, undefined, this)
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(DropdownMenuContent2, {
                children: EDITOR_SHAPES.map((shape) => /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(DropdownMenuItem2, {
                  onClick: () => handleAddShape(shape.type),
                  title: shape.label,
                  children: [
                    shape.icon,
                    /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("span", {
                      className: "ml-2",
                      children: shape.label
                    }, undefined, false, undefined, this)
                  ]
                }, shape.type, true, undefined, this))
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Button, {
            variant: "ghost",
            size: "icon",
            onClick: handleAddImage,
            title: "",
            children: /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Image4, {
              className: "h-4 w-4"
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Button, {
            variant: "ghost",
            size: "icon",
            onClick: handleAddLine,
            title: "",
            children: /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Minus, {
              className: "h-4 w-4"
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("div", {
        className: "h-6 w-px bg-border"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Button, {
        variant: isMasterEditMode ? "secondary" : "ghost",
        size: "icon",
        onClick: onToggleMasterEdit,
        className: isMasterEditMode ? "bg-accent text-accent-foreground border-accent" : "",
        title: isMasterEditMode ? "" : "",
        children: /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Layers, {
          className: "h-4 w-4"
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("div", {
        className: "h-6 w-px bg-border"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("div", {
        className: "flex items-center gap-0.5",
        children: [
          /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Button, {
            variant: "ghost",
            size: "icon",
            onClick: () => onZoomChange(zoom - 10),
            title: "",
            children: /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(ZoomOut, {
              className: "h-4 w-4"
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("span", {
            className: "text-xs w-8 text-center",
            children: [
              zoom,
              "%"
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Button, {
            variant: "ghost",
            size: "icon",
            onClick: () => onZoomChange(zoom + 10),
            title: "",
            children: /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(ZoomIn, {
              className: "h-4 w-4"
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("div", {
        className: "flex-1"
      }, undefined, false, undefined, this),
      extraActions && !isMasterEditMode && /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("div", {
        className: "flex items-center gap-0.5",
        children: extraActions
      }, undefined, false, undefined, this),
      extraActions && !isMasterEditMode && /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("div", {
        className: "h-6 w-px bg-border"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("div", {
        className: "flex items-center gap-0.5",
        children: [
          /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Button, {
            variant: "ghost",
            size: "icon",
            onClick: onUndo,
            disabled: !canUndo,
            title: "",
            children: /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Undo2, {
              className: "h-4 w-4"
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Button, {
            variant: "ghost",
            size: "icon",
            onClick: onRedo,
            disabled: !canRedo,
            title: "",
            children: /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Redo2, {
              className: "h-4 w-4"
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("div", {
        className: "h-6 w-px bg-border"
      }, undefined, false, undefined, this),
      isMasterEditMode ? /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("div", {
        className: "flex items-center gap-1",
        children: [
          /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(DropdownMenu2, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(DropdownMenuTrigger2, {
                asChild: true,
                children: /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Button, {
                  variant: "outline",
                  size: "sm",
                  className: "gap-1 px-2 py-1 text-xs",
                  title: "",
                  children: [
                    /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Palette, {
                      className: "h-4 w-4"
                    }, undefined, false, undefined, this),
                    ""
                  ]
                }, undefined, true, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(DropdownMenuContent2, {
                children: [
                  SLIDE_TEMPLATES.map((t2) => /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(DropdownMenuItem2, {
                    onClick: () => onSelectTemplate?.(t2.id),
                    children: t2.name
                  }, t2.id, false, undefined, this)),
                  savedMasters && savedMasters.length > 0 && /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(jsx_dev_runtime80.Fragment, {
                    children: [
                      /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("div", {
                        className: "h-px bg-border my-1"
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("div", {
                        className: "px-2 py-1 text-xs text-muted-foreground",
                        children: ""
                      }, undefined, false, undefined, this),
                      savedMasters.map((m3) => /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(DropdownMenuItem2, {
                        onClick: () => onLoadSavedMaster?.(m3.id),
                        children: m3.title
                      }, m3.id, false, undefined, this))
                    ]
                  }, undefined, true, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this),
          extraActions
        ]
      }, undefined, true, undefined, this) : /* @__PURE__ */ jsx_dev_runtime80.jsxDEV("div", {
        className: "flex items-center gap-1",
        children: [
          /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Button, {
            variant: "ghost",
            size: "sm",
            className: "px-2 py-1 text-xs",
            onClick: onPlay,
            title: "",
            children: [
              /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Play, {
                className: "h-4 w-4 mr-1 map-fill",
                fill: "currentColor"
              }, undefined, false, undefined, this),
              "Play"
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(DropdownMenu2, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(DropdownMenuTrigger2, {
                asChild: true,
                children: /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Button, {
                  variant: "outline",
                  size: "sm",
                  className: "gap-1 px-2 py-1 text-xs",
                  title: "",
                  children: [
                    /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Download, {
                      className: "h-4 w-4"
                    }, undefined, false, undefined, this),
                    "Export"
                  ]
                }, undefined, true, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(DropdownMenuContent2, {
                align: "end",
                children: [
                  /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(DropdownMenuItem2, {
                    onClick: onExportImage,
                    children: [
                      /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Image4, {
                        className: "h-4 w-4 mr-2"
                      }, undefined, false, undefined, this),
                      "Image"
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(DropdownMenuItem2, {
                    onClick: onExport,
                    disabled: !pptxEnabled,
                    children: [
                      /* @__PURE__ */ jsx_dev_runtime80.jsxDEV(Download, {
                        className: "h-4 w-4 mr-2"
                      }, undefined, false, undefined, this),
                      "PPTX"
                    ]
                  }, undefined, true, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/slide-editor/components/PresentationMode.tsx
var import_react58 = __toESM(require_react(), 1);
var jsx_dev_runtime81 = __toESM(require_jsx_dev_runtime(), 1);
var PresentationMode = ({
  doc,
  initialSlideId,
  onExit,
  className
}) => {
  const containerRef = import_react58.useRef(null);
  const [isFullscreen, setIsFullscreen] = import_react58.useState(false);
  const slides = doc.surfaces.filter((s2) => s2.type === "slide");
  const [currentIndex, setCurrentIndex] = import_react58.useState(() => {
    const idx = slides.findIndex((s2) => s2.id === initialSlideId);
    return idx >= 0 ? idx : 0;
  });
  const currentSlide = slides[currentIndex];
  const currentNodes = doc.nodes.filter((n2) => n2.s === currentSlide.id);
  const [scale, setScale] = import_react58.useState(1);
  const [dimensions, setDimensions] = import_react58.useState({ w: 0, h: 0 });
  import_react58.useEffect(() => {
    const handleFullscreenChange = () => {
      setIsFullscreen(!!document.fullscreenElement);
    };
    document.addEventListener("fullscreenchange", handleFullscreenChange);
    return () => {
      document.removeEventListener("fullscreenchange", handleFullscreenChange);
    };
  }, []);
  const toggleFullscreen = import_react58.useCallback(() => {
    if (!containerRef.current)
      return;
    if (!document.fullscreenElement) {
      containerRef.current.requestFullscreen().catch((err) => {
        console.error("Failed to enter fullscreen:", err);
      });
    } else {
      document.exitFullscreen();
    }
  }, []);
  import_react58.useEffect(() => {
    const updateSize = () => {
      if (!containerRef.current)
        return;
      const { clientWidth, clientHeight } = containerRef.current;
      setDimensions({ w: clientWidth, h: clientHeight });
      const slideW = currentSlide?.w || 297;
      const slideH = currentSlide?.h || 210;
      const margin = isFullscreen ? 0 : 0;
      const availW = clientWidth - margin;
      const availH = clientHeight - margin;
      const scaleW = availW / slideW;
      const scaleH = availH / slideH;
      setScale(Math.min(scaleW, scaleH));
    };
    updateSize();
    const ro = new ResizeObserver(updateSize);
    if (containerRef.current)
      ro.observe(containerRef.current);
    window.addEventListener("resize", updateSize);
    return () => {
      window.removeEventListener("resize", updateSize);
      ro.disconnect();
    };
  }, [currentSlide, isFullscreen]);
  const nextSlide = import_react58.useCallback(() => {
    setCurrentIndex((prev) => Math.min(prev + 1, slides.length - 1));
  }, [slides.length]);
  const prevSlide = import_react58.useCallback(() => {
    setCurrentIndex((prev) => Math.max(prev - 1, 0));
  }, []);
  import_react58.useEffect(() => {
    const handleKeyDown = (e2) => {
      if (e2.key === "ArrowRight" || e2.key === "Space") {
        nextSlide();
      } else if (e2.key === "ArrowLeft") {
        prevSlide();
      } else if (e2.key === "Escape") {
        if (document.fullscreenElement) {
          document.exitFullscreen();
        } else {}
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [nextSlide, prevSlide, onExit]);
  const handleContainerClick = (e2) => {
    if (isFullscreen) {
      const { clientWidth } = e2.currentTarget;
      const x3 = e2.nativeEvent.offsetX;
      if (x3 < clientWidth * 0.3) {
        prevSlide();
      } else {
        nextSlide();
      }
    } else {
      nextSlide();
    }
  };
  if (!currentSlide)
    return null;
  const stageW = (currentSlide.w || 297) * scale;
  const stageH = (currentSlide.h || 210) * scale;
  const stageX = (dimensions.w - stageW) / 2;
  const stageY = (dimensions.h - stageH) / 2;
  return /* @__PURE__ */ jsx_dev_runtime81.jsxDEV("div", {
    ref: containerRef,
    className: cn("bg-black flex items-center justify-center relative overflow-hidden group outline-none", isFullscreen ? "fixed inset-0 z-[9999]" : "w-full h-full", className),
    onClick: handleContainerClick,
    tabIndex: 0,
    children: [
      /* @__PURE__ */ jsx_dev_runtime81.jsxDEV(Stage2, {
        width: dimensions.w,
        height: dimensions.h,
        scale: { x: scale, y: scale },
        x: stageX,
        y: stageY,
        children: /* @__PURE__ */ jsx_dev_runtime81.jsxDEV(Layer2, {
          children: [
            /* @__PURE__ */ jsx_dev_runtime81.jsxDEV(Rect2, {
              width: currentSlide.w || 297,
              height: currentSlide.h || 210,
              fill: currentSlide.bg || "#ffffff"
            }, undefined, false, undefined, this),
            currentNodes.map((node) => /* @__PURE__ */ jsx_dev_runtime81.jsxDEV(CanvasElementRenderer, {
              element: node,
              isSelected: false,
              allElements: currentNodes,
              stageScale: scale,
              onSelect: () => {},
              onChange: () => {},
              readOnly: true
            }, node.id, false, undefined, this))
          ]
        }, undefined, true, undefined, this)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime81.jsxDEV("div", {
        className: "absolute top-4 right-4 flex gap-2 opacity-0 group-hover:opacity-100 transition-opacity z-20",
        onClick: (e2) => e2.stopPropagation(),
        children: [
          isFullscreen ? /* @__PURE__ */ jsx_dev_runtime81.jsxDEV("button", {
            onClick: toggleFullscreen,
            className: "p-2 bg-black/50 text-white rounded-full hover:bg-white/20",
            title: "Exit Fullscreen",
            children: /* @__PURE__ */ jsx_dev_runtime81.jsxDEV(Minimize, {
              size: 20
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this) : /* @__PURE__ */ jsx_dev_runtime81.jsxDEV("button", {
            onClick: toggleFullscreen,
            className: "p-2 bg-black/50 text-white rounded-full hover:bg-white/20",
            title: "Enter Fullscreen",
            children: /* @__PURE__ */ jsx_dev_runtime81.jsxDEV(Maximize, {
              size: 20
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime81.jsxDEV("button", {
            onClick: onExit,
            className: "p-2 bg-black/50 text-white rounded-full hover:bg-white/20 hover:text-red-400",
            title: "Close",
            children: /* @__PURE__ */ jsx_dev_runtime81.jsxDEV(X, {
              size: 20
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime81.jsxDEV("div", {
        className: "absolute bottom-6 left-1/2 -translate-x-1/2 flex items-center gap-4 opacity-0 group-hover:opacity-100 transition-opacity bg-black/60 p-2.5 rounded-full border border-white/10 z-20 backdrop-blur-sm",
        onClick: (e2) => e2.stopPropagation(),
        children: [
          /* @__PURE__ */ jsx_dev_runtime81.jsxDEV("button", {
            onClick: prevSlide,
            className: "text-white hover:text-primary transition-colors disabled:opacity-30",
            disabled: currentIndex === 0,
            children: /* @__PURE__ */ jsx_dev_runtime81.jsxDEV(ChevronLeft, {
              size: 24
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime81.jsxDEV("span", {
            className: "text-white text-sm font-medium min-w-[3rem] text-center select-none font-mono",
            children: [
              currentIndex + 1,
              " / ",
              slides.length
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime81.jsxDEV("button", {
            onClick: nextSlide,
            className: "text-white hover:text-primary transition-colors disabled:opacity-30",
            disabled: currentIndex === slides.length - 1,
            children: /* @__PURE__ */ jsx_dev_runtime81.jsxDEV(ChevronRight, {
              size: 24
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime81.jsxDEV("div", {
            className: "w-px h-4 bg-white/20 mx-1"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime81.jsxDEV("button", {
            onClick: toggleFullscreen,
            className: "text-white hover:text-primary transition-colors",
            children: isFullscreen ? /* @__PURE__ */ jsx_dev_runtime81.jsxDEV(Minimize, {
              size: 20
            }, undefined, false, undefined, this) : /* @__PURE__ */ jsx_dev_runtime81.jsxDEV(Maximize, {
              size: 20
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      !isFullscreen && /* @__PURE__ */ jsx_dev_runtime81.jsxDEV("div", {
        className: "absolute inset-0 flex items-center justify-center bg-black/10 transition-colors hover:bg-black/20",
        children: /* @__PURE__ */ jsx_dev_runtime81.jsxDEV("button", {
          onClick: (e2) => {
            e2.stopPropagation();
            toggleFullscreen();
          },
          className: "bg-primary/90 hover:bg-primary text-white p-4 rounded-full shadow-2xl scale-100 hover:scale-110 transition-all cursor-pointer",
          title: "Start Slideshow",
          children: /* @__PURE__ */ jsx_dev_runtime81.jsxDEV(Play, {
            size: 32,
            fill: "currentColor"
          }, undefined, false, undefined, this)
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/features/slide-editor/hooks/useSlideHistory.ts
var import_react59 = __toESM(require_react(), 1);
function useSlideHistory(initialDoc) {
  const [history, setHistory] = import_react59.useState({
    past: [],
    present: initialDoc,
    future: []
  });
  const setDoc = import_react59.useCallback((docOrUpdater, options2 = {}) => {
    const { saveToHistory = true, force = false } = options2;
    setHistory((prev) => {
      const newPresent = typeof docOrUpdater === "function" ? docOrUpdater(prev.present) : docOrUpdater;
      if (!force && JSON.stringify(newPresent) === JSON.stringify(prev.present)) {
        return prev;
      }
      if (!saveToHistory) {
        return {
          ...prev,
          present: newPresent,
          future: []
        };
      }
      return {
        past: [...prev.past, prev.present],
        present: newPresent,
        future: []
      };
    });
  }, []);
  const undo = import_react59.useCallback(() => {
    setHistory((prev) => {
      if (prev.past.length === 0)
        return prev;
      const newPast = prev.past.slice(0, prev.past.length - 1);
      const newPresent = prev.past[prev.past.length - 1];
      return {
        past: newPast,
        present: newPresent,
        future: [prev.present, ...prev.future]
      };
    });
  }, []);
  const redo = import_react59.useCallback(() => {
    setHistory((prev) => {
      if (prev.future.length === 0)
        return prev;
      const newFuture = prev.future.slice(1);
      const newPresent = prev.future[0];
      return {
        past: [...prev.past, prev.present],
        present: newPresent,
        future: newFuture
      };
    });
  }, []);
  const reset = import_react59.useCallback((doc) => {
    const validation = validateDoc(doc);
    if (!validation.success) {
      console.warn("[useSlideHistory] Doc validation failed:", validation.errors);
    }
    setHistory({
      past: [],
      present: doc,
      future: []
    });
  }, []);
  return {
    doc: history.present,
    setDoc,
    canUndo: history.past.length > 0,
    canRedo: history.future.length > 0,
    undo,
    redo,
    reset
  };
}

// ../../src/features/slide-editor/hooks/useFitToScreen.ts
var import_react60 = __toESM(require_react(), 1);
function useFitToScreen(containerRef, slideWidthMm, slideHeightMm, marginRatio = 0.9) {
  const [zoom, setZoom] = import_react60.useState(100);
  const calculateZoom = import_react60.useCallback(() => {
    if (!containerRef.current)
      return;
    const { clientWidth, clientHeight } = containerRef.current;
    if (clientWidth === 0 || clientHeight === 0)
      return;
    const dpi3 = 96;
    const slideWidthPx = mmToPx(slideWidthMm, { dpi: dpi3 });
    const slideHeightPx = mmToPx(slideHeightMm, { dpi: dpi3 });
    const fitW = clientWidth / slideWidthPx;
    const fitH = clientHeight / slideHeightPx;
    const scale = Math.min(fitW, fitH) * marginRatio;
    setZoom(Math.floor(scale * 100));
  }, [containerRef, slideWidthMm, slideHeightMm, marginRatio]);
  import_react60.useEffect(() => {
    if (!containerRef.current)
      return;
    const observer = new ResizeObserver(() => {
      calculateZoom();
    });
    observer.observe(containerRef.current);
    calculateZoom();
    return () => observer.disconnect();
  }, [containerRef, calculateZoom]);
  return { zoom, calculateZoom };
}

// ../../src/features/slide-editor/hooks/useMasterModeToggle.ts
var import_react61 = __toESM(require_react(), 1);

// ../../src/features/slide-editor/utils/slideHelpers.ts
function isMasterSurface(surface) {
  if (!surface)
    return false;
  return !surface.masterId && surface.id !== "master-blank";
}
function getFirstSlideId(surfaces) {
  return surfaces.find((s2) => !!s2.masterId)?.id || surfaces[0]?.id || "";
}
function getFirstMasterId(surfaces) {
  return surfaces.find((s2) => !s2.masterId && s2.id !== "master-blank")?.id;
}
function processMasterNodesForDisplay(masterNodes, pageNumber) {
  return masterNodes.filter((n2) => !n2.isPlaceholder).map((n2) => {
    const node = { ...n2, locked: true };
    if (node.t === "text" && node.dynamicContent === "slide-number") {
      return { ...node, text: String(pageNumber) };
    }
    return node;
  });
}
function mergeDisplayNodes(isMasterEditMode, processedMasterNodes, currentSurfaceNodes) {
  if (isMasterEditMode) {
    return currentSurfaceNodes;
  }
  return [...processedMasterNodes, ...currentSurfaceNodes];
}
function getSlidePageNumber(surfaces, currentSlideId) {
  const slides = surfaces.filter((s2) => !!s2.masterId);
  const index2 = slides.findIndex((s2) => s2.id === currentSlideId);
  return index2 >= 0 ? index2 + 1 : 1;
}
function getTargetMasterIdForEdit(currentSlide, surfaces) {
  let targetMasterId = currentSlide?.masterId;
  if (!targetMasterId || targetMasterId === "master-blank") {
    targetMasterId = getFirstMasterId(surfaces);
  }
  if (targetMasterId && surfaces.find((s2) => s2.id === targetMasterId)) {
    return targetMasterId;
  }
  return getFirstMasterId(surfaces);
}
function getTargetSlideIdForExit(lastSlideId, surfaces) {
  return lastSlideId || getFirstSlideId(surfaces);
}

// ../../src/features/slide-editor/hooks/useMasterModeToggle.ts
function useMasterModeToggle({
  currentSlideId,
  currentSlide,
  doc,
  isMasterEditMode,
  setCurrentSlideId
}) {
  const lastSlideIdRef = import_react61.useRef(null);
  const handleToggleMasterEdit = import_react61.useCallback(() => {
    if (isMasterEditMode) {
      const targetId = getTargetSlideIdForExit(lastSlideIdRef.current, doc.surfaces);
      console.log("[useMasterModeToggle] Exiting Master Mode. Target ID:", targetId);
      setCurrentSlideId(targetId);
    } else {
      lastSlideIdRef.current = currentSlideId;
      const targetMasterId = getTargetMasterIdForEdit(currentSlide, doc.surfaces);
      if (targetMasterId) {
        console.log("[useMasterModeToggle] Entering Master Mode. Target Master ID:", targetMasterId);
        setCurrentSlideId(targetMasterId);
      } else {
        const anyMaster = getFirstMasterId(doc.surfaces);
        if (anyMaster) {
          console.log("[useMasterModeToggle] Falling back to any master:", anyMaster);
          setCurrentSlideId(anyMaster);
        } else {
          console.warn("No master slide found to edit.");
        }
      }
    }
  }, [isMasterEditMode, currentSlideId, currentSlide, doc.surfaces, setCurrentSlideId]);
  return {
    handleToggleMasterEdit
  };
}

// ../../src/constants/pageSizes.ts
var PAGE_SIZES = {
  A4_LANDSCAPE: {
    id: "a4_landscape",
    name: "A4 Landscape",
    w: 297,
    h: 210
  },
  A4_PORTRAIT: {
    id: "a4_portrait",
    name: "A4 Portrait",
    w: 210,
    h: 297
  }
};

// ../../src/features/slide-editor/utils/slideFactories.ts
var generateMasterNodes = (surfaceId, w2, h3) => {
  return [{
    id: `master-pagenum-${surfaceId}`,
    t: "text",
    s: surfaceId,
    x: w2 - 20,
    y: h3 - 15,
    w: 15,
    h: 10,
    text: "#",
    dynamicContent: "slide-number",
    fontSize: ptToMm(12),
    align: "r",
    fill: "#94a3b8",
    locked: true
  }];
};
var INITIAL_MASTERS = SLIDE_LAYOUTS.map((layout) => ({
  surface: {
    id: `master-${layout.id}`,
    type: "slide",
    w: PAGE_SIZES.A4_LANDSCAPE.w,
    h: PAGE_SIZES.A4_LANDSCAPE.h,
    bg: "#ffffff"
  },
  nodes: [
    ...generateMasterNodes(`master-${layout.id}`, PAGE_SIZES.A4_LANDSCAPE.w, PAGE_SIZES.A4_LANDSCAPE.h),
    ...layout.generateNodes(`master-${layout.id}`, PAGE_SIZES.A4_LANDSCAPE.w, PAGE_SIZES.A4_LANDSCAPE.h)
  ]
}));
var INITIAL_DOC2 = {
  v: 1,
  id: "slide-doc-1",
  title: "New Presentation",
  unit: "mm",
  surfaces: [
    ...INITIAL_MASTERS.map((m3) => m3.surface),
    {
      id: "slide-1",
      type: "slide",
      w: PAGE_SIZES.A4_LANDSCAPE.w,
      h: PAGE_SIZES.A4_LANDSCAPE.h,
      bg: undefined,
      masterId: "master-title"
    }
  ],
  nodes: [
    ...INITIAL_MASTERS.flatMap((m3) => m3.nodes),
    ...SLIDE_LAYOUTS.find((l4) => l4.id === "title")?.generateNodes("slide-1", PAGE_SIZES.A4_LANDSCAPE.w, PAGE_SIZES.A4_LANDSCAPE.h) || []
  ]
};

// ../../src/features/slide-editor/hooks/useSlideOperations.ts
var import_react62 = __toESM(require_react(), 1);
var useSlideOperations = ({
  setDoc,
  currentSlideId,
  doc,
  setCurrentSlideId,
  isMasterEditMode
}) => {
  const currentSlide = doc.surfaces.find((s2) => s2.id === currentSlideId);
  const handleAddSlide = import_react62.useCallback((layoutId) => {
    const layout = SLIDE_LAYOUTS.find((l4) => l4.id === layoutId) || SLIDE_LAYOUTS[0];
    const generateLayoutNodes = (surfaceId, w2, h3) => {
      return layout.generateNodes(surfaceId, w2, h3) || [];
    };
    if (isMasterEditMode) {
      const newMasterId = `master-${crypto.randomUUID()}`;
      const newSurface = {
        id: newMasterId,
        type: "slide",
        w: currentSlide?.w || PAGE_SIZES.A4_LANDSCAPE.w,
        h: currentSlide?.h || PAGE_SIZES.A4_LANDSCAPE.h,
        bg: "#ffffff"
      };
      const newNodes = generateLayoutNodes(newMasterId, newSurface.w, newSurface.h);
      setDoc((prev) => ({
        ...prev,
        surfaces: [newSurface, ...prev.surfaces],
        nodes: [...prev.nodes, ...newNodes]
      }));
      setCurrentSlideId(newMasterId);
    } else {
      const newSlideId = `slide-${crypto.randomUUID()}`;
      const targetMasterId = `master-${layoutId}`;
      const masterSurface = doc.surfaces.find((s2) => s2.id === targetMasterId);
      const safeMasterId = masterSurface ? targetMasterId : "master-blank";
      const newSurface = {
        id: newSlideId,
        type: "slide",
        w: currentSlide?.w || PAGE_SIZES.A4_LANDSCAPE.w,
        h: currentSlide?.h || PAGE_SIZES.A4_LANDSCAPE.h,
        bg: undefined,
        masterId: safeMasterId
      };
      let newNodes = [];
      if (masterSurface) {
        const masterPlaceholders = doc.nodes.filter((n2) => n2.s === masterSurface.id && n2.isPlaceholder);
        newNodes = masterPlaceholders.map((n2) => ({
          ...n2,
          id: `${n2.t}-${crypto.randomUUID()}`,
          s: newSlideId,
          isPlaceholder: undefined,
          locked: false
        }));
      }
      setDoc((prev) => {
        const currentIndex = prev.surfaces.findIndex((s2) => s2.id === currentSlideId);
        const insertIndex = currentIndex >= 0 ? currentIndex + 1 : prev.surfaces.length;
        const newSurfaces = [...prev.surfaces];
        newSurfaces.splice(insertIndex, 0, newSurface);
        return {
          ...prev,
          surfaces: newSurfaces,
          nodes: [...prev.nodes, ...newNodes]
        };
      }, { saveToHistory: true });
      setCurrentSlideId(newSlideId);
    }
  }, [currentSlideId, currentSlide, isMasterEditMode, setDoc, doc.surfaces, doc.nodes, setCurrentSlideId]);
  const handleSelectTemplate = import_react62.useCallback((templateId) => {
    const template = SLIDE_TEMPLATES.find((t2) => t2.id === templateId);
    if (!template)
      return;
    setDoc((prev) => {
      const masterSurfaces = prev.surfaces.filter((s2) => !s2.masterId && s2.type === "slide");
      const newSurfaces = prev.surfaces.map((s2) => {
        if (masterSurfaces.find((m3) => m3.id === s2.id)) {
          return { ...s2, bg: template.master.bg };
        }
        return s2;
      });
      let newNodes = prev.nodes.filter((n2) => {
        if (!masterSurfaces.find((m3) => m3.id === n2.s))
          return true;
        if (n2.isPlaceholder)
          return true;
        return false;
      }).map((n2) => {
        if (n2.isPlaceholder && n2.t === "text" && template.master.textColor) {
          return { ...n2, fill: template.master.textColor };
        }
        return n2;
      });
      masterSurfaces.forEach((master) => {
        const templateNodesForMaster = template.master.nodes.map((n2) => ({
          ...n2,
          id: `${n2.t}-${crypto.randomUUID()}`,
          s: master.id
        }));
        newNodes = [...newNodes, ...templateNodesForMaster];
      });
      return {
        ...prev,
        surfaces: newSurfaces,
        nodes: newNodes
      };
    });
  }, [setDoc]);
  return {
    handleAddSlide,
    handleSelectTemplate
  };
};

// ../../src/features/slide-editor/components/SlideEditor.tsx
var jsx_dev_runtime82 = __toESM(require_jsx_dev_runtime(), 1);
var SlideEditor = ({
  loadDoc,
  loadNonce,
  onDocChange,
  onMasterModeChange,
  savedMasters,
  onLoadSavedMaster,
  toolbarActions
}) => {
  const { doc, setDoc, undo, redo, canUndo, canRedo, reset } = useSlideHistory(INITIAL_DOC2);
  const [currentSlideId, setCurrentSlideId] = import_react63.useState(() => {
    return doc.surfaces.find((s2) => !!s2.masterId)?.id || doc.surfaces[0]?.id || "";
  });
  const [selectedIds, setSelectedIds] = import_react63.useState([]);
  const [activeTool, setActiveTool] = import_react63.useState("select");
  const [isPresentationMode, setIsPresentationMode] = import_react63.useState(false);
  const [showGrid, setShowGrid] = import_react63.useState(false);
  const [gridSize, setGridSize] = import_react63.useState(15);
  const [snapStrength, setSnapStrength] = import_react63.useState(5);
  const editorContainerRef = import_react63.useRef(null);
  const canvasRef = import_react63.useRef(null);
  const lastLoadNonceRef = import_react63.useRef(undefined);
  import_react63.useEffect(() => {
    onDocChange?.(doc);
  }, [doc, onDocChange]);
  import_react63.useEffect(() => {
    if (!loadDoc)
      return;
    if (loadNonce === undefined)
      return;
    if (lastLoadNonceRef.current === loadNonce)
      return;
    console.log("[SlideEditor] loadDoc starting...", loadNonce);
    const nextSlideId = loadDoc.surfaces.find((s2) => !!s2.masterId)?.id || loadDoc.surfaces[0]?.id || "";
    console.log("[SlideEditor] loadDoc surfaces:", loadDoc.surfaces.map((s2) => ({ id: s2.id, mid: s2.masterId })));
    console.log("[SlideEditor] loadDoc target slide detected:", nextSlideId);
    reset(loadDoc);
    setSelectedIds([]);
    setActiveTool("select");
    setIsPresentationMode(false);
    setShowGrid(false);
    setThumbnails({});
    console.log("[SlideEditor] loadDoc target slide:", nextSlideId);
    setCurrentSlideId(nextSlideId);
    lastLoadNonceRef.current = loadNonce;
  }, [loadDoc, loadNonce, reset]);
  import_react63.useEffect(() => {
    if (!doc.surfaces.find((s2) => s2.id === currentSlideId)) {
      if (doc.surfaces.length > 0) {
        const fallbackId = doc.surfaces.find((s2) => !!s2.masterId)?.id || doc.surfaces[0].id;
        console.log("[SlideEditor] Missing currentSlideId fallback to:", fallbackId);
        setCurrentSlideId(fallbackId);
      }
    }
  }, [doc.surfaces, currentSlideId]);
  const currentSlide = doc.surfaces.find((s2) => s2.id === currentSlideId);
  const isMasterEditMode = isMasterSurface(currentSlide);
  import_react63.useEffect(() => {
    console.log("[SlideEditor] State Check:", {
      currentSlideId,
      isMasterEditMode,
      surfaceCount: doc.surfaces.length,
      currentSlideFound: !!currentSlide,
      currentSlideMasterId: currentSlide?.masterId,
      docId: doc.id
    });
  }, [currentSlideId, isMasterEditMode, doc.surfaces.length, currentSlide, doc.id]);
  import_react63.useEffect(() => {
    onMasterModeChange?.(isMasterEditMode);
  }, [isMasterEditMode, onMasterModeChange]);
  const masterSurfaceForSlide = currentSlide?.masterId ? doc.surfaces.find((s2) => s2.id === currentSlide.masterId) : null;
  const masterNodes = masterSurfaceForSlide ? doc.nodes.filter((n2) => n2.s === masterSurfaceForSlide.id) : [];
  const currentSurfaceNodes = doc.nodes.filter((n2) => n2.s === currentSlideId);
  const pageNumber = getSlidePageNumber(doc.surfaces, currentSlideId);
  const processedMasterNodes = processMasterNodesForDisplay(masterNodes, pageNumber);
  const displayNodes = mergeDisplayNodes(isMasterEditMode, processedMasterNodes, currentSurfaceNodes);
  const { handleToggleMasterEdit } = useMasterModeToggle({
    currentSlideId,
    currentSlide,
    doc,
    isMasterEditMode,
    setCurrentSlideId
  });
  const { zoom } = useFitToScreen(editorContainerRef, currentSlide?.w || PAGE_SIZES.A4_LANDSCAPE.w, currentSlide?.h || PAGE_SIZES.A4_LANDSCAPE.h);
  const [userZoom, setUserZoom] = import_react63.useState(null);
  const effectiveZoom = userZoom ?? zoom;
  const handleZoomChange = (z) => {
    setUserZoom(Math.max(10, Math.min(400, z)));
  };
  const [thumbnails, setThumbnails] = import_react63.useState({});
  const captureThumbnail = import_react63.useCallback(() => {
    if (!canvasRef.current)
      return;
    const stage = canvasRef.current.getStage();
    if (!stage)
      return;
    const width = stage.width();
    const targetWidth = 300;
    const pixelRatio = targetWidth / width;
    try {
      const dataURL = stage.toDataURL({ pixelRatio: Number.isFinite(pixelRatio) ? pixelRatio : 0.2 });
      setThumbnails((prev) => ({
        ...prev,
        [currentSlideId]: dataURL
      }));
    } catch (e2) {
      console.error("Failed to capture thumbnail", e2);
    }
  }, [currentSlideId]);
  const handleStageInteractionEnd = import_react63.useCallback(() => {
    setTimeout(captureThumbnail, 50);
  }, [captureThumbnail]);
  import_react63.useEffect(() => {
    const timer = setTimeout(captureThumbnail, 500);
    return () => clearTimeout(timer);
  }, [currentSlideId, captureThumbnail]);
  import_react63.useEffect(() => {
    const timer = setTimeout(captureThumbnail, 500);
    return () => clearTimeout(timer);
  }, [doc.nodes, captureThumbnail]);
  const handleSelect = import_react63.useCallback((ids) => {
    setSelectedIds(ids);
  }, []);
  const selectedElementId = selectedIds.length === 1 ? selectedIds[0] : null;
  const handleCanvasChange = import_react63.useCallback((updates, options2) => {
    setDoc((prev) => {
      const changesArray = Array.isArray(updates) ? updates : [updates];
      const updateMap = new Map(changesArray.map((u2) => [u2.id, u2]));
      const nextNodes = prev.nodes.map((n2) => {
        if (n2.id && updateMap.has(n2.id)) {
          return { ...n2, ...updateMap.get(n2.id) };
        }
        return n2;
      });
      return { ...prev, nodes: nextNodes };
    }, options2);
  }, [setDoc]);
  const { handleAddSlide, handleSelectTemplate } = useSlideOperations({
    setDoc,
    currentSlideId,
    doc,
    setCurrentSlideId,
    isMasterEditMode
  });
  const handleExport = import_react63.useCallback(async () => {
    try {
      await exportToPptx(doc, `${doc.title || "presentation"}.pptx`);
    } catch (e2) {
      alert("Failed to export PPTX");
      console.error(e2);
    }
  }, [doc]);
  const handleExportImage = import_react63.useCallback(() => {
    const stage = canvasRef.current?.getStage();
    if (!stage)
      return;
    const dataURL = stage.toDataURL({ pixelRatio: 2 });
    const link = document.createElement("a");
    link.download = `${doc.title || "presentation"}.png`;
    link.href = dataURL;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }, [doc.title]);
  if (isPresentationMode) {
    return /* @__PURE__ */ jsx_dev_runtime82.jsxDEV(PresentationMode, {
      doc,
      initialSlideId: currentSlideId,
      onExit: () => setIsPresentationMode(false)
    }, undefined, false, undefined, this);
  }
  return /* @__PURE__ */ jsx_dev_runtime82.jsxDEV("div", {
    className: "flex flex-col w-full h-full bg-background overflow-hidden",
    children: [
      /* @__PURE__ */ jsx_dev_runtime82.jsxDEV(TopToolbar, {
        doc,
        presentationTitle: doc.title ?? "",
        onPresentationTitleChange: (title) => {
          setDoc((prev) => ({
            ...prev,
            title
          }));
        },
        currentSlideId,
        onDocChange: setDoc,
        onSelectElement: (id) => setSelectedIds([id]),
        zoom: effectiveZoom,
        onZoomChange: handleZoomChange,
        onPlay: () => setIsPresentationMode(true),
        onExport: handleExport,
        onExportImage: handleExportImage,
        canUndo,
        canRedo,
        onUndo: undo,
        onRedo: redo,
        activeTool,
        onToolSelect: setActiveTool,
        onAddSlide: handleAddSlide,
        isMasterEditMode,
        onToggleMasterEdit: handleToggleMasterEdit,
        onSelectTemplate: handleSelectTemplate,
        savedMasters,
        onLoadSavedMaster,
        extraActions: toolbarActions
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime82.jsxDEV("div", {
        className: "flex-1 flex overflow-hidden",
        children: [
          /* @__PURE__ */ jsx_dev_runtime82.jsxDEV("div", {
            className: "w-48 flex-shrink-0",
            children: /* @__PURE__ */ jsx_dev_runtime82.jsxDEV(SlideListPanel, {
              doc,
              currentSlideId,
              onSlideSelect: setCurrentSlideId,
              onChange: setDoc,
              thumbnails,
              onAddSlide: handleAddSlide,
              isMasterEditMode
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime82.jsxDEV("div", {
            className: "flex-1 relative overflow-hidden bg-gray-100 dark:bg-gray-900",
            ref: editorContainerRef,
            children: currentSlide && /* @__PURE__ */ jsx_dev_runtime82.jsxDEV(KonvaCanvasEditor, {
              ref: canvasRef,
              elements: displayNodes,
              selectedIds,
              onSelect: handleSelect,
              onChange: handleCanvasChange,
              zoom: effectiveZoom / 100,
              paperWidth: currentSlide?.w || PAGE_SIZES.A4_LANDSCAPE.w,
              paperHeight: currentSlide?.h || PAGE_SIZES.A4_LANDSCAPE.h,
              background: /* @__PURE__ */ jsx_dev_runtime82.jsxDEV(Rect2, {
                x: 0,
                y: 0,
                width: currentSlide?.w || PAGE_SIZES.A4_LANDSCAPE.w,
                height: currentSlide?.h || PAGE_SIZES.A4_LANDSCAPE.h,
                fill: isMasterEditMode ? currentSlide?.bg || "#ffffff" : currentSlide?.bg || masterSurfaceForSlide?.bg || "#ffffff"
              }, undefined, false, undefined, this),
              showGrid,
              onUndo: undo,
              onRedo: redo,
              onDelete: () => {
                if (selectedIds.length > 0) {
                  setDoc((prev) => ({
                    ...prev,
                    nodes: prev.nodes.filter((n2) => !selectedIds.includes(n2.id))
                  }));
                }
              },
              onCreateElements: (newNodes) => {
                const nodesWithSurface = newNodes.map((n2) => ({
                  ...n2,
                  s: currentSlideId
                }));
                setDoc((prev) => ({
                  ...prev,
                  nodes: [...prev.nodes, ...nodesWithSurface]
                }));
              },
              className: "flex items-center justify-center",
              onStageMouseUp: handleStageInteractionEnd
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime82.jsxDEV("div", {
            className: "w-72 border-l border-border bg-background",
            children: /* @__PURE__ */ jsx_dev_runtime82.jsxDEV(WysiwygPropertiesPanel, {
              templateDoc: doc,
              selectedElementId,
              onTemplateChange: setDoc,
              currentPageId: currentSlideId,
              showGrid,
              onShowGridChange: setShowGrid,
              gridSize,
              onGridSizeChange: setGridSize,
              snapStrength,
              onSnapStrengthChange: setSnapStrength
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
// ../../src/modules/queue/QueueContext.tsx
var import_react64 = __toESM(require_react(), 1);
var jsx_dev_runtime83 = __toESM(require_jsx_dev_runtime(), 1);
var QueueContext = import_react64.createContext(undefined);
var QueueProvider = ({
  children,
  maxConcurrent = 3
}) => {
  const [items, setItems] = import_react64.useState([]);
  const itemsRef = import_react64.useRef([]);
  const updateItem = import_react64.useCallback((id, updates) => {
    itemsRef.current = itemsRef.current.map((item) => item.id === id ? { ...item, ...updates } : item);
    setItems(itemsRef.current);
  }, []);
  const stats = import_react64.useMemo(() => {
    return items.reduce((acc, item) => {
      acc.total++;
      acc[item.status]++;
      return acc;
    }, {
      total: 0,
      pending: 0,
      in_progress: 0,
      completed: 0,
      failed: 0,
      cancelled: 0
    });
  }, [items]);
  const runTask = import_react64.useCallback(async (item) => {
    const abortController = new AbortController;
    updateItem(item.id, {
      status: "in_progress",
      startedAt: new Date,
      abortController,
      progress: 0,
      error: undefined
    });
    try {
      const result = await item.handler(item, (progress) => updateItem(item.id, { progress }), abortController.signal);
      updateItem(item.id, {
        status: "completed",
        completedAt: new Date,
        progress: 100,
        result
      });
    } catch (err) {
      if (err.name === "AbortError" || err.message === "Cancelled") {
        updateItem(item.id, { status: "cancelled", completedAt: new Date });
      } else {
        updateItem(item.id, {
          status: "failed",
          completedAt: new Date,
          error: err.message || "Unknown error"
        });
      }
    }
  }, [updateItem]);
  import_react64.useEffect(() => {
    const pendingTasks = items.filter((item) => item.status === "pending");
    const runningCount = items.filter((item) => item.status === "in_progress").length;
    if (pendingTasks.length > 0 && runningCount < maxConcurrent) {
      const nextTask = pendingTasks[0];
      runTask(nextTask);
    }
  }, [items, maxConcurrent, runTask]);
  const addTask = import_react64.useCallback((name, handler) => {
    const id = Math.random().toString(36).substring(2, 11);
    const newItem = {
      id,
      name,
      status: "pending",
      progress: 0,
      handler
    };
    itemsRef.current = [...itemsRef.current, newItem];
    setItems(itemsRef.current);
    return id;
  }, []);
  const cancelTask = import_react64.useCallback((id) => {
    const item = itemsRef.current.find((i4) => i4.id === id);
    if (item?.status === "in_progress" && item.abortController) {
      item.abortController.abort();
    } else if (item?.status === "pending") {
      updateItem(id, { status: "cancelled" });
    }
  }, [updateItem]);
  const retryTask = import_react64.useCallback((id) => {
    const item = itemsRef.current.find((i4) => i4.id === id);
    if (item && (item.status === "failed" || item.status === "cancelled")) {
      updateItem(id, { status: "pending", progress: 0, error: undefined, result: undefined });
    }
  }, [updateItem]);
  const removeTask = import_react64.useCallback((id) => {
    const item = itemsRef.current.find((i4) => i4.id === id);
    if (item?.status === "in_progress") {
      cancelTask(id);
    }
    itemsRef.current = itemsRef.current.filter((i4) => i4.id !== id);
    setItems(itemsRef.current);
  }, [cancelTask]);
  const clear = import_react64.useCallback(() => {
    itemsRef.current.forEach((item) => {
      if (item.status === "in_progress" && item.abortController) {
        item.abortController.abort();
      }
    });
    itemsRef.current = [];
    setItems([]);
  }, []);
  const clearCompleted = import_react64.useCallback(() => {
    itemsRef.current = itemsRef.current.filter((item) => item.status !== "completed" && item.status !== "cancelled");
    setItems(itemsRef.current);
  }, []);
  return /* @__PURE__ */ jsx_dev_runtime83.jsxDEV(QueueContext.Provider, {
    value: {
      items,
      stats,
      addTask,
      cancelTask,
      retryTask,
      removeTask,
      clear,
      clearCompleted
    },
    children
  }, undefined, false, undefined, this);
};
// ../../src/modules/queue/hooks.ts
var import_react65 = __toESM(require_react(), 1);
var useQueue = () => {
  const context = import_react65.useContext(QueueContext);
  if (!context) {
    throw new Error("useQueue must be used within a QueueProvider");
  }
  return context;
};
var useQueueItem = (id) => {
  const { items, cancelTask, retryTask, removeTask } = useQueue();
  const item = items.find((i4) => i4.id === id);
  return {
    item,
    cancel: () => cancelTask(id),
    retry: () => retryTask(id),
    remove: () => removeTask(id)
  };
};
// ../../src/components/ui/queue/QueueViewer.tsx
var import_react67 = __toESM(require_react(), 1);

// ../../src/components/ui/queue/QueueHeader.tsx
var jsx_dev_runtime84 = __toESM(require_jsx_dev_runtime(), 1);
var QueueHeader = ({ expanded, onToggle, onClose }) => {
  const { stats, items, clearCompleted } = useQueue();
  const handleToggleKeyDown = (event) => {
    if (event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      onToggle();
    }
  };
  const isRunning = stats.inProgress > 0;
  const hasFailed = stats.failed > 0;
  const isAllCompleted = stats.total > 0 && stats.completed === stats.total;
  let bgColor = "bg-background";
  let textColor = "text-foreground";
  let borderColor = "border-border";
  if (!expanded) {
    if (isRunning) {
      bgColor = "bg-blue-50 dark:bg-blue-900/20";
      textColor = "text-blue-600 dark:text-blue-400";
      borderColor = "border-blue-200 dark:border-blue-800";
    } else if (hasFailed) {
      bgColor = "bg-red-50 dark:bg-red-900/20";
      textColor = "text-red-600 dark:text-red-400";
      borderColor = "border-red-200 dark:border-red-800";
    } else if (isAllCompleted) {
      bgColor = "bg-green-50 dark:bg-green-900/20";
      textColor = "text-green-600 dark:text-green-400";
      borderColor = "border-green-200 dark:border-green-800";
    }
  }
  const currentTask = items.find((item) => item.status === "in_progress");
  return /* @__PURE__ */ jsx_dev_runtime84.jsxDEV("div", {
    className: cn("flex items-center justify-between gap-2 border-b p-3 transition-colors duration-300", bgColor, borderColor),
    children: [
      /* @__PURE__ */ jsx_dev_runtime84.jsxDEV("div", {
        className: cn("flex flex-1 items-center gap-2 text-sm font-semibold cursor-pointer", textColor),
        role: "button",
        tabIndex: 0,
        "aria-expanded": expanded,
        onClick: onToggle,
        onKeyDown: handleToggleKeyDown,
        children: [
          expanded ? /* @__PURE__ */ jsx_dev_runtime84.jsxDEV(ChevronDown, {
            className: "h-4 w-4"
          }, undefined, false, undefined, this) : /* @__PURE__ */ jsx_dev_runtime84.jsxDEV(ChevronUp, {
            className: "h-4 w-4"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime84.jsxDEV("div", {
            className: "flex items-center gap-2",
            children: [
              !expanded && isRunning && /* @__PURE__ */ jsx_dev_runtime84.jsxDEV(LoaderCircle, {
                className: "h-4 w-4 animate-spin"
              }, undefined, false, undefined, this),
              !expanded && hasFailed && !isRunning && /* @__PURE__ */ jsx_dev_runtime84.jsxDEV(CircleAlert, {
                className: "h-4 w-4"
              }, undefined, false, undefined, this),
              !expanded && isAllCompleted && /* @__PURE__ */ jsx_dev_runtime84.jsxDEV(CheckCheck, {
                className: "h-4 w-4"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime84.jsxDEV("span", {
                className: "truncate max-w-[200px]",
                children: !expanded && currentTask ? currentTask.name : !expanded && hasFailed ? "Task Failed" : !expanded && isAllCompleted ? "All Completed" : "Tasks"
              }, undefined, false, undefined, this),
              expanded && /* @__PURE__ */ jsx_dev_runtime84.jsxDEV("span", {
                className: "text-xs font-normal opacity-70",
                children: [
                  "(",
                  stats.completed,
                  " / ",
                  stats.total,
                  ")"
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime84.jsxDEV("div", {
        className: "flex items-center gap-1",
        children: expanded ? /* @__PURE__ */ jsx_dev_runtime84.jsxDEV(jsx_dev_runtime84.Fragment, {
          children: [
            stats.completed > 0 && /* @__PURE__ */ jsx_dev_runtime84.jsxDEV(Button, {
              variant: "ghost",
              size: "icon",
              onClick: clearCompleted,
              title: "Clear Completed",
              className: "h-8 w-8",
              children: /* @__PURE__ */ jsx_dev_runtime84.jsxDEV(CheckCheck, {
                className: "h-4 w-4"
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx_dev_runtime84.jsxDEV(Button, {
              variant: "ghost",
              size: "icon",
              onClick: onClose,
              title: "Close",
              className: "h-8 w-8",
              children: /* @__PURE__ */ jsx_dev_runtime84.jsxDEV(X, {
                className: "h-4 w-4"
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this) : /* @__PURE__ */ jsx_dev_runtime84.jsxDEV(Button, {
          variant: "ghost",
          size: "icon",
          onClick: (e2) => {
            e2.stopPropagation();
            onClose();
          },
          className: cn("h-8 w-8 hover:bg-muted", textColor),
          title: "Close",
          children: /* @__PURE__ */ jsx_dev_runtime84.jsxDEV(X, {
            className: "h-4 w-4"
          }, undefined, false, undefined, this)
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/components/ui/queue/QueueItem.tsx
var import_react66 = __toESM(require_react(), 1);
var jsx_dev_runtime85 = __toESM(require_jsx_dev_runtime(), 1);
var QueueItem = ({ item }) => {
  const { cancel, retry, remove } = useQueueItem(item.id);
  const elapsed = import_react66.useMemo(() => {
    if (!item.startedAt)
      return null;
    const end = item.completedAt || new Date;
    const seconds = Math.floor((end.getTime() - item.startedAt.getTime()) / 1000);
    return seconds;
  }, [item.startedAt, item.completedAt]);
  const statusDisplay = import_react66.useMemo(() => {
    switch (item.status) {
      case "pending":
        return {
          icon: /* @__PURE__ */ jsx_dev_runtime85.jsxDEV(Clock, {
            className: "h-5 w-5 text-muted-foreground"
          }, undefined, false, undefined, this),
          bgColor: "bg-background"
        };
      case "in_progress":
        return {
          icon: /* @__PURE__ */ jsx_dev_runtime85.jsxDEV(LoaderCircle, {
            className: "h-5 w-5 animate-spin text-blue-500"
          }, undefined, false, undefined, this),
          bgColor: "bg-blue-50/50 dark:bg-blue-900/10"
        };
      case "completed":
        return {
          icon: /* @__PURE__ */ jsx_dev_runtime85.jsxDEV(Check, {
            className: "h-5 w-5 text-green-500"
          }, undefined, false, undefined, this),
          bgColor: "bg-green-50/50 dark:bg-green-900/10"
        };
      case "failed":
        return {
          icon: /* @__PURE__ */ jsx_dev_runtime85.jsxDEV(CircleAlert, {
            className: "h-5 w-5 text-red-500"
          }, undefined, false, undefined, this),
          bgColor: "bg-red-50/50 dark:bg-red-900/10"
        };
      case "cancelled":
        return {
          icon: /* @__PURE__ */ jsx_dev_runtime85.jsxDEV(X, {
            className: "h-5 w-5 text-muted-foreground"
          }, undefined, false, undefined, this),
          bgColor: "bg-background"
        };
      default:
        return {
          icon: /* @__PURE__ */ jsx_dev_runtime85.jsxDEV(Clock, {
            className: "h-5 w-5 text-muted-foreground"
          }, undefined, false, undefined, this),
          bgColor: "bg-background"
        };
    }
  }, [item.status]);
  return /* @__PURE__ */ jsx_dev_runtime85.jsxDEV("div", {
    className: cn("flex items-center gap-3 rounded-md border p-3 transition-colors", "border-border hover:bg-muted/50", statusDisplay.bgColor),
    children: [
      /* @__PURE__ */ jsx_dev_runtime85.jsxDEV("div", {
        className: "flex-shrink-0",
        children: statusDisplay.icon
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime85.jsxDEV("div", {
        className: "flex-1 min-w-0",
        children: [
          /* @__PURE__ */ jsx_dev_runtime85.jsxDEV("div", {
            className: "truncate text-sm font-medium text-foreground",
            children: item.name
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime85.jsxDEV("div", {
            className: "flex items-center gap-2 mt-0.5",
            children: [
              item.status === "in_progress" && /* @__PURE__ */ jsx_dev_runtime85.jsxDEV("div", {
                className: "flex-1 h-1 bg-muted rounded-full overflow-hidden",
                children: /* @__PURE__ */ jsx_dev_runtime85.jsxDEV("div", {
                  className: "h-full bg-blue-500 transition-all duration-300",
                  style: { width: `${item.progress}%` }
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              elapsed !== null && /* @__PURE__ */ jsx_dev_runtime85.jsxDEV("div", {
                className: "text-[10px] text-muted-foreground",
                children: [
                  elapsed,
                  "s"
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this),
          item.error && /* @__PURE__ */ jsx_dev_runtime85.jsxDEV("div", {
            className: "mt-1 text-xs text-red-500 line-clamp-2",
            children: item.error
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime85.jsxDEV("div", {
        className: "flex items-center gap-1 flex-shrink-0",
        children: [
          item.status === "in_progress" && /* @__PURE__ */ jsx_dev_runtime85.jsxDEV(Button, {
            variant: "ghost",
            size: "icon",
            onClick: cancel,
            title: "Cancel",
            className: "h-7 w-7",
            children: /* @__PURE__ */ jsx_dev_runtime85.jsxDEV(X, {
              className: "h-4 w-4"
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          item.status === "failed" && /* @__PURE__ */ jsx_dev_runtime85.jsxDEV(Button, {
            variant: "ghost",
            size: "icon",
            onClick: retry,
            title: "Retry",
            className: "h-7 w-7",
            children: /* @__PURE__ */ jsx_dev_runtime85.jsxDEV(RefreshCw, {
              className: "h-4 w-4"
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this),
          (item.status === "completed" || item.status === "failed" || item.status === "cancelled") && /* @__PURE__ */ jsx_dev_runtime85.jsxDEV(Button, {
            variant: "ghost",
            size: "icon",
            onClick: remove,
            title: "Remove",
            className: "h-7 w-7",
            children: /* @__PURE__ */ jsx_dev_runtime85.jsxDEV(X, {
              className: "h-4 w-4"
            }, undefined, false, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// ../../src/components/ui/queue/QueueViewer.tsx
var jsx_dev_runtime86 = __toESM(require_jsx_dev_runtime(), 1);
var positionClasses = {
  "bottom-right": "bottom-4 right-4",
  "bottom-left": "bottom-4 left-4",
  "top-right": "top-4 right-4",
  "top-left": "top-4 left-4"
};
var QueueViewer = ({
  position = "bottom-right",
  defaultExpanded = true,
  maxHeight = 400,
  className
}) => {
  const { items, stats, clear } = useQueue();
  const [expanded, setExpanded] = import_react67.useState(defaultExpanded);
  if (items.length === 0)
    return null;
  const handleClose = () => {
    if (stats.inProgress > 0) {
      if (window.confirm("Tasks are currently running. Stopping the queue will cancel all running tasks. Are you sure?")) {
        clear();
      }
    } else {
      clear();
    }
  };
  return /* @__PURE__ */ jsx_dev_runtime86.jsxDEV("div", {
    id: "queue-viewer",
    className: cn("fixed z-[100] w-80 overflow-hidden rounded-lg border border-border bg-background shadow-xl transition-all duration-300", positionClasses[position], className),
    children: [
      /* @__PURE__ */ jsx_dev_runtime86.jsxDEV(QueueHeader, {
        expanded,
        onToggle: () => setExpanded(!expanded),
        onClose: handleClose
      }, undefined, false, undefined, this),
      expanded && /* @__PURE__ */ jsx_dev_runtime86.jsxDEV("div", {
        className: "overflow-y-auto p-2 scrollbar-thin",
        style: { maxHeight: `${maxHeight}px` },
        children: /* @__PURE__ */ jsx_dev_runtime86.jsxDEV("div", {
          className: "flex flex-col gap-1.5",
          children: items.map((item) => /* @__PURE__ */ jsx_dev_runtime86.jsxDEV(QueueItem, {
            item
          }, item.id, false, undefined, this))
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
// ../../src/utils/docUnitConversion.ts
function isRecord(v2) {
  return typeof v2 === "object" && v2 !== null;
}
function convertMarginLikeToMm(m3, unit, options2) {
  if (!isRecord(m3))
    return;
  const t2 = typeof m3.t === "number" ? m3.t : typeof m3.top === "number" ? m3.top : undefined;
  const r3 = typeof m3.r === "number" ? m3.r : typeof m3.right === "number" ? m3.right : undefined;
  const b4 = typeof m3.b === "number" ? m3.b : typeof m3.bottom === "number" ? m3.bottom : undefined;
  const l4 = typeof m3.l === "number" ? m3.l : typeof m3.left === "number" ? m3.left : undefined;
  if (t2 === undefined || r3 === undefined || b4 === undefined || l4 === undefined)
    return;
  return {
    t: toMm(t2, unit, options2),
    r: toMm(r3, unit, options2),
    b: toMm(b4, unit, options2),
    l: toMm(l4, unit, options2)
  };
}
function convertSurfaceToMm(surface, unit, options2) {
  return {
    ...surface,
    w: toMm(surface.w, unit, options2),
    h: toMm(surface.h, unit, options2),
    margin: convertMarginLikeToMm(surface.margin, unit, options2) ?? surface.margin
  };
}
function convertNodeToMm(node, unit, options2) {
  if (node.t === "line") {
    return {
      ...node,
      pts: node.pts.map((v2) => toMm(v2, unit, options2)),
      strokeW: toMm(node.strokeW, unit, options2)
    };
  }
  if (node.t === "signature") {
    return {
      ...node,
      x: toMm(node.x, unit, options2),
      y: toMm(node.y, unit, options2),
      w: toMm(node.w, unit, options2),
      h: toMm(node.h, unit, options2),
      strokeW: toMm(node.strokeW, unit, options2),
      strokes: node.strokes.map((stroke) => stroke.map((v2) => toMm(v2, unit, options2)))
    };
  }
  if (node.t === "table") {
    return {
      ...node,
      x: toMm(node.x, unit, options2),
      y: toMm(node.y, unit, options2),
      w: toMm(node.w, unit, options2),
      h: toMm(node.h, unit, options2),
      table: {
        ...node.table,
        rows: node.table.rows.map((v2) => toMm(v2, unit, options2)),
        cols: node.table.cols.map((v2) => toMm(v2, unit, options2)),
        cells: node.table.cells.map((c3) => ({
          ...c3,
          borderW: typeof c3.borderW === "number" ? toMm(c3.borderW, unit, options2) : c3.borderW,
          fontSize: typeof c3.fontSize === "number" ? toMm(c3.fontSize, unit, options2) : c3.fontSize
        }))
      }
    };
  }
  if (node.t === "text") {
    return {
      ...node,
      x: toMm(node.x, unit, options2),
      y: toMm(node.y, unit, options2),
      w: toMm(node.w, unit, options2),
      h: toMm(node.h, unit, options2),
      strokeW: typeof node.strokeW === "number" ? toMm(node.strokeW, unit, options2) : node.strokeW,
      fontSize: typeof node.fontSize === "number" ? toMm(node.fontSize, unit, options2) : node.fontSize
    };
  }
  if (node.t === "shape") {
    return {
      ...node,
      x: toMm(node.x, unit, options2),
      y: toMm(node.y, unit, options2),
      w: toMm(node.w, unit, options2),
      h: toMm(node.h, unit, options2),
      strokeW: typeof node.strokeW === "number" ? toMm(node.strokeW, unit, options2) : node.strokeW,
      radius: typeof node.radius === "number" ? toMm(node.radius, unit, options2) : node.radius
    };
  }
  if (node.t === "image" || node.t === "group" || node.t === "widget") {
    return {
      ...node,
      x: toMm(node.x, unit, options2),
      y: toMm(node.y, unit, options2),
      w: toMm(node.w, unit, options2),
      h: toMm(node.h, unit, options2)
    };
  }
  return node;
}
function roundDoc(doc, digits) {
  const roundN = (v2) => roundTo(v2, digits);
  const surfaces = doc.surfaces.map((s2) => ({
    ...s2,
    w: roundN(s2.w),
    h: roundN(s2.h),
    margin: s2.margin ? {
      t: roundN(s2.margin.t),
      r: roundN(s2.margin.r),
      b: roundN(s2.margin.b),
      l: roundN(s2.margin.l)
    } : s2.margin
  }));
  const nodes = doc.nodes.map((n2) => {
    if (n2.t === "line") {
      return { ...n2, pts: n2.pts.map(roundN), strokeW: roundN(n2.strokeW) };
    }
    if (n2.t === "signature") {
      return {
        ...n2,
        x: roundN(n2.x),
        y: roundN(n2.y),
        w: roundN(n2.w),
        h: roundN(n2.h),
        strokeW: roundN(n2.strokeW),
        strokes: n2.strokes.map((s2) => s2.map(roundN))
      };
    }
    if (n2.t === "table") {
      return {
        ...n2,
        x: roundN(n2.x),
        y: roundN(n2.y),
        w: roundN(n2.w),
        h: roundN(n2.h),
        table: {
          ...n2.table,
          rows: n2.table.rows.map(roundN),
          cols: n2.table.cols.map(roundN),
          cells: n2.table.cells.map((c3) => ({
            ...c3,
            borderW: typeof c3.borderW === "number" ? roundN(c3.borderW) : c3.borderW,
            fontSize: typeof c3.fontSize === "number" ? roundN(c3.fontSize) : c3.fontSize
          }))
        }
      };
    }
    if (n2.t === "text") {
      return {
        ...n2,
        x: roundN(n2.x),
        y: roundN(n2.y),
        w: roundN(n2.w),
        h: roundN(n2.h),
        strokeW: typeof n2.strokeW === "number" ? roundN(n2.strokeW) : n2.strokeW,
        fontSize: typeof n2.fontSize === "number" ? roundN(n2.fontSize) : n2.fontSize
      };
    }
    if (n2.t === "shape") {
      return {
        ...n2,
        x: roundN(n2.x),
        y: roundN(n2.y),
        w: roundN(n2.w),
        h: roundN(n2.h),
        strokeW: typeof n2.strokeW === "number" ? roundN(n2.strokeW) : n2.strokeW,
        radius: typeof n2.radius === "number" ? roundN(n2.radius) : n2.radius
      };
    }
    if (n2.t === "image" || n2.t === "group" || n2.t === "widget") {
      return {
        ...n2,
        x: roundN(n2.x),
        y: roundN(n2.y),
        w: roundN(n2.w),
        h: roundN(n2.h)
      };
    }
    return n2;
  });
  return { ...doc, surfaces, nodes };
}
function convertDocToMm(input, options2 = {}) {
  if (!isRecord(input)) {
    throw new Error("convertDocToMm: input must be an object");
  }
  const assume = options2.assumeUnitIfMissing ?? "mm";
  const unit = typeof input.unit === "string" ? input.unit : assume;
  const doc = input;
  if (!Array.isArray(doc.surfaces) || !Array.isArray(doc.nodes)) {
    throw new Error("convertDocToMm: invalid doc shape");
  }
  const normalized = {
    ...doc,
    unit: "mm",
    surfaces: doc.surfaces.map((s2) => convertSurfaceToMm(s2, unit, options2)),
    nodes: doc.nodes.map((n2) => convertNodeToMm(n2, unit, options2))
  };
  const digits = options2.roundDigitsForSave ?? 3;
  return roundDoc(normalized, digits);
}
function denormalizeMargin(m3, unit, options2) {
  if (!m3)
    return m3;
  return {
    t: fromMm(m3.t, unit, options2),
    r: fromMm(m3.r, unit, options2),
    b: fromMm(m3.b, unit, options2),
    l: fromMm(m3.l, unit, options2)
  };
}
function denormalizeSurface(surface, unit, options2) {
  return {
    ...surface,
    w: fromMm(surface.w, unit, options2),
    h: fromMm(surface.h, unit, options2),
    margin: denormalizeMargin(surface.margin, unit, options2)
  };
}
function denormalizeNode(node, unit, options2) {
  if (node.t === "line") {
    return {
      ...node,
      pts: node.pts.map((v2) => fromMm(v2, unit, options2)),
      strokeW: fromMm(node.strokeW, unit, options2)
    };
  }
  if (node.t === "signature") {
    return {
      ...node,
      x: fromMm(node.x, unit, options2),
      y: fromMm(node.y, unit, options2),
      w: fromMm(node.w, unit, options2),
      h: fromMm(node.h, unit, options2),
      strokeW: fromMm(node.strokeW, unit, options2),
      strokes: node.strokes.map((stroke) => stroke.map((v2) => fromMm(v2, unit, options2)))
    };
  }
  if (node.t === "table") {
    return {
      ...node,
      x: fromMm(node.x, unit, options2),
      y: fromMm(node.y, unit, options2),
      w: fromMm(node.w, unit, options2),
      h: fromMm(node.h, unit, options2),
      table: {
        ...node.table,
        rows: node.table.rows.map((v2) => fromMm(v2, unit, options2)),
        cols: node.table.cols.map((v2) => fromMm(v2, unit, options2)),
        cells: node.table.cells.map((c3) => ({
          ...c3,
          borderW: typeof c3.borderW === "number" ? fromMm(c3.borderW, unit, options2) : c3.borderW,
          fontSize: typeof c3.fontSize === "number" ? fromMm(c3.fontSize, unit, options2) : c3.fontSize
        }))
      }
    };
  }
  if (node.t === "text") {
    return {
      ...node,
      x: fromMm(node.x, unit, options2),
      y: fromMm(node.y, unit, options2),
      w: fromMm(node.w, unit, options2),
      h: fromMm(node.h, unit, options2),
      strokeW: typeof node.strokeW === "number" ? fromMm(node.strokeW, unit, options2) : node.strokeW,
      fontSize: typeof node.fontSize === "number" ? fromMm(node.fontSize, unit, options2) : node.fontSize
    };
  }
  if (node.t === "shape") {
    return {
      ...node,
      x: fromMm(node.x, unit, options2),
      y: fromMm(node.y, unit, options2),
      w: fromMm(node.w, unit, options2),
      h: fromMm(node.h, unit, options2),
      strokeW: typeof node.strokeW === "number" ? fromMm(node.strokeW, unit, options2) : node.strokeW,
      radius: typeof node.radius === "number" ? fromMm(node.radius, unit, options2) : node.radius
    };
  }
  if (node.t === "image" || node.t === "group" || node.t === "widget") {
    return {
      ...node,
      x: fromMm(node.x, unit, options2),
      y: fromMm(node.y, unit, options2),
      w: fromMm(node.w, unit, options2),
      h: fromMm(node.h, unit, options2)
    };
  }
  return node;
}
function roundDocAnyUnit(doc, digits) {
  const roundN = (v2) => roundTo(v2, digits);
  const surfaces = doc.surfaces.map((s2) => ({
    ...s2,
    w: roundN(s2.w),
    h: roundN(s2.h),
    margin: s2.margin ? {
      t: roundN(s2.margin.t),
      r: roundN(s2.margin.r),
      b: roundN(s2.margin.b),
      l: roundN(s2.margin.l)
    } : s2.margin
  }));
  const nodes = doc.nodes.map((n2) => {
    if (n2.t === "line")
      return { ...n2, pts: n2.pts.map(roundN), strokeW: roundN(n2.strokeW) };
    if (n2.t === "signature") {
      return {
        ...n2,
        x: roundN(n2.x),
        y: roundN(n2.y),
        w: roundN(n2.w),
        h: roundN(n2.h),
        strokeW: roundN(n2.strokeW),
        strokes: n2.strokes.map((s2) => s2.map(roundN))
      };
    }
    if (n2.t === "table") {
      return {
        ...n2,
        x: roundN(n2.x),
        y: roundN(n2.y),
        w: roundN(n2.w),
        h: roundN(n2.h),
        table: {
          ...n2.table,
          rows: n2.table.rows.map(roundN),
          cols: n2.table.cols.map(roundN),
          cells: n2.table.cells.map((c3) => ({
            ...c3,
            borderW: typeof c3.borderW === "number" ? roundN(c3.borderW) : c3.borderW,
            fontSize: typeof c3.fontSize === "number" ? roundN(c3.fontSize) : c3.fontSize
          }))
        }
      };
    }
    if (n2.t === "text") {
      return {
        ...n2,
        x: roundN(n2.x),
        y: roundN(n2.y),
        w: roundN(n2.w),
        h: roundN(n2.h),
        strokeW: typeof n2.strokeW === "number" ? roundN(n2.strokeW) : n2.strokeW,
        fontSize: typeof n2.fontSize === "number" ? roundN(n2.fontSize) : n2.fontSize
      };
    }
    if (n2.t === "shape") {
      return {
        ...n2,
        x: roundN(n2.x),
        y: roundN(n2.y),
        w: roundN(n2.w),
        h: roundN(n2.h),
        strokeW: typeof n2.strokeW === "number" ? roundN(n2.strokeW) : n2.strokeW,
        radius: typeof n2.radius === "number" ? roundN(n2.radius) : n2.radius
      };
    }
    if (n2.t === "image" || n2.t === "group" || n2.t === "widget") {
      return {
        ...n2,
        x: roundN(n2.x),
        y: roundN(n2.y),
        w: roundN(n2.w),
        h: roundN(n2.h)
      };
    }
    return n2;
  });
  return { ...doc, surfaces, nodes };
}
function convertDocFromMm(doc, targetUnit, options2 = {}) {
  const converted = {
    ...doc,
    unit: targetUnit,
    surfaces: doc.surfaces.map((s2) => denormalizeSurface(s2, targetUnit, options2)),
    nodes: doc.nodes.map((n2) => denormalizeNode(n2, targetUnit, options2))
  };
  const digits = options2.roundDigitsForSave ?? 3;
  return roundDocAnyUnit(converted, digits);
}
export {
  useReportHistory,
  useQueueItem,
  useQueue,
  useI18n,
  useEditorState,
  useEditorHistoryDoc,
  useEditorHistory,
  importFromMermaid,
  exportToMermaid,
  defaultT,
  convertDocToMm,
  convertDocFromMm,
  WysiwygPropertiesPanel,
  WysiwygEditorToolbar,
  TooltipTrigger2 as TooltipTrigger,
  TooltipProvider2 as TooltipProvider,
  TooltipContent2 as TooltipContent,
  Tooltip2 as Tooltip,
  SlideEditor,
  SignatureKonvaEditor,
  ShortcutHelpModal,
  SettingsDrawer,
  ReportKonvaEditor,
  ReportEditor,
  RenderSignature,
  RenderShape,
  RenderLine,
  QueueViewer,
  QueueProvider,
  QueueItem,
  QueueHeader,
  QueueContext,
  PrintLayout,
  PresentationMode,
  ModalFooter,
  Modal,
  MindmapEditor,
  MermaidImportModal,
  MermaidExportModal,
  KonvaViewer,
  I18nProvider,
  EditorHeader,
  DocumentLoadMenu,
  Toolbar as BedToolbar,
  PropertyPanel as BedPropertyPanel,
  BedPrintLayout,
  BedLayoutViewer,
  BedLayoutHeader,
  BedLayoutEditor
};
